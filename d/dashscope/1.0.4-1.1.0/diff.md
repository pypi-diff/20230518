# Comparing `tmp/dashscope-1.0.4-py3-none-any.whl.zip` & `tmp/dashscope-1.1.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,44 +1,45 @@
-Zip file size: 48811 bytes, number of entries: 42
--rw-r--r--  2.0 unx      835 b- defN 23-Apr-04 06:54 dashscope/__init__.py
--rw-r--r--  2.0 unx    13361 b- defN 23-Apr-06 08:21 dashscope/cli.py
+Zip file size: 52227 bytes, number of entries: 43
+-rw-r--r--  2.0 unx      909 b- defN 23-May-16 06:21 dashscope/__init__.py
+-rw-r--r--  2.0 unx    13474 b- defN 23-May-16 06:21 dashscope/cli.py
 -rw-r--r--  2.0 unx     3445 b- defN 23-Mar-30 08:43 dashscope/deployment.py
 -rw-r--r--  2.0 unx     3753 b- defN 23-Mar-30 08:43 dashscope/file.py
 -rw-r--r--  2.0 unx     4808 b- defN 23-Mar-30 08:43 dashscope/finetune.py
 -rw-r--r--  2.0 unx     1696 b- defN 23-Mar-30 08:43 dashscope/model.py
--rw-r--r--  2.0 unx       22 b- defN 23-Apr-25 12:06 dashscope/version.py
--rw-r--r--  2.0 unx       66 b- defN 23-Mar-23 09:23 dashscope/aigc/__init__.py
--rw-r--r--  2.0 unx     8484 b- defN 23-Apr-26 09:20 dashscope/aigc/conversation.py
--rw-r--r--  2.0 unx     4743 b- defN 23-Apr-26 09:20 dashscope/aigc/generation.py
+-rw-r--r--  2.0 unx       22 b- defN 23-May-18 07:51 dashscope/version.py
+-rw-r--r--  2.0 unx      239 b- defN 23-May-16 06:21 dashscope/aigc/__init__.py
+-rw-r--r--  2.0 unx     8844 b- defN 23-May-17 12:24 dashscope/aigc/conversation.py
+-rw-r--r--  2.0 unx     5064 b- defN 23-May-17 12:24 dashscope/aigc/generation.py
+-rw-r--r--  2.0 unx     7669 b- defN 23-May-16 06:21 dashscope/aigc/image_synthesis.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Mar-23 09:23 dashscope/api_entities/__init__.py
 -rw-r--r--  2.0 unx    10361 b- defN 23-Apr-06 08:21 dashscope/api_entities/aiohttp_request.py
 -rw-r--r--  2.0 unx     5310 b- defN 23-Apr-05 17:08 dashscope/api_entities/api_request_data.py
 -rw-r--r--  2.0 unx     4057 b- defN 23-Apr-06 03:24 dashscope/api_entities/api_request_factory.py
--rw-r--r--  2.0 unx      608 b- defN 23-Apr-05 17:08 dashscope/api_entities/base_request.py
--rw-r--r--  2.0 unx     5801 b- defN 23-Apr-18 06:30 dashscope/api_entities/dashscope_response.py
--rw-r--r--  2.0 unx     9401 b- defN 23-Apr-10 06:30 dashscope/api_entities/http_request.py
+-rw-r--r--  2.0 unx      976 b- defN 23-May-16 06:21 dashscope/api_entities/base_request.py
+-rw-r--r--  2.0 unx     8130 b- defN 23-May-16 06:21 dashscope/api_entities/dashscope_response.py
+-rw-r--r--  2.0 unx     9457 b- defN 23-May-16 06:21 dashscope/api_entities/http_request.py
 -rw-r--r--  2.0 unx     8798 b- defN 23-Apr-05 03:15 dashscope/api_entities/sync_http_request.py
--rw-r--r--  2.0 unx    15625 b- defN 23-Apr-06 08:21 dashscope/api_entities/websocket_request.py
+-rw-r--r--  2.0 unx    15705 b- defN 23-May-16 06:21 dashscope/api_entities/websocket_request.py
 -rw-r--r--  2.0 unx       35 b- defN 23-Mar-23 09:23 dashscope/audio/__init__.py
 -rw-r--r--  2.0 unx       75 b- defN 23-Apr-04 06:54 dashscope/audio/asr/__init__.py
 -rw-r--r--  2.0 unx     6946 b- defN 23-Apr-04 01:24 dashscope/audio/asr/transcribe.py
 -rw-r--r--  2.0 unx     5103 b- defN 23-Apr-10 06:30 dashscope/audio/asr/transcription.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Mar-23 09:23 dashscope/client/__init__.py
--rw-r--r--  2.0 unx    21665 b- defN 23-Apr-06 08:21 dashscope/client/base_api.py
+-rw-r--r--  2.0 unx    25911 b- defN 23-May-16 06:21 dashscope/client/base_api.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Mar-23 09:23 dashscope/common/__init__.py
 -rw-r--r--  2.0 unx     1986 b- defN 23-Mar-23 09:23 dashscope/common/api_key.py
--rw-r--r--  2.0 unx     1983 b- defN 23-Apr-25 14:06 dashscope/common/constants.py
+-rw-r--r--  2.0 unx     2215 b- defN 23-May-16 06:21 dashscope/common/constants.py
 -rw-r--r--  2.0 unx      869 b- defN 23-Apr-10 12:54 dashscope/common/env.py
--rw-r--r--  2.0 unx     1592 b- defN 23-Apr-01 07:54 dashscope/common/error.py
+-rw-r--r--  2.0 unx     1592 b- defN 23-May-16 06:21 dashscope/common/error.py
 -rw-r--r--  2.0 unx      984 b- defN 23-Mar-23 09:23 dashscope/common/logging.py
--rw-r--r--  2.0 unx     3330 b- defN 23-Apr-06 08:21 dashscope/common/utils.py
+-rw-r--r--  2.0 unx     4038 b- defN 23-May-16 06:21 dashscope/common/utils.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Mar-23 09:23 dashscope/io/__init__.py
 -rw-r--r--  2.0 unx     2781 b- defN 23-Mar-30 11:54 dashscope/io/input_output.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Mar-23 09:23 dashscope/protocol/__init__.py
 -rw-r--r--  2.0 unx      561 b- defN 23-Mar-23 09:23 dashscope/protocol/websocket.py
--rw-r--r--  2.0 unx    11413 b- defN 23-Apr-26 09:20 dashscope-1.0.4.dist-info/LICENSE
--rw-r--r--  2.0 unx     7201 b- defN 23-Apr-26 09:20 dashscope-1.0.4.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Apr-26 09:20 dashscope-1.0.4.dist-info/WHEEL
--rw-r--r--  2.0 unx       50 b- defN 23-Apr-26 09:20 dashscope-1.0.4.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       10 b- defN 23-Apr-26 09:20 dashscope-1.0.4.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     3590 b- defN 23-Apr-26 09:20 dashscope-1.0.4.dist-info/RECORD
-42 files, 171440 bytes uncompressed, 43039 bytes compressed:  74.9%
+-rw-r--r--  2.0 unx    11413 b- defN 23-May-18 07:51 dashscope-1.1.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     7201 b- defN 23-May-18 07:51 dashscope-1.1.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-May-18 07:51 dashscope-1.1.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       50 b- defN 23-May-18 07:51 dashscope-1.1.0.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       10 b- defN 23-May-18 07:51 dashscope-1.1.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     3681 b- defN 23-May-18 07:51 dashscope-1.1.0.dist-info/RECORD
+43 files, 188260 bytes uncompressed, 46313 bytes compressed:  75.4%
```

## zipnote {}

```diff
@@ -24,14 +24,17 @@
 
 Filename: dashscope/aigc/conversation.py
 Comment: 
 
 Filename: dashscope/aigc/generation.py
 Comment: 
 
+Filename: dashscope/aigc/image_synthesis.py
+Comment: 
+
 Filename: dashscope/api_entities/__init__.py
 Comment: 
 
 Filename: dashscope/api_entities/aiohttp_request.py
 Comment: 
 
 Filename: dashscope/api_entities/api_request_data.py
@@ -102,26 +105,26 @@
 
 Filename: dashscope/protocol/__init__.py
 Comment: 
 
 Filename: dashscope/protocol/websocket.py
 Comment: 
 
-Filename: dashscope-1.0.4.dist-info/LICENSE
+Filename: dashscope-1.1.0.dist-info/LICENSE
 Comment: 
 
-Filename: dashscope-1.0.4.dist-info/METADATA
+Filename: dashscope-1.1.0.dist-info/METADATA
 Comment: 
 
-Filename: dashscope-1.0.4.dist-info/WHEEL
+Filename: dashscope-1.1.0.dist-info/WHEEL
 Comment: 
 
-Filename: dashscope-1.0.4.dist-info/entry_points.txt
+Filename: dashscope-1.1.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: dashscope-1.0.4.dist-info/top_level.txt
+Filename: dashscope-1.1.0.dist-info/top_level.txt
 Comment: 
 
-Filename: dashscope-1.0.4.dist-info/RECORD
+Filename: dashscope-1.1.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## dashscope/__init__.py

```diff
@@ -1,21 +1,22 @@
 import logging
 from logging import NullHandler
 
 from dashscope.aigc.conversation import Conversation, History, HistoryItem
 from dashscope.aigc.generation import Generation
+from dashscope.aigc.image_synthesis import ImageSynthesis
 from dashscope.audio.asr.transcription import Transcription
 from dashscope.common.api_key import save_api_key
 from dashscope.common.env import (api_key, api_key_file_path,
                                   base_http_api_url, base_websocket_api_url)
 from dashscope.deployment import Deployment
 from dashscope.file import File
 from dashscope.finetune import FineTune
 from dashscope.model import Model
 
 __all__ = [
     base_http_api_url, base_websocket_api_url, api_key, api_key_file_path,
     save_api_key, Conversation, Generation, History, HistoryItem,
-    Transcription, File, Deployment, FineTune, Model
+    ImageSynthesis, Transcription, File, Deployment, FineTune, Model
 ]
 
 logging.getLogger(__name__).addHandler(NullHandler())
```

## dashscope/cli.py

```diff
@@ -34,16 +34,16 @@
             validation_file_ids=args.validation_file_ids,
             hyper_parameters=hyper_parameters)
         if rsp.status_code == HTTPStatus.OK:
             print('Create fine-tune job success, job_id: %s' %
                   rsp.output['job_id'])
             cls.wait(rsp.output['job_id'])
         else:
-            print('Failed, code: %s, message: %s' %
-                  (rsp.status_code, rsp.message))
+            print('Failed, status_code: %s, code: %s, message: %s' %
+                  (rsp.status_code, rsp.code, rsp.message))
 
     @classmethod
     def wait(cls, job_id):
         while True:
             rsp = dashscope.FineTune.get(job_id)
             if rsp.status_code == HTTPStatus.OK:
                 if rsp.output['status'] == TaskStatus.FAILED:
@@ -56,16 +56,16 @@
                     print('Fine-tune task success, fine-tuned model:%s' %
                           rsp.output['output_model'])
                     break
                 else:
                     print('The fine-tune task is: %s' % rsp.output['status'])
                     time.sleep(30)
             else:
-                print('Failed, code: %s, message: %s' %
-                      (rsp.code, rsp.message))
+                print('Failed, status_code: %s, code: %s, message: %s' %
+                      (rsp.status_code, rsp.code, rsp.message))
 
     @classmethod
     def get(cls, args):
         rsp = dashscope.FineTune.get(args.job)
         if rsp.status_code == HTTPStatus.OK:
             if rsp.output['status'] == TaskStatus.FAILED:
                 print('Fine-tune failed!')
@@ -73,15 +73,16 @@
                 print('Fine-tune task canceled')
             elif rsp.output['status'] == TaskStatus.SUCCEEDED:
                 print('Fine-tune task success, fine-tuned model : %s' %
                       rsp.output['output_model'])
             else:
                 print('The fine-tune task is: %s' % rsp.output['status'])
         else:
-            print('Failed, code: %s, message: %s' % (rsp.code, rsp.message))
+            print('Failed, status_code: %s, code: %s, message: %s' %
+                  (rsp.status_code, rsp.code, rsp.message))
 
     @classmethod
     def list(cls, args):
         rsp = dashscope.FineTune.list()
         if rsp.status_code == HTTPStatus.OK:
             for job in rsp.output['jobs']:
                 if job['status'] == TaskStatus.SUCCEEDED:
```

## dashscope/version.py

```diff
@@ -1 +1 @@
-__version__ = '1.0.4'
+__version__ = '1.1.0'
```

## dashscope/aigc/__init__.py

```diff
@@ -1,5 +1,11 @@
+from .conversation import Conversation, History, HistoryItem
 from .generation import Generation
+from .image_synthesis import ImageSynthesis
 
 __all__ = [
     Generation,
+    Conversation,
+    HistoryItem,
+    History,
+    ImageSynthesis,
 ]
```

## dashscope/aigc/conversation.py

```diff
@@ -1,15 +1,14 @@
 from http import HTTPStatus
 from typing import Any, Generator, List, Union
 
 from dashscope.api_entities.dashscope_response import ConversationResponse
 from dashscope.client.base_api import BaseApi
 from dashscope.common.constants import HISTORY, PROMPT
 from dashscope.common.error import InputRequired, InvalidInput, ModelRequired
-from dashscope.common.logging import logger
 from dashscope.common.utils import _get_task_group_and_task
 
 
 class HistoryItem(dict):
     """A conversation history item.
 
     """
@@ -54,16 +53,18 @@
         """
         if items is not None:
             list.__init__(items)
         else:
             list.__init__([])
 
 
-def history_to_simple_format(history: History, n_history: int):
+def _history_to_qwen_format(history: History, n_history: int):
     """Convert history to simple format.
+       [{"user":"您好", "bot":"我是你的助手，很高兴为您服务"},
+        {"user":"user input", "bot":"bot output"}]
     """
     simple_history = []
     user = None
     bot = None
 
     if n_history != -1 and len(history) >= 2 * n_history:
         history = history[len(history) - 2 * n_history:]
@@ -156,48 +157,24 @@
             stream is True, return Generator, otherwise ConversationResponse.
 
         """
         if prompt is None or not prompt:
             raise InputRequired('prompt is required!')
         if model is None or not model:
             raise ModelRequired('Model is required!')
-        task_group, function = _get_task_group_and_task(__name__)
-        input = {PROMPT: prompt}
-        if history is not None and auto_history:
-            raise InvalidInput('auto_history is True, history must None')
-        if history is not None:  # use user provided history.
-            input = {
-                PROMPT:
-                prompt,
-                HISTORY:
-                history_to_simple_format(history, n_history)
-                if history else [],
-            }
-        elif auto_history:
-            input = {
-                PROMPT: prompt,
-                HISTORY: history_to_simple_format(self.history, n_history)
-            }
-        logger.debug(input)
-        parameters = {}
-        if model.startswith('qwen'):
-            enable_search = kwargs.pop('enable_search', False)
-            M6_NUM_WEB_SEARCH = 0
-            if enable_search:
-                M6_NUM_WEB_SEARCH = 5
-            parameters['M6_NUM_WEB_SEARCH'] = M6_NUM_WEB_SEARCH
-            parameters['M6_SEARCH_IN_FIRST_QUERY'] = 0
+        task_group, _ = _get_task_group_and_task(__name__)
+        input, parameters = self._build_input_parameters(
+            model, prompt, history, auto_history, n_history, **kwargs)
         response = super().call(model=model,
-                                task_group='aigc',
+                                task_group=task_group,
                                 task='text-generation',
                                 function='generation',
                                 api_key=api_key,
                                 input=input,
-                                **parameters,
-                                **kwargs)
+                                **parameters)
         is_stream = kwargs.get('stream', False)
         return self._handle_response(prompt, response, is_stream)
 
     def _handle_stream_response(self, prompt, responses):
         for rsp in responses:
             rsp = ConversationResponse.from_api_response(rsp)
             yield rsp
@@ -216,7 +193,37 @@
             if response.status_code == HTTPStatus.OK:
                 user_item = HistoryItem('user', text=prompt)
                 bot_history_item = HistoryItem('bot',
                                                text=response.output['text'])
                 self.history.append(user_item)
                 self.history.append(bot_history_item)
             return response
+
+    def _build_input_parameters(self, model, prompt, history, auto_history,
+                                n_history, **kwargs):
+        parameters = {}
+        if history is not None and auto_history:
+            raise InvalidInput('auto_history is True, history must None')
+        if history is not None:  # use user provided history.
+            input = {
+                PROMPT:
+                prompt,
+                HISTORY:
+                _history_to_qwen_format(history, n_history) if history else [],
+            }
+        elif auto_history:
+            input = {
+                PROMPT: prompt,
+                HISTORY: _history_to_qwen_format(self.history, n_history)
+            }
+        else:
+            input = {
+                PROMPT: prompt,
+            }
+        if model.startswith('qwen'):
+            enable_search = kwargs.pop('enable_search', False)
+            QWEN_NUM_WEB_SEARCH = 0
+            if enable_search:
+                QWEN_NUM_WEB_SEARCH = 5
+            parameters['QWEN_NUM_WEB_SEARCH'] = QWEN_NUM_WEB_SEARCH
+            parameters['QWEN_SEARCH_IN_FIRST_QUERY'] = 0
+        return input, {**parameters, **kwargs}
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## dashscope/aigc/generation.py

```diff
@@ -11,14 +11,15 @@
     task = 'text-generation'
     """API for AI-Generated Content(AIGC) models.
 
     """
     class Models:
         qwen_v1 = 'qwen-v1'
         bailian_v1 = 'bailian-v1'
+        dolly_12b_v2 = 'dolly-12b-v2'
 
     @classmethod
     def call(
         cls,
         model: str,
         prompt: Any,
         history: list = None,
@@ -36,24 +37,24 @@
                     'bot': 'Suitable for outings'}].
                 Defaults to None.
             api_key (str, optional): The api api_key, can be None,
                 if None, will get by default rule(TODO: api key doc).
             **kwargs:
                 stream(bool, `optional`): Enable server-sent events
                     (ref: https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events)  # noqa E501
-                    the result will back partially.
+                    the result will back partially[qwen-v1,bailian-v1].
                 max_length(int, `optional`): The maximum length of tokens to
                     generate. The token count of your prompt plus max_length
                     cannot exceed the model's context length. Most models
-                    have a context length of 2000 tokens.
+                    have a context length of 2000 tokens[qwen-v1,bailian-v1]. # noqa E501
                 top_p(int, `optional`): A sampling strategy, called nucleus
                     sampling, where the model considers the results of the
                     tokens with top_p probability mass. So 0.1 means only
                     the tokens comprising the top 10% probability mass are
-                    considered.
+                    considered[qwen-v1,bailian-v1].
                 enable_search(bool, `optional`): Whether to enable web search(quark).  # noqa E501
                     Currently works best only on the first round of conversation.
                     Default to False, support model: [qwen-v1].
                 customized_model_id(string, required) The enterprise-specific
                     large model id, which needs to be generated from the
                     operation background of the enterprise-specific
                     large model product, support model: [bailian-v1].
@@ -67,39 +68,45 @@
             stream is True, return Generator, otherwise GenerationResponse.
         """
         if prompt is None or not prompt:
             raise InputRequired('prompt is required!')
         if model is None or not model:
             raise ModelRequired('Model is required!')
         task_group, function = _get_task_group_and_task(__name__)
+        input, parameters = cls._build_input_parameters(
+            model, prompt, history, **kwargs)
+        response = super().call(model=model,
+                                task_group=task_group,
+                                task=Generation.task,
+                                function=function,
+                                api_key=api_key,
+                                input=input,
+                                **parameters)
+        is_stream = kwargs.get('stream', False)
+        if is_stream:
+            return (GenerationResponse.from_api_response(rsp)
+                    for rsp in response)
+        else:
+            return GenerationResponse.from_api_response(response)
+
+    @classmethod
+    def _build_input_parameters(cls, model, prompt, history, **kwargs):
         parameters = {}
         input = {
             PROMPT: prompt,
             HISTORY: history if history else [],
         }
         if model.startswith('qwen'):
             enable_search = kwargs.pop('enable_search', False)
-            M6_NUM_WEB_SEARCH = 0
+            QWEN_NUM_WEB_SEARCH = 0
             if enable_search:
-                M6_NUM_WEB_SEARCH = 5
-            parameters['M6_NUM_WEB_SEARCH'] = M6_NUM_WEB_SEARCH
-            parameters['M6_SEARCH_IN_FIRST_QUERY'] = 0
-        if model.startswith('bailian'):
+                QWEN_NUM_WEB_SEARCH = 5
+            parameters['QWEN_NUM_WEB_SEARCH'] = QWEN_NUM_WEB_SEARCH
+            parameters['QWEN_SEARCH_IN_FIRST_QUERY'] = 0
+        elif model.startswith('bailian'):
             customized_model_id = kwargs.pop('customized_model_id', None)
             if customized_model_id is None:
                 raise InputRequired('customized_model_id is required for %s' %
                                     model)
             input[CUSTOMIZED_MODEL_ID] = customized_model_id
-        response = super().call(model=model,
-                                task_group=task_group,
-                                task=Generation.task,
-                                function=function,
-                                api_key=api_key,
-                                input=input,
-                                **parameters,
-                                **kwargs)
-        is_stream = kwargs.get('stream', False)
-        if is_stream:
-            return (GenerationResponse.from_api_response(rsp)
-                    for rsp in response)
-        else:
-            return GenerationResponse.from_api_response(response)
+
+        return input, {**parameters, **kwargs}
```

## dashscope/api_entities/base_request.py

```diff
@@ -1,22 +1,30 @@
+import os
 import platform
 from abc import ABC, abstractmethod
 
+from dashscope.common.constants import DASHSCOPE_DISABLE_DATA_INSPECTION_ENV
 from dashscope.version import __version__
 
 
 class BaseRequest(ABC):
     def __init__(self) -> None:
         ua = 'dashscope/%s; python/%s; platform/%s; processor/%s' % (
             __version__,
             platform.python_version(),
             platform.platform(),
             platform.processor(),
         )
         self.headers = {'user-agent': ua}
+        disable_data_inspection = os.environ.get(
+            DASHSCOPE_DISABLE_DATA_INSPECTION_ENV, False)
+
+        if (not disable_data_inspection
+                or (disable_data_inspection.lower() == 'false')):
+            self.headers['X-DashScope-DataInspection'] = 'enable'
 
     @abstractmethod
     def call(self):
         raise NotImplementedError()
 
 
 class AioBaseRequest(BaseRequest):
```

## dashscope/api_entities/dashscope_response.py

```diff
@@ -1,19 +1,19 @@
 import json
 from dataclasses import dataclass
 from http import HTTPStatus
-from typing import Any
+from typing import Any, List
 
 
 @dataclass(init=False)
 class DictMixin(dict):
     __slots__ = ()
 
-    def __init__(self, **kwargs):
-        super().__init__(**kwargs)
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
 
     def __getitem__(self, key):
         return super().__getitem__(key)
 
     def __setitem__(self, key, value):
         return super().__setitem__(key, value)
 
@@ -185,7 +185,74 @@
                                          usage=usage)
 
         else:
             return TranscriptionResponse(status_code=api_response.status_code,
                                          request_id=api_response.request_id,
                                          code=api_response.code,
                                          message=api_response.message)
+
+
+@dataclass(init=False)
+class ImageSynthesisResult(DictMixin):
+    url: str
+
+    def __init__(self, url: str = '', **kwargs) -> None:
+        super().__init__(url=url, **kwargs)
+
+
+@dataclass(init=False)
+class ImageSynthesisOutput(DictMixin):
+    task_id: str
+    task_status: str
+    results: List[ImageSynthesisResult]
+
+    def __init__(self,
+                 task_id: str,
+                 task_status: str,
+                 results: List[ImageSynthesisResult] = [],
+                 **kwargs):
+        res = []
+        if len(results) > 0:
+            for result in results:
+                res.append(ImageSynthesisResult(**result))
+        super().__init__(self,
+                         task_id=task_id,
+                         task_status=task_status,
+                         results=res,
+                         **kwargs)
+
+
+@dataclass(init=False)
+class ImageSynthesisUsage(DictMixin):
+    image_count: int
+
+    def __init__(self, image_count: int, **kwargs):
+        super().__init__(image_count=image_count, **kwargs)
+
+
+@dataclass(init=False)
+class ImageSynthesisResponse(DashScopeAPIResponse):
+    output: ImageSynthesisOutput
+    usage: ImageSynthesisUsage
+
+    @staticmethod
+    def from_api_response(api_response: DashScopeAPIResponse):
+        if api_response.status_code == HTTPStatus.OK:
+            output = None
+            usage = None
+            if api_response.output is not None:
+                output = ImageSynthesisOutput(**api_response.output)
+            if api_response.usage is not None:
+                usage = ImageSynthesisUsage(**api_response.usage)
+
+            return ImageSynthesisResponse(status_code=api_response.status_code,
+                                          request_id=api_response.request_id,
+                                          code=api_response.code,
+                                          message=api_response.message,
+                                          output=output,
+                                          usage=usage)
+
+        else:
+            return ImageSynthesisResponse(status_code=api_response.status_code,
+                                          request_id=api_response.request_id,
+                                          code=api_response.code,
+                                          message=api_response.message)
```

## dashscope/api_entities/http_request.py

```diff
@@ -1,11 +1,12 @@
 import json
 from http import HTTPStatus
 
 import requests
+
 from dashscope.api_entities.base_request import BaseRequest
 from dashscope.api_entities.dashscope_response import DashScopeAPIResponse
 from dashscope.common.constants import (DEFAULT_REQUEST_TIMEOUT_SECONDS,
                                         SSE_CONTENT_TYPE, HTTPMethod,
                                         StreamResultMode)
 from dashscope.common.error import UnsupportedHTTPMethod
 from dashscope.common.logging import logger
@@ -125,19 +126,22 @@
                         request_id=request_id,
                         status_code=HTTPStatus.BAD_REQUEST,
                         output=None,
                         code='Unknown',
                         message=data)
                     continue
                 if is_error:
-                    yield DashScopeAPIResponse(request_id=request_id,
-                                               status_code=status_code,
-                                               output=None,
-                                               code=msg['code'],
-                                               message=msg['message'])
+                    yield DashScopeAPIResponse(
+                        request_id=request_id,
+                        status_code=status_code,
+                        output=None,
+                        code=msg['code']
+                        if 'code' in msg else None,  # noqa E501
+                        message=msg['message']
+                        if 'message' in msg else None)  # noqa E501
                 else:
                     yield DashScopeAPIResponse(request_id=request_id,
                                                status_code=HTTPStatus.OK,
                                                output=output,
                                                usage=usage)
         elif response.status_code == HTTPStatus.OK:
             json_content = response.json()
@@ -165,19 +169,21 @@
                     logger.error('Request: %s failed, status: %s' %
                                  (self.url, response.status_code))
                 else:
                     message = error['message']
                     logger.error(
                         'Request: %s failed, status: %s, message: %s' %
                         (self.url, response.status_code, error['message']))
-                yield DashScopeAPIResponse(request_id=request_id,
-                                           status_code=response.status_code,
-                                           output=None,
-                                           code=error['code'],
-                                           message=message)
+                yield DashScopeAPIResponse(
+                    request_id=request_id,
+                    status_code=response.status_code,
+                    output=None,
+                    code=error['code']
+                    if 'code' in error else None,  # noqa E501
+                    message=message)
             else:
                 msg = response.content
                 yield DashScopeAPIResponse(request_id=request_id,
                                            status_code=response.status_code,
                                            output=None,
                                            code='Unknown',
                                            message=msg.decode('utf-8'))
```

## dashscope/api_entities/websocket_request.py

```diff
@@ -5,15 +5,16 @@
 from typing import Tuple, Union
 
 import aiohttp
 
 from dashscope.api_entities.base_request import AioBaseRequest
 from dashscope.api_entities.dashscope_response import DashScopeAPIResponse
 from dashscope.common.constants import (DEFAULT_REQUEST_TIMEOUT_SECONDS,
-                                        SERVICE_503_MESSAGE, StreamResultMode)
+                                        SERVICE_503_MESSAGE,
+                                        WEBSOCKET_ERROR_CODE, StreamResultMode)
 from dashscope.common.error import (RequestFailure, UnexpectedMessageReceived,
                                     UnknownMessageReceived)
 from dashscope.common.logging import logger
 from dashscope.common.utils import async_to_sync
 from dashscope.protocol.websocket import (ACTION_KEY, ERROR_MESSAGE,
                                           ERROR_NAME, EVENT_KEY, HEADER,
                                           TASK_ID, ActionType, EventType,
@@ -231,15 +232,15 @@
                 elif self.stream_result_mode == StreamResultMode.ACCUMULATE:
                     final_payload = msg.data
                 else:
                     final_payload += msg.data
 
     def _on_failed(self, details):
         error = RequestFailure(request_id=details[HEADER][TASK_ID],
-                               http_code=44,
+                               http_code=WEBSOCKET_ERROR_CODE,
                                name=details[HEADER][ERROR_NAME],
                                message=details[HEADER][ERROR_MESSAGE])
         logger.error(error)
         raise error
 
     async def _start_task(self, ws):
         self.task_headers['task_id'] = uuid.uuid4().hex  # create task id.
```

## dashscope/client/base_api.py

```diff
@@ -1,27 +1,62 @@
 import json
 import os
 import time
 from http import HTTPStatus
 from typing import List, Union
 
 import aiohttp
+import requests
 
 import dashscope
-import requests
 from dashscope.api_entities.api_request_factory import _build_api_request
 from dashscope.api_entities.dashscope_response import DashScopeAPIResponse
 from dashscope.common.api_key import get_default_api_key
 from dashscope.common.constants import (DEFAULT_REQUEST_TIMEOUT_SECONDS,
                                         REPEATABLE_STATUS, TaskStatus)
-from dashscope.common.error import InvalidParameter, ModelRequired
+from dashscope.common.error import InvalidParameter, InvalidTask, ModelRequired
 from dashscope.common.logging import logger
 from dashscope.common.utils import _handle_http_response, default_headers
 
 
+def _handle_http_failed_response(
+        response: requests.Response) -> DashScopeAPIResponse:
+    msg = ''
+    code = None
+    request_id = ''
+    if 'application/json' in response.headers.get('content-type', ''):
+        error = response.json()
+        if 'message' in error:
+            msg = error['message']
+        if 'code' in error:
+            code = error['code']
+        if 'request_id' in error:
+            request_id = error['request_id']
+        return DashScopeAPIResponse(request_id=request_id,
+                                    status_code=response.status_code,
+                                    code=code,
+                                    message=msg)
+    else:
+        msg = response.content.decode('utf-8')
+        return DashScopeAPIResponse(request_id=request_id,
+                                    status_code=response.status_code,
+                                    code='Unknown',
+                                    message=msg)
+
+
+def _normalization_url(*args):
+    url = dashscope.base_http_api_url
+    if not url.endswith('/'):
+        url += '/'
+    for arg in args:
+        url += arg
+        url += '/'
+    return url[:-1]
+
+
 class BaseApi():
     """BaseApi, internal use only.
 
     """
     @classmethod
     def _validate_params(cls, api_key, model):
         if api_key is None:
@@ -72,24 +107,16 @@
                                      **kwargs)
         # call request service.
         return request.call()
 
 
 class AsyncTaskGetMixin():
     @classmethod
-    def _status_url(cls, task_id: str):
-        if dashscope.base_http_api_url.endswith('/'):
-            url = dashscope.base_http_api_url + 'tasks/%s' % task_id
-        else:
-            url = dashscope.base_http_api_url + '/tasks/%s' % task_id
-        return url
-
-    @classmethod
     def _get(cls, task_id: str, api_key: str = None) -> DashScopeAPIResponse:
-        status_url = cls._status_url(task_id)
+        status_url = _normalization_url('tasks', task_id)
         with requests.Session() as session:
             logger.debug('Starting request: %s' % status_url)
             response = session.get(status_url,
                                    headers={
                                        **default_headers(api_key),
                                    },
                                    timeout=DEFAULT_REQUEST_TIMEOUT_SECONDS)
@@ -118,34 +145,15 @@
             return DashScopeAPIResponse(request_id=request_id,
                                         status_code=response.status_code,
                                         code=code,
                                         output=output,
                                         usage=usage,
                                         message=msg)
         else:
-            if 'application/json' in response.headers.get('content-type', ''):
-                error = response.json()
-                msg = ''
-                code = None
-                if 'message' in error:
-                    msg = error['message']
-                if 'code' in error:
-                    code = error['code']
-                if 'request_id' in error:
-                    request_id = error['request_id']
-                return DashScopeAPIResponse(request_id=request_id,
-                                            status_code=response.status_code,
-                                            code=code,
-                                            message=msg)
-            else:
-                msg = response.content
-                return DashScopeAPIResponse(request_id=request_id,
-                                            status_code=response.status_code,
-                                            code='Unknown',
-                                            message=msg)
+            return _handle_http_failed_response(response)
 
 
 class BaseAsyncApi(AsyncTaskGetMixin):
     """BaseAsyncApi,for async task, internal use only.
 
     """
     @classmethod
@@ -168,20 +176,126 @@
     def _get_task_id(cls, task):
         if isinstance(task, str):
             task_id = task
         elif isinstance(task, DashScopeAPIResponse):
             if task.status_code == HTTPStatus.OK:
                 task_id = task.output['task_id']
             else:
-                task_id = None
+                raise InvalidTask('Invalid task, task create failed: %s' %
+                                  task)
         else:
-            raise InvalidParameter('fetch task parameter invalid!')
+            raise InvalidParameter('task invalid!')
         return task_id
 
     @classmethod
+    def cancel(
+        cls,
+        task: Union[str, DashScopeAPIResponse],
+        api_key: str = None,
+    ) -> DashScopeAPIResponse:
+        """Cancel PENDING task.
+
+        Args:
+            task (Union[str, DashScopeAPIResponse]): The task_id, or
+                async_call response.
+            api_key (str, optional): The api-key. Defaults to None.
+
+        Returns:
+            DashScopeAPIResponse: The cancel result.
+        """
+        task_id = cls._get_task_id(task)
+        url = _normalization_url('tasks', task_id, 'cancel')
+        with requests.Session() as session:
+            response = session.post(url,
+                                    headers={
+                                        **default_headers(api_key),
+                                    })
+            if response.status_code == HTTPStatus.OK:
+                json_content = response.json()
+                request_id = ''
+                if 'request_id' in json_content:
+                    request_id = json_content['request_id']
+                return DashScopeAPIResponse(request_id=request_id,
+                                            status_code=response.status_code,
+                                            code=None,
+                                            output=None,
+                                            usage=None,
+                                            message='')
+            else:
+                return _handle_http_failed_response(response)
+
+    @classmethod
+    def list(cls,
+             start_time: str = None,
+             end_time: str = None,
+             model_name: str = None,
+             api_key_id: str = None,
+             region: str = None,
+             status: str = None,
+             page_no: int = 1,
+             page_size: int = 10,
+             api_key: str = None,
+             **kwargs) -> DashScopeAPIResponse:
+        """List async tasks.
+
+        Args:
+            start_time (str, optional): The tasks start time,
+                for example: 20230420000000. Defaults to None.
+            end_time (str, optional): The tasks end time,
+                for example: 20230420000000. Defaults to None.
+            model_name (str, optional): The tasks model name. Defaults to None.
+            api_key_id (str, optional): The tasks api-key-id. Defaults to None.
+            region (str, optional): The service region,
+                for example: cn-beijing. Defaults to None.
+            status (str, optional): The status of tasks[PENDING,
+                RUNNING, SUCCEEDED, FAILED, CANCELED]. Defaults to None.
+            page_no (int, optional): The page number. Defaults to 1.
+            page_size (int, optional): The page size. Defaults to 10.
+            api_key (str, optional): The user api-key. Defaults to None.
+
+        Returns:
+            DashScopeAPIResponse: The response data.
+        """
+        url = _normalization_url('tasks')
+        params = {'page_no': page_no, 'page_size': page_size}
+        if start_time is not None:
+            params['start_time'] = start_time
+        if end_time is not None:
+            params['end_time'] = end_time
+        if model_name is not None:
+            params['model_name'] = model_name
+        if api_key_id is not None:
+            params['api_key_id'] = api_key_id
+        if region is not None:
+            params['region'] = region
+        if status is not None:
+            params['status'] = status
+
+        with requests.Session() as session:
+            response = session.get(url,
+                                   params=params,
+                                   headers={
+                                       **default_headers(api_key),
+                                   })
+            if response.status_code == HTTPStatus.OK:
+                json_content = response.json()
+                request_id = ''
+                if 'request_id' in json_content:
+                    request_id = json_content['request_id']
+                    json_content.pop('request_id')
+                return DashScopeAPIResponse(request_id=request_id,
+                                            status_code=response.status_code,
+                                            code=None,
+                                            output=json_content,
+                                            usage=None,
+                                            message='')
+            else:
+                return _handle_http_failed_response(response)
+
+    @classmethod
     def fetch(
         cls,
         task: Union[str, DashScopeAPIResponse],
         api_key: str = None,
     ) -> DashScopeAPIResponse:
         """Query async task status.
 
@@ -190,16 +304,14 @@
                 async_call response.
             api_key (str, optional): The api_key. Defaults to None.
 
         Returns:
             DashScopeAPIResponse: The async task information.
         """
         task_id = cls._get_task_id(task)
-        if task_id is None:
-            return task
         return cls._get(task_id, api_key)
 
     @classmethod
     def wait(
         cls,
         task: Union[str, DashScopeAPIResponse],
         api_key: str = None,
@@ -210,18 +322,16 @@
             task (Union[str, DashScopeAPIResponse]): The task_id, or
                 async_call response.
             api_key (str, optional): The api_key. Defaults to None.
 
         Returns:
             DashScopeAPIResponse: The async task information.
         """
+        task_id = cls._get_task_id(task)
         while True:
-            task_id = cls._get_task_id(task)
-            if task_id is None:
-                return task
             rsp = cls._get(task_id, api_key)
             if rsp.status_code == HTTPStatus.OK:
                 if rsp.output is None:
                     return rsp
 
                 task_status = rsp.output['task_status']
                 if task_status in [
@@ -263,15 +373,17 @@
                 will get by default rule(TODO: api key doc). Defaults to None.
 
         Returns:
             DashScopeAPIResponse: The async task information,
                 which contains the task id, you can use the task id
                 to query the task status.
         """
-
+        is_stream = kwargs.pop('stream', None)  # async api not support stream.
+        if is_stream:
+            logger.warn('async_call do not support stream argument')
         api_key, model = BaseApi._validate_params(api_key, model)
         request = _build_api_request(model=model,
                                      input=input,
                                      task_group=task_group,
                                      task=task,
                                      function=function,
                                      api_key=api_key,
@@ -305,15 +417,15 @@
             order (str, optional): Items order['desc', 'asc'].
                 Defaults to 'desc'.
 
         Returns:
             DashScopeAPIResponse: The object list in output.
         """
         headers = kwargs.pop('headers', {})
-        url = '%s%s' % (dashscope.base_http_api_url, cls.SUB_PATH.lower())
+        url = _normalization_url(cls.SUB_PATH.lower())
         async with aiohttp.ClientSession() as client:
             response = await client.get(url=url,
                                         params={
                                             'limits': limits,
                                             'page': page,
                                             'per_page': per_page,
                                             'offset': offset,
@@ -340,16 +452,15 @@
             api_key (str, optional): The api api_key, if not present,
                 will get by default rule(TODO: api key doc). Defaults to None.
 
         Returns:
             DashScopeAPIResponse: The object information in output.
         """
         headers = kwargs.pop('headers', {})
-        url = '%s%s/%s' % (dashscope.base_http_api_url, cls.SUB_PATH.lower(),
-                           target)
+        url = _normalization_url(cls.SUB_PATH.lower(), target)
         async with aiohttp.ClientSession() as client:
             response = await client.get(url=url,
                                         headers={
                                             **default_headers(api_key),
                                             **headers
                                         })  # noqa E501
             return await _handle_http_response(response)
@@ -368,16 +479,15 @@
             api_key (str, optional): The api api_key, if not present,
                 will get by default rule(TODO: api key doc). Defaults to None.
 
         Returns:
             DashScopeAPIResponse: The delete result.
         """
         headers = kwargs.pop('headers', {})
-        url = '%s%s/%s' % (dashscope.base_http_api_url, cls.SUB_PATH.lower(),
-                           target)
+        url = _normalization_url(cls.SUB_PATH.lower(), target)
         async with aiohttp.ClientSession() as client:
             response = await client.delete(url=url,
                                            headers={
                                                **default_headers(api_key),
                                                **headers
                                            })  # noqa E501
             return await _handle_http_response(response)
@@ -396,15 +506,15 @@
             api_key (str, optional): The api api_key, if not present,
                 will get by default rule(TODO: api key doc). Defaults to None.
 
         Returns:
             DashScopeAPIResponse: The created object in output.
         """
         headers = kwargs.pop('headers', {})
-        url = '%s%s' % (dashscope.base_http_api_url, cls.SUB_PATH.lower())
+        url = _normalization_url(cls.SUB_PATH.lower())
         async with aiohttp.ClientSession() as client:
             response = await client.post(url=url,
                                          json=json,
                                          headers={
                                              **default_headers(api_key),
                                              **headers
                                          })  # noqa E501
@@ -426,16 +536,15 @@
             api_key (str, optional): The api api_key, if not present,
                 will get by default rule(TODO: api key doc). Defaults to None.
 
         Returns:
             DashScopeAPIResponse: The updated object information in output.
         """
         headers = kwargs.pop('headers', {})
-        url = '%s%s/%s' % (dashscope.base_http_api_url, cls.SUB_PATH.lower(),
-                           target)
+        url = _normalization_url(cls.SUB_PATH.lower(), target)
         async with aiohttp.ClientSession() as client:
             response = await client.patch(url=url,
                                           json=json,
                                           headers={
                                               **default_headers(api_key),
                                               **headers
                                           })  # noqa E501
@@ -459,15 +568,15 @@
             api_key (str, optional): The api api_key, if not present,
                 will get by default rule(TODO: api key doc). Defaults to None.
 
         Returns:
             DashScopeAPIResponse: The uploaded file information in the output.
         """
         headers = kwargs.pop('headers', {})
-        url = '%s%s' % (dashscope.base_http_api_url, cls.SUB_PATH.lower())
+        url = _normalization_url(cls.SUB_PATH.lower())
         form = aiohttp.FormData()
         for name, file, file_name in files:
             if name is None:
                 form.add_field(os.path.basename(file.name),
                                file,
                                filename=file_name)
             else:
@@ -498,16 +607,15 @@
             api_key (str, optional): The api api_key, if not present,
                 will get by default rule(TODO: api key doc). Defaults to None.
 
         Returns:
             DashScopeAPIResponse: The cancel result.
         """
         headers = kwargs.pop('headers', {})
-        url = '%s%s/%s/cancel' % (dashscope.base_http_api_url,
-                                  cls.SUB_PATH.lower(), target)
+        url = _normalization_url(cls.SUB_PATH.lower(), target, 'cancel')
         async with aiohttp.ClientSession() as client:
             response = await client.post(url=url,
                                          headers={
                                              **default_headers(api_key),
                                              **headers
                                          })  # noqa E501
             return await _handle_http_response(response)
@@ -526,16 +634,15 @@
             api_key (str, optional): The api api_key, if not present,
                 will get by default rule(TODO: api key doc). Defaults to None.
 
         Returns:
             DashScopeAPIResponse: The target outputs.
         """
         headers = kwargs.pop('headers', {})
-        url = '%s%s/%s/events' % (dashscope.base_http_api_url,
-                                  cls.SUB_PATH.lower(), target)
+        url = _normalization_url(cls.SUB_PATH.lower(), target, 'events')
         async with aiohttp.ClientSession() as client:
             response = await client.get(url=url,
                                         headers={
                                             **default_headers(api_key),
                                             **headers
                                         })  # noqa E501
             return await _handle_http_response(response)
```

## dashscope/common/constants.py

```diff
@@ -1,28 +1,33 @@
 from http import HTTPStatus
 from pathlib import Path
 
 DASHSCOPE_API_KEY_ENV = 'DASHSCOPE_API_KEY'
 DASHSCOPE_API_KEY_FILE_PATH_ENV = 'DASHSCOPE_API_KEY_FILE_PATH'
 DASHSCOPE_API_REGION_ENV = 'DASHSCOPE_API_REGION'
 DASHSCOPE_API_VERSION_ENV = 'DASHSCOPE_API_VERSION'
+# to disable data inspection
+# export DASHSCOPE_DISABLE_DATA_INSPECTION=true
+DASHSCOPE_DISABLE_DATA_INSPECTION_ENV = 'DASHSCOPE_DISABLE_DATA_INSPECTION'
 DEFAULT_DASHSCOPE_CACHE_PATH = Path.home().joinpath('.dashscope')
 DEFAULT_DASHSCOPE_API_KEY_FILE_PATH = Path.joinpath(
     DEFAULT_DASHSCOPE_CACHE_PATH, 'api_key')
 
 DEFAULT_REQUEST_TIMEOUT_SECONDS = 300
 SERVICE_API_PATH = 'services'
-
 DASHSCOPE_LOGGING_LEVEL_ENV = 'DASHSCOPE_LOGGING_LEVEL'
 # task config keys.
 PROMPT = 'prompt'
+NEGATIVE_PROMPT = 'negative_prompt'
 HISTORY = 'history'
 CUSTOMIZED_MODEL_ID = 'customized_model_id'
-SERVICE_503_MESSAGE = 'Service temporarily unavailable, possibly overloaded or not ready.'  # noqa E501
+IMAGES = 'images'
 
+SERVICE_503_MESSAGE = 'Service temporarily unavailable, possibly overloaded or not ready.'  # noqa E501
+WEBSOCKET_ERROR_CODE = 44
 SSE_CONTENT_TYPE = 'text/event-stream'
 
 REPEATABLE_STATUS = [
     HTTPStatus.SERVICE_UNAVAILABLE, HTTPStatus.GATEWAY_TIMEOUT
 ]
```

## dashscope/common/error.py

 * *Ordering differences only*

```diff
@@ -2,27 +2,27 @@
     pass
 
 
 class InvalidParameter(Exception):
     pass
 
 
-class UnsupportedModel(Exception):
+class InvalidTask(Exception):
     pass
 
 
-class UnsupportedTask(Exception):
+class UnsupportedModel(Exception):
     pass
 
 
-class ModelRequired(Exception):
+class UnsupportedTask(Exception):
     pass
 
 
-class InvalidTask(Exception):
+class ModelRequired(Exception):
     pass
 
 
 class InvalidModel(Exception):
     pass
```

## dashscope/common/utils.py

```diff
@@ -1,12 +1,14 @@
 import asyncio
 import json
+import os
 import platform
 from http import HTTPStatus
 from typing import Dict
+from urllib.parse import urlparse
 
 import aiohttp
 
 from dashscope.api_entities.dashscope_response import DashScopeAPIResponse
 from dashscope.common.api_key import get_default_api_key
 from dashscope.version import __version__
 
@@ -33,14 +35,46 @@
     """
     pkg, task = module_name.rsplit('.', 1)
     task = task.replace('_', '-')
     _, task_group = pkg.rsplit('.', 1)
     return task_group, task
 
 
+def is_path(path: str):
+    """Check the input path is valid local path.
+
+    Args:
+        path_or_url (str): The path.
+
+    Returns:
+        bool: If path return True, otherwise False.
+    """
+    url_parsed = urlparse(path)
+    if url_parsed.scheme in ('file', ''):
+        return os.path.exists(url_parsed.path)
+    else:
+        return False
+
+
+def is_url(url: str):
+    """Check the input url is valid url.
+
+    Args:
+        url (str): The url
+
+    Returns:
+        bool: If is url return True, otherwise False.
+    """
+    url_parsed = urlparse(url)
+    if url_parsed.scheme in ('http', 'https', 'oss'):
+        return True
+    else:
+        return False
+
+
 def iter_over_async(ait, loop):
     ait = ait.__aiter__()
 
     async def get_next():
         try:
             obj = await ait.__anext__()
             return False, obj
```

## Comparing `dashscope-1.0.4.dist-info/LICENSE` & `dashscope-1.1.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `dashscope-1.0.4.dist-info/METADATA` & `dashscope-1.1.0.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: dashscope
-Version: 1.0.4
+Version: 1.1.0
 Summary: dashscope client sdk library
 Home-page: https://dashscope.aliyun.com/
 Author: Alibaba
 Author-email: dashscope@alibaba-inc.com
 License: Apache 2.0
 Platform: Posix; MacOS X; Windows
 Classifier: Development Status :: 4 - Beta
```

## Comparing `dashscope-1.0.4.dist-info/RECORD` & `dashscope-1.1.0.dist-info/RECORD`

 * *Files 14% similar despite different names*

```diff
@@ -1,42 +1,43 @@
-dashscope/__init__.py,sha256=mfYfC_Wv9cP0grx8laHj6Nw0PUAnT4TVYRCFN16Gsk0,835
-dashscope/cli.py,sha256=O7NzpeQVgficKnjO3fkj6oduAI14HBWpIFnQ2ZDthDo,13361
+dashscope/__init__.py,sha256=j634OmFq9eHDmXcb1fsV0cemdyjGwKRJEP7wY26bXvk,909
+dashscope/cli.py,sha256=FHz1UGh8dCDBV25FQttJM1uxZT3rNKGDp_krfCel7rY,13474
 dashscope/deployment.py,sha256=OA7FMkFTXwKDTcLLZe57_ZlCk38S29krdijy-_W64G4,3445
 dashscope/file.py,sha256=maMrfMB5_WVltYEyGN4QcAH0Xxj0eHkScisP8AXx4RQ,3753
 dashscope/finetune.py,sha256=jUj43EmwtCDYNqMvjKimuCQigG0Ux2EvZBypGcmkqHg,4808
 dashscope/model.py,sha256=kLXawzbbq4VkFFFjruz06MkuY-uEMUWCqs-4quqV7Us,1696
-dashscope/version.py,sha256=thGZHY6pLPhJc6CwYBjUaQ6pGxLhwPMp_pjoYsiwvI4,22
-dashscope/aigc/__init__.py,sha256=CHacUkZVIDlNFrhBnQiyjxeWNByH8MsndcZoB8y2vbg,66
-dashscope/aigc/conversation.py,sha256=UxG9vPdZIEuw5ENOcdFm_-elm06wxj0OW47JGYbA7EI,8484
-dashscope/aigc/generation.py,sha256=hj67t6rFYGpZ8GVEyfUlNbHDlhR3IWkiXMaoVw0GTzY,4743
+dashscope/version.py,sha256=b6-WiVk0Li5MaV2rBnHYl104TsouINojSWKqHDas0js,22
+dashscope/aigc/__init__.py,sha256=llQdhMk9N11SKlTSAvYK-E4xT46GcXUAF51I-oDDDMM,239
+dashscope/aigc/conversation.py,sha256=H46NzB7CvCNBVFeD61bG-IBxcdfe3hjenszvI4M0AeY,8844
+dashscope/aigc/generation.py,sha256=LwyYEu-aRZGbXBilaaYQqkk2MF7Ojc1kBl-UU8nOAbI,5064
+dashscope/aigc/image_synthesis.py,sha256=zZhpny20azLinMhhvAgyLY4qHugtl1EEApJQ5vuHNZI,7669
 dashscope/api_entities/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dashscope/api_entities/aiohttp_request.py,sha256=LpUM-BGKTHUeBnZ6cOfmdlp4-7czWLkhdNSzS2ydOh0,10361
 dashscope/api_entities/api_request_data.py,sha256=kz6_nYV1Ddx-F0MmYHAmlzetiHbV72PE5ffccR1NsKc,5310
 dashscope/api_entities/api_request_factory.py,sha256=4COz8WMEJOBP2_7jkW62Rua21SpoyrthCOMT0yg_z_k,4057
-dashscope/api_entities/base_request.py,sha256=RmeAxfjr3CKp-tTyd62ewQKXMqrPw0qQ5xXDTkpcWLU,608
-dashscope/api_entities/dashscope_response.py,sha256=lLD94qdcfimPcdEHtNXb6saWxMzW1yn7boTH5HRKIMM,5801
-dashscope/api_entities/http_request.py,sha256=bx4Bx4PcaKNxR4jaCqaYO5YXnmYsn4PoAl2bXsKn5yk,9401
+dashscope/api_entities/base_request.py,sha256=dSkLxV7hJyLCse5v4msceRiUyKzDforp5iOGVMuh2tA,976
+dashscope/api_entities/dashscope_response.py,sha256=jaBqecBjJz1OqL_8YqfSQ328p1LPHiA4gwugDBUotVA,8130
+dashscope/api_entities/http_request.py,sha256=fP8E54rX2Sz2aiYSAqT9mEiRjtSFSy_-hBnDsfAq3dk,9457
 dashscope/api_entities/sync_http_request.py,sha256=Yn1ursuviL5enxs87hraKkUBenQLyiHDV487KKQq5A0,8798
-dashscope/api_entities/websocket_request.py,sha256=9MqDRcL1choHqISj3od5EQg7Ecejan6bNFKTMVOM6qM,15625
+dashscope/api_entities/websocket_request.py,sha256=dUU6-wRP28IZQDDL_OTytQxpzKwXKMJcCijii06bheI,15705
 dashscope/audio/__init__.py,sha256=b8cHgjJF9VyvYAvEOGJykcQhLGejnOaJd6yXUlp6oH4,35
 dashscope/audio/asr/__init__.py,sha256=kgQYk8-q7lg64oBD7sRhCuZECvOWswmoA-zRoeU2aqw,75
 dashscope/audio/asr/transcribe.py,sha256=tJYu2u9qdnoTDmv__KIUDZ1u1LEc8mUX78vqacvxMtI,6946
 dashscope/audio/asr/transcription.py,sha256=niqgLGcvpsnv1LR2JFFinN7Gan92CJiMV_DrhfbY9e8,5103
 dashscope/client/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dashscope/client/base_api.py,sha256=b0wimtEe6upoCPxHBs3KLq0hexGJECysBecBZ7pf-yU,21665
+dashscope/client/base_api.py,sha256=eAPdh02tsA7AA9ORImQQ7bMAaLe0SNuXJFbYWDoZASM,25911
 dashscope/common/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dashscope/common/api_key.py,sha256=5Stp0odL5JSuIO3qJBp23QNppuGbqhhvKPS66qbMs0I,1986
-dashscope/common/constants.py,sha256=QTT0rQDPHcK5hBzjVe_FoKhQ75_tLZKRCgK5ouH6gn4,1983
+dashscope/common/constants.py,sha256=QJbCxQoy_uzPfVHdfLCoxPN1lfoeFORE49UweDqB2mw,2215
 dashscope/common/env.py,sha256=oQOZW5JyEeTSde394un2lpDJ5RBh4fMU9hBfbtrKKkc,869
-dashscope/common/error.py,sha256=Y78DEs5-HL_hG3ImweJyZA7w3vn0iNXvuapzF5EbaKs,1592
+dashscope/common/error.py,sha256=zbWWjgBXWFNtyVBMQpjuLhOKN4k5XlyByrHn1yWy4Qc,1592
 dashscope/common/logging.py,sha256=ecGxylG3bWES_Xv5-BD6ep4_0Ciu7F6ZPBjiZtu9Jx4,984
-dashscope/common/utils.py,sha256=xVibdtpfEx-Nf9oVkfwW16JhoWEi4lZh8MwfQS4Z95U,3330
+dashscope/common/utils.py,sha256=F5GOEMIzB2Sh1ohzx_nNgGKe752F92aQQpsaqFh-4nM,4038
 dashscope/io/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dashscope/io/input_output.py,sha256=vLYMeKgV5JbzjTqzZv8dzAGxWqArXjq1FnBCxcmV-zg,2781
 dashscope/protocol/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dashscope/protocol/websocket.py,sha256=z-v6PGx3L4zYBANuC48s7SWSQSwRCDoh0zcfhv9Bf8U,561
-dashscope-1.0.4.dist-info/LICENSE,sha256=Izp5L1DF1Mbza6qojkqNNWlE_mYLnr4rmzx2EBF8YFw,11413
-dashscope-1.0.4.dist-info/METADATA,sha256=cq9EsGYSvAMYoFLjb1oPTNGwQaTKWyvP3Luj6cDl-3I,7201
-dashscope-1.0.4.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-dashscope-1.0.4.dist-info/entry_points.txt,sha256=raEp5dOuj8whJ7yqZlDM8WQ5p2RfnGrGNo0QLQEnatY,50
-dashscope-1.0.4.dist-info/top_level.txt,sha256=woqavFJK9zas5xTqynmALqOtlafghjsk63Xk86powTU,10
-dashscope-1.0.4.dist-info/RECORD,,
+dashscope-1.1.0.dist-info/LICENSE,sha256=Izp5L1DF1Mbza6qojkqNNWlE_mYLnr4rmzx2EBF8YFw,11413
+dashscope-1.1.0.dist-info/METADATA,sha256=H0FSfxC1tUHvnNpAKFgvKBVeKlu7Sfr0ErBWmZVPcl4,7201
+dashscope-1.1.0.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+dashscope-1.1.0.dist-info/entry_points.txt,sha256=raEp5dOuj8whJ7yqZlDM8WQ5p2RfnGrGNo0QLQEnatY,50
+dashscope-1.1.0.dist-info/top_level.txt,sha256=woqavFJK9zas5xTqynmALqOtlafghjsk63Xk86powTU,10
+dashscope-1.1.0.dist-info/RECORD,,
```

