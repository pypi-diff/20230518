# Comparing `tmp/big-0.7.1.tar.gz` & `tmp/big-0.8.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "big-0.7.1.tar", last modified: Mon Mar 13 14:54:29 2023, max compression
+gzip compressed data, was "big-0.8.tar", last modified: Fri Jan  1 00:00:00 2016, max compression
```

## Comparing `big-0.7.1.tar` & `big-0.8.tar`

### file list

```diff
@@ -1,32 +1,32 @@
--rw-r--r--   0        0        0       50 2022-10-16 10:01:54.529408 big-0.7.1/.gitignore
--rw-r--r--   0        0        0     1084 2023-02-27 05:20:01.216693 big-0.7.1/LICENSE
--rw-r--r--   0        0        0   133502 2023-03-13 13:53:41.045348 big-0.7.1/README.md
--rw-r--r--   0        0        0     1242 2023-03-13 13:37:05.138390 big-0.7.1/big/__init__.py
--rw-r--r--   0        0        0     1941 2023-02-27 05:20:38.629843 big-0.7.1/big/all.py
--rw-r--r--   0        0        0     5705 2023-02-27 05:20:21.669321 big-0.7.1/big/boundinnerclass.py
--rw-r--r--   0        0        0     3274 2023-02-27 05:20:04.132782 big-0.7.1/big/builtin.py
--rw-r--r--   0        0        0    11015 2023-02-27 09:44:52.168908 big-0.7.1/big/file.py
--rw-r--r--   0        0        0    25350 2023-02-27 05:20:18.117212 big-0.7.1/big/graph.py
--rw-r--r--   0        0        0     5347 2023-02-27 05:20:24.201399 big-0.7.1/big/heap.py
--rw-r--r--   0        0        0     2499 2023-02-27 05:14:09.761886 big-0.7.1/big/itertools.py
--rw-r--r--   0        0        0    12574 2023-03-13 09:41:06.951462 big-0.7.1/big/scheduler.py
--rw-r--r--   0        0        0    73099 2023-03-13 13:26:32.502959 big-0.7.1/big/text.py
--rw-r--r--   0        0        0     7163 2023-02-27 09:47:27.277744 big-0.7.1/big/time.py
--rw-r--r--   0        0        0      585 2023-02-27 05:14:09.765886 big-0.7.1/pyproject.toml
--rw-r--r--   0        0        0       16 2022-10-27 05:15:36.832936 big-0.7.1/requirements.txt
--rw-r--r--   0        0        0   174313 2022-05-27 04:32:07.000000 big-0.7.1/resources/experiments/alice.in.wonderland.txt
--rw-r--r--   0        0        0     6060 2023-02-27 05:19:48.340297 big-0.7.1/resources/experiments/time_multisplit.py
--rw-r--r--   0        0        0  1391641 2022-06-02 13:08:28.000000 big-0.7.1/resources/images/big.header.png
--rw-r--r--   0        0        0     2692 2023-02-27 05:18:57.142722 big-0.7.1/test/bigtestlib.py
--rw-r--r--   0        0        0       50 2023-02-27 04:22:21.366710 big-0.7.1/test/grepfile
--rw-r--r--   0        0        0     1422 2023-02-27 05:19:13.267218 big-0.7.1/test/test_all.py
--rw-r--r--   0        0        0     5847 2023-02-27 05:19:16.007302 big-0.7.1/test/test_boundinnerclass.py
--rw-r--r--   0        0        0     6486 2023-02-27 05:19:07.179031 big-0.7.1/test/test_builtin.py
--rw-r--r--   0        0        0     8332 2023-02-27 05:19:09.707109 big-0.7.1/test/test_file.py
--rw-r--r--   0        0        0    12302 2023-02-27 09:47:52.190521 big-0.7.1/test/test_graph.py
--rw-r--r--   0        0        0     4978 2023-02-27 05:19:42.312111 big-0.7.1/test/test_heap.py
--rw-r--r--   0        0        0     3373 2023-02-27 05:19:21.135460 big-0.7.1/test/test_itertools.py
--rw-r--r--   0        0        0    11445 2023-03-11 18:10:35.385796 big-0.7.1/test/test_scheduler.py
--rw-r--r--   0        0        0    93129 2023-03-09 13:08:09.671707 big-0.7.1/test/test_text.py
--rw-r--r--   0        0        0     6069 2023-02-27 09:48:42.012074 big-0.7.1/test/test_time.py
--rw-r--r--   0        0        0   134047 1970-01-01 00:00:00.000000 big-0.7.1/PKG-INFO
+-rw-r--r--   0        0        0       50 2022-12-06 08:53:33.203521 big-0.8/.gitignore
+-rw-r--r--   0        0        0     1084 2023-04-12 21:51:57.496190 big-0.8/LICENSE
+-rw-r--r--   0        0        0   142096 2023-05-18 12:33:28.374029 big-0.8/README.md
+-rw-r--r--   0        0        0     1240 2023-05-18 12:31:45.441153 big-0.8/big/__init__.py
+-rw-r--r--   0        0        0     1941 2023-04-12 21:51:57.504191 big-0.8/big/all.py
+-rw-r--r--   0        0        0     5705 2023-04-12 21:51:57.504191 big-0.8/big/boundinnerclass.py
+-rw-r--r--   0        0        0     3274 2023-04-12 21:51:57.504191 big-0.8/big/builtin.py
+-rw-r--r--   0        0        0    11015 2023-04-12 21:51:57.504191 big-0.8/big/file.py
+-rw-r--r--   0        0        0    25350 2023-04-12 21:51:57.504191 big-0.8/big/graph.py
+-rw-r--r--   0        0        0     5347 2023-04-12 21:51:57.504191 big-0.8/big/heap.py
+-rw-r--r--   0        0        0     2499 2023-04-12 21:51:57.504191 big-0.8/big/itertools.py
+-rw-r--r--   0        0        0    12574 2023-04-12 21:51:57.504191 big-0.8/big/scheduler.py
+-rw-r--r--   0        0        0    95441 2023-05-18 12:28:37.491552 big-0.8/big/text.py
+-rw-r--r--   0        0        0     7163 2023-04-12 21:51:57.504191 big-0.8/big/time.py
+-rw-r--r--   0        0        0      613 2023-04-12 21:51:57.504191 big-0.8/pyproject.toml
+-rw-r--r--   0        0        0       16 2022-12-06 08:53:33.203521 big-0.8/requirements.txt
+-rw-r--r--   0        0        0   174313 2022-05-27 04:32:07.000000 big-0.8/resources/experiments/alice.in.wonderland.txt
+-rw-r--r--   0        0        0     6060 2023-04-12 21:51:57.504191 big-0.8/resources/experiments/time_multisplit.py
+-rw-r--r--   0        0        0  1391641 2022-06-02 13:08:28.000000 big-0.8/resources/images/big.header.png
+-rw-r--r--   0        0        0     2692 2023-04-12 21:51:57.504191 big-0.8/test/bigtestlib.py
+-rw-r--r--   0        0        0       50 2022-05-28 09:56:21.000000 big-0.8/test/grepfile
+-rw-r--r--   0        0        0     1422 2023-04-12 21:51:57.504191 big-0.8/test/test_all.py
+-rw-r--r--   0        0        0     5847 2023-04-12 21:51:57.504191 big-0.8/test/test_boundinnerclass.py
+-rw-r--r--   0        0        0     6486 2023-04-12 21:51:57.504191 big-0.8/test/test_builtin.py
+-rw-r--r--   0        0        0     8332 2023-04-12 21:51:57.504191 big-0.8/test/test_file.py
+-rw-r--r--   0        0        0    12302 2023-04-12 21:51:57.504191 big-0.8/test/test_graph.py
+-rw-r--r--   0        0        0     4978 2023-04-12 21:51:57.504191 big-0.8/test/test_heap.py
+-rw-r--r--   0        0        0     3373 2023-04-12 21:51:57.504191 big-0.8/test/test_itertools.py
+-rw-r--r--   0        0        0    11445 2023-04-12 21:51:57.504191 big-0.8/test/test_scheduler.py
+-rw-r--r--   0        0        0   111989 2023-05-18 11:26:19.367687 big-0.8/test/test_text.py
+-rw-r--r--   0        0        0     6069 2023-04-12 21:51:57.508190 big-0.8/test/test_time.py
+-rw-r--r--   0        0        0   142699 1970-01-01 00:00:00.000000 big-0.8/PKG-INFO
```

### Comparing `big-0.7.1/LICENSE` & `big-0.8/LICENSE`

 * *Files identical despite different names*

### Comparing `big-0.7.1/README.md` & `big-0.8/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,24 @@
-![# big](/resources/images/big.header.png)
+Metadata-Version: 2.1
+Name: big
+Version: 0.8
+Summary: The big package is a grab-bag of cool code for use in your programs.
+Author-email: Larry Hastings <larry@hastings.org>
+Requires-Python: >=3.6
+Description-Content-Type: text/markdown
+Classifier: Intended Audience :: Developers
+Classifier: License :: CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
+Classifier: Programming Language :: Python :: 3 :: Only
+Requires-Dist: regex ; extra == "test"
+Requires-Dist: python-dateutil ; extra == "time"
+Project-URL: Source, https://github.com/larryhastings/big/
+Provides-Extra: test
+Provides-Extra: time
+
+![# big](https://raw.githubusercontent.com/larryhastings/big/master/resources/images/big.header.png)
 
 ##### Copyright 2022-2023 by Larry Hastings
 
 **big** is a Python package, a grab-bag of useful technology
 I always want to have handy.
 
 Finally!  For years, I've copied-and-pasted all my little
@@ -195,14 +211,16 @@
 
 [`Regulator.now()`](#regulatornow)
 
 [`Regulator.sleep(t)`](#regulatorsleept)
 
 [`Regulator.wake()`](#regulatorwake)
 
+[`reversed_re_finditer(pattern, string, flags=0)`](#reversed_re_finditerpattern-string-flags0)
+
 [`safe_mkdir(path)`](#safe_mkdirpath)
 
 [`safe_unlink(path)`](#safe_unlinkpath)
 
 [`Scheduler(regulator=default_regulator)`](#schedulerregulatordefault_regulator)
 
 [`Scheduler.schedule(o, time, *, absolute=False, priority=DEFAULT_PRIORITY)`](#schedulerscheduleo-time--absolutefalse-prioritydefault_priority)
@@ -374,20 +392,20 @@
 > tries `int(o)`.  If that conversion succeeds, returns the result.
 > Otherwise, tries `float(o)`.  If that conversion succeeds, returns
 > the result.  Otherwise returns the default value.  If you don't
 > pass in an explicit default value, the default value is `o`.
 
 #### `try_float(o)`
 
-> Returns `True` if `o` can be converted into a float,
+> Returns `True` if `o` can be converted into a `float`,
 > and `False` if it can't.
 
 #### `try_int(o)`
 
-> Returns `True` if `o` can be converted into an int,
+> Returns `True` if `o` can be converted into an `int`,
 > and `False` if it can't.
 
 
 ## `big.file`
 
 Functions for working with files, directories, and I/O.
 
@@ -402,30 +420,31 @@
 > * a bytes object, or
 > * a `pathlib.Path` object.
 >
 > `text` should be either string or bytes.
 >
 > `encoding` is used as the file encoding when opening the file.
 >
-> if `text` is a str, the file is opened in text mode.
-> if `text` is a bytes object, the file is opened in binary mode.
-> `encoding` must be `None` when the file is opened in binary mode.
+> * If `text` is a str, the file is opened in text mode.
+> * If `text` is a bytes object, the file is opened in binary mode.
+>   `encoding` must be `None` when the file is opened in binary mode.
 >
 > If `case_insensitive` is true, perform the search in a case-insensitive
 > manner.
 >
 > Returns a list of lines in the file containing `text`.  The lines are either
 > strings or bytes objects, depending on the type of `pattern`.  The lines
 > have their newlines stripped but preserve all other whitespace.
 >
 > If `enumerate` is true, returns a list of tuples of (line_number, line).
 > The first line of the file is line number 1.
 >
 > For simplicity of implementation, the entire file is read in to memory
-> at one time.  If `case_insensitive` is True, a lowercased copy is also used.
+> at one time.  If `case_insensitive` is true, `fgrep` also makes a lowercased
+> copy.
 
 #### `file_mtime(path)`
 
 > Returns the modification time of `path`, in seconds since the epoch.
 > Note that seconds is a float, indicating the sub-second with some
 > precision.
 
@@ -437,15 +456,15 @@
 
 > Returns the size of the file at `path`, as an integer representing the
 > number of bytes.
 
 #### `grep(path, pattern, *, encoding=None, enumerate=False, flags=0)`
 
 > Look for matches to a regular expression pattern in the lines of a file,
-> like the UNIX `grep` utility program.
+> similarly to the UNIX `grep` utility program.
 >
 > `path` should be an object representing a path to an existing file, one of:
 >
 > * a string,
 > * a bytes object, or
 > * a `pathlib.Path` object.
 >
@@ -494,36 +513,39 @@
 > This would change into the `'x'` subdirectory before
 > executing the nested block, then change back to
 > the original directory after the nested block.
 >
 > You can change directories in the nested block;
 > this won't affect pushd restoring the original current
 > working directory upon exiting the nested block.
+>
+> You can safely nest `with pushd` blocks.
 
 #### `safe_mkdir(path)`
 
 > Ensures that a directory exists at `path`.
 > If this function returns and doesn't raise,
 > it guarantees that a directory exists at `path`.
 >
 > If a directory already exists at `path`,
-> does nothing.
+> `safe_mkdir` does nothing.
 >
-> If a file exists at `path`, unlinks it
-> then creates the directory.
+> If a file exists at `path`, `safe_mkdir`
+> unlinks `path` then creates the directory.
 >
 > If the parent directory doesn't exist,
-> creates it, then creates `path`.
+> `safe_mkdir` creates that directory,
+> then creates `path`.
 >
 > This function can still fail:
 >
-> * 'path' could be on a read-only filesystem.
+> * `path` could be on a read-only filesystem.
 > * You might lack the permissions to create `path`.
-> * You could ask to create the directory 'x/y'
->   and 'x' is a file (not a directory).
+> * You could ask to create the directory `x/y`
+>   and `x` is a file (not a directory).
 
 #### `safe_unlink(path)`
 
 > Unlinks `path`, if `path` exists and is a file.
 
 #### `touch(path)`
 
@@ -986,29 +1008,60 @@
 >
 > This `Regulator` isn't guaranteed to be safe
 > for use while in a signal-handler callback.
 
 
 ## `big.text`
 
-> Functions for working with text strings.  There are
-> several families of functions inside the `text` module;
-> for a higher-level view of those families, read the
-> following deep-dives:
->
-> * [**The `multi-` family of functions**](#The-multi--family-of-functions)
-> * [**`lines` and lines modifier functions**](#lines-and-lines-modifier-functions)
-> * [**Word wrapping and formatting**](#word-wrapping-and-formatting)
->
-> All the functions in `big.text` will work with either
-> `str` or `bytes` objects, except the three
-> [**Word wrapping and formatting**](#word-wrapping-and-formatting)
-> functions.  When working with `bytes`,
-> by default the functions will only work with ASCII
-> characters.
+Functions for working with text strings.  There are
+several families of functions inside the `text` module;
+for a higher-level view of those families, read the
+following deep-dives:
+
+* [**The `multi-` family of functions**](#The-multi--family-of-functions)
+* [**`lines` and lines modifier functions**](#lines-and-lines-modifier-functions)
+* [**Word wrapping and formatting**](#word-wrapping-and-formatting)
+
+All the functions in `big.text` will work with either
+`str` or `bytes` objects, except the three
+[**Word wrapping and formatting**](#word-wrapping-and-formatting)
+functions.  When working with `bytes`,
+by default the functions will only work with ASCII
+characters.
+
+## Support for bytes and str
+
+The **big** text functions all support both `str` and `bytes`.
+The functions all automatically detect whether you passed in
+`str` or `bytes`  using an
+intentionally simple and predictable process, as follows:
+
+At the start of each function, it'll test its first "string"
+argument to see if it's a `bytes` object.
+
+```Python
+is_bytes = isinstance(<argument>, bytes)
+```
+
+If `isinstance` returns `True`, the function assumes all arguments are
+`bytes` objects.  Otherwise the function assumes all arguments
+are `str` objects.
+
+As a rule, no further further testing, casting, or catching exceptions
+is done.
+
+Functions that take multiple string-like parameters require all
+such arguments to be the same type.
+These functions will check that all such arguments
+are of the same type.
+
+Subclasses of `str` and `bytes` will also work; anywhere you
+should pass in a `str`, you can also pass in a subclass of
+`str`, and likewise for `bytes`.
+
 
 #### `gently_title(s, *, apostrophes=None, double_quotes=None)`
 
 > Uppercase the first character of every word in `s`.
 > Leave the other letters alone.  s should be `str` or `bytes`.
 >
 > (For the purposes of this algorithm, words are
@@ -1064,26 +1117,25 @@
 > is set to a string containing these Unicode double quote code points:
 >     "“”„‟«»‹›
 
 #### `lines(s, separators=None, *, line_number=1, column_number=1, tab_width=8, **kwargs)`
 
 > A "lines iterator" object.  Splits s into lines, and iterates yielding those lines.
 >
-> `s` can be `str`, `bytes`, or any iterable.
+> `s` can be `str`, `bytes`, or any iterable of `str` or `bytes`.
 >
-> By default, if `s` is `str`, splits `s` by all Unicode line break characters.
-> If `s` is `bytes`, splits `s` by all ASCII line break characters.
->
-> If `s` is neither str nor bytes, `s` must be an iterable;
-> lines yields successive elements of `s` as lines.
->
-> `separators`, if not `None`, must be an iterable of strings of the
-> same type as `s`.  `lines` will split `s` using those strings as
-> separator strings (using
-> [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)).
+> If `s` is neither `str` nor `bytes`, `s` must be an iterable;
+> `lines` yields successive elements of `s` as lines.  All objects
+> yielded by this iterable should be homogeneous, either `str` or `bytes`.
+>
+> If `s` is `str` or `bytes`, and `separators` is `None`, `lines`
+> will split `s` at line boundaries and yield those lines, including
+> empty lines.  If `separators` is not `None`, it must be an iterable
+> of strings of the same type as `s`; `lines` will split `s` using
+> [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse).
 >
 > When iterated over, yields 2-tuples:
 >     (info, line)
 >
 > `info` is a `LineInfo` object, which contains three fields by
 > default:
 >
@@ -1293,18 +1345,18 @@
 > Returns a string.
 >
 > `columns` should be an iterable of column tuples.
 > Each column tuple should contain three items:
 > ```Python
 >     (text, min_width, max_width)
 > ```
-> `text` should be a single text string, with newline
-> characters separating lines. `min_width` and `max_width`
-> are the minimum and maximum permissible widths for that
-> column, not including the column separator (if any).
+> `text` should be a single string, either `str` or `bytes`,
+> with newline characters separating lines. `min_width`
+> and `max_width` are the minimum and maximum permissible widths
+> for that column, not including the column separator (if any).
 >
 > Note that this function does not text-wrap the lines.
 >
 > `column_separator` is printed between every column.
 >
 > `overflow_strategy` tells merge_columns how to handle a column
 > with one or more lines that are wider than that column's `max_width`.
@@ -1326,15 +1378,15 @@
 > [**Word wrapping and formatting.**](#word-wrapping-and-formatting)
 
 #### `multipartition(s, separators, count=1, *, reverse=False, separate=True)`
 
 > Like `str.partition`, but supports partitioning based on multiple
 > separator strings, and can partition more than once.
 >
-> `s` can be str or bytes.
+> `s` can be either `str` or `bytes`.
 >
 > `separators` should be an iterable of objects of the same type as `s`.
 >
 > By default, if any of the strings in `separators` are found in `s`,
 > returns a tuple of three strings: the portion of `s` leading up to
 > the earliest separator, the separator, and the portion of `s` after
 > that separator.  Example:
@@ -1370,18 +1422,15 @@
 
 #### `multisplit(s, separators, *, keep=False, maxsplit=-1, reverse=False, separate=False, strip=False)`
 
 > Splits strings like `str.split`, but with multiple separators and options.
 >
 > `s` can be `str` or `bytes`.
 >
-> `separators` should be an iterable.  Each element of `separators`
-> should be the same type as `text`.  If `separators` is a string or bytes
-> object, `multisplit` behaves as separators is a tuple containing each
-> individual character.
+> `separators` should be an iterable of `str` or `bytes`, matching `s`.
 >
 > Returns an iterator yielding the strings split from `s`.  If `keep`
 > is true (or `ALTERNATING`), and `strip` is false, joining these strings
 > together will recreate `s`.
 >
 > `multisplit` is *greedy:* if two or more separators start at the same
 > location in `s`, `multisplit` splits using the longest matching separator.
@@ -1468,41 +1517,35 @@
 >            parse moving left (towards the beginning).
 >
 >    Splitting starting from the end of the string and parsing to
 >    the left has two effects.  First, if `maxsplit` is a number
 >    greater than 0, the splits will start at the end of the string
 >    rather than the beginning.  Second, if there are overlapping
 >    instances of separators in the string, `multisplit` will prefer
->    the rightmost separator rather than the left.  For example:
->
->        multisplit(" x x ", (" x ",), keep=big.ALTERNATING)
->
->    will split on the leftmost instance of `" x "`, yielding
->
->        "", " x ", "x "
+>    the rightmost separator rather than the left.  Consider this
+>    example, where `reverse` is false:
 >
->    whereas
+>        multisplit("A x x Z", (" x ",), keep=big.ALTERNATING) => "A", " x ", "x Z"
 >
->        multisplit(" x x ", (" x ",), keep=big.ALTERNATING, reverse=True)
+>    If you pass in a true value for `reverse`, `multisplit` will prefer
+>    the rightmost overlapping separator:
 >
->    will split on the rightmost instance of `" x "`, yielding
->
->        " x", " x ", ""
+>        multisplit("A x x Z", (" x ",), keep=big.ALTERNATING, reverse=True) => "A x", " x ", "Z"
 >
 > For more information, see the deep-dive on
 > [**The `multi-` family of functions.**](#The-multi--family-of-functions)
 
 #### `multistrip(s, separators, left=True, right=True)`
 
 > Like `str.strip`, but supports stripping multiple substrings from `s`.
 >
 > Strips from the string `s` all leading and trailing instances of strings
 > found in `separators`.
 >
-> `s` should be str or bytes.
+> `s` should be `str` or `bytes`.
 >
 > `separators` should be an iterable of either `str` or `bytes`
 > objects matching the type of `s`.
 >
 > If `left` is a true value, strips all leading separators
 > from `s`.
 >
@@ -1520,31 +1563,34 @@
 > [**The `multi-` family of functions.**](#The-multi--family-of-functions)
 
 #### `newlines`
 
 > A list of all newline characters recognized by Python.
 > Includes many Unicode newline characters, like `'\u2029'`
 > (a paragraph separator).  Useful as a list of separator
-> strings for `[`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)` et al; `newlines` is specifically
-> used by the [`lines`](#liness-separatorsnone--line_number1-column_number1-tab_width8-kwargs) iterator constructor.
+> strings for
+> [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
+> et al; `newlines` is specifically used by the
+> [`lines`](#liness-separatorsnone--line_number1-column_number1-tab_width8-kwargs)
+> iterator constructor.
 >
 > **big** also defines `utf8_newlines`, which is `newlines`
 > with all strings encoded to UTF-8 (as bytes),
 > and `ascii_newlines`, with all strings converted into
 > bytes and all characters with code points greater than
 > 128 discarded.
 >
 > Note that `newlines` contains `'\r\n'`, the DOS sequence
 > of characters representing a newline.  This lets **big**
 > text-processing functions recognize this sequence as a
 > *single* newline marker, rather than as two *separate*
 > newline characters.  If you don't want this behavior,
-> you can use `newlines_without_dos` instead;
-> **big** also provides `utf8_newlines_without_dos` and
-> `ascii_newlines_without_dos`.
+> you can use `newlines_without_dos` instead.
+> (**big** also provides `utf8_newlines_without_dos` and
+> `ascii_newlines_without_dos`.)
 
 
 #### `normalize_whitespace(s, separators=None, replacement=None)`
 
 > Returns `s`, but with every run of consecutive
 > separator characters turned into a replacement string.
 > By default turns all runs of consecutive whitespace
@@ -1552,29 +1598,28 @@
 >
 > `s` may be `str` or `bytes`.
 > `separators` should be an iterable of either `str` or `bytes`
 > objects, matching `s`.
 > `replacement` should be either a `str` or `bytes` object,
 > also matching `s`, or `None` (the default).
 > If `replacement` is `None`, `normalize_whitespace` will use
-> a replacement string consisting of a single space character,
-> either `str` or `bytes` as appropriate.)
+> a replacement string consisting of a single space character.
 >
 > Leading or trailing runs of separator characters will
 > be replaced with the replacement string, e.g.:
 >
 >     normalize_whitespace("   a    b   c") == " a b c"
 
 #### `re_partition(text, pattern, count=1, *, flags=0, reverse=False)`
 
 > Like `str.partition`, but `pattern` is matched as a regular expression.
 >
 > `text` can be a string or a bytes object.
 >
-> `pattern` can be a string, bytes, or an `re.Pattern` object.
+> `pattern` can be a string, bytes, or `re.Pattern` object.
 >
 > `text` and `pattern` (or `pattern.pattern`) must be the same type.
 >
 > If `pattern` is found in text, returns a tuple
 > ```Python
 >     (before, match, after)
 > ```
@@ -1607,17 +1652,17 @@
 > (In older versions of Python, `re.Pattern` was a private type called
 > `re._pattern_type`.)
 
 #### `re_rpartition(text, pattern, count=1, *, flags=0)`
 
 > Like `str.rpartition`, but `pattern` is matched as a regular expression.
 >
-> `text` can be a string or a bytes object.
+> `text` can be a `str` or `bytes` object.
 >
-> `pattern` can be a string, bytes, or an `re.Pattern` object.
+> `pattern` can be a `str`, `bytes`, or `re.Pattern` object.
 >
 > `text` and `pattern` (or `pattern.pattern`) must be the same type.
 >
 > If `pattern` is found in `text`, returns a tuple
 > ```Python
 >     (before, match, after)
 > ```
@@ -1643,36 +1688,56 @@
 >
 > If `pattern` is a string, `flags` is passed in
 > as the `flags` argument to `re.compile`.
 >
 > (In older versions of Python, `re.Pattern` was a private type called
 > `re._pattern_type`.)
 
+#### `reversed_re_finditer(pattern, string, flags=0)`
+
+> An iterator.  Behaves almost identically to the Python
+> standard library function `re.finditer`, yielding
+> non-overlapping matches of `pattern` in `string`.  The difference
+> is, `reversed_re_finditer` searches `string` from right to left.
+>
+> `pattern` can be str, bytes, or a precompiled `re.Pattern` object.
+> If it's str or bytes, it'll be compiled
+> with `re.compile` using the `flags` you passed in.
+>
+> `string` should be the same type as `pattern` (or `pattern.pattern`).
+
 #### `split_quoted_strings(s, quotes=('"', "'"), *, triple_quotes=True, backslash='\\')`
 
-> Splits s into quoted and unquoted segments.  Returns an iterator yielding 2-tuples:
->     (is_quoted, segment)
-> where `segment` is a substring of `s`, and `is_quoted` is true if the segment is
-> quoted.  Joining all the segments together recreates `s`.
+> Splits `s` into quoted and unquoted segments.
 >
-> `quotes` is an iterable of quote separators.  Note that `split_quoted_strings`
+> `s` can be either `str` or `bytes`.
+>
+> `quotes` is an iterable of quote separators, either `str` or `bytes`
+> matching `s`.  Note that `split_quoted_strings`
 > only supports quote *characters,* as in, each quote separator must be exactly
 > one character long.
 >
+> Returns an iterator yielding 2-tuples:
+>     (is_quoted, segment)
+> where `segment` is a substring of `s`, and `is_quoted` is true if the segment is
+> quoted.  Joining all the segments together recreates `s`.
+>
 > If `triple_quotes` is true, supports "triple-quoted" strings like Python.
 >
 > If `backslash` is a character, this character will quoting characters inside
 > a quoted string, like the backslash character inside strings in Python.
 
 #### `split_text_with_code(s, *, tab_width=8, allow_code=True, code_indent=4, convert_tabs_to_spaces=True)`
 
-> Splits the string `s` into individual words,
+> Splits `s` into individual words,
 > suitable for feeding into
 > [`wrap_words`](#wrap_wordswords-margin79--two_spacestrue).
 >
+> `s` may be either `str` or `bytes`.
+>
 > Paragraphs indented by less than `code_indent` will be
 > broken up into individual words.
 >
 > If `allow_code` is true, paragraphs indented by at least
 > `code_indent` spaces will preserve their whitespace:
 > internal whitespace is preserved, and the newline is
 > preserved.  (This will preserve the formatting of code
@@ -1683,15 +1748,17 @@
 > [**Word wrapping and formatting.**](#word-wrapping-and-formatting)
 
 #### `whitespace`
 
 > A list of all whitespace characters recognized by Python.
 > Includes many Unicode whitespace strings, like `'\xa0'`
 > (a non-breaking space).  Useful as a list of separator
-> strings for `[`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)` et al.
+> strings for
+> [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
+>5 et al.
 >
 > **big** also defines `utf8_whitespace`, which is `whitespace`
 > with all strings encoded to UTF-8 (as bytes),
 > and `ascii_whitespace`, with all strings converted into
 > bytes and all characters with code points greater than
 > 128 discarded.
 >
@@ -1705,16 +1772,17 @@
 > `ascii_whitespace_without_dos`.
 
 #### `wrap_words(words, margin=79, *, two_spaces=True)`
 
 > Combines `words` into lines and returns the result as a string.
 > Similar to `textwrap.wrap`.
 >
-> `words` should be an iterator containing text split at word
-> boundaries.  Example:
+> `words` should be an iterator yielding str or bytes strings,
+> and these strings should already be split at word boundaries.
+> Here's an example of a valid argument for `words`:
 > ```Python
 >      "this is an example of text split at word boundaries".split()
 > ```
 >
 > A single `'\n'` indicates a line break.
 > If you want a paragraph break, embed two `'\n'` characters in a row.
 >
@@ -1917,24 +1985,24 @@
 (For example, `comment_separators` for `lines_filter_comment_lines`.)
 
 The downside of [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
 is that, since it *is* so
 sophisticated and tunable, it can be hard to use.  It takes
 *five keyword-only parameters* after all.  However, they're
 designed to be reasonably memorable, and their default values
-are designedo to be easy to remember.  But the best
+are designed to be easy to remember.  But the best
 way to combat the complexity of calling
 [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
 is to use it as a building block for your own
 text splitting functions.  For example, inside **big**,
 [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
 is used to implement
 [`multipartition`,](#multipartitions-separators-count1--reverseFalse-separateTrue)
 [`normalize_whitespace`,](#normalize_whitespaces-separatorsNone-replacementnone)
-[`lines`,](#liness-separatorsnone--line_number1-column_number1-tab_width8-kwargs),
+[`lines`,](#liness-separatorsnone--line_number1-column_number1-tab_width8-kwargs)
 and several others.
 
 ### Demonstrations of each `multisplit` keyword-only parameter
 
 To give you a sense of how the five keyword-only parameters changes the behavior of
 [`multisplit`,](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
 here's a breakdown of each of these parameters with examples.
@@ -2025,26 +2093,33 @@
 ```Python
     >>> list(big.multisplit('appleXbananaYcookie', ('X', 'Y'), keep=big.AS_PAIRS))
     [('apple', 'X'), ('banana', 'Y'), ('cookie', '')]
     >>> list(big.multisplit('appleXbananaYcookieXXX', ('X', 'Y'), keep=big.AS_PAIRS, strip=True))
     [('apple', 'X'), ('banana', 'Y'), ('cookie', '')]
 ```
 
+(This rule means that `AS_PAIRS` always emits an *even* number of strings.
+Contrast that with `ALTERNATING`, which always emits an *odd* number of strings,
+and the last string it emits is always a non-separator string.  Put another
+way: if you ignore the tuples, the list of strings emitted by `AS_PAIRS` is the
+same as those emitted by `ALTERNATING`, except `AS_PAIRS` appends an empty
+string.)
+
 Because of this rule, if the original string ends with a separator,
-and `multisplit` doesn't `strip` the right side, `AS_PAIRS`
-will emit a 2-tuple containing two empty strings:
+and `multisplit` doesn't `strip` the right side, the final tuple
+emitted by `AS_PAIRS` will be a 2-tuple containing two empty strings:
 
 ```Python
     >>> list(big.multisplit('appleXbananaYcookieX', ('X', 'Y'), keep=big.AS_PAIRS))
     [('apple', 'X'), ('banana', 'Y'), ('cookie', 'X'), ('', '')]
 ```
 
-This looks strange--but it *is* correct.  This behavior is discussed in the
+This looks strange and unnecessary.  But it *is* what you want.
+This odd-looking behavior is discussed at length in the section below, titled
 [Why do you sometimes get empty strings when you split?](#why-do-you-sometimes-get-empty-strings-when-you-split)
-section below.
 
 The behavior of `keep` can be affected by the value of `separate`.
 For more information, see the next section, on `separate`.
 
 
 #### `separate`
 
@@ -2173,18 +2248,19 @@
     ['apple', 'Ybanana', 'Ycookie']
     >>> list(big.multisplit('appleXAYbananaXAYcookie', ('XA', 'AY'), reverse=True))
     ['appleX', 'bananaX', 'cookie']
 ```
 
 ### Reimplementing library functions using `multisplit`
 
-Finally, here are some concrete examples of how you could use
+Here are some examples of how you could use
 [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
 to replace some common Python string splitting methods.  These exactly duplicate the
-behavior of the originals:
+behavior of the originals.
+
 ```Python
 def _multisplit_to_split(s, sep, maxsplit, reverse):
     separate = sep != None
     if separate:
         strip = False
     else:
         sep = big.ascii_whitespace if isinstance(s, bytes) else big.whitespace
@@ -2229,14 +2305,17 @@
 def str_partition(s, sep):
     return _partition_to_multisplit(s, sep, False)
 
 def str_rpartition(s, sep):
     return _partition_to_multisplit(s, sep, True)
 ```
 
+You wouldn't want to use these, of course--Python's built-in
+functions are so much faster!
+
 ### Why do you sometimes get empty strings when you split?
 
 Sometimes when you split using
 [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse),
 you'll get empty strings in the return value.  This might be unexpected,
 violating the [Principle Of Least Astonishment.](https://en.wikipedia.org/wiki/Principle_of_least_astonishment)
 But there are excellent reasons for this behavior.
@@ -2449,14 +2528,84 @@
 ['', '1', 'a', '1', 'z', '1', '']
 ```
 
 If the `AS_PAIRS` output *didn't* end with that tuple of empty strings,
 you'd need to add an `if` statement to restore the trailing empty
 strings as needed.
 
+### Other differences between multisplit and str.split
+
+`str.split` returns an *empty list* when you split an
+empty string by whitespace:
+
+```Python
+>>> ''.split()
+[]
+```
+
+But not when you split by an explicit separator:
+
+```Python
+>>> ''.split('x')
+['']
+```
+
+[`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
+is consistent here.  If you split an empty string, it always returns an empty string,
+as long as the separators are valid:
+
+```Python
+>>> list(big.multisplit(''))
+['']
+>>> list(big.multisplit('', ('a', 'b', 'c')))
+['']
+```
+
+Similarly, when splitting a string that only contains whitespace, `str.split` also
+returns an empty list:
+
+```Python
+>>> '     '.split()
+[]
+```
+
+This is really the same as "splitting an empty string", because when `str.split`
+splits on whitespace, the first thing it does is strip leading whitespace.
+
+If you [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
+a string that only contains whitespace, and you split on whitespace characters,
+it returns two empty strings:
+
+```Python
+>>> list(big.multisplit('     '))
+['', '']
+```
+
+This is because the string conceptually starts with a zero-length string,
+then has a run of whitespace characters, then ends with another zero-length
+string.  So those two empty strings are the leading and trailing zero-length
+strings, separated by whitespace.  If you tell
+[`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
+to also strip the string, you'll get back a single empty string:
+
+```Python
+>>> list(big.multisplit('     ', strip=True))
+['']
+```
+
+And
+[`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
+behaves consistently even when you use different separators:
+
+```Python
+>>> list(big.multisplit('ababa', 'ab'))
+['', '']
+>>> list(big.multisplit('ababa', 'ab', strip=True))
+['']
+```
 
 ## `lines` and lines modifier functions
 
 [`lines`](#liness-separatorsnone--line_number1-column_number1-tab_width8-kwargs) creates an iterator that yields individual lines
 split from a string.  It's designed to make it easy to write
 well-behaved simple text parsers.
 
@@ -2773,31 +2922,32 @@
 [`merge_columns`](#merge_columnscolumns-column_separator--overflow_responseoverflowresponseraise-overflow_before0-overflow_after0)
 needs to consider both "overflow lines",
 lines that are longer than `max_width`, and "overflow columns",
 columns that contain one or more overflow lines.
 
 What does
 [`merge_columns`](#merge_columnscolumns-column_separator--overflow_responseoverflowresponseraise-overflow_before0-overflow_after0)
-do when it encounters overflow?  It depends on what you want.
+do when it encounters overflow?
 [`merge_columns`](#merge_columnscolumns-column_separator--overflow_responseoverflowresponseraise-overflow_before0-overflow_after0)
-provides three "strategies" to deal with this condition, and you can specify
-which one you want with its `overflow_strategy` parameter.  The three are:
+supports three "strategies" to deal with this condition, and you can specify
+which one you want using its `overflow_strategy` parameter.  The three
+strategies are:
 
 - `OverflowStrategy.RAISE`: Raise an `OverflowError` exception.  The default.
 
 - `OverflowStrategy.INTRUDE_ALL`: Intrude into all subsequent columns on
-all lines where the overflowed column is wider than its max_width.
+all lines where the overflowed column is wider than its `max_width`.
 The subsequent columns "make space" for the overflow text by not adding
 text on those overflowed lines; this is called "pausing" their output.
 
 - `OverflowStrategy.DELAY_ALL`:  Delay all columns after the overflowed
 column, not beginning any until after the last overflowed line
-in the overflowed column.  This is like `INTRUDE_ALL`, except that
-they "make space" by pausing their output until the last overflowed
-line.
+in the overflowed column.  This is like the `INTRUDE_ALL` strategy,
+except that the columns "make space" by pausing their output until
+the last overflowed line.
 
 When `overflow_strategy` is `INTRUDE_ALL` or `DELAY_ALL`, and
 either `overflow_before` or `overflow_after` is nonzero, these
 specify the number of extra lines before or after
 the overflowed lines in a column where the subsequent columns
 "pause".
 
@@ -2890,17 +3040,17 @@
 others.  Views are completely independent from each other.
 
 
 ## Bound inner classes
 
 #### Overview
 
-One minor complaint I have about Python is about inner classes.
+One minor complaint I have about Python regards inner classes.
 An "inner class" is a class defined inside another class.  And,
-well, inner classes seem kind of half-baked.   Unlike methods,
+well, inner classes seem kind of half-baked.  Unlike functions,
 inner classes don't get bound to the object.
 
 Consider this Python code:
 
 ```Python
 class Outer(object):
     def method(self):
@@ -2914,17 +3064,18 @@
 i = o.Inner()
 ```
 
 When `o.method` is called, Python automatically passes in the `o` object as the first parameter
 (generally called `self`).  In object-oriented lingo, `o` is *bound* to `method`, and indeed
 Python calls this object a *bound method*:
 
-
+```
     >>> o.method
     <bound method Outer.method of <__main__.Outer object at 0x########>>
+```
 
 But that doesn't happen when `o.Inner` is called.  (It *does* pass in
 a `self`, but in this case it's the newly-created `Inner` object.)
 There's just no built-in way for the `o.Inner` object being constructed
 to *automatically* get a reference to `o`.  If you need one, you must
 explicitly pass one in, like so:
 
@@ -2941,15 +3092,16 @@
 i = o.Inner(o)
 ```
 
 This seems redundant.  You don't have to pass in `o` explicitly to method calls,
 why should you have to pass it in explicitly to inner classes?
 
 Well--now you don't have to!
-You just need to decorate the inner class with `@big.BoundInnerClass`.
+You just decorate the inner class with `@big.BoundInnerClass`,
+and `BoundInnerClass` takes care of the rest!
 
 #### Using bound inner classes
 
 Let's modify the above example to use our [`BoundInnerClass`](#boundinnerclasscls)
 decorator:
 
 ```Python
@@ -2965,23 +3117,23 @@
             self.outer = outer
 
 o = Outer()
 o.method()
 i = o.Inner()
 ```
 
-Notice that `Inner.__init__` now accepts an `outer` parameter,
+Notice that `Inner.__init__` now requires an `outer` parameter,
 even though you didn't pass in any arguments to `o.Inner`.
-And when it's called, `o` is magically passed in to `outer`!
-Thanks, [`BoundInnerClass`](#boundinnerclasscls)!  You've saved the day.
+When it's called, `o` is magically passed in to `outer`!
+Thanks, [`BoundInnerClass`](#boundinnerclasscls)!  You've saved the day!
 
 Decorating an inner class like this always adds a second positional
-parameter, after `self`.  And, like `self`, in theory you don't have
-to use the name `outer`.  (Although for consistency's sakes, it's probably
-a good idea.)
+parameter, after `self`.  And, like `self`, you don't have
+to use the name `outer`, you can use any name you like.
+(Although it's probably a good idea, for consistency's sakes.)
 
 #### Inheritance
 
 Bound inner classes get slightly complicated when mixed with inheritance.
 It's not all that difficult, you merely need to obey the following rules:
 
 1. *A bound inner class can inherit normally from any unbound class.*
@@ -2990,31 +3142,34 @@
 class scope, or when referencing the inner class from the outer class
 (as opposed to an instance of the outer class), you must actually
 subclass or reference `classname.cls`.*  This is because inside the
 outer class, the "class" you see is actually an instance of a
 [`BoundInnerClass`](#boundinnerclasscls) object.
 
 3. *All classes that inherit from a bound inner class must always call the
-superclass's `__init__`. You don't need to pass in the outer parameter;
+superclass's `__init__`. You don't need to pass in the `outer` parameter;
 it'll be automatically passed in to the superclass's `__init__` as before.*
 
-4. *An inner class that inherits from a bound inner class, and which also wants
-to be bound to the outer object, should be decorated with
+4. *An inner class that inherits from a bound inner class, and which also
+wants to be bound to the outer object, should be decorated with
 [`BoundInnerClass`](#boundinnerclasscls).*
 
-5. *An inner class that inherits from a bound inner class, but doesn't want
-to be bound to the outer object, should be decorated with
+5. *An inner class that inherits from a bound inner class, but doesn't
+want to be bound to the outer object, should be decorated with
 [`UnboundInnerClass`](#unboundinnerclasscls).*
 
 Restating the last two rules: every class that descends from any
 [`BoundInnerClass`](#boundinnerclasscls)
 should be decorated with either
 [`BoundInnerClass`](#boundinnerclasscls)
 or
 [`UnboundInnerClass`](#unboundinnerclasscls).
+Which one you use depends on what behavior you want--whether or
+not you want your inner subclass to automatically get the `outer`
+instance passed in to its `__init__`.
 
 Here's a simple example using inheritance with bound inner classes:
 
 ```Python
 from big import BoundInnerClass, UnboundInnerClass
 
 class Outer(object):
@@ -3086,21 +3241,23 @@
 You can see more complex examples of using inheritance with
 [`BoundInnerClass`](#boundinnerclasscls)
 (and [`UnboundInnerClass`](#unboundinnerclasscls))
 in the **big** test suite.
 
 #### Miscellaneous notes
 
-* If you refer to a bound inner class directly from the outer class,
-  rather than using the outer instance, you get the original class.
-  This means that references to `Outer.Inner` are consistent, and it's
-  a base class of all the bound inner classes. This also means that if
-  you attempt to construct one without using an outer instance, you must
-  pass in the outer parameter by hand, just as you would have to pass
-  in the self parameter by hand when calling an unbound method.
+* If you refer to a bound inner class directly from the outer *class,*
+  rather than using the outer *instance,* you get the original class.
+  This ensures that references to `Outer.Inner` are consistent; this
+  class is also a base class of all the bound inner classes. Additionally,
+  if you attempt to construct an instance of an unbound `Outer.Inner`
+  class without referencing it via an instance, you must pass in the
+  outer parameter by hand--just like you'd have to pass in the `self`
+  parameter by hand when calling a method on the *class itself* rather
+  than on an *instance* of the class.
 
 * If you refer to a bound inner class from an outer instance,
   you get a subclass of the original class.
 
 * Bound classes are cached in the outer object, which both provides
   a small speedup and ensures that `isinstance` relationships are
   consistent.
@@ -3143,24 +3300,98 @@
   class from the `__init__` of the outer class, which should allow
   the code to cache the bound inner class instance before a second
   thread could ever get a reference to the outer object.
 
 
 ## Release history
 
+**0.8**
+
+* Major retooling of `str` and `bytes` support in `big.text`.
+  * Functions in `big.text` now uniformly accept `str` or `bytes`
+    or a subclass of either.  See the
+    [Support for bytes and str](#Support-for-bytes-and-str) section
+    for how it works.
+  * Functions in `big.text` are now more consistent about raising
+    `TypeError` vs `ValueError`.  If you mix `bytes` and `str`
+    objects together in one call, you'll get a `TypeError`, but
+    if you pass in an empty iterable (of a correct type) where
+    a non-empty iterable is required you'll get a `ValueError`.
+    `big.text` generally tries to give the `TypeError` higher
+    priority; if you pass in a value that fails both the type
+    check and the value check, the `big.text` function will raise
+    `TypeError` first.
+* Major rewrite of
+  [`re_rpartition`.](#re_rpartitiontext-pattern-count1--flags0)
+  I realized it had the same "reverse mode" problem that
+  I fixed in
+  [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
+  back in version **0.6.10**: the regular expression should really
+  search the string in "reverse mode", from right to left.
+  The difference is whether the regular
+  expression potentially matches against overlapping strings.
+  When in forwards mode, the regular expression should prefer
+  the *leftmost* overlapping match, but in reverse mode it
+  should prefer the *rightmost* overlapping match.  Most of the
+  time this produces the same list of matches as you'd
+  find searching the string forwards--but sometimes the matches come
+  out *very* different.
+  This was way harder to fix with `re_rpartition` than with `multisplit`,
+  because Python's `re` module only supports searching forwards.
+  I have to emulate reverse-mode searching by manually checking for
+  overlapping matches and figuring out which one(s) to keep--a *lot* of
+  work!  Fortunately it's only a minor speed hit if you don't have
+  overlapping matches.  (And if you *do* have overlapping matches,
+  you're probably just happy `re_rpartition` now produces correct
+  results--though I did my best to make it performant anyway.)
+  In the future, **big** will probably add support for the
+  PyPI package `regex`, which reimplements Python's `re` module
+  but adds many features... including reverse mode!
+* New function:
+  [`reversed_re_finditer`.](#reversed_re_finditerpattern-string-flags0)
+  Behaves almost identically to the Python
+  standard library function `re.finditer`, yielding
+  non-overlapping matches of `pattern` in `string`.  The difference
+  is, `reversed_re_finditer` searches `string` from right to left.
+  (Written as part of the
+  [`re_rpartition`](#re_rpartitiontext-pattern-count1--flags0)
+  rewrite mentioned above.)
+* Added `apostrophes`, `double_quotes`,
+  `ascii_apostrophes`, `ascii_double_quotes`,
+  `utf8_apostrophes`, and `utf8_double_quotes`
+  to the `big.text` module.  Previously the first
+  four of these were hard-coded strings inside
+  [`gently_title`.](#gently_titles-apostrophesnone-double_quotesnone)
+  (And the last two didn't exist!)
+* Code cleanup in `split_text_with_code`, removed redundant code.
+  I think it has about the same number of `if` statements; if anything
+  it might be slightly faster.
+* Retooled
+  [`re_partition`](#re_partitiontext-pattern-count1--flags0)
+  and
+  [`re_rpartition`](#re_rpartitiontext-pattern-count1--flags0)
+  slightly, should now be very-slightly faster.  (Well, `re_rpartition`
+  will be slower if your pattern finds overlapping matches.  But at
+  least now it's correct!)
+* Lots and lots of doc improvements, as usual.
+
 **0.7.1**
 
-* Tweaked the implementation of `multisplit`.  Internally, it does the
+* Tweaked the implementation of
+  [`multisplit`.](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
+  Internally, it does the
   string splitting using `re.split`, which returns a `list`.  It used
   to iterate over the list and yield each element.  But that meant keeping
-  tne entire list around in memory until `multisplit` exited.  Now,
-  `multisplit` reverses the list, pops off the final element, and yields
-  that.  This means `multisplit` drops all references to the split strings
+  the entire list around in memory until `multisplit` exited.  Now,
+  [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
+  reverses the list, pops off the final element, and yields
+  that.  This means
+  [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
+  drops all references to the split strings
   as it iterates over the string, which may help in low-memory situations.
-
 * Minor doc fixes.
 
 **0.7**
 
 * Breaking changes to the
   [`Scheduler`](#schedulerregulatordefault_regulator):
   * It's no longer thread-safe by default, which means it's much faster
@@ -3185,15 +3416,14 @@
     [`Event`](#eventscheduler-event-time-priority-sequence)
     constructor were rearranged.  (You shouldn't care, as you
     shouldn't be manually constructing
     [`Event`](#eventscheduler-event-time-priority-sequence)
     objects anyway.)
   * The `Scheduler` now guarantees that it will only call `now` and `wake`
     on a `Regulator` object while holding that `Regulator`'s lock.
-
 * Minor doc fixes.
 
 **0.6.18**
 
 * Retooled
   [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
   and
@@ -3251,16 +3481,16 @@
 
 * Changed [`translate_filename_to_exfat(s)`](#translate_filename_to_exfats)
   behavior: when modifying a string with a colon (`':'`) *not* followed by
   a space, it used to convert it to a dash (`'-'`).  Now it converts the
   colon to a period (`'.'`), which looks a little more natural.  A colon
   followed by a space is still converted to a dash followed by a space.
 
-*p.s.* There's a revision with a comment claiming it represents 0.6.13.  But
-I forgot to actually tag it and release it, and I forgot to actually.  Oops!
+*p.s.* I forgot to release packages for 0.6.11 and 0.6.12.  But they're
+tagged, in case you want to examine them for some reason.
 
 **0.6.12**
 
 * Bugfix: When calling
   [`TopologicalSorter.print()`](#topologicalsorterprintprintprint),
   it sorts the list of nodes, for consistency's sakes.
   But if the node objects don't support `<` or `>` comparison,
@@ -3456,7 +3686,8 @@
   If the colon is not followed by a space, turns the colon into `'-'`.
   This is good for tiresome modern gobbledygook like `'Re:code'`, which
   will now be translated to `'Re-code'`.
 
 **0.5**
 
 * Initial release.
+
```

### Comparing `big-0.7.1/big/__init__.py` & `big-0.8/big/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -27,9 +27,9 @@
 IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
 THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 """
 
 
-__version__ = "0.7.1"
+__version__ = "0.8"
```

### Comparing `big-0.7.1/big/all.py` & `big-0.8/big/all.py`

 * *Files identical despite different names*

### Comparing `big-0.7.1/big/boundinnerclass.py` & `big-0.8/big/boundinnerclass.py`

 * *Files identical despite different names*

### Comparing `big-0.7.1/big/builtin.py` & `big-0.8/big/builtin.py`

 * *Files identical despite different names*

### Comparing `big-0.7.1/big/file.py` & `big-0.8/big/file.py`

 * *Files identical despite different names*

### Comparing `big-0.7.1/big/graph.py` & `big-0.8/big/graph.py`

 * *Files identical despite different names*

### Comparing `big-0.7.1/big/heap.py` & `big-0.8/big/heap.py`

 * *Files identical despite different names*

### Comparing `big-0.7.1/big/itertools.py` & `big-0.8/big/itertools.py`

 * *Files identical despite different names*

### Comparing `big-0.7.1/big/scheduler.py` & `big-0.8/big/scheduler.py`

 * *Files identical despite different names*

### Comparing `big-0.7.1/big/text.py` & `big-0.8/big/text.py`

 * *Files 15% similar despite different names*

```diff
@@ -25,43 +25,64 @@
 """
 
 import enum
 import functools
 import itertools
 from itertools import zip_longest
 from .itertools import PushbackIterator
+import math
 import operator
 import re
 import struct
 import sys
 
 try:
     from re import Pattern as re_Pattern
 except ImportError: # pragma: no cover
     re_Pattern = re._pattern_type
 
+try:
+    import regex
+    regex_Pattern = regex.Pattern
+    def isinstance_re_pattern(o):
+        return isinstance(o, (re_Pattern, regex_Pattern))
+except ImportError: # pragma: no cover
+    regex_Pattern = re_Pattern
+    def isinstance_re_pattern(o):
+        return isinstance(o, re_Pattern)
+
 
 __all__ = []
 
 def _export_name(s):
     __all__.append(s)
 
 def _export(o):
     _export_name(o.__name__)
     return o
 
 
+def _iterate_over_bytes(b):
+    # this may not actually iterate over bytes.
+    # for example, we iterate over apostrophes and double_quotes
+    # for gently_title, and those might be strings or bytes,
+    # or iterables of strings or bytes.
+    if isinstance(b, bytes):
+        return (b[i:i+1] for i in range(len(b)))
+    return iter(b)
+
+
 @_export
 def re_partition(s, pattern, count=1, *, flags=0, reverse=False):
     """
     Like str.partition, but pattern is matched as a regular expression.
 
-    s can be a string or a bytes object.
+    s can be either a str or bytes object.
 
-    pattern can be a string, bytes, or an re.Pattern object.
+    pattern can be a str, bytes, or re.Pattern object.
 
     s and pattern (or pattern.pattern) must be the same type.
 
     If pattern is found in s, returns a tuple
         (before, match, after)
     where before is the text before the match,
     match is the re.Match object resulting from the match, and
@@ -71,69 +92,326 @@
     re_partition will match against the first (leftmost)
     appearance.
 
     If pattern is not found in s, returns a tuple
         (s, None, '')
     where the empty string is str or bytes as appropriate.
 
+    To convert the output into a tuple of strings like str.partition,
+    use
+        t = re_partition(...)
+        t2 = (t[0], t[1].group(0) if t[1] else '', t[2])
+
     Passing in an explicit "count" lets you control how many times
     re_partition partitions the string.  re_partition will always
     return a tuple containing (2*count)+1 elements, and
     odd-numbered elements will be either re.Match objects or None.
     Passing in a count of 0 will always return a tuple containing s.
 
     If pattern is a string or bytes, flags is passed in
     as the flags argument to re.compile.
 
     If reverse is true, partitions starting at the right,
     like re_rpartition.
 
+    You can pass in an instance of a subclass of bytes or str
+    for s and pattern (or pattern.pattern), but the base class
+    for both must be the same (str or bytes).  re_partition will
+    only return str or bytes objects.
+
     (In older versions of Python, re.Pattern was a private type called
     re._pattern_type.)
     """
     if reverse:
         return re_rpartition(s, pattern, count, flags=flags)
-    if not isinstance(pattern, re_Pattern):
+
+    if isinstance(s, bytes):
+        empty_string = b''
+        extension = (None, b'')
+    else:
+        empty_string = ''
+        extension = (None, '')
+
+    if not isinstance_re_pattern(pattern):
         pattern = re.compile(pattern, flags=flags)
-    if not (isinstance(s, (str, bytes)) and
-        (type(s) == type(pattern.pattern))):
-        raise ValueError("s must be str or int, and string used in pattern must be the same type")
-    as_bytes = isinstance(s, bytes)
-    empty = b'' if as_bytes else ''
+
+    # optimized fast path for the most frequent use case
+    if count == 1:
+        match = pattern.search(s)
+        if not match:
+            return (s, None, empty_string)
+        before, separator, after = s.partition(match.group(0))
+        return (before, match, after)
+
+    if count == 0:
+        return (s,)
 
     if count < 0:
         raise ValueError("count must be >= 0")
 
-    result = [s]
-    if count == 0:
-        return result
+    result = []
+    extend = result.extend
+    matches_iterator = pattern.finditer(s)
 
-    if count == 1:
-        # much cheaper for the general case
-        match = pattern.search(s)
-        if match:
-            matches = [match]
-        else:
-            matches = ()
-    else:
-        matches = list(pattern.finditer(s))
-        matches.reverse()
+    try:
+        for remaining in range(count, 0, -1):
+            match = next(matches_iterator)
+            before, separator, s = s.partition(match.group(0))
+            extend((before, match))
+        extension = ()
+    except StopIteration:
+        extension *= remaining
 
-    for _ in range(count):
-        if not matches:
-            result.extend((None, empty))
-            continue
+    result.append(s)
+    return tuple(result) + extension
 
-        match = matches.pop()
-        s = result.pop()
+@_export
+def reversed_re_finditer(pattern, string, flags=0):
+    """
+    An iterator.  Behaves almost identically to the Python
+    standard library function re.finditer, yielding non-overlapping
+    matches of "pattern" in "string".  The difference is,
+    reversed_re_finditer searches "string" from right to left.
 
-        before, separator, after = s.partition(match.group(0))
-        result.extend((before, match, after))
+    pattern can be str, bytes, or a precompiled re.Pattern object.
+    If it's str or bytes, it'll be compiled with re.compile using
+    the flags you passed in.
 
-    return tuple(result)
+    string should be the same type as pattern (or pattern.pattern).
+    """
+    if not isinstance_re_pattern(pattern):
+        pattern = re.compile(pattern, flags=flags)
+
+    # matches are found by re.search *going forwards.*
+    # but what we need here is the *reverse* matches.
+    #
+    # consider this call:
+    #    re_rpartition('abcdefgh', '(abcdef|efg|ab|b|c|d)', count=4)
+    #
+    # re.finditer with that string and pattern yields one match:
+    #    'abcdef'
+    # but reverse searching, e.g. with
+    # regex.finditer(flags=regex.REVERSE), yields four matches:
+    #    'efg', 'd', 'c', 'ab'
+    #
+    # so what we do is: we ask re.finditer for all the forward
+    # matches.  then, for every match it found, we check every
+    # overlapping character to see if there's a different match
+    # there that we might prefer.  if we prefer one of those,
+    # we yield that--but we keep around the other matches,
+    # because one of those (or a truncated version of it) might
+    # also work.
+
+
+    # matches and overlapping_matches are lists of 3-tuples of:
+    #    (end_pos, -start_pos, match)
+    # if we sort the list, the last element will be the correct
+    # last match in "reverse" order.  see
+    #    https://en.wikipedia.org/wiki/Schwartzian_transform
+    #
+    # matches contains the list of matches we got directly from
+    # re.finditer(), reversed.  since this was found using re in
+    # "forward" order, we need to check every match in this list
+    # for potential overlapping matches.
+    matches = [(match.end(), -match.start(), match) for match in pattern.finditer(string)]
+    if not matches:
+        # print(f"no matches at all! exiting immediately.")
+        return
+
+    # Does this pattern match zero-length strings?
+    zero_length_match = pattern.match(string, 0, 0)
+    if zero_length_match:
+        # This pattern matches zero-length strings.
+        # Since the rules are a little different for
+        # zero-length strings when in reverse mode,
+        # we need to doctor the match results a little.
+
+        # These seem to be the rules:
+        #
+        # In forwards mode, we consider two matches to overlap
+        # if they start at the same position, or if they have
+        # any characters in common.  There's an implicit
+        # zero-length string at the beginning and end of every
+        # string, so if the pattern matches against a zero-length
+        # string at the start or end, and there isn't another
+        # (longer) match that starts at that position, we'll
+        # yield these matches too.  Since only a zero-length
+        # match can start at position len(string), we'll always
+        # yield a zero-length match starting and ending at
+        # position length(string) if the pattern matches there.
+        #
+        # In reverse mode, we consider two matches to overlap
+        # if they end at the same position, or if they have any
+        # characters in common with any other match.  There's an
+        # implicit zero-length string at the beginning and end of
+        # every string, so if the pattern matches a zero-length
+        # string at the start or end, and there isn't another
+        # (longer) match that ends at that position, we'll yield
+        # these matches too.  Since only a zero-length match can
+        # end at position 0, we'll always yield a zero-length
+        # match starting and ending at position 0 if the pattern
+        # matches there.
+
+        # We need to ensure that, for every non-zero-length match,
+        # if the pattern matches a zero-length string starting at
+        # the same position, we have that zero-length match in
+        # matches too.
+        #
+        # So specifically we're going to do this:
+        #
+        # for every match m in matches:
+        #   if m has nonzero length,
+        #     and the pattern matches a zero-length string
+        #       starting at m,
+        #     ensure that the zero-length match is also in matches.
+        #   elif m has zero length,
+        #     if we've already ensured that a zero-length
+        #     match starting at m.start() is in matches,
+        #     discard m.
+
+        zeroes = set()
+        new_matches = []
+        append = new_matches.append
+        last_start = -1
+        for t in matches:
+            match = t[2]
+            start, end = match.span()
+
+            if start not in zeroes:
+                if (start == end):
+                    append(t)
+                    zeroes.add(start)
+                    continue
+
+                zero_match = pattern.match(string, start, start)
+                if zero_match:
+                    t_zero_length = (start, -start, zero_match)
+                    append(t_zero_length)
+                zeroes.add(start)
+            append(t)
+        # del zeroes
+        matches = new_matches
+
+    matches.sort()
+
+    # overlapping_matches is a list of the possibly-viable
+    # overlapping matches we found from checking a match
+    # we got from "matches".
+    overlapping_matches = []
+
+    result = []
+    match = None
+
+    # We truncate each match at the start
+    # of the previously yielded match.
+    #
+    # The initial value allows the initial match
+    # to extend all the way to the end of the string.
+    previous_match_start = len(string)
+
+    # cache some method lookups
+    pattern_match = pattern.match
+    append = overlapping_matches.append
+
+    while True:
+        if overlapping_matches:
+            # overlapping_matches contains the overlapping
+            # matches found *last* time around, before we
+            # yielded the most recent match.
+            #
+            # The thing is, some of these matches might overlap that match.
+            # But we only yield *non*-overlapping matches.  So we need to
+            # filter the matches in overlapping_matches accordingly.
+
+            truncated_matches = []
+            # (overlapping_matches will be set to truncated_matches in a few lines)
+            append = truncated_matches.append
+
+            for t in overlapping_matches:
+                end, negated_start, match = t
+                start = -negated_start
+                if start > previous_match_start:
+                    # This match starts *after* the previous match started.
+                    # All matches starting at this position are no longer
+                    # viable.  Throw away the match.
+                    continue
+                if end <= previous_match_start:
+                    # This match ends *before* the previous match started.
+                    # In other words, this match is still 100% viable.
+                    # Keep it, we don't need to change it at all.
+                    append(t)
+                    continue
+
+                # This match starts before the previous match started,
+                # but ends after the previous match start.
+                # In other words, it overlaps the previous match.
+                #
+                # So this match is itself no longer viable.  But!
+                # There might be a *different* match starting at this
+                # position in the string.  So we do a fresh re.match here,
+                # stopping at the start of the previously yielded match.
+                # (That's the third parameter, "endpos".)
+
+                match = pattern_match(string, start, previous_match_start)
+                if match:
+                    append((match.end(), -start, match))
+
+            overlapping_matches = truncated_matches
+
+        if (not overlapping_matches) and matches:
+            # We don't currently have any pre-screened
+            # overlapping matches we can use.
+            #
+            # But we *do* have a match (or matches) found in forwards mode.
+            # Grab the next one that's still viable.
+
+            scan_for_overlapping_matches = False
+            while matches:
+                t = matches.pop()
+                end, negated_start, match = t
+                start = -negated_start
+                if end <= previous_match_start:
+                    assert start <= previous_match_start
+                    append(t)
+                    start += 1
+                    scan_for_overlapping_matches = True
+                    break
+
+            if scan_for_overlapping_matches:
+                # We scan every** position inside the match for an
+                # overlapping match.  All the matches we find go in
+                # overlapping_matches, then we sort it and yield
+                # the last one.
+                #
+                # ** We don't actually need to check the *first* position,
+                #    "start", because we already know what we'll find:
+                #    the match that we got from re.finditer() and
+                #    scanned for overlaps.
+                #
+                # As mentioned, the match we got from finditer
+                # is viable here, so add it to the list.
+
+                end = min(end, previous_match_start)
+                for pos in range(start, end):
+                    match = pattern_match(string, pos, previous_match_start)
+                    if match:
+                        # print(f"  found {match=}")
+                        append((match.end(), -pos, match))
+
+        if not overlapping_matches:
+            # matches and overlapping matches are both empty.
+            # We've exhausted the matches.  Stop iterating.
+            return
+
+        # overlapping_matches is now guaranteed current and non-empty.
+        # We sort it so the rightmost match is last, and yield that.
+        overlapping_matches.sort()
+        match = overlapping_matches.pop()[2]
+        previous_match_start = match.start()
+        yield match
 
 
 @_export
 def re_rpartition(s, pattern, count=1, *, flags=0):
     """
     Like str.rpartition, but pattern is matched as a regular expression.
 
@@ -145,65 +423,94 @@
 
     If pattern is found in s, returns a tuple
         (before, match, after)
     where before is the text before the match,
     match is the re.Match object resulting from the match, and
     after is the text after the match.
 
-    If pattern appears in s multiple times,
-    re_partition will match against the last (rightmost)
-    appearance.
+    re_rpartition searches for pattern in s from right
+    to left, and partitions at the non-overlapping
+    matches it finds.
+
+    If pattern matches multiple substrings of s, re_partition
+    will match against the last (rightmost) appearance.
 
     If pattern is not found in s, returns a tuple
         ('', None, s)
     where the empty string is str or bytes as appropriate.
 
+    To convert the output into a tuple of strings like str.rpartition,
+    use
+        t = re_rpartition(...)
+        t2 = (t[0], t[1].group(0) if t[1] else '', t[2])
+
     Passing in an explicit "count" lets you control how many times
     re_rpartition partitions the string.  re_rpartition will always
     return a tuple containing (2*count)+1 elements, and
     odd-numbered elements will be either re.Match objects or None.
     Passing in a count of 0 will always return a tuple containing s.
 
     If pattern is a string, flags is passed in
     as the flags argument to re.compile.
 
+    You can pass in an instance of a subclass of bytes or str
+    for s and pattern (or pattern.pattern), but the base class
+    for both must be the same (str or bytes).  re_rpartition will
+    only return str or bytes objects.
+
+    You can pass in a regex Pattern object (see the PyPi 'regex'
+    package).  Patterns using the "Reverse Searching" feature
+    of 'regex' (the REVERSE flag or the '(?r)' token) are unsupported.
+
     (In older versions of Python, re.Pattern was a private type called
     re._pattern_type.)
     """
-    if not isinstance(pattern, re_Pattern):
-        pattern = re.compile(pattern, flags=flags)
-    if not (isinstance(s, (str, bytes)) and
-        (type(s) == type(pattern.pattern))):
-        raise ValueError("s must be str or int, and string used in pattern must be the same type")
+    if isinstance(s, bytes):
+        empty_string = b''
+        extension = (b'', None)
+    else:
+        empty_string = ''
+        extension = ('', None)
+
+    # optimized fast path for the most frequent use case
+    if count == 1:
+        matches_iterator = reversed_re_finditer(pattern, s, flags)
+        try:
+            match = next(matches_iterator)
+            before, separator, after = s.rpartition(match.group(0))
+            return (before, match, after)
+        except StopIteration:
+            return (empty_string, None, s)
+
+    if count == 0:
+        return (s,)
 
     if count < 0:
         raise ValueError("count must be >= 0")
 
-    result = [s]
-    if count == 0:
-        return result
+    result = []
+    extend = result.extend
+    matches_iterator = reversed_re_finditer(pattern, s, flags)
 
-    as_bytes = not isinstance(s, str)
-    empty = b'' if as_bytes else ''
-    matches = list(pattern.finditer(s))
-
-    for i in range(count):
-        if not matches:
-            r = [empty, None]
-        else:
-            match = matches.pop()
-            s = result.pop(0)
-            before, separator, after = list(s.rpartition(match.group(0)))
-            r = [before, match, after]
-        r.extend(result)
-        result = r
-    return tuple(result)
+    try:
+        for remaining in range(count, 0, -1):
+            match = next(matches_iterator)
+            s, separator, after = s.rpartition(match.group(0))
+            extend((after, match))
+        extension = ()
+    except StopIteration:
+        extension *= remaining
+
+    result.append(s)
+    result.reverse()
+    return extension + tuple(result)
 
 
 # a list of all unicode whitespace characters known to Python
+# (note: we check this list is correct and complete in a unit test)
 _export_name('whitespace')
 whitespace = (
     '\t'    , #     9 0x0009 - tab
     '\n'    , #    10 0x000a - newline
     '\x0b'  , #    11 0x000b - vertical tab
     '\x0c'  , #    12 0x000c - form feed
     '\r'    , #    13 0x000d - carriage return
@@ -228,18 +535,18 @@
     '\u200a', #  8202 0x200a - hair space
     '\u2028', #  8232 0x2028 - line separator
     '\u2029', #  8233 0x2029 - paragraph separator
     '\u202f', #  8239 0x202f - narrow no-break space
     '\u205f', #  8287 0x205f - medium mathematical space
     '\u3000', # 12288 0x3000 - ideographic space
 
-    '\r\n'  , # the classic DOS newline sequence
+    '\r\n'  , # bonus! the classic DOS newline sequence!
     )
 
-# this omits the DOS convention '\r\n'
+# this omits the DOS newline sequence '\r\n'
 _export_name('whitespace_without_dos')
 whitespace_without_dos = tuple(s for s in whitespace if s != '\r\n')
 
 _export_name('newlines')
 newlines = (
     '\n'    , #   10 0x000a - newline
     '\x0b'  , #   11 0x000b - vertical tab
@@ -296,14 +603,16 @@
 _export_name('utf8_newlines')
 utf8_newlines   = _cheap_encode_iterable_of_strings(newlines,   "utf-8")
 _export_name('utf8_newlines_without_dos')
 utf8_newlines_without_dos =  tuple(s for s in utf8_newlines if s != b'\r\n')
 
 # reverse an iterable thing.
 # o must be str, bytes, list, tuple, set, or frozenset.
+# if o is a collection (not str or bytes),
+# the elements of o are recursively reversed.
 # value returned is the same type as o.
 #
 # we don't need to bother checking the type of o.
 # _multisplit_reversed is an internal function
 # and I've manually checked every call site.
 def _multisplit_reversed(o, name='s'):
     if isinstance(o, str):
@@ -353,26 +662,25 @@
 def _re_quote(s):
     # don't bother escaping whitespace.
     # re.escape escapes whitespace because of VERBOSE mode,
     # which we're not using.  (escaping the whitespace doesn't
     # hurt anything really, but it makes the patterns harder
     # to read for us humans.)
     if not s.isspace():
-        s = re.escape(s)
+        return re.escape(s)
     if len(s) > 1:
         if isinstance(s, bytes):
-            s = b"(?:" + s + b")"
-        else:
-            s = f"(?:{s})"
+            return b"(?:" + s + b")"
+        return f"(?:{s})"
     return s
 
 
 @functools.lru_cache(re._MAXCACHE)
-def __separators_to_re(separators, as_bytes, separate=False, keep=False):
-    if as_bytes:
+def __separators_to_re(separators, separators_is_bytes, separate=False, keep=False):
+    if separators_is_bytes:
         pipe = b'|'
         separate_start = b'(?:'
         separate_end = b')+'
         keep_start = b'('
         keep_end = b')'
     else:
         pipe = '|'
@@ -383,89 +691,118 @@
 
     # sort longer separator strings earlier.
     # re processes | operator from left-to-right,
     # so you want to match against longer strings first.
     separators = list(separators)
     separators.sort(key=lambda o: -len(o))
     pattern = pipe.join(_re_quote(o) for o in separators)
-    # print(f"  P1 {pattern!r}")
     if not separate:
         pattern = separate_start + pattern + separate_end
-    # print(f"  P2 {pattern!r}")
     if keep:
         pattern = keep_start + pattern + keep_end
-    # print(f"  P3 {pattern!r}")
     return pattern
 
-def _separators_to_re(separators, as_bytes, separate=False, keep=False):
+def _separators_to_re(separators, separators_is_bytes, separate=False, keep=False):
+    # this ensures that separators is hashable,
+    # which will keep functools.lru_cache happy.
     try:
         hash(separators)
     except TypeError:
         separators = tuple(separators)
-    return __separators_to_re(separators, bool(as_bytes), separate=bool(separate), keep=bool(keep))
+    return __separators_to_re(separators, separators_is_bytes, separate=bool(separate), keep=bool(keep))
 
 
 
 @_export
 def multistrip(s, separators, left=True, right=True):
     """
     Like str.strip, but supports stripping multiple strings.
 
     Strips from the string "s" all leading and trailing
     instances of strings found in "separators".
 
+    Returns a copy of s with the leading and/or trailing
+    separators stripped.  (If left and right are both false,
+    the contents are unchanged.)
+
     s should be str or bytes.
     separators should be an iterable of either str or bytes
     objects matching the type of s.
 
     If left is a true value, strips all leading separators
     from s.
 
     If right is a true value, strips all trailing separators
     from s.
 
-    Processing always stops at the first character that
-    doesn't match one of the separators.
-
-    Returns a copy of s with the leading and/or trailing
-    separators stripped.  (If left and right are both
-    false, returns s unchanged.)
-    """
-    type_of_s = type(s)
-    as_bytes = type_of_s == bytes
-
-    if not (as_bytes or (type_of_s == str)):
-        raise TypeError('s must be str or bytes')
-
-    type_of_separators = type(separators)
-    if as_bytes:
+    multistrip first removes leading separators, until the
+    string does not start with a separator (or is empty).
+    Then it removes trailing separators, until the string
+    until the string does not end with a separator (or is
+    empty).
+
+    multistrip is "greedy"; if more than one separator
+    matches, multistrip will strip the longest one.
+
+    You can pass in an instance of a subclass of bytes or str
+    for s and elements of separators, but the base class
+    for both must be the same (str or bytes).  multistrip will
+    only return str or bytes objects, even if left and right
+    are both false.
+    """
+
+    is_bytes = isinstance(s, bytes)
+    if is_bytes:
+        s_type = bytes
         head = b'^'
         tail = b'$'
-        if type_of_separators == bytes:
+
+        if isinstance(separators, str):
+            raise TypeError("separators must be an iterable of non-empty objects the same type as s")
+        if isinstance(separators, bytes):
             # not iterable of bytes, literally a bytes string.
             # split it ourselves.  otherwise, _separators_to_re will
-            # iterate over it, and... oops! it gets bytes!
+            # iterate over it, which... yields integers! oops!
+            separators = tuple(_iterate_over_bytes(separators))
             check_separators = False
-            separators = tuple(separators[i:i+1] for i in range(len(separators)))
         else:
             check_separators = True
     else:
+        s_type = str
         head = '^'
         tail = '$'
-        check_separators = type_of_separators != str
 
+        if isinstance(separators, bytes):
+            raise TypeError("separators must be an iterable of non-empty objects the same type as s")
+        if isinstance(separators, str):
+            separators = tuple(separators)
+            check_separators = False
+        else:
+            check_separators = True
+
+    if not separators:
+        raise ValueError("separators must be an iterable of non-empty objects the same type as s")
     if check_separators:
+        s2 = []
         for o in separators:
-            if not isinstance(o, type_of_s):
-                raise TypeError("separators must be an iterable of objects the same type as s")
+            if not isinstance(o, s_type):
+                raise TypeError("separators must be an iterable of non-empty objects the same type as s")
+            if not o:
+                raise ValueError("separators must be an iterable of non-empty objects the same type as s")
+            s2.append(o)
+        separators = tuple(s2)
 
+    # deliberately do this *after* checking types,
+    # so we complain about bad types even if this is a do-nothing call.
     if not (left or right):
         return s
 
-    pattern = _separators_to_re(separators, as_bytes, separate=False, keep=False)
+    # we can sidestep the hashability test of _separators_to_re,
+    # separators is guaranteed to always a tuple at this point
+    pattern = __separators_to_re(separators, is_bytes, separate=False, keep=False)
 
     start = 0
     end = len(s)
     if left:
         left_match = re.match(head + pattern, s)
         if left_match:
             start = left_match.end(0)
@@ -507,15 +844,15 @@
 
     separators should be an iterable of str or bytes, matching s.
 
     Returns an iterator yielding the strings split from s.  If keep
     is true (or ALTERNATING), and strip is false, joining these strings
     together will recreate s.
 
-    multisplit is *greedy*: if two or more separators start at the same
+    multisplit is "greedy": if two or more separators start at the same
     location in "s", multisplit splits using the longest matching separator.
     For example:
         big.multisplit('wxabcyz', ('a', 'abc'))
     yields 'wx' then 'yz'.
 
     "keep" indicates whether or not multisplit should keep the separator
     strings.  It supports four values:
@@ -591,53 +928,63 @@
             scanning left.
     Splitting from the end of the string and scanning left has two
     effects.  First, if maxsplit is a number greater than 0,
     the splits will start at the end of the string rather than
     the beginning.  Second, if there are overlapping instances of
     separators in the string, multisplit will prefer the rightmost
     separator rather than the left.  For example:
-        multisplit(" x x ", (" x ",), keep=big.ALTERNATING)
+        multisplit("A x x Z", (" x ",), keep=big.ALTERNATING)
     will split on the leftmost instance of " x ", yielding
-        "", " x ", "x "
+        "A", " x ", "x Z"
     whereas
-        multisplit(" x x ", (" x ",), keep=big.ALTERNATING, reverse=True)
+        multisplit("A x x Z", (" x ",), keep=big.ALTERNATING, reverse=True)
     will split on the rightmost instance of " x ", yielding
-        " x", " x ", ""
-    """
-    type_of_s = type(s)
-    as_bytes = type_of_s == bytes
-    if not (as_bytes or (type_of_s == str)):
-        raise TypeError('s must be str or bytes')
+        "A x", " x ", "Z"
 
-    if separators is None:
-        separators = ascii_whitespace if as_bytes else whitespace
-        check_separators = False
-    elif not separators:
-        raise TypeError("separators must be either None or an iterable of objects the same type as s")
-    else:
-        check_separators = True
+    You can pass in an instance of a subclass of bytes or str
+    for s and elements of separators, but the base class
+    for both must be the same (str or bytes).  multisplit will
+    only return str or bytes objects.
+    """
+    is_bytes = isinstance(s, bytes)
+    separators_is_bytes = isinstance(separators, bytes)
+    separators_is_str = isinstance(separators, str)
 
-    type_of_separators = type(separators)
-    if as_bytes:
-        if type_of_separators == bytes:
+    if is_bytes:
+        if separators_is_bytes:
             # not iterable of bytes, literally a bytes string.
             # split it ourselves.
-            separators = tuple(separators[i:i+1] for i in range(len(separators)))
+            separators = tuple(_iterate_over_bytes(separators))
             check_separators = False
+        else:
+            if separators_is_str:
+                raise TypeError("separators must be either None or an iterable of objects the same type as s")
+            check_separators = True
         empty = b''
+        s_type = bytes
     else:
+        if separators_is_bytes:
+            raise TypeError("separators must be either None or an iterable of objects the same type as s")
+        check_separators = True
         empty = ''
-        if check_separators:
-            check_separators = type_of_separators != str
+        s_type = str
+
+    if separators is None:
+        separators = ascii_whitespace if is_bytes else whitespace
+        check_separators = False
+    elif not separators:
+        raise ValueError("separators must be either None or an iterable of objects the same type as s")
 
     # check_separators is True if separators isn't str or bytes
     # or something we split ourselves.
     if check_separators:
+        if not hasattr(separators, '__iter__'):
+            raise TypeError("separators must be either None or an iterable of objects the same type as s")
         for o in separators:
-            if not isinstance(o, type_of_s):
+            if not isinstance(o, s_type):
                 raise TypeError("separators must be either None or an iterable of objects the same type as s")
 
     separators_to_re_keep = keep
 
     if strip:
         if strip == PROGRESSIVE:
             if maxsplit == -1:
@@ -653,15 +1000,15 @@
         if not s:
             # oops! all separators!
             # this will make us exit early, just a few lines down from here.
             maxsplit = 0
 
     if maxsplit == None:
         maxsplit = -1
-    if maxsplit == 0:
+    elif maxsplit == 0:
         if keep == ALTERNATING:
             yield s
         elif keep == AS_PAIRS:
             yield (s, empty)
         else:
             yield s
         return
@@ -671,15 +1018,15 @@
     # re.split interprets maxsplit slightly differently:
     #   its maxsplit==0 means "allow all splits".
     #   its maxsplit==1 means "only allow one split".
     #
     # (re.split doesn't have a way to express
     #  "don't split" with its maxsplit parameter,
     #  which is why we handled it already.)
-    re_split_maxsplit = maxsplit if maxsplit != -1 else 0
+    re_split_maxsplit = 0 if maxsplit == -1 else maxsplit
 
     if reverse:
         # if reverse is true, when separators overlap,
         # we need to prefer the rightmost one rather than
         # the leftmost one.  how do we do *that*?
         # Eric Smith had the brainstorm: reverse the string
         # and the separators, split, and reverse the output
@@ -688,15 +1035,15 @@
         separators = tuple(separators)
         s2 = _reversed_builtin_separators.get(separators, None)
         if s2 != None:
             separators = s2
         else:
             separators = _multisplit_reversed(separators, 'separators')
 
-    pattern = _separators_to_re(separators, as_bytes, keep=separators_to_re_keep, separate=separate)
+    pattern = _separators_to_re(separators, is_bytes, keep=separators_to_re_keep, separate=separate)
     # print("PATTERN", pattern, f"{separators_to_re_keep=} {separate=}")
 
     l = re.split(pattern, s, re_split_maxsplit)
     assert l
     # print("S", repr(s), "L", l, f"{re_split_maxsplit=}")
 
     if strip == PROGRESSIVE:
@@ -801,55 +1148,87 @@
 
         big.text.multipartition('aXYbYXc', ('X', 'Y',), count=2, separate=False) => ('a', 'XY', 'b', 'YX', 'c')
         big.text.multipartition('aXYbYXc', ('X', 'Y',), count=2, separate=True ) => ('a', 'X', '', 'Y', 'bYXc')
 
     If reverse is true, multipartition behaves like str.rpartition.
     It partitions starting on the right, scanning backwards through
     s looking for separators.
+
+    You can pass in an instance of a subclass of bytes or str
+    for s and elements of separators, but the base class
+    for both must be the same (str or bytes).  multipartition
+    will only yield str or bytes objects.
     """
     if count < 0:
         raise ValueError("count must be positive")
     result = list(multisplit(s, separators,
         keep=ALTERNATING,
         reverse=reverse,
         separate=separate,
         strip=False,
         maxsplit=count))
     desired_length = (2 * count) + 1
     result_length = len(result)
     if result_length < desired_length:
-        as_bytes = isinstance(s, bytes)
-        if as_bytes:
-            empty = b''
+        if isinstance(s, bytes):
+            empty = (b'',)
         else:
-            empty = ''
-        extension = [empty] * (desired_length - result_length)
+            empty = ('',)
+        extension = empty * (desired_length - result_length)
         if reverse:
-            result = extension + result
+            result = list(extension) + result
         else:
             result.extend(extension)
     return tuple(result)
 
 @_export
 def multirpartition(s, separators, count=1, *, reverse=False, separate=True):
     return multipartition(s, separators, count=count, reverse=not reverse, separate=separate)
 
 
+# I think that, for our purposes,
+#     ` (the "back-tick" character U+0060)
+# is *not* an apostrophe.  it's a diacritical
+# used to modify a letter, rather than a
+# separator used to separate letters.
+apostrophes = unicode_apostrophes = "'‘’‚‛"
+_export_name('apostrophes')
+double_quotes = unicode_double_quotes = '"“”„‟«»‹›'
+_export_name('double_quotes')
+
+ascii_apostrophes = b"'"
+_export_name('ascii_apostrophes')
+ascii_double_quotes = b'"'
+_export_name('ascii_double_quotes')
+
+utf8_apostrophes = apostrophes.encode('utf-8')
+_export_name('utf8_apostrophes')
+utf8_double_quotes = double_quotes.encode('utf-8')
+_export_name('utf8_double_quotes')
+
+
 _invalid_state = "_invalid_state"
 _in_word = "_in_word"
 _after_whitespace = "_after_whitespace"
 _after_whitespace_then_apostrophe_or_double_quote = "_after_whitespace_then_apostrophe_or_double_quote"
 _after_whitespace_then_D_or_O = "_after_whitespace_then_D_or_O"
 _after_whitespace_then_D_or_O_then_apostrophe = "_after_whitespace_then_D_or_O_then_apostrophe"
 
+_default_str_is_apostrophe = frozenset(unicode_apostrophes).__contains__
+_default_str_is_double_quote = frozenset(unicode_double_quotes).__contains__
+_default_bytes_is_apostrophe = ascii_apostrophes.__eq__
+_default_bytes_is_double_quote = ascii_double_quotes.__eq__
+_str_do_contains = 'DO'.__contains__
+_bytes_do_contains = b'DO'.__contains__
+
 @_export
 def gently_title(s, *, apostrophes=None, double_quotes=None):
     """
-    Uppercase the first character of every word in s.
-    Leave the other letters alone.  s should be str or bytes.
+    Uppercase the first character of every word in s,
+    and leave all other characters alone.
 
     (For the purposes of this algorithm, words are
     any blob of non-whitespace characters.)
 
     Capitalize the letter after an apostrophe if
         a) the apostrophe is after whitespace or a
            left parenthesis character ('(')
@@ -871,61 +1250,89 @@
     the quote mark is after whitespace (or is the
     first letter of a string).
 
     A run of consecutive apostrophes and/or
     quote marks is considered one quote mark for
     the purposes of capitalization.
 
-    If specified, apostrophes should be a str
-    or bytes object containing characters that
-    should be considered apostrophes.  If apostrophes
-    is false, and s is bytes, apostrophes is set to "'".
-    If apostrophes is false and s is str, apostrophes
-    is set to a string containing these Unicode
-    apostrophe code points:
-        '‘’‚‛
-
-    If specified, double_quotes should be a str
-    or bytes object containing characters that
-    should be considered double-quote characters.
-    If double_quotes is false, and s is bytes,
-    double_quotes is set to "'".
-    If double_quotes is false, and s is str, double_quotes
-    is set to a string containing these Unicode double quote
-    code points:
-        "“”„‟«»‹›
+    s should be a str or bytes object.  s can also
+    be an instance of a subclass of str or bytes,
+    however, gently_title will only ever return a
+    str or bytes object.
+
+    If specified, apostrophes and double_quotes should
+    an string, or iterable of strings, of the same type
+    as s (or a conformant type).
+
+    If apostrophes is false, gently_title will use a
+    default value for apostrophes:
+        If s is str, the default value is big.text.apostrophes,
+        a string containing all Unicode code points that
+        represent apostrophes.
+
+        If s is bytes, the default value is
+        big.text.ascii_apostrophes, which is the string b"'".
+
+    If double_quotes is false, gently_title will use a
+    default value for double_quotes:
+        If s is str, the default value is big.text.double_quotes,
+        a string containing all Unicode code points representing
+        double-quote marks.
+
+        If s is bytes, the default value is
+        big.text.ascii_double_quotes, which is the string b"'".
     """
-    as_bytes = isinstance(s, bytes)
-    if as_bytes:
+    if isinstance(s, bytes):
+        s_type = bytes
         empty = b""
-        if not apostrophes:
-            apostrophes = b"'"
-        if not double_quotes:
-            double_quotes = b'"'
-        d_and_o = b'DO'
+        _is_d_or_o = _bytes_do_contains
         lparen = b'('
-        characters_in_s = (s[i:i+1] for i in range(len(s)))
+        iterator = _iterate_over_bytes
+        default_is_apostrophe = _default_bytes_is_apostrophe
+        default_is_double_quote = _default_bytes_is_double_quote
     else:
+        s_type = str
         empty = ""
-        if not apostrophes:
-            apostrophes = "'‘’‚‛"
-        if not double_quotes:
-            double_quotes = '"“”„‟«»‹›'
-        d_and_o = 'DO'
+        default_is_apostrophe = _default_str_is_apostrophe
+        default_is_double_quote = _default_str_is_double_quote
+        _is_d_or_o = _str_do_contains
         lparen = '('
-        characters_in_s = iter(s)
+        iterator = iter
 
-    # ooh, fancy!
-    _is_apostrophe = apostrophes.__contains__
-    _is_double_quote = double_quotes.__contains__
-    _is_d_or_o = d_and_o.__contains__
+    if apostrophes is None:
+        _is_apostrophe = default_is_apostrophe
+    else:
+        cast_apostrophes = []
+        for o in iterator(apostrophes):
+            if not isinstance(o, s_type):
+                raise TypeError(f"apostrophes must be an iterable of non-empty objects the same type as s, or None")
+            if not o:
+                raise ValueError("apostrophes must be an iterable of non-empty objects the same type as s, or None")
+            cast_apostrophes.append(o)
+        if not apostrophes:
+            raise ValueError("apostrophes must be an iterable of non-empty objects the same type as s")
+        _is_apostrophe = frozenset(cast_apostrophes).__contains__
+
+    if double_quotes is None:
+        _is_double_quote = default_is_double_quote
+    else:
+        cast_double_quotes = []
+        for o in iterator(double_quotes):
+            if not isinstance(o, s_type):
+                raise TypeError("double_quotes must be an iterable of non-empty objects the same type as s, or None")
+            if not o:
+                raise ValueError("double_quotes must be an iterable of non-empty objects the same type as s, or None")
+            cast_double_quotes.append(o)
+        if not double_quotes:
+            raise ValueError("double_quotes must be an iterable of non-empty objects the same type as s")
+        _is_double_quote = frozenset(cast_double_quotes).__contains__
 
     result = []
     state = _after_whitespace
-    for c in characters_in_s:
+    for c in iterator(s):
         original_c = c
         original_state = state
         is_space = c.isspace() or (c == lparen)
         is_apostrophe = _is_apostrophe(c)
         is_double_quote = _is_double_quote(c)
         if state == _in_word:
             if is_space:
@@ -947,109 +1354,147 @@
             if is_apostrophe:
                 state = _after_whitespace_then_D_or_O_then_apostrophe
             else:
                 state = _in_word
         elif state == _after_whitespace_then_D_or_O_then_apostrophe:
             c = c.upper()
             state = _in_word
-        # print(f"  {original_c!r} {repr(is_space):5} {original_state!r:49} -> {c!r} {state!r}")
         result.append(c)
     return empty.join(result)
 
-
 @_export
 def normalize_whitespace(s, separators=None, replacement=None):
     """
     Returns s, but with every run of consecutive
     separator characters turned into a replacement string.
     By default turns all runs of consecutive whitespace
     characters into a single space character.
 
     s may be str or bytes.
     separators should be an iterable of either str or bytes objects,
     matching s.
     replacement should be either a str or bytes object,
     also matching s, or None (the default).
     If replacement is None, normalize_whitespace will use
-    a replacement string consisting of a single space character,
-    either str or bytes as appropriate.
+    a replacement string consisting of a single space character.
 
     Leading or trailing runs of separator characters will
     be replaced with the replacement string, e.g.:
 
        normalize_whitespace("   a    b   c") == " a b c".
+
+    You can pass in an instance of a subclass of bytes or str
+    for s and elements of separators, but the base class
+    for both must be the same (str or bytes).
+    normalize_whitespace will only return str or bytes objects.
     """
-    as_bytes = isinstance(s, bytes)
-    if as_bytes:
+
+    if isinstance(s, bytes):
         empty = b''
         default_replacement = b' '
-        default_separators = ascii_whitespace
+        default_separators = ascii_whitespace_without_dos
+        s_type = bytes
     else:
         empty = ''
         default_replacement = ' '
-        default_separators = whitespace
-
-    if not s:
-        return empty
+        default_separators = whitespace_without_dos
+        s_type = str
 
     if separators is None:
         separators = default_separators
+    elif isinstance(separators, s_type):
+        if s_type == bytes:
+            # not iterable of bytes, literally a bytes string.
+            # split it ourselves.  otherwise, _separators_to_re will
+            # iterate over it, which... yields integers! oops!
+            separators = _iterate_over_bytes(separators)
+        separators = tuple(separators)
+    else:
+        cast_separators = []
+        for o in separators:
+            if not isinstance(o, s_type):
+                raise TypeError("separators must be an iterable of non-empty objects the same type as s, or None")
+            if not o:
+                raise ValueError("separators must be an iterable of non-empty objects the same type as s, or None")
+            cast_separators.append(o)
+        if not cast_separators:
+            raise ValueError("separators must be an iterable of non-empty objects the same type as s, or None")
+        separators = tuple(cast_separators)
+
     if replacement is None:
         replacement = default_replacement
+    elif not isinstance(replacement, s_type):
+        raise TypeError("replacement must be the same type as s, or None")
+
+    if not s:
+        return empty
 
-    if separators in (whitespace, ascii_whitespace, utf8_whitespace, None):
+    # normalize_whitespace has a fast path for
+    # normalizing whitespace on str objects.
+    # if your "separators" qualifies,
+    # it'll automatically use the fast path.
+    #
+    # we can't use the fast path for bytes objects,
+    # because it won't work with encoded whitespace
+    # characters > chr(127).
+    #
+    # (it'd *usually* work, sure.
+    # but "usually" isn't good enough for big!)
+    if (   (separators is whitespace_without_dos)
+        or (separators is whitespace)
+        ):
         if not s.strip():
             return replacement
         words = s.split()
-        cleaned = replacement.join(words)
-        del words
         if s[:1].isspace():
-            cleaned = replacement + cleaned
+            words.insert(0, empty)
         if s[-1:].isspace():
-            cleaned = cleaned + replacement
+            words.append(empty)
+        cleaned = replacement.join(words)
         return cleaned
 
-    words = list(multisplit(s, separators, keep=False, separate=False, strip=True, reverse=False, maxsplit=-1))
+    words = list(multisplit(s, separators, keep=False, separate=False, strip=False, reverse=False, maxsplit=-1))
     cleaned = replacement.join(words)
     del words
-    stripped_left = multistrip(s, separators, left=True, right=False) != s
-    if stripped_left:
-        cleaned = replacement + cleaned
-    stripped_right = multistrip(s, separators, left=False, right=True) != s
-    if stripped_right:
-        cleaned = cleaned + replacement
     return cleaned
 
 
 @_export
 def split_quoted_strings(s, quotes=None, *, triple_quotes=True, backslash=None):
     """
-    Splits s into quoted and unquoted segments.  Returns an iterator yielding
-    2-tuples:
+    Splits s into quoted and unquoted segments.
+
+    s can be either str or bytes.
+
+    quotes is an iterable of quote separators, either str or bytes matching s.
+    Note that split_quoted_strings only supports quote *characters*, as in,
+    each quote separator must be exactly one character long.
+
+    Returns an iterator yielding 2-tuples:
         (is_quoted, segment)
     where segment is a substring of s, and is_quoted is true if the segment is
     quoted.  Joining all the segments together recreates s.
 
-    quotes is an iterable of quote separators.  Note that split_quoted_strings
-    only supports quote *characters*, as in, each quote separator must be exactly
-    one character long.
-
     If triple_quotes is true, supports "triple-quoted" strings like Python.
 
     If backslash is a character, this character will quoting characters inside
     a quoted string, like the backslash character inside strings in Python.
+
+    You can pass in an instance of a subclass of bytes or str
+    for s and quotes, but the base class for both must be
+    the same (str or bytes).  split_quoted_strings will only
+    return str or bytes objects.
     """
-    as_bytes = isinstance(s, bytes)
-    if as_bytes:
+    if isinstance(s, bytes):
         empty = b''
         if quotes is None:
             quotes=(b'"', b"'")
         if backslash is None:
             backslash = b'\\'
-        i = (s[i:i+1] for i in range(len(s)))
+        i = _iterate_over_bytes(s)
     else:
         empty = ''
         if quotes is None:
             quotes=('"', "'")
         if backslash is None:
             backslash = '\\'
         i = s
@@ -1207,25 +1652,25 @@
 
 @_export
 class lines:
     def __init__(self, s, separators=None, *, line_number=1, column_number=1, tab_width=8, **kwargs):
         """
         A "lines iterator" object.  Splits s into lines, and iterates yielding those lines.
 
-        "s" can be str, bytes, or any iterable.
-
-        By default, if "s" is str, splits "s" by all Unicode line break characters.
-        If "s" is bytes, splits "s" by all ASCII line break characters.
+        "s" can be str, bytes, or any iterable of str or bytes.
 
-        If "s" is neither str nor bytes, "s" must be an iterable;
-        lines yields successive elements of "s" as lines.
-
-        "separators", if not None, must be an iterable of strings of the
-        same type as "s".  lines will split "s" using those strings as
-        separator strings (using big.multisplit).
+        If s is neither str nor bytes, s must be an iterable;
+        lines yields successive elements of s as lines.  All objects
+        yielded by this iterable should be homogeneous, either str or bytes.
+
+        If s is str or bytes, and separators is None, lines
+        will split s at line boundaries and yield those lines,
+        including empty lines.  If separators is not None,
+        it must be an iterable of strings of the same type as s;
+        lines will split s using multisplit.
 
         When iterated over, yields 2-tuples:
             (info, line)
 
         info is a LineInfo object, which contains three fields by default:
             * line - the original line, never modified
             * line_number - the line number of this line, starting at the
@@ -1236,51 +1681,56 @@
 
         tab_width is not used by lines itself, but is stored internally and
         may be used by other lines modifier functions
         (e.g. lines_convert_tabs_to_spaces, lines_strip_indent). Similarly,
         all keyword arguments passed in via kwargs are stored internally
         and can be accessed by user-defined lines modifier functions.
 
+        You can pass in an instance of a subclass of bytes or str
+        for s and elements of separators, but the base class
+        for both must be the same (str or bytes).  lines will
+        only yield str or bytes objects.
+
         Composable with all the lines_ modifier functions in the big.text module.
         """
         if not isinstance(line_number, int):
             raise TypeError("line_number must be int")
         if not isinstance(column_number, int):
             raise TypeError("column_number must be int")
         if not isinstance(tab_width, int):
             raise TypeError("tab_width must be int")
 
-        as_bytes = isinstance(s, bytes)
-        as_str = isinstance(s, str)
-        if as_bytes or as_str:
+        is_bytes = isinstance(s, bytes)
+        is_str = isinstance(s, str)
+        if is_bytes or is_str:
             if not separators:
-                separators = newlines if as_str else ascii_newlines
+                separators = newlines if is_str else ascii_newlines
             i = multisplit(s, separators, keep=False, separate=True, strip=False)
         else:
             i = iter(s)
-            as_bytes = None
+            is_bytes = None
 
         self.s = s
         self.separators = separators
         self.line_number = line_number
         self.column_number = column_number
         self.tab_width = tab_width
-        self.as_bytes = as_bytes
+        self.s_is_bytes = is_bytes
 
         self.i = i
 
         self.__dict__.update(kwargs)
 
     def __iter__(self):
         return self
 
     def __next__(self):
         line = next(self.i)
-        if self.as_bytes is None:
-            self.as_bytes = isinstance(line, bytes)
+        if self.s_is_bytes is None:
+            self.s_is_bytes = isinstance(line, bytes)
         return_value = (LineInfo(line, self.line_number, self.column_number), line)
         self.line_number += 1
         return return_value
 
 @_export
 def lines_rstrip(li):
     """
@@ -1339,20 +1789,21 @@
 
     Composable with all the lines_ modifier functions in the big.text module.
     """
     if not comment_separators:
         raise ValueError("illegal comment_separators")
 
     if isinstance(comment_separators, bytes):
-        comment_separators = tuple(comment_separators[i:i+1] for i in range(len(comment_separators)))
-        as_bytes = True
+        comment_separators = _iterate_over_bytes(comment_separators)
+        comment_separators_is_bytes = True
     else:
-        as_bytes = isinstance(comment_separators[0], bytes)
+        comment_separators_is_bytes = isinstance(comment_separators[0], bytes)
+    comment_separators = tuple(comment_separators)
 
-    comment_pattern = _separators_to_re(tuple(comment_separators), as_bytes, separate=False, keep=False)
+    comment_pattern = _separators_to_re(comment_separators, comment_separators_is_bytes, separate=False, keep=False)
     comment_re = re.compile(comment_pattern)
     for info, line in li:
         s = line.lstrip()
         if comment_re.match(s):
             continue
         yield (info, line)
 
@@ -1393,15 +1844,15 @@
     filters out lines that match pattern.
 
     Composable with all the lines_ functions from the big.text module.
 
     (In older versions of Python, re.Pattern was a private type called
     re._pattern_type.)
     """
-    if not isinstance(pattern, re_Pattern):
+    if not isinstance_re_pattern(pattern):
         pattern = re.compile(pattern, flags=flags)
     search = pattern.search
     if invert:
         for t in li:
             if not search(t[1]):
                 yield t
         return
@@ -1466,26 +1917,27 @@
 
     Composable with all the lines_ modifier functions in the big.text module.
     """
     if not comment_separators:
         raise ValueError("illegal comment_separators")
 
     if isinstance(comment_separators, bytes):
-        comment_separators = tuple(comment_separators[i:i+1] for i in range(len(comment_separators)))
-        as_bytes = True
+        comment_separators = _iterate_over_bytes(comment_separators)
+        comment_separators_is_bytes = True
     else:
-        as_bytes = isinstance(comment_separators[0], bytes)
+        comment_separators_is_bytes = isinstance(comment_separators[0], bytes)
+    comment_separators = tuple(comment_separators)
 
-    if as_bytes:
+    if comment_separators_is_bytes:
         empty = b''
     else:
         empty = ''
     empty_join = empty.join
 
-    comment_pattern = _separators_to_re(comment_separators, as_bytes=as_bytes, separate=True, keep=True)
+    comment_pattern = __separators_to_re(comment_separators, separators_is_bytes=comment_separators_is_bytes, separate=True, keep=True)
     re_comment = re.compile(comment_pattern)
     split = re_comment.split
     for info, line in li:
         if quotes:
             i = split_quoted_strings(line, quotes, backslash=backslash, triple_quotes=triple_quotes)
         else:
             i = ((False, line),)
@@ -1620,75 +2072,117 @@
 
 @_export
 def wrap_words(words, margin=79, *, two_spaces=True):
     """
     Combines 'words' into lines and returns the result as a string.
     Similar to textwrap.wrap.
 
-    'words' should be an iterator containing text split at word
-    boundaries.  Example:
+    'words' should be an iterator yielding str or bytes strings, and
+    these strings should already be split at word boundaries.
+    Here's an example of a valid argument for words:
         "this is an example of text split at word boundaries".split()
+
+    A single '\n' indicates a line break.
     If you want a paragraph break, embed two '\n' characters in a row.
 
     'margin' specifies the maximum length of each line. The length of
     every line will be less than or equal to 'margin', unless the length
     of an individual element inside 'words' is greater than 'margin'.
 
     If 'two_spaces' is true, elements from 'words' that end in
     sentence-ending punctuation ('.', '?', and '!') will be followed
     by two spaces, not one.
 
     Elements in 'words' are not modified; any leading or trailing
     whitespace will be preserved.  You can use this to preserve
     whitespace where necessary, like in code examples.
+
+    The objects yielded by words can be a subclass of either
+    str or bytes, though wrap_words will only return str or bytes.
+    All the objects yielded by words must have the same base class
+    (str or bytes).
     """
     words = iter(words)
     col = 0
-    lastword = ''
+    empty = None
+    lastword = None
     text = []
+    first_word = True
 
     for word in words:
+        if first_word:
+            first_word = False
+            if isinstance(word, bytes):
+                empty = lastword = b''
+                sentence_ending_punctuation = (b'.', b'?', b'!')
+                two_spaces = b'  '
+                one_space = b' '
+                newline = b'\n'
+            else:
+                empty = lastword = ''
+                sentence_ending_punctuation = ('.', '?', '!')
+                two_spaces = '  '
+                one_space = ' '
+                newline = '\n'
+
         if word.isspace():
             lastword = word
             col = 0
             text.append(word)
             continue
 
         l = len(word)
 
-        if two_spaces and lastword.endswith(('.', '?', '!')):
-            space = "  "
+        if two_spaces and lastword.endswith(sentence_ending_punctuation):
+            space = two_spaces
             len_space = 2
         else:
-            space = " "
+            space = one_space
             len_space = 1
 
         if (l + len_space + col) > margin:
             if col:
-                text.append('\n')
+                text.append(newline)
                 col = 0
         elif col:
             text.append(space)
             col += len_space
 
         text.append(word)
         col += len(word)
         lastword = word
 
-    return "".join(text)
+    if first_word:
+        raise ValueError("no words to wrap")
+    return empty.join(text)
 
 
 
 _code_paragraph = "code paragraph"
 _text_paragraph = "text paragraph"
 
 class _column_wrapper_splitter:
 
-    def __init__(self, tab_width, allow_code, code_indent, convert_tabs_to_spaces):
+    def __init__(self, is_bytes, tab_width, allow_code, code_indent, convert_tabs_to_spaces):
         # print(f"\n_column_wrapper_splitter({tab_width=}, {allow_code=}, {convert_tabs_to_spaces=})")
+        self.is_bytes = is_bytes
+        if is_bytes:
+            self.empty = b''
+            self.tab_string = b'\t'
+            self.space_string = b' '
+            self.newline_string = b'\n'
+            self.paragraph_string = b'\n\n'
+            self.make_iterator = _iterate_over_bytes
+        else:
+            self.empty = ''
+            self.tab_string = '\t'
+            self.space_string = ' '
+            self.newline_string = '\n'
+            self.paragraph_string = '\n\n'
+            self.make_iterator = iter
         self.tab_width = tab_width
         self.allow_code = allow_code
         self.code_indent = code_indent
         self.convert_tabs_to_spaces = convert_tabs_to_spaces
 
         self.init()
 
@@ -1708,29 +2202,29 @@
 
     def emit(self, c):
         # print(f" [emit]", repr(c))
         self.words.append(c)
 
     def line_break(self):
         # print(f" [  \\n]")
-        self.words.append('\n')
+        self.words.append(self.newline_string)
 
     def paragraph_break(self):
         # print(f" [\\n\\n]")
-        self.words.append('\n\n')
+        self.words.append(self.paragraph_string)
 
     def next(self, state, leading=None, word=None):
         # print(f" [  ->]", state.__name__, repr(leading), repr(word))
         self.state = state
         assert ((leading is None) and (word is None)) or ((leading is not None) and (word is not None))
         if word is not None:
             self.state(leading, word)
 
-    def write(self, s):
-        # write consumes s and makes calls as appropriate to
+    def write(self, c):
+        # write consumes c and makes calls as appropriate to
         # self.state().
         #
         # first, write aggregates together all consecutive
         # non-line-breaking whitespace characters, which it
         # stores in 'leading'.  if the next character is
         # a newline, it passes that single newline as 'word'.
         # otherwise it aggregates all consecutive non-whitespace
@@ -1772,83 +2266,99 @@
         # is the same as calling
         #     self.write('abcdef')
         #
         # you should call close() after the last write() call.
 
         leading = self.leading
         word = self.word
+        write_word = None
+        write_newline = False
+        append_c_to_leading = False
+        empty = self.empty
+        newline_string = self.newline_string
 
-        for c in s:
-            # print(f"<{c!r}> ", end='')
+        # print(f"<{c!r}> ", end='')
 
-            if not c.isspace():
-                word.append(c)
-                continue
+        if not c.isspace():
+            word.append(c)
+            return
 
-            if word:
-                w = "".join(word)
-                word.clear()
-                if leading:
-                    l = ''.join(leading)
-                else:
-                    l = ''
-                leading.clear()
-                self.state(l, w)
-            if c == '\n':
-                if leading:
-                    l = ''.join(leading)
-                else:
-                    l = ''
+        if word:
+            write_word = empty.join(word)
+            word.clear()
+
+        if c == newline_string:
+            if write_word:
+                write_newline = True
+            else:
+                write_word = c
+        else:
+            append_c_to_leading = True
+
+        if write_word:
+            if leading:
+                l = empty.join(leading)
                 leading.clear()
-                self.state(l, c)
             else:
-                leading.append(c)
+                l = empty
+
+            self.state(l, write_word)
+            write_word = None
+
+            if write_newline:
+                self.state(empty, newline_string)
+                write_newline = False
+
+        if append_c_to_leading:
+            leading.append(c)
+            append_c_to_leading = False
 
     def close(self):
         # flush the current word, if any.
         if self.word:
-            self.state("".join(self.leading), "".join(self.word))
+            empty = self.empty
+            self.state(empty.join(self.leading), empty.join(self.word))
             self.leading.clear()
             self.word.clear()
 
     def state_paragraph_start(self, leading, word):
         """
         Initial state.  Also the state we return to
         after encountering two '\n's in a row after
         a text line.
         """
-        if word == '\n':
+        if word == self.newline_string:
             return
         if self.previous_paragraph:
             self.paragraph_break()
             self.previous_paragraph = None
         self.next(self.state_line_start, leading, word)
 
     state_initial = state_paragraph_start
 
     def state_line_start(self, leading, word):
-        if word == '\n':
+        if word == self.newline_string:
             # two '\n's in a row.
             if self.previous_paragraph == _code_paragraph:
                 # we could still be in a code block.
                 # remember the whitespace and continue.
                 # we don't need to save the leading whitespace.
                 self.code.append(word)
                 return
 
             self.next(self.state_paragraph_start)
             return
 
         if self.allow_code:
             col = 0
             tab_width = self.tab_width
-            for c in leading:
-                if c == '\t':
+            for c in self.make_iterator(leading):
+                if c == self.tab_string:
                     col = col + tab_width - (col % tab_width)
-                elif c == ' ':
+                elif c == self.space_string:
                     col += 1
                 else:
                     raise RuntimeError("unhandled whitespace character " + repr(c))
             if col >= self.code_indent:
                 # code line!
                 if self.previous_paragraph == _text_paragraph:
                     self.paragraph_break()
@@ -1867,43 +2377,45 @@
         self.next(self.state_text_line_start, leading, word)
 
     def state_text_line_start(self, leading, word):
         self.previous_paragraph = _text_paragraph
         self.next(self.state_in_text_line, leading, word)
 
     def state_in_text_line(self, leading, word):
-        if word == '\n':
+        if word == self.newline_string:
             self.next(self.state_line_start)
             return
         self.emit(word)
 
     def state_code_line_start(self, leading, word):
         self.previous_paragraph = _code_paragraph
         self.col = 0
         self.next(self.state_in_code_line, leading, word)
 
     def state_in_code_line(self, leading, word):
-        if word == '\n':
-            self.emit("".join(self.code))
+        if word == self.newline_string:
+            self.emit(self.empty.join(self.code))
             self.code.clear()
-            self.next(self.state_line_start, '', word)
+            self.next(self.state_line_start, self.empty, word)
             return
 
         tab_width = self.tab_width
         convert_tabs_to_spaces = self.convert_tabs_to_spaces
         col = self.col
-        for c in leading:
-            if c == '\t':
+        tab_string = self.tab_string
+        space_string = self.space_string
+        for c in self.make_iterator(leading):
+            if c == tab_string:
                 delta = tab_width - (col % tab_width)
                 col += delta
                 if convert_tabs_to_spaces:
-                    self.code.append(' ' * delta)
+                    self.code.append(space_string * delta)
                 else:
                     self.code.append(c)
-            elif c == ' ':
+            elif c == space_string:
                 col += 1
                 self.code.append(c)
             else:
                 raise RuntimeError("unhandled whitespace character " + repr(c))
         self.code.append(word)
         self.col = col + len(word)
 
@@ -1911,29 +2423,48 @@
 
 @_export
 def split_text_with_code(s, *, tab_width=8, allow_code=True, code_indent=4, convert_tabs_to_spaces=True):
     """
     Splits the string s into individual words,
     suitable for feeding into wrap_words.
 
+    s may be either str or bytes.
+
     Paragraphs indented by less than code_indent will be
     broken up into individual words.
 
     If `allow_code` is true, paragraphs indented by at least
     code_indent spaces will preserve their whitespace:
     internal whitespace is preserved, and the newline is
     preserved.  (This will preserve the formatting of code
     examples, when these words are rejoined into lines
     by wrap_words.)
+
+    s can be str, bytes, or a subclass of either, though
+    split_text_with_code will only return str or bytes.
+
+    if s is empty, returns a list containing an empty string.
     """
-    cws = _column_wrapper_splitter(tab_width, allow_code, code_indent, convert_tabs_to_spaces)
-    for c in s:
+    is_bytes = isinstance(s, bytes)
+    if is_bytes:
+        iterable = _iterate_over_bytes(s)
+        empty = b''
+    else:
+        iterable = s
+        empty = ''
+
+    cws = _column_wrapper_splitter(is_bytes, tab_width, allow_code, code_indent, convert_tabs_to_spaces)
+
+    for c in iterable:
         cws.write(c)
     cws.close()
-    return cws.words
+    return_value = cws.words
+    if not return_value:
+        return [empty]
+    return return_value
 
 
 @_export
 class OverflowStrategy(enum.Enum):
     """
     Enum providing constants to specify how merge_columns
     handles overflow in columns.
@@ -1942,31 +2473,32 @@
     RAISE = enum.auto()
     INTRUDE_ALL = enum.auto()
     # INTRUDE_MINIMUM = enum.auto()  # not implemented yet
     DELAY_ALL = enum.auto()
     # DELAY_MINIMUM = enum.auto()  # not implemented yet
 
 @_export
-def merge_columns(*columns, column_separator=" ",
+def merge_columns(*columns, column_separator=None,
     overflow_strategy=OverflowStrategy.RAISE,
     overflow_before=0,
     overflow_after=0,
     ):
     """
     Merge n column tuples, with each column tuple being
     formatted into its own column in the resulting string.
     Returns a string.
 
     columns should be an iterable of column tuples.
     Each column tuple should contain three items:
         (text, min_width, max_width)
-    text should be a single text string, with newline
-    characters separating lines. min_width and max_width
-    are the minimum and maximum permissible widths for that
-    column, not including the column separator (if any).
+    text should be a single string, either str or bytes,
+    with newline characters separating lines. min_width
+    and max_width are the minimum and maximum permissible
+    widths for that column, not including the column
+    separator (if any).
 
     Note that this function doesn't text-wrap the lines.
 
     column_separator is printed between every column.
 
     overflow_strategy tells merge_columns how to handle a column
     with one or more lines that are wider than that column's max_width.
@@ -1987,37 +2519,57 @@
            not beginning any until after the last overflowed line
            in the overflowed column.
 
     When overflow_strategy is INTRUDE_ALL or DELAY_ALL, and
     either overflow_before or overflow_after is nonzero, these
     specify the number of extra lines before or after
     the overflowed lines in a column.
+
+    text and column_separator can be str, bytes, or a subclass
+    of either, though merge_columns will only return str or bytes.
+    All these objects (text and column_separator) must have the
+    same baseclass, str or bytes.
     """
     assert overflow_strategy in (OverflowStrategy.INTRUDE_ALL, OverflowStrategy.DELAY_ALL, OverflowStrategy.RAISE)
     raise_overflow_error = overflow_strategy == OverflowStrategy.RAISE
     delay_all = overflow_strategy == OverflowStrategy.DELAY_ALL
 
+    assert columns
+    is_bytes = isinstance(columns[0][0], bytes)
+
+    if is_bytes:
+        empty = b''
+        space = b' '
+        newline = b'\n'
+    else:
+        empty = ''
+        space = ' '
+        newline = '\n'
+
+    if column_separator is None:
+        column_separator = space
+
     _columns = columns
     columns = []
     empty_columns = []
     last_too_wide_lines = []
     max_lines = -1
 
     column_spacing = len(column_separator)
 
     for column_number, (s, min_width, max_width) in enumerate(_columns):
 
         # check types, let them raise exceptions as needed
         operator.index(min_width)
         operator.index(max_width)
 
-        empty_columns.append(max_width * " ")
+        empty_columns.append(max_width * space)
 
-        if isinstance(s, str):
-            lines = s.rstrip().split('\n')
+        if isinstance(s, (str, bytes)):
+            lines = s.rstrip().split(newline)
         else:
             lines = s
         max_lines = max(max_lines, len(lines))
 
         # loop 1:
         # measure each line length, determining
         #  * maximum line length, and
@@ -2036,15 +2588,15 @@
                     overflows.pop()
                     overflows.append((last_overflow[0], overflow_end))
                     return
             overflows.append((overflow_start, overflow_end))
 
         for line_number, line in enumerate(lines):
             line = line.rstrip()
-            assert not "\n" in line
+            assert not newline in line
             rstripped_lines.append(line)
 
             length = len(line)
             max_line_length = max(max_line_length, length)
 
             line_overflowed = length > max_width
             if (not in_overflow) and line_overflowed:
@@ -2058,15 +2610,15 @@
                 overflow_end = line_number - 1 + overflow_after
                 add_overflow()
 
         if in_overflow:
             overflow_end = line_number + overflow_after
             add_overflow()
             for i in range(overflow_after):
-                rstripped_lines.append('')
+                rstripped_lines.append(empty)
 
         if delay_all and overflows:
             overflows.clear()
             overflows.append((0, overflow_end))
 
         # loop 2:
         # compute padded lines and in_overflow for every line
@@ -2116,13 +2668,13 @@
             except StopIteration:
                 column = empty_column
             line.append(column)
             if in_overflow:
                 break
         if all_iterators_are_exhausted:
             break
-        line = "".join(line).rstrip()
+        line = empty.join(line).rstrip()
         lines.append(line)
 
-    text = "\n".join(lines)
+    text = newline.join(lines)
     return text.rstrip()
```

### Comparing `big-0.7.1/big/time.py` & `big-0.8/big/time.py`

 * *Files identical despite different names*

### Comparing `big-0.7.1/pyproject.toml` & `big-0.8/pyproject.toml`

 * *Files 20% similar despite different names*

```diff
@@ -23,7 +23,10 @@
 [project.urls]
 Source = "https://github.com/larryhastings/big/"
 
 [project.optional-dependencies]
 time = [
     "python-dateutil",
     ]
+test = [
+    "regex",
+    ]
```

### Comparing `big-0.7.1/resources/experiments/alice.in.wonderland.txt` & `big-0.8/resources/experiments/alice.in.wonderland.txt`

 * *Files identical despite different names*

### Comparing `big-0.7.1/resources/experiments/time_multisplit.py` & `big-0.8/resources/experiments/time_multisplit.py`

 * *Files identical despite different names*

### Comparing `big-0.7.1/resources/images/big.header.png` & `big-0.8/resources/images/big.header.png`

 * *Files identical despite different names*

### Comparing `big-0.7.1/test/bigtestlib.py` & `big-0.8/test/bigtestlib.py`

 * *Files identical despite different names*

### Comparing `big-0.7.1/test/test_all.py` & `big-0.8/test/test_all.py`

 * *Files identical despite different names*

### Comparing `big-0.7.1/test/test_boundinnerclass.py` & `big-0.8/test/test_boundinnerclass.py`

 * *Files identical despite different names*

### Comparing `big-0.7.1/test/test_builtin.py` & `big-0.8/test/test_builtin.py`

 * *Files identical despite different names*

### Comparing `big-0.7.1/test/test_file.py` & `big-0.8/test/test_file.py`

 * *Files identical despite different names*

### Comparing `big-0.7.1/test/test_graph.py` & `big-0.8/test/test_graph.py`

 * *Files identical despite different names*

### Comparing `big-0.7.1/test/test_heap.py` & `big-0.8/test/test_heap.py`

 * *Files identical despite different names*

### Comparing `big-0.7.1/test/test_itertools.py` & `big-0.8/test/test_itertools.py`

 * *Files identical despite different names*

### Comparing `big-0.7.1/test/test_scheduler.py` & `big-0.8/test/test_scheduler.py`

 * *Files identical despite different names*

### Comparing `big-0.7.1/test/test_text.py` & `big-0.8/test/test_text.py`

 * *Files 10% similar despite different names*

```diff
@@ -68,5754 +68,6933 @@
 00000430: 5741 5245 204f 520a 5448 4520 5553 4520  WARE OR.THE USE 
 00000440: 4f52 204f 5448 4552 2044 4541 4c49 4e47  OR OTHER DEALING
 00000450: 5320 494e 2054 4845 2053 4f46 5457 4152  S IN THE SOFTWAR
 00000460: 452e 0a22 2222 0a0a 696d 706f 7274 2063  E.."""..import c
 00000470: 6f70 790a 696d 706f 7274 2062 6967 2e61  opy.import big.a
 00000480: 6c6c 2061 7320 6269 670a 696d 706f 7274  ll as big.import
 00000490: 206d 6174 680a 696d 706f 7274 2072 650a   math.import re.
-000004a0: 696d 706f 7274 2075 6e69 7474 6573 740a  import unittest.
-000004b0: 0a0a 6465 6620 756e 6368 616e 6765 6428  ..def unchanged(
-000004c0: 6f29 3a0a 2020 2020 7265 7475 726e 206f  o):.    return o
-000004d0: 0a0a 6465 6620 746f 5f62 7974 6573 286f  ..def to_bytes(o
-000004e0: 293a 2023 2070 7261 676d 613a 206e 6f20  ): # pragma: no 
-000004f0: 636f 7665 720a 2020 2020 6966 2069 7369  cover.    if isi
-00000500: 6e73 7461 6e63 6528 6f2c 2073 7472 293a  nstance(o, str):
-00000510: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00000520: 6f2e 656e 636f 6465 2827 6173 6369 6927  o.encode('ascii'
-00000530: 290a 2020 2020 6966 2069 7369 6e73 7461  ).    if isinsta
-00000540: 6e63 6528 6f2c 206c 6973 7429 3a0a 2020  nce(o, list):.  
-00000550: 2020 2020 2020 7265 7475 726e 205b 746f        return [to
-00000560: 5f62 7974 6573 2878 2920 666f 7220 7820  _bytes(x) for x 
-00000570: 696e 206f 5d0a 2020 2020 6966 2069 7369  in o].    if isi
-00000580: 6e73 7461 6e63 6528 6f2c 2074 7570 6c65  nstance(o, tuple
-00000590: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
-000005a0: 6e20 7475 706c 6528 746f 5f62 7974 6573  n tuple(to_bytes
-000005b0: 2878 2920 666f 7220 7820 696e 206f 290a  (x) for x in o).
-000005c0: 2020 2020 7265 7475 726e 206f 0a0a 0a6b      return o...k
-000005d0: 6e6f 776e 5f73 6570 6172 6174 6f72 7320  nown_separators 
-000005e0: 3d20 5b0a 2020 2020 2862 6967 2e77 6869  = [.    (big.whi
-000005f0: 7465 7370 6163 652c 2022 6269 672e 7768  tespace, "big.wh
-00000600: 6974 6573 7061 6365 2229 2c0a 2020 2020  itespace"),.    
-00000610: 2862 6967 2e77 6869 7465 7370 6163 655f  (big.whitespace_
-00000620: 7769 7468 6f75 745f 646f 732c 2022 6269  without_dos, "bi
-00000630: 672e 7768 6974 6573 7061 6365 5f77 6974  g.whitespace_wit
-00000640: 686f 7574 5f64 6f73 2229 2c0a 2020 2020  hout_dos"),.    
-00000650: 2862 6967 2e6e 6577 6c69 6e65 732c 2020  (big.newlines,  
-00000660: 2022 6269 672e 6e65 776c 696e 6573 2229   "big.newlines")
-00000670: 2c0a 2020 2020 2862 6967 2e6e 6577 6c69  ,.    (big.newli
-00000680: 6e65 735f 7769 7468 6f75 745f 646f 732c  nes_without_dos,
-00000690: 2020 2022 6269 672e 6e65 776c 696e 6573     "big.newlines
-000006a0: 5f77 6974 686f 7574 5f64 6f73 2229 2c0a  _without_dos"),.
-000006b0: 0a20 2020 2028 6269 672e 6173 6369 695f  .    (big.ascii_
-000006c0: 7768 6974 6573 7061 6365 2c20 2262 6967  whitespace, "big
-000006d0: 2e61 7363 6969 5f77 6869 7465 7370 6163  .ascii_whitespac
-000006e0: 6522 292c 0a20 2020 2028 6269 672e 6173  e"),.    (big.as
-000006f0: 6369 695f 7768 6974 6573 7061 6365 5f77  cii_whitespace_w
-00000700: 6974 686f 7574 5f64 6f73 2c20 2262 6967  ithout_dos, "big
-00000710: 2e61 7363 6969 5f77 6869 7465 7370 6163  .ascii_whitespac
-00000720: 655f 7769 7468 6f75 745f 646f 7322 292c  e_without_dos"),
-00000730: 0a20 2020 2028 6269 672e 6173 6369 695f  .    (big.ascii_
-00000740: 6e65 776c 696e 6573 2c20 2020 2262 6967  newlines,   "big
-00000750: 2e61 7363 6969 5f6e 6577 6c69 6e65 7322  .ascii_newlines"
-00000760: 292c 0a20 2020 2028 6269 672e 6173 6369  ),.    (big.asci
-00000770: 695f 6e65 776c 696e 6573 5f77 6974 686f  i_newlines_witho
-00000780: 7574 5f64 6f73 2c20 2020 2262 6967 2e61  ut_dos,   "big.a
-00000790: 7363 6969 5f6e 6577 6c69 6e65 735f 7769  scii_newlines_wi
-000007a0: 7468 6f75 745f 646f 7322 292c 0a0a 2020  thout_dos"),..  
-000007b0: 2020 2862 6967 2e75 7466 385f 7768 6974    (big.utf8_whit
-000007c0: 6573 7061 6365 2c20 2262 6967 2e75 7466  espace, "big.utf
-000007d0: 385f 7768 6974 6573 7061 6365 2229 2c0a  8_whitespace"),.
-000007e0: 2020 2020 2862 6967 2e75 7466 385f 7768      (big.utf8_wh
-000007f0: 6974 6573 7061 6365 5f77 6974 686f 7574  itespace_without
-00000800: 5f64 6f73 2c20 2262 6967 2e75 7466 385f  _dos, "big.utf8_
-00000810: 7768 6974 6573 7061 6365 5f77 6974 686f  whitespace_witho
-00000820: 7574 5f64 6f73 2229 2c0a 2020 2020 2862  ut_dos"),.    (b
-00000830: 6967 2e75 7466 385f 6e65 776c 696e 6573  ig.utf8_newlines
-00000840: 2c20 2020 2262 6967 2e75 7466 385f 6e65  ,   "big.utf8_ne
-00000850: 776c 696e 6573 2229 2c0a 2020 2020 2862  wlines"),.    (b
-00000860: 6967 2e75 7466 385f 6e65 776c 696e 6573  ig.utf8_newlines
-00000870: 5f77 6974 686f 7574 5f64 6f73 2c20 2020  _without_dos,   
-00000880: 2262 6967 2e75 7466 385f 6e65 776c 696e  "big.utf8_newlin
-00000890: 6573 5f77 6974 686f 7574 5f64 6f73 2229  es_without_dos")
-000008a0: 2c0a 5d0a 0a64 6566 2070 7269 6e74 6162  ,.]..def printab
-000008b0: 6c65 5f73 6570 6172 6174 6f72 7328 7365  le_separators(se
-000008c0: 7061 7261 746f 7273 293a 0a20 2020 2066  parators):.    f
-000008d0: 6f72 206b 6e6f 776e 2c20 6e61 6d65 2069  or known, name i
-000008e0: 6e20 6b6e 6f77 6e5f 7365 7061 7261 746f  n known_separato
-000008f0: 7273 3a0a 2020 2020 2020 2020 6966 2073  rs:.        if s
-00000900: 6570 6172 6174 6f72 7320 3d3d 206b 6e6f  eparators == kno
-00000910: 776e 3a0a 2020 2020 2020 2020 2020 2020  wn:.            
-00000920: 7265 7475 726e 2066 227b 6e61 6d65 7d22  return f"{name}"
-00000930: 0a20 2020 2072 6574 7572 6e20 7365 7061  .    return sepa
-00000940: 7261 746f 7273 0a0a 636c 6173 7320 4269  rators..class Bi
-00000950: 6754 6578 7454 6573 7473 2875 6e69 7474  gTextTests(unitt
-00000960: 6573 742e 5465 7374 4361 7365 293a 0a0a  est.TestCase):..
-00000970: 2020 2020 6465 6620 7465 7374 5f77 6869      def test_whi
-00000980: 7465 7370 6163 655f 616e 645f 6e65 776c  tespace_and_newl
-00000990: 696e 6573 2873 656c 6629 3a0a 2020 2020  ines(self):.    
-000009a0: 2020 2020 2320 656e 7375 7265 2074 6861      # ensure tha
-000009b0: 7420 6269 672e 7768 6974 6573 7061 6365  t big.whitespace
-000009c0: 2061 6e64 2062 6967 2e6e 6577 6c69 6e65   and big.newline
-000009d0: 730a 2020 2020 2020 2020 2320 636f 7272  s.        # corr
-000009e0: 6563 746c 7920 6d61 7463 6865 7320 7468  ectly matches th
-000009f0: 6520 6c69 7374 206f 6620 6368 6172 6163  e list of charac
-00000a00: 7465 7273 2074 6861 740a 2020 2020 2020  ters that.      
-00000a10: 2020 2320 5079 7468 6f6e 2063 6f6e 7369    # Python consi
-00000a20: 6465 7273 2077 6869 7465 7370 6163 6520  ders whitespace 
-00000a30: 2f20 6e65 776c 696e 6573 2e0a 0a20 2020  / newlines...   
-00000a40: 2020 2020 2023 2050 7974 686f 6e20 7768       # Python wh
-00000a50: 6974 6573 7061 6365 206f 6e6c 7920 636f  itespace only co
-00000a60: 6e73 6964 6572 7320 696e 6469 7669 6475  nsiders individu
-00000a70: 616c 0a20 2020 2020 2020 2023 2077 6869  al.        # whi
-00000a80: 7465 7370 6163 6520 6368 6172 6374 6572  tespace charcter
-00000a90: 732c 2061 6e64 2064 6f65 736e 2774 2069  s, and doesn't i
-00000aa0: 6e63 6c75 6465 2074 6865 0a20 2020 2020  nclude the.     
-00000ab0: 2020 2023 2044 4f53 2065 6e64 2d6f 662d     # DOS end-of-
-00000ac0: 6c69 6e65 2073 6571 7565 6e63 6520 275c  line sequence '\
-00000ad0: 725c 6e27 2e20 2073 6f20 7768 6174 2077  r\n'.  so what w
-00000ae0: 6527 7265 0a20 2020 2020 2020 2023 2067  e're.        # g
-00000af0: 6f69 6e67 2074 6f20 7072 6f64 7563 6520  oing to produce 
-00000b00: 696e 2074 6865 2062 656c 6f77 206c 6973  in the below lis
-00000b10: 7420 6973 2074 6563 686e 6963 616c 6c79  t is technically
-00000b20: 0a20 2020 2020 2020 2023 2074 6865 2022  .        # the "
-00000b30: 7769 7468 6f75 7420 444f 5322 2076 6572  without DOS" ver
-00000b40: 7369 6f6e 732e 0a20 2020 2020 2020 2070  sions..        p
-00000b50: 7974 686f 6e5f 7768 6974 6573 7061 6365  ython_whitespace
-00000b60: 5f77 6974 686f 7574 5f64 6f73 203d 205b  _without_dos = [
-00000b70: 5d0a 2020 2020 2020 2020 7079 7468 6f6e  ].        python
-00000b80: 5f6e 6577 6c69 6e65 735f 7769 7468 6f75  _newlines_withou
-00000b90: 745f 646f 7320 3d20 5b5d 0a0a 2020 2020  t_dos = []..    
-00000ba0: 2020 2020 2320 7465 6368 6e69 6361 6c6c      # technicall
-00000bb0: 7920 7765 2064 6f6e 2774 206e 6565 6420  y we don't need 
-00000bc0: 746f 2063 6865 636b 2074 6865 2073 7572  to check the sur
-00000bd0: 726f 6761 7465 2070 6169 7220 6368 6172  rogate pair char
-00000be0: 6163 7465 7273 2e0a 2020 2020 2020 2020  acters..        
-00000bf0: 2320 6275 7420 6974 2773 2066 6173 7465  # but it's faste
-00000c00: 7220 746f 206c 6561 7665 2074 6865 6d20  r to leave them 
-00000c10: 696e 2e0a 2020 2020 2020 2020 756e 6963  in..        unic
-00000c20: 6f64 655f 636f 6465 5f70 6f69 6e74 7320  ode_code_points 
-00000c30: 3d20 322a 2a31 3620 2b20 322a 2a32 300a  = 2**16 + 2**20.
-00000c40: 0a20 2020 2020 2020 2066 6f72 2069 2069  .        for i i
-00000c50: 6e20 7261 6e67 6528 756e 6963 6f64 655f  n range(unicode_
-00000c60: 636f 6465 5f70 6f69 6e74 7329 3a0a 2020  code_points):.  
-00000c70: 2020 2020 2020 2020 2020 6320 3d20 6368            c = ch
-00000c80: 7228 6929 0a20 2020 2020 2020 2020 2020  r(i).           
-00000c90: 2073 203d 2066 2261 7b63 7d62 220a 2020   s = f"a{c}b".  
-00000ca0: 2020 2020 2020 2020 2020 6966 206c 656e            if len
-00000cb0: 2873 2e73 706c 6974 2829 2920 3d3d 2032  (s.split()) == 2
-00000cc0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00000cd0: 2020 7079 7468 6f6e 5f77 6869 7465 7370    python_whitesp
-00000ce0: 6163 655f 7769 7468 6f75 745f 646f 732e  ace_without_dos.
-00000cf0: 6170 7065 6e64 2863 290a 2020 2020 2020  append(c).      
-00000d00: 2020 2020 2020 2020 2020 6966 206c 656e            if len
-00000d10: 2873 2e73 706c 6974 6c69 6e65 7328 2929  (s.splitlines())
-00000d20: 203d 3d20 323a 0a20 2020 2020 2020 2020   == 2:.         
-00000d30: 2020 2020 2020 2020 2020 2070 7974 686f             pytho
-00000d40: 6e5f 6e65 776c 696e 6573 5f77 6974 686f  n_newlines_witho
-00000d50: 7574 5f64 6f73 2e61 7070 656e 6428 6329  ut_dos.append(c)
-00000d60: 0a0a 2020 2020 2020 2020 7365 6c66 2e61  ..        self.a
-00000d70: 7373 6572 7445 7175 616c 2873 6574 2862  ssertEqual(set(b
-00000d80: 6967 2e77 6869 7465 7370 6163 655f 7769  ig.whitespace_wi
-00000d90: 7468 6f75 745f 646f 7329 2c20 7365 7428  thout_dos), set(
-00000da0: 7079 7468 6f6e 5f77 6869 7465 7370 6163  python_whitespac
-00000db0: 655f 7769 7468 6f75 745f 646f 7329 290a  e_without_dos)).
-00000dc0: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
-00000dd0: 6572 7445 7175 616c 2873 6574 2862 6967  ertEqual(set(big
-00000de0: 2e6e 6577 6c69 6e65 735f 7769 7468 6f75  .newlines_withou
-00000df0: 745f 646f 7329 2c20 7365 7428 7079 7468  t_dos), set(pyth
-00000e00: 6f6e 5f6e 6577 6c69 6e65 735f 7769 7468  on_newlines_with
-00000e10: 6f75 745f 646f 7329 290a 0a20 2020 2020  out_dos))..     
-00000e20: 2020 2070 7974 686f 6e5f 7768 6974 6573     python_whites
-00000e30: 7061 6365 203d 206c 6973 7428 7079 7468  pace = list(pyth
-00000e40: 6f6e 5f77 6869 7465 7370 6163 655f 7769  on_whitespace_wi
-00000e50: 7468 6f75 745f 646f 7329 0a20 2020 2020  thout_dos).     
-00000e60: 2020 2070 7974 686f 6e5f 7768 6974 6573     python_whites
-00000e70: 7061 6365 2e61 7070 656e 6428 225c 725c  pace.append("\r\
-00000e80: 6e22 290a 2020 2020 2020 2020 7079 7468  n").        pyth
-00000e90: 6f6e 5f6e 6577 6c69 6e65 7320 3d20 6c69  on_newlines = li
-00000ea0: 7374 2870 7974 686f 6e5f 6e65 776c 696e  st(python_newlin
-00000eb0: 6573 5f77 6974 686f 7574 5f64 6f73 290a  es_without_dos).
-00000ec0: 2020 2020 2020 2020 7079 7468 6f6e 5f6e          python_n
-00000ed0: 6577 6c69 6e65 732e 6170 7065 6e64 2822  ewlines.append("
-00000ee0: 5c72 5c6e 2229 0a20 2020 2020 2020 2073  \r\n").        s
-00000ef0: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
-00000f00: 7365 7428 6269 672e 7768 6974 6573 7061  set(big.whitespa
-00000f10: 6365 292c 2073 6574 2870 7974 686f 6e5f  ce), set(python_
-00000f20: 7768 6974 6573 7061 6365 2929 0a20 2020  whitespace)).   
-00000f30: 2020 2020 2073 656c 662e 6173 7365 7274       self.assert
-00000f40: 4571 7561 6c28 7365 7428 6269 672e 6e65  Equal(set(big.ne
-00000f50: 776c 696e 6573 292c 2073 6574 2870 7974  wlines), set(pyt
-00000f60: 686f 6e5f 6e65 776c 696e 6573 2929 0a0a  hon_newlines))..
-00000f70: 2020 2020 2020 2020 2320 6e6f 7720 7465          # now te
-00000f80: 7374 2074 6865 2075 7466 2d38 2061 6e64  st the utf-8 and
-00000f90: 2061 7363 6969 2076 6172 6961 6e74 7321   ascii variants!
-00000fa0: 0a0a 2020 2020 2020 2020 7079 7468 6f6e  ..        python
-00000fb0: 5f61 7363 6969 5f77 6869 7465 7370 6163  _ascii_whitespac
-00000fc0: 6520 3d20 6269 672e 7465 7874 2e5f 6368  e = big.text._ch
-00000fd0: 6561 705f 656e 636f 6465 5f69 7465 7261  eap_encode_itera
-00000fe0: 626c 655f 6f66 5f73 7472 696e 6773 2870  ble_of_strings(p
-00000ff0: 7974 686f 6e5f 7768 6974 6573 7061 6365  ython_whitespace
-00001000: 2c20 2761 7363 6969 2729 0a20 2020 2020  , 'ascii').     
-00001010: 2020 2073 656c 662e 6173 7365 7274 4571     self.assertEq
-00001020: 7561 6c28 7365 7428 6269 672e 6173 6369  ual(set(big.asci
-00001030: 695f 7768 6974 6573 7061 6365 292c 2073  i_whitespace), s
-00001040: 6574 2870 7974 686f 6e5f 6173 6369 695f  et(python_ascii_
-00001050: 7768 6974 6573 7061 6365 2929 0a20 2020  whitespace)).   
-00001060: 2020 2020 2070 7974 686f 6e5f 6173 6369       python_asci
-00001070: 695f 7768 6974 6573 7061 6365 5f77 6974  i_whitespace_wit
-00001080: 686f 7574 5f64 6f73 203d 2062 6967 2e74  hout_dos = big.t
-00001090: 6578 742e 5f63 6865 6170 5f65 6e63 6f64  ext._cheap_encod
-000010a0: 655f 6974 6572 6162 6c65 5f6f 665f 7374  e_iterable_of_st
-000010b0: 7269 6e67 7328 7079 7468 6f6e 5f77 6869  rings(python_whi
-000010c0: 7465 7370 6163 655f 7769 7468 6f75 745f  tespace_without_
-000010d0: 646f 732c 2027 6173 6369 6927 290a 2020  dos, 'ascii').  
-000010e0: 2020 2020 2020 7365 6c66 2e61 7373 6572        self.asser
-000010f0: 7445 7175 616c 2873 6574 2862 6967 2e61  tEqual(set(big.a
-00001100: 7363 6969 5f77 6869 7465 7370 6163 655f  scii_whitespace_
-00001110: 7769 7468 6f75 745f 646f 7329 2c20 7365  without_dos), se
-00001120: 7428 7079 7468 6f6e 5f61 7363 6969 5f77  t(python_ascii_w
-00001130: 6869 7465 7370 6163 655f 7769 7468 6f75  hitespace_withou
-00001140: 745f 646f 7329 290a 2020 2020 2020 2020  t_dos)).        
-00001150: 7079 7468 6f6e 5f61 7363 6969 5f6e 6577  python_ascii_new
-00001160: 6c69 6e65 7320 3d20 6269 672e 7465 7874  lines = big.text
-00001170: 2e5f 6368 6561 705f 656e 636f 6465 5f69  ._cheap_encode_i
-00001180: 7465 7261 626c 655f 6f66 5f73 7472 696e  terable_of_strin
-00001190: 6773 2870 7974 686f 6e5f 6e65 776c 696e  gs(python_newlin
-000011a0: 6573 2c20 2761 7363 6969 2729 0a20 2020  es, 'ascii').   
-000011b0: 2020 2020 2073 656c 662e 6173 7365 7274       self.assert
-000011c0: 4571 7561 6c28 7365 7428 6269 672e 6173  Equal(set(big.as
-000011d0: 6369 695f 6e65 776c 696e 6573 292c 2073  cii_newlines), s
-000011e0: 6574 2870 7974 686f 6e5f 6173 6369 695f  et(python_ascii_
-000011f0: 6e65 776c 696e 6573 2929 0a20 2020 2020  newlines)).     
-00001200: 2020 2070 7974 686f 6e5f 6173 6369 695f     python_ascii_
-00001210: 6e65 776c 696e 6573 5f77 6974 686f 7574  newlines_without
-00001220: 5f64 6f73 203d 2062 6967 2e74 6578 742e  _dos = big.text.
-00001230: 5f63 6865 6170 5f65 6e63 6f64 655f 6974  _cheap_encode_it
-00001240: 6572 6162 6c65 5f6f 665f 7374 7269 6e67  erable_of_string
-00001250: 7328 7079 7468 6f6e 5f6e 6577 6c69 6e65  s(python_newline
-00001260: 735f 7769 7468 6f75 745f 646f 732c 2027  s_without_dos, '
-00001270: 6173 6369 6927 290a 2020 2020 2020 2020  ascii').        
-00001280: 7365 6c66 2e61 7373 6572 7445 7175 616c  self.assertEqual
-00001290: 2873 6574 2862 6967 2e61 7363 6969 5f6e  (set(big.ascii_n
-000012a0: 6577 6c69 6e65 735f 7769 7468 6f75 745f  ewlines_without_
-000012b0: 646f 7329 2c20 7365 7428 7079 7468 6f6e  dos), set(python
-000012c0: 5f61 7363 6969 5f6e 6577 6c69 6e65 735f  _ascii_newlines_
-000012d0: 7769 7468 6f75 745f 646f 7329 290a 0a20  without_dos)).. 
-000012e0: 2020 2020 2020 2070 7974 686f 6e5f 7574         python_ut
-000012f0: 6638 5f77 6869 7465 7370 6163 6520 3d20  f8_whitespace = 
-00001300: 6269 672e 7465 7874 2e5f 6368 6561 705f  big.text._cheap_
-00001310: 656e 636f 6465 5f69 7465 7261 626c 655f  encode_iterable_
-00001320: 6f66 5f73 7472 696e 6773 2870 7974 686f  of_strings(pytho
-00001330: 6e5f 7768 6974 6573 7061 6365 2c20 2775  n_whitespace, 'u
-00001340: 7466 3827 290a 2020 2020 2020 2020 7365  tf8').        se
-00001350: 6c66 2e61 7373 6572 7445 7175 616c 2873  lf.assertEqual(s
-00001360: 6574 2862 6967 2e75 7466 385f 7768 6974  et(big.utf8_whit
-00001370: 6573 7061 6365 292c 2073 6574 2870 7974  espace), set(pyt
-00001380: 686f 6e5f 7574 6638 5f77 6869 7465 7370  hon_utf8_whitesp
-00001390: 6163 6529 290a 2020 2020 2020 2020 7079  ace)).        py
-000013a0: 7468 6f6e 5f75 7466 385f 7768 6974 6573  thon_utf8_whites
-000013b0: 7061 6365 5f77 6974 686f 7574 5f64 6f73  pace_without_dos
-000013c0: 203d 2062 6967 2e74 6578 742e 5f63 6865   = big.text._che
-000013d0: 6170 5f65 6e63 6f64 655f 6974 6572 6162  ap_encode_iterab
-000013e0: 6c65 5f6f 665f 7374 7269 6e67 7328 7079  le_of_strings(py
-000013f0: 7468 6f6e 5f77 6869 7465 7370 6163 655f  thon_whitespace_
-00001400: 7769 7468 6f75 745f 646f 732c 2027 7574  without_dos, 'ut
-00001410: 6638 2729 0a20 2020 2020 2020 2073 656c  f8').        sel
-00001420: 662e 6173 7365 7274 4571 7561 6c28 7365  f.assertEqual(se
-00001430: 7428 6269 672e 7574 6638 5f77 6869 7465  t(big.utf8_white
-00001440: 7370 6163 655f 7769 7468 6f75 745f 646f  space_without_do
-00001450: 7329 2c20 7365 7428 7079 7468 6f6e 5f75  s), set(python_u
-00001460: 7466 385f 7768 6974 6573 7061 6365 5f77  tf8_whitespace_w
-00001470: 6974 686f 7574 5f64 6f73 2929 0a20 2020  ithout_dos)).   
-00001480: 2020 2020 2070 7974 686f 6e5f 7574 6638       python_utf8
-00001490: 5f6e 6577 6c69 6e65 7320 3d20 6269 672e  _newlines = big.
-000014a0: 7465 7874 2e5f 6368 6561 705f 656e 636f  text._cheap_enco
-000014b0: 6465 5f69 7465 7261 626c 655f 6f66 5f73  de_iterable_of_s
-000014c0: 7472 696e 6773 2870 7974 686f 6e5f 6e65  trings(python_ne
-000014d0: 776c 696e 6573 2c20 2775 7466 3827 290a  wlines, 'utf8').
-000014e0: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
-000014f0: 6572 7445 7175 616c 2873 6574 2862 6967  ertEqual(set(big
-00001500: 2e75 7466 385f 6e65 776c 696e 6573 292c  .utf8_newlines),
-00001510: 2073 6574 2870 7974 686f 6e5f 7574 6638   set(python_utf8
-00001520: 5f6e 6577 6c69 6e65 7329 290a 2020 2020  _newlines)).    
-00001530: 2020 2020 7079 7468 6f6e 5f75 7466 385f      python_utf8_
-00001540: 6e65 776c 696e 6573 5f77 6974 686f 7574  newlines_without
-00001550: 5f64 6f73 203d 2062 6967 2e74 6578 742e  _dos = big.text.
-00001560: 5f63 6865 6170 5f65 6e63 6f64 655f 6974  _cheap_encode_it
-00001570: 6572 6162 6c65 5f6f 665f 7374 7269 6e67  erable_of_string
-00001580: 7328 7079 7468 6f6e 5f6e 6577 6c69 6e65  s(python_newline
-00001590: 735f 7769 7468 6f75 745f 646f 732c 2027  s_without_dos, '
-000015a0: 7574 6638 2729 0a20 2020 2020 2020 2073  utf8').        s
-000015b0: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
-000015c0: 7365 7428 6269 672e 7574 6638 5f6e 6577  set(big.utf8_new
-000015d0: 6c69 6e65 735f 7769 7468 6f75 745f 646f  lines_without_do
-000015e0: 7329 2c20 7365 7428 7079 7468 6f6e 5f75  s), set(python_u
-000015f0: 7466 385f 6e65 776c 696e 6573 5f77 6974  tf8_newlines_wit
-00001600: 686f 7574 5f64 6f73 2929 0a0a 2020 2020  hout_dos))..    
-00001610: 2020 2020 2320 6e6f 7720 7465 7374 2074      # now test t
-00001620: 6865 2063 6163 6865 6420 7265 7665 7273  he cached revers
-00001630: 6564 2062 7569 6c74 696e 2073 6570 6172  ed builtin separ
-00001640: 6174 6f72 7321 0a20 2020 2020 2020 2066  ators!.        f
-00001650: 6f72 2066 6f72 7761 7264 732c 2062 6163  or forwards, bac
-00001660: 6b77 6172 6473 2069 6e20 6269 672e 7465  kwards in big.te
-00001670: 7874 2e5f 7265 7665 7273 6564 5f62 7569  xt._reversed_bui
-00001680: 6c74 696e 5f73 6570 6172 6174 6f72 732e  ltin_separators.
-00001690: 6974 656d 7328 293a 0a20 2020 2020 2020  items():.       
-000016a0: 2020 2020 2073 656c 662e 6173 7365 7274       self.assert
-000016b0: 4571 7561 6c28 7365 7428 6261 636b 7761  Equal(set(backwa
-000016c0: 7264 7329 2c20 7365 7428 6269 672e 7465  rds), set(big.te
-000016d0: 7874 2e5f 6d75 6c74 6973 706c 6974 5f72  xt._multisplit_r
-000016e0: 6576 6572 7365 6428 666f 7277 6172 6473  eversed(forwards
-000016f0: 2929 2c20 6622 6661 696c 6564 206f 6e20  )), f"failed on 
-00001700: 7b70 7269 6e74 6162 6c65 5f73 6570 6172  {printable_separ
-00001710: 6174 6f72 7328 666f 7277 6172 6473 297d  ators(forwards)}
-00001720: 2229 0a0a 2020 2020 6465 6620 7465 7374  ")..    def test
-00001730: 5f72 655f 7061 7274 6974 696f 6e28 7365  _re_partition(se
-00001740: 6c66 293a 0a20 2020 2020 2020 2064 6566  lf):.        def
-00001750: 2067 726f 7570 3028 7265 5f70 6172 7469   group0(re_parti
-00001760: 7469 6f6e 5f72 6573 756c 7429 3a0a 2020  tion_result):.  
-00001770: 2020 2020 2020 2020 2020 7265 7375 6c74            result
-00001780: 203d 205b 5d0a 2020 2020 2020 2020 2020   = [].          
-00001790: 2020 666f 7220 692c 206f 2069 6e20 656e    for i, o in en
-000017a0: 756d 6572 6174 6528 7265 5f70 6172 7469  umerate(re_parti
-000017b0: 7469 6f6e 5f72 6573 756c 7429 3a0a 2020  tion_result):.  
-000017c0: 2020 2020 2020 2020 2020 2020 2020 6966                if
-000017d0: 2028 6920 2520 3229 2061 6e64 2028 6f20   (i % 2) and (o 
-000017e0: 6973 206e 6f74 204e 6f6e 6529 3a0a 2020  is not None):.  
-000017f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001800: 2020 6f20 3d20 6f2e 6772 6f75 7028 3029    o = o.group(0)
-00001810: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00001820: 2072 6573 756c 742e 6170 7065 6e64 286f   result.append(o
-00001830: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
-00001840: 7475 726e 2074 7570 6c65 2872 6573 756c  turn tuple(resul
-00001850: 7429 0a0a 2020 2020 2020 2020 666f 7220  t)..        for 
-00001860: 6320 696e 2028 756e 6368 616e 6765 642c  c in (unchanged,
-00001870: 2074 6f5f 6279 7465 7329 3a0a 2020 2020   to_bytes):.    
-00001880: 2020 2020 2020 2020 7061 7474 6572 6e20          pattern 
-00001890: 3d20 6328 225b 302d 395d 2b22 290a 0a20  = c("[0-9]+").. 
-000018a0: 2020 2020 2020 2020 2020 2073 203d 2063             s = c
-000018b0: 2822 6162 6331 3233 6465 6634 3536 6768  ("abc123def456gh
-000018c0: 6922 290a 2020 2020 2020 2020 2020 2020  i").            
-000018d0: 7365 6c66 2e61 7373 6572 7445 7175 616c  self.assertEqual
-000018e0: 2867 726f 7570 3028 6269 672e 7265 5f70  (group0(big.re_p
-000018f0: 6172 7469 7469 6f6e 2873 2c20 7061 7474  artition(s, patt
-00001900: 6572 6e29 292c 0a20 2020 2020 2020 2020  ern)),.         
-00001910: 2020 2020 2020 2063 2828 2261 6263 222c         c(("abc",
-00001920: 2022 3132 3322 2c20 2264 6566 3435 3667   "123", "def456g
-00001930: 6869 2229 2920 290a 2020 2020 2020 2020  hi")) ).        
-00001940: 2020 2020 7365 6c66 2e61 7373 6572 7445      self.assertE
-00001950: 7175 616c 2867 726f 7570 3028 6269 672e  qual(group0(big.
-00001960: 7265 5f72 7061 7274 6974 696f 6e28 732c  re_rpartition(s,
-00001970: 2070 6174 7465 726e 2929 2c0a 2020 2020   pattern)),.    
-00001980: 2020 2020 2020 2020 2020 2020 6328 2822              c(("
-00001990: 6162 6331 3233 6465 6622 2c20 2234 3536  abc123def", "456
-000019a0: 222c 2022 6768 6922 2929 2029 0a20 2020  ", "ghi")) ).   
-000019b0: 2020 2020 2020 2020 2073 656c 662e 6173           self.as
-000019c0: 7365 7274 4571 7561 6c28 6772 6f75 7030  sertEqual(group0
-000019d0: 2862 6967 2e72 655f 7061 7274 6974 696f  (big.re_partitio
-000019e0: 6e28 732c 2070 6174 7465 726e 2c20 7265  n(s, pattern, re
-000019f0: 7665 7273 653d 5472 7565 2929 2c0a 2020  verse=True)),.  
-00001a00: 2020 2020 2020 2020 2020 2020 2020 6328                c(
-00001a10: 2822 6162 6331 3233 6465 6622 2c20 2234  ("abc123def", "4
-00001a20: 3536 222c 2022 6768 6922 2929 2029 0a0a  56", "ghi")) )..
-00001a30: 2020 2020 2020 2020 2020 2020 7320 3d20              s = 
-00001a40: 6328 2261 6263 3132 3334 3564 6566 3637  c("abc12345def67
-00001a50: 3839 3067 6869 2229 0a20 2020 2020 2020  890ghi").       
-00001a60: 2020 2020 2073 656c 662e 6173 7365 7274       self.assert
-00001a70: 4571 7561 6c28 6772 6f75 7030 2862 6967  Equal(group0(big
-00001a80: 2e72 655f 7061 7274 6974 696f 6e28 732c  .re_partition(s,
-00001a90: 2070 6174 7465 726e 2929 2c0a 2020 2020   pattern)),.    
-00001aa0: 2020 2020 2020 2020 2020 2020 6328 2822              c(("
-00001ab0: 6162 6322 2c20 2231 3233 3435 222c 2022  abc", "12345", "
-00001ac0: 6465 6636 3738 3930 6768 6922 2929 2029  def67890ghi")) )
-00001ad0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00001ae0: 662e 6173 7365 7274 4571 7561 6c28 6772  f.assertEqual(gr
-00001af0: 6f75 7030 2862 6967 2e72 655f 7270 6172  oup0(big.re_rpar
-00001b00: 7469 7469 6f6e 2873 2c20 7061 7474 6572  tition(s, patter
-00001b10: 6e29 292c 0a20 2020 2020 2020 2020 2020  n)),.           
-00001b20: 2020 2020 2063 2828 2261 6263 3132 3334       c(("abc1234
-00001b30: 3564 6566 222c 2022 3637 3839 3022 2c20  5def", "67890", 
-00001b40: 2267 6869 2229 2920 290a 0a20 2020 2020  "ghi")) )..     
-00001b50: 2020 2020 2020 2070 6174 7465 726e 203d         pattern =
-00001b60: 2072 652e 636f 6d70 696c 6528 7061 7474   re.compile(patt
-00001b70: 6572 6e29 0a20 2020 2020 2020 2020 2020  ern).           
-00001b80: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
-00001b90: 6c28 6772 6f75 7030 2862 6967 2e72 655f  l(group0(big.re_
-00001ba0: 7061 7274 6974 696f 6e28 732c 2070 6174  partition(s, pat
-00001bb0: 7465 726e 2929 2c0a 2020 2020 2020 2020  tern)),.        
-00001bc0: 2020 2020 2020 2020 6328 2822 6162 6322          c(("abc"
-00001bd0: 2c20 2231 3233 3435 222c 2022 6465 6636  , "12345", "def6
-00001be0: 3738 3930 6768 6922 2929 2029 0a20 2020  7890ghi")) ).   
-00001bf0: 2020 2020 2020 2020 2073 656c 662e 6173           self.as
-00001c00: 7365 7274 4571 7561 6c28 6772 6f75 7030  sertEqual(group0
-00001c10: 2862 6967 2e72 655f 7270 6172 7469 7469  (big.re_rpartiti
-00001c20: 6f6e 2873 2c20 7061 7474 6572 6e29 292c  on(s, pattern)),
-00001c30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00001c40: 2063 2828 2261 6263 3132 3334 3564 6566   c(("abc12345def
-00001c50: 222c 2022 3637 3839 3022 2c20 2267 6869  ", "67890", "ghi
-00001c60: 2229 2920 290a 0a20 2020 2020 2020 2020  ")) )..         
-00001c70: 2020 2070 6174 7465 726e 203d 2063 2822     pattern = c("
-00001c80: 6661 2b72 6b22 290a 2020 2020 2020 2020  fa+rk").        
-00001c90: 2020 2020 7365 6c66 2e61 7373 6572 7445      self.assertE
-00001ca0: 7175 616c 2867 726f 7570 3028 6269 672e  qual(group0(big.
-00001cb0: 7265 5f70 6172 7469 7469 6f6e 2873 2c20  re_partition(s, 
-00001cc0: 7061 7474 6572 6e29 292c 0a20 2020 2020  pattern)),.     
-00001cd0: 2020 2020 2020 2020 2020 2063 2828 2261             c(("a
-00001ce0: 6263 3132 3334 3564 6566 3637 3839 3067  bc12345def67890g
-00001cf0: 6869 222c 204e 6f6e 652c 2022 2229 2920  hi", None, "")) 
-00001d00: 290a 2020 2020 2020 2020 2020 2020 7365  ).            se
-00001d10: 6c66 2e61 7373 6572 7445 7175 616c 2867  lf.assertEqual(g
-00001d20: 726f 7570 3028 6269 672e 7265 5f72 7061  roup0(big.re_rpa
-00001d30: 7274 6974 696f 6e28 732c 2070 6174 7465  rtition(s, patte
-00001d40: 726e 2929 2c0a 2020 2020 2020 2020 2020  rn)),.          
-00001d50: 2020 2020 2020 6328 2822 222c 204e 6f6e        c(("", Non
-00001d60: 652c 2022 6162 6331 3233 3435 6465 6636  e, "abc12345def6
-00001d70: 3738 3930 6768 6922 2929 2029 0a0a 2020  7890ghi")) )..  
-00001d80: 2020 2020 2020 2020 2020 2320 7465 7374            # test
-00001d90: 206f 7665 726c 6170 7069 6e67 206d 6174   overlapping mat
-00001da0: 6368 6573 0a20 2020 2020 2020 2020 2020  ches.           
-00001db0: 2070 6174 7465 726e 203d 2063 2822 7468   pattern = c("th
-00001dc0: 6973 414e 4474 6869 7322 290a 2020 2020  isANDthis").    
-00001dd0: 2020 2020 2020 2020 7320 3d20 6328 2274          s = c("t
-00001de0: 6869 7341 4e44 7468 6973 414e 4474 6869  hisANDthisANDthi
-00001df0: 7322 290a 2020 2020 2020 2020 2020 2020  s").            
-00001e00: 7365 6c66 2e61 7373 6572 7445 7175 616c  self.assertEqual
-00001e10: 2867 726f 7570 3028 6269 672e 7265 5f70  (group0(big.re_p
-00001e20: 6172 7469 7469 6f6e 2873 2c20 7061 7474  artition(s, patt
-00001e30: 6572 6e29 292c 0a20 2020 2020 2020 2020  ern)),.         
-00001e40: 2020 2020 2020 2063 2828 2222 2c20 2274         c(("", "t
-00001e50: 6869 7341 4e44 7468 6973 222c 2022 414e  hisANDthis", "AN
-00001e60: 4474 6869 7322 2929 2029 0a20 2020 2020  Dthis")) ).     
-00001e70: 2020 2020 2020 2073 656c 662e 6173 7365         self.asse
-00001e80: 7274 4571 7561 6c28 6772 6f75 7030 2862  rtEqual(group0(b
-00001e90: 6967 2e72 655f 7270 6172 7469 7469 6f6e  ig.re_rpartition
-00001ea0: 2873 2c20 7061 7474 6572 6e29 292c 0a20  (s, pattern)),. 
-00001eb0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00001ec0: 2828 2274 6869 7341 4e44 222c 2022 7468  (("thisAND", "th
-00001ed0: 6973 414e 4474 6869 7322 2c20 2222 2929  isANDthis", ""))
-00001ee0: 2029 0a0a 2020 2020 2020 2020 2020 2020   )..            
-00001ef0: 666f 7220 666e 2069 6e20 2862 6967 2e72  for fn in (big.r
-00001f00: 655f 7061 7274 6974 696f 6e2c 2062 6967  e_partition, big
-00001f10: 2e72 655f 7270 6172 7469 7469 6f6e 293a  .re_rpartition):
-00001f20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00001f30: 2073 203d 2063 2822 4c65 7427 7320 6669   s = c("Let's fi
-00001f40: 6e64 2074 6865 206e 756d 6265 7220 3839  nd the number 89
-00001f50: 2069 6e20 7468 6973 2073 7472 696e 6722   in this string"
-00001f60: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00001f70: 2020 7061 7474 6572 6e20 3d20 6328 7222    pattern = c(r"
-00001f80: 6e75 6d62 6572 2028 5b30 2d39 5d2b 2922  number ([0-9]+)"
-00001f90: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00001fa0: 2020 7265 7375 6c74 203d 2066 6e28 732c    result = fn(s,
-00001fb0: 2070 6174 7465 726e 290a 2020 2020 2020   pattern).      
-00001fc0: 2020 2020 2020 2020 2020 2320 7072 696e            # prin
-00001fd0: 7428 7265 7375 6c74 290a 2020 2020 2020  t(result).      
-00001fe0: 2020 2020 2020 2020 2020 2320 7072 696e            # prin
-00001ff0: 7428 6772 6f75 7030 2872 6573 756c 7429  t(group0(result)
-00002000: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00002010: 2020 7365 6c66 2e61 7373 6572 7445 7175    self.assertEqu
-00002020: 616c 2867 726f 7570 3028 7265 7375 6c74  al(group0(result
-00002030: 292c 2063 2828 224c 6574 2773 2066 696e  ), c(("Let's fin
-00002040: 6420 7468 6520 222c 2022 6e75 6d62 6572  d the ", "number
-00002050: 2038 3922 2c20 2220 696e 2074 6869 7320   89", " in this 
-00002060: 7374 7269 6e67 2229 2929 0a20 2020 2020  string"))).     
-00002070: 2020 2020 2020 2020 2020 206d 6174 6368             match
-00002080: 203d 2072 6573 756c 745b 315d 0a20 2020   = result[1].   
-00002090: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-000020a0: 662e 6173 7365 7274 4571 7561 6c28 6d61  f.assertEqual(ma
-000020b0: 7463 682e 6772 6f75 7028 3029 2c20 6328  tch.group(0), c(
-000020c0: 226e 756d 6265 7220 3839 2229 290a 2020  "number 89")).  
-000020d0: 2020 2020 2020 2020 2020 2020 2020 7365                se
-000020e0: 6c66 2e61 7373 6572 7445 7175 616c 286d  lf.assertEqual(m
-000020f0: 6174 6368 2e67 726f 7570 2831 292c 2063  atch.group(1), c
-00002100: 2822 3839 2229 290a 0a20 2020 2020 2020  ("89"))..       
-00002110: 2020 2020 2064 6566 2074 6573 745f 7265       def test_re
-00002120: 5f70 6172 7469 7469 6f6e 2873 2c20 7061  _partition(s, pa
-00002130: 7474 6572 6e2c 2063 6f75 6e74 2c20 6578  ttern, count, ex
-00002140: 7065 6374 6564 293a 0a20 2020 2020 2020  pected):.       
-00002150: 2020 2020 2020 2020 2073 656c 662e 6173           self.as
-00002160: 7365 7274 4571 7561 6c28 6772 6f75 7030  sertEqual(group0
-00002170: 2862 6967 2e72 655f 7061 7274 6974 696f  (big.re_partitio
-00002180: 6e28 732c 2070 6174 7465 726e 2c20 636f  n(s, pattern, co
-00002190: 756e 7429 292c 0a20 2020 2020 2020 2020  unt)),.         
-000021a0: 2020 2020 2020 2020 2020 2065 7870 6563             expec
-000021b0: 7465 6420 290a 0a20 2020 2020 2020 2020  ted )..         
-000021c0: 2020 2074 6573 745f 7265 5f70 6172 7469     test_re_parti
-000021d0: 7469 6f6e 2822 613a 623a 633a 6422 2c20  tion("a:b:c:d", 
-000021e0: 223a 222c 2030 2c20 2822 613a 623a 633a  ":", 0, ("a:b:c:
-000021f0: 6422 2c29 290a 2020 2020 2020 2020 2020  d",)).          
-00002200: 2020 7465 7374 5f72 655f 7061 7274 6974    test_re_partit
-00002210: 696f 6e28 2261 3a62 3a63 3a64 222c 2022  ion("a:b:c:d", "
-00002220: 3a22 2c20 312c 2028 2261 222c 2022 3a22  :", 1, ("a", ":"
-00002230: 2c20 2262 3a63 3a64 2229 290a 2020 2020  , "b:c:d")).    
-00002240: 2020 2020 2020 2020 7465 7374 5f72 655f          test_re_
-00002250: 7061 7274 6974 696f 6e28 2261 3a62 3a63  partition("a:b:c
-00002260: 3a64 222c 2022 3a22 2c20 322c 2028 2261  :d", ":", 2, ("a
-00002270: 222c 2022 3a22 2c20 2262 222c 2022 3a22  ", ":", "b", ":"
-00002280: 2c20 2263 3a64 2229 290a 2020 2020 2020  , "c:d")).      
-00002290: 2020 2020 2020 7465 7374 5f72 655f 7061        test_re_pa
-000022a0: 7274 6974 696f 6e28 2261 3a62 3a63 3a64  rtition("a:b:c:d
-000022b0: 222c 2022 3a22 2c20 332c 2028 2261 222c  ", ":", 3, ("a",
-000022c0: 2022 3a22 2c20 2262 222c 2022 3a22 2c20   ":", "b", ":", 
-000022d0: 2263 222c 2022 3a22 2c20 2264 2229 290a  "c", ":", "d")).
-000022e0: 2020 2020 2020 2020 2020 2020 7465 7374              test
-000022f0: 5f72 655f 7061 7274 6974 696f 6e28 2261  _re_partition("a
-00002300: 3a62 3a63 3a64 222c 2022 3a22 2c20 342c  :b:c:d", ":", 4,
-00002310: 2028 2261 222c 2022 3a22 2c20 2262 222c   ("a", ":", "b",
-00002320: 2022 3a22 2c20 2263 222c 2022 3a22 2c20   ":", "c", ":", 
-00002330: 2264 222c 204e 6f6e 652c 2027 2729 290a  "d", None, '')).
-00002340: 2020 2020 2020 2020 2020 2020 7465 7374              test
-00002350: 5f72 655f 7061 7274 6974 696f 6e28 2261  _re_partition("a
-00002360: 3a62 3a63 3a64 222c 2022 3a22 2c20 352c  :b:c:d", ":", 5,
-00002370: 2028 2261 222c 2022 3a22 2c20 2262 222c   ("a", ":", "b",
-00002380: 2022 3a22 2c20 2263 222c 2022 3a22 2c20   ":", "c", ":", 
-00002390: 2264 222c 204e 6f6e 652c 2027 272c 204e  "d", None, '', N
-000023a0: 6f6e 652c 2027 2729 290a 0a20 2020 2020  one, ''))..     
-000023b0: 2020 2020 2020 2064 6566 2074 6573 745f         def test_
-000023c0: 7265 5f72 7061 7274 6974 696f 6e28 732c  re_rpartition(s,
-000023d0: 2070 6174 7465 726e 2c20 636f 756e 742c   pattern, count,
-000023e0: 2065 7870 6563 7465 6429 3a0a 2020 2020   expected):.    
-000023f0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00002400: 2e61 7373 6572 7445 7175 616c 2867 726f  .assertEqual(gro
-00002410: 7570 3028 6269 672e 7265 5f72 7061 7274  up0(big.re_rpart
-00002420: 6974 696f 6e28 732c 2070 6174 7465 726e  ition(s, pattern
-00002430: 2c20 636f 756e 7429 292c 0a20 2020 2020  , count)),.     
-00002440: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-00002450: 7870 6563 7465 6420 290a 2020 2020 2020  xpected ).      
-00002460: 2020 2020 2020 2020 2020 7365 6c66 2e61            self.a
-00002470: 7373 6572 7445 7175 616c 2867 726f 7570  ssertEqual(group
-00002480: 3028 6269 672e 7265 5f70 6172 7469 7469  0(big.re_partiti
-00002490: 6f6e 2873 2c20 7061 7474 6572 6e2c 2063  on(s, pattern, c
-000024a0: 6f75 6e74 2c20 7265 7665 7273 653d 5472  ount, reverse=Tr
-000024b0: 7565 2929 2c0a 2020 2020 2020 2020 2020  ue)),.          
-000024c0: 2020 2020 2020 2020 2020 6578 7065 6374            expect
-000024d0: 6564 2029 0a0a 2020 2020 2020 2020 2020  ed )..          
-000024e0: 2020 7465 7374 5f72 655f 7270 6172 7469    test_re_rparti
-000024f0: 7469 6f6e 2822 613a 623a 633a 6422 2c20  tion("a:b:c:d", 
-00002500: 223a 222c 2030 2c20 2822 613a 623a 633a  ":", 0, ("a:b:c:
-00002510: 6422 2c29 290a 2020 2020 2020 2020 2020  d",)).          
-00002520: 2020 7465 7374 5f72 655f 7270 6172 7469    test_re_rparti
-00002530: 7469 6f6e 2822 613a 623a 633a 6422 2c20  tion("a:b:c:d", 
-00002540: 223a 222c 2031 2c20 2822 613a 623a 6322  ":", 1, ("a:b:c"
-00002550: 2c20 273a 2720 2c22 6422 2929 0a20 2020  , ':' ,"d")).   
-00002560: 2020 2020 2020 2020 2074 6573 745f 7265           test_re
-00002570: 5f72 7061 7274 6974 696f 6e28 2261 3a62  _rpartition("a:b
-00002580: 3a63 3a64 222c 2022 3a22 2c20 322c 2028  :c:d", ":", 2, (
-00002590: 2261 3a62 222c 2022 3a22 2c20 2263 222c  "a:b", ":", "c",
-000025a0: 2027 3a27 202c 2264 2229 290a 2020 2020   ':' ,"d")).    
-000025b0: 2020 2020 2020 2020 7465 7374 5f72 655f          test_re_
-000025c0: 7270 6172 7469 7469 6f6e 2822 613a 623a  rpartition("a:b:
-000025d0: 633a 6422 2c20 223a 222c 2033 2c20 2822  c:d", ":", 3, ("
-000025e0: 6122 2c20 223a 222c 2022 6222 2c20 223a  a", ":", "b", ":
-000025f0: 222c 2022 6322 2c20 273a 2720 2c22 6422  ", "c", ':' ,"d"
-00002600: 2929 0a20 2020 2020 2020 2020 2020 2074  )).            t
-00002610: 6573 745f 7265 5f72 7061 7274 6974 696f  est_re_rpartitio
-00002620: 6e28 2261 3a62 3a63 3a64 222c 2022 3a22  n("a:b:c:d", ":"
-00002630: 2c20 342c 2028 2222 2c20 4e6f 6e65 2c20  , 4, ("", None, 
-00002640: 2261 222c 2022 3a22 2c20 2262 222c 2022  "a", ":", "b", "
-00002650: 3a22 2c20 2263 222c 2027 3a27 202c 2264  :", "c", ':' ,"d
-00002660: 2229 290a 2020 2020 2020 2020 2020 2020  ")).            
-00002670: 7465 7374 5f72 655f 7270 6172 7469 7469  test_re_rpartiti
-00002680: 6f6e 2822 613a 623a 633a 6422 2c20 223a  on("a:b:c:d", ":
-00002690: 222c 2035 2c20 2822 222c 204e 6f6e 652c  ", 5, ("", None,
-000026a0: 2022 222c 204e 6f6e 652c 2022 6122 2c20   "", None, "a", 
-000026b0: 223a 222c 2022 6222 2c20 223a 222c 2022  ":", "b", ":", "
-000026c0: 6322 2c20 273a 2720 2c22 6422 2929 0a0a  c", ':' ,"d"))..
-000026d0: 2020 2020 2020 2020 7320 3d20 2261 6263          s = "abc
-000026e0: 3132 3364 6566 3435 3667 6869 220a 2020  123def456ghi".  
-000026f0: 2020 2020 2020 7061 7474 6572 6e20 3d20        pattern = 
-00002700: 6222 5b30 2d39 5d2b 220a 2020 2020 2020  b"[0-9]+".      
-00002710: 2020 7769 7468 2073 656c 662e 6173 7365    with self.asse
-00002720: 7274 5261 6973 6573 2856 616c 7565 4572  rtRaises(ValueEr
-00002730: 726f 7229 3a0a 2020 2020 2020 2020 2020  ror):.          
-00002740: 2020 6269 672e 7265 5f70 6172 7469 7469    big.re_partiti
-00002750: 6f6e 2873 2c20 7061 7474 6572 6e29 0a20  on(s, pattern). 
-00002760: 2020 2020 2020 2077 6974 6820 7365 6c66         with self
-00002770: 2e61 7373 6572 7452 6169 7365 7328 5661  .assertRaises(Va
-00002780: 6c75 6545 7272 6f72 293a 0a20 2020 2020  lueError):.     
-00002790: 2020 2020 2020 2062 6967 2e72 655f 7270         big.re_rp
-000027a0: 6172 7469 7469 6f6e 2873 2c20 7061 7474  artition(s, patt
-000027b0: 6572 6e29 0a20 2020 2020 2020 2070 6174  ern).        pat
-000027c0: 7465 726e 203d 2072 652e 636f 6d70 696c  tern = re.compil
-000027d0: 6528 7061 7474 6572 6e29 0a20 2020 2020  e(pattern).     
-000027e0: 2020 2077 6974 6820 7365 6c66 2e61 7373     with self.ass
-000027f0: 6572 7452 6169 7365 7328 5661 6c75 6545  ertRaises(ValueE
-00002800: 7272 6f72 293a 0a20 2020 2020 2020 2020  rror):.         
-00002810: 2020 2062 6967 2e72 655f 7061 7274 6974     big.re_partit
-00002820: 696f 6e28 732c 2070 6174 7465 726e 290a  ion(s, pattern).
-00002830: 2020 2020 2020 2020 7769 7468 2073 656c          with sel
-00002840: 662e 6173 7365 7274 5261 6973 6573 2856  f.assertRaises(V
-00002850: 616c 7565 4572 726f 7229 3a0a 2020 2020  alueError):.    
-00002860: 2020 2020 2020 2020 6269 672e 7265 5f72          big.re_r
-00002870: 7061 7274 6974 696f 6e28 732c 2070 6174  partition(s, pat
-00002880: 7465 726e 290a 0a20 2020 2020 2020 2077  tern)..        w
-00002890: 6974 6820 7365 6c66 2e61 7373 6572 7452  ith self.assertR
-000028a0: 6169 7365 7328 5661 6c75 6545 7272 6f72  aises(ValueError
-000028b0: 293a 0a20 2020 2020 2020 2020 2020 2062  ):.            b
-000028c0: 6967 2e72 655f 7061 7274 6974 696f 6e28  ig.re_partition(
-000028d0: 2761 3a62 272c 2027 3a27 2c20 2d31 290a  'a:b', ':', -1).
-000028e0: 2020 2020 2020 2020 7769 7468 2073 656c          with sel
-000028f0: 662e 6173 7365 7274 5261 6973 6573 2856  f.assertRaises(V
-00002900: 616c 7565 4572 726f 7229 3a0a 2020 2020  alueError):.    
-00002910: 2020 2020 2020 2020 6269 672e 7265 5f70          big.re_p
-00002920: 6172 7469 7469 6f6e 2862 2761 3a62 272c  artition(b'a:b',
-00002930: 2062 273a 272c 202d 3129 0a20 2020 2020   b':', -1).     
-00002940: 2020 2077 6974 6820 7365 6c66 2e61 7373     with self.ass
-00002950: 6572 7452 6169 7365 7328 5661 6c75 6545  ertRaises(ValueE
-00002960: 7272 6f72 293a 0a20 2020 2020 2020 2020  rror):.         
-00002970: 2020 2062 6967 2e72 655f 7270 6172 7469     big.re_rparti
-00002980: 7469 6f6e 2827 613a 6227 2c20 273a 272c  tion('a:b', ':',
-00002990: 202d 3129 0a20 2020 2020 2020 2077 6974   -1).        wit
-000029a0: 6820 7365 6c66 2e61 7373 6572 7452 6169  h self.assertRai
-000029b0: 7365 7328 5661 6c75 6545 7272 6f72 293a  ses(ValueError):
-000029c0: 0a20 2020 2020 2020 2020 2020 2062 6967  .            big
-000029d0: 2e72 655f 7270 6172 7469 7469 6f6e 2862  .re_rpartition(b
-000029e0: 2761 3a62 272c 2062 273a 272c 202d 3129  'a:b', b':', -1)
-000029f0: 0a0a 2020 2020 6465 6620 7465 7374 5f6d  ..    def test_m
-00002a00: 756c 7469 7374 7269 7028 7365 6c66 293a  ultistrip(self):
-00002a10: 0a20 2020 2020 2020 2064 6566 2074 6573  .        def tes
-00002a20: 745f 6d75 6c74 6973 7472 6970 286c 6566  t_multistrip(lef
-00002a30: 742c 2073 2c20 7269 6768 742c 2073 6570  t, s, right, sep
-00002a40: 6172 6174 6f72 7329 3a0a 2020 2020 2020  arators):.      
-00002a50: 2020 2020 2020 666f 7220 5f20 696e 2072        for _ in r
-00002a60: 616e 6765 2832 293a 0a20 2020 2020 2020  ange(2):.       
-00002a70: 2020 2020 2020 2020 2069 6620 5f20 3d3d           if _ ==
-00002a80: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
-00002a90: 2020 2020 2020 2020 6c65 6674 203d 206c          left = l
-00002aa0: 6566 742e 656e 636f 6465 2827 6173 6369  eft.encode('asci
-00002ab0: 6927 290a 2020 2020 2020 2020 2020 2020  i').            
-00002ac0: 2020 2020 2020 2020 7320 3d20 732e 656e          s = s.en
-00002ad0: 636f 6465 2827 6173 6369 6927 290a 2020  code('ascii').  
-00002ae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002af0: 2020 7269 6768 7420 3d20 7269 6768 742e    right = right.
-00002b00: 656e 636f 6465 2827 6173 6369 6927 290a  encode('ascii').
-00002b10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002b20: 2020 2020 6966 2073 6570 6172 6174 6f72      if separator
-00002b30: 7320 3d3d 2062 6967 2e77 6869 7465 7370  s == big.whitesp
-00002b40: 6163 653a 0a20 2020 2020 2020 2020 2020  ace:.           
-00002b50: 2020 2020 2020 2020 2020 2020 2073 6570               sep
-00002b60: 6172 6174 6f72 7320 3d20 6269 672e 6173  arators = big.as
-00002b70: 6369 695f 7768 6974 6573 7061 6365 0a20  cii_whitespace. 
-00002b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002b90: 2020 2065 6c69 6620 7365 7061 7261 746f     elif separato
-00002ba0: 7273 203d 3d20 6269 672e 6e65 776c 696e  rs == big.newlin
-00002bb0: 6573 3a0a 2020 2020 2020 2020 2020 2020  es:.            
-00002bc0: 2020 2020 2020 2020 2020 2020 7365 7061              sepa
-00002bd0: 7261 746f 7273 203d 2062 6967 2e61 7363  rators = big.asc
-00002be0: 6969 5f6e 6577 6c69 6e65 730a 2020 2020  ii_newlines.    
-00002bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002c00: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00002c10: 2020 2020 2020 2020 2020 2020 2020 6173                as
-00002c20: 7365 7274 2069 7369 6e73 7461 6e63 6528  sert isinstance(
-00002c30: 7365 7061 7261 746f 7273 2c20 7374 7229  separators, str)
-00002c40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002c50: 2020 2020 2020 2020 2073 6570 6172 6174           separat
-00002c60: 6f72 7320 3d20 7365 7061 7261 746f 7273  ors = separators
-00002c70: 2e65 6e63 6f64 6528 2761 7363 6969 2729  .encode('ascii')
-00002c80: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00002c90: 2020 7365 6c66 2e61 7373 6572 7445 7175    self.assertEqu
-00002ca0: 616c 2862 6967 2e6d 756c 7469 7374 7269  al(big.multistri
-00002cb0: 7028 732c 2073 6570 6172 6174 6f72 732c  p(s, separators,
-00002cc0: 206c 6566 743d 4661 6c73 652c 2072 6967   left=False, rig
-00002cd0: 6874 3d46 616c 7365 292c 2073 290a 2020  ht=False), s).  
-00002ce0: 2020 2020 2020 2020 2020 2020 2020 7365                se
-00002cf0: 6c66 2e61 7373 6572 7445 7175 616c 2862  lf.assertEqual(b
-00002d00: 6967 2e6d 756c 7469 7374 7269 7028 732c  ig.multistrip(s,
-00002d10: 2073 6570 6172 6174 6f72 732c 206c 6566   separators, lef
-00002d20: 743d 4661 6c73 652c 2072 6967 6874 3d54  t=False, right=T
-00002d30: 7275 6520 292c 2073 290a 2020 2020 2020  rue ), s).      
-00002d40: 2020 2020 2020 2020 2020 7365 6c66 2e61            self.a
-00002d50: 7373 6572 7445 7175 616c 2862 6967 2e6d  ssertEqual(big.m
-00002d60: 756c 7469 7374 7269 7028 732c 2073 6570  ultistrip(s, sep
-00002d70: 6172 6174 6f72 732c 206c 6566 743d 5472  arators, left=Tr
-00002d80: 7565 2c20 2072 6967 6874 3d46 616c 7365  ue,  right=False
-00002d90: 292c 2073 290a 2020 2020 2020 2020 2020  ), s).          
-00002da0: 2020 2020 2020 7365 6c66 2e61 7373 6572        self.asser
-00002db0: 7445 7175 616c 2862 6967 2e6d 756c 7469  tEqual(big.multi
-00002dc0: 7374 7269 7028 732c 2073 6570 6172 6174  strip(s, separat
-00002dd0: 6f72 732c 206c 6566 743d 5472 7565 2c20  ors, left=True, 
-00002de0: 2072 6967 6874 3d54 7275 6520 292c 2073   right=True ), s
-00002df0: 290a 0a20 2020 2020 2020 2020 2020 2020  )..             
-00002e00: 2020 206c 7320 3d20 6c65 6674 202b 2073     ls = left + s
-00002e10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002e20: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
-00002e30: 6c28 6269 672e 6d75 6c74 6973 7472 6970  l(big.multistrip
-00002e40: 286c 732c 2073 6570 6172 6174 6f72 732c  (ls, separators,
-00002e50: 206c 6566 743d 4661 6c73 652c 2072 6967   left=False, rig
-00002e60: 6874 3d46 616c 7365 292c 206c 7329 0a20  ht=False), ls). 
-00002e70: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00002e80: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
-00002e90: 6269 672e 6d75 6c74 6973 7472 6970 286c  big.multistrip(l
-00002ea0: 732c 2073 6570 6172 6174 6f72 732c 206c  s, separators, l
-00002eb0: 6566 743d 4661 6c73 652c 2072 6967 6874  eft=False, right
-00002ec0: 3d54 7275 6520 292c 206c 7329 0a20 2020  =True ), ls).   
-00002ed0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-00002ee0: 662e 6173 7365 7274 4571 7561 6c28 6269  f.assertEqual(bi
-00002ef0: 672e 6d75 6c74 6973 7472 6970 286c 732c  g.multistrip(ls,
-00002f00: 2073 6570 6172 6174 6f72 732c 206c 6566   separators, lef
-00002f10: 743d 5472 7565 2c20 2072 6967 6874 3d46  t=True,  right=F
-00002f20: 616c 7365 292c 2073 290a 2020 2020 2020  alse), s).      
-00002f30: 2020 2020 2020 2020 2020 7365 6c66 2e61            self.a
-00002f40: 7373 6572 7445 7175 616c 2862 6967 2e6d  ssertEqual(big.m
-00002f50: 756c 7469 7374 7269 7028 6c73 2c20 7365  ultistrip(ls, se
-00002f60: 7061 7261 746f 7273 2c20 6c65 6674 3d54  parators, left=T
-00002f70: 7275 652c 2020 7269 6768 743d 5472 7565  rue,  right=True
-00002f80: 2029 2c20 7329 0a0a 2020 2020 2020 2020   ), s)..        
-00002f90: 2020 2020 2020 2020 7372 203d 2073 202b          sr = s +
-00002fa0: 2072 6967 6874 0a20 2020 2020 2020 2020   right.         
-00002fb0: 2020 2020 2020 2073 656c 662e 6173 7365         self.asse
-00002fc0: 7274 4571 7561 6c28 6269 672e 6d75 6c74  rtEqual(big.mult
-00002fd0: 6973 7472 6970 2873 722c 2073 6570 6172  istrip(sr, separ
-00002fe0: 6174 6f72 732c 206c 6566 743d 4661 6c73  ators, left=Fals
-00002ff0: 652c 2072 6967 6874 3d46 616c 7365 292c  e, right=False),
-00003000: 2073 7229 0a20 2020 2020 2020 2020 2020   sr).           
-00003010: 2020 2020 2073 656c 662e 6173 7365 7274       self.assert
-00003020: 4571 7561 6c28 6269 672e 6d75 6c74 6973  Equal(big.multis
-00003030: 7472 6970 2873 722c 2073 6570 6172 6174  trip(sr, separat
-00003040: 6f72 732c 206c 6566 743d 4661 6c73 652c  ors, left=False,
-00003050: 2072 6967 6874 3d54 7275 6520 292c 2073   right=True ), s
-00003060: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00003070: 2020 7365 6c66 2e61 7373 6572 7445 7175    self.assertEqu
-00003080: 616c 2862 6967 2e6d 756c 7469 7374 7269  al(big.multistri
-00003090: 7028 7372 2c20 7365 7061 7261 746f 7273  p(sr, separators
-000030a0: 2c20 6c65 6674 3d54 7275 652c 2020 7269  , left=True,  ri
-000030b0: 6768 743d 4661 6c73 6529 2c20 7372 290a  ght=False), sr).
-000030c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000030d0: 7365 6c66 2e61 7373 6572 7445 7175 616c  self.assertEqual
-000030e0: 2862 6967 2e6d 756c 7469 7374 7269 7028  (big.multistrip(
-000030f0: 7372 2c20 7365 7061 7261 746f 7273 2c20  sr, separators, 
-00003100: 6c65 6674 3d54 7275 652c 2020 7269 6768  left=True,  righ
-00003110: 743d 5472 7565 2029 2c20 7329 0a0a 2020  t=True ), s)..  
-00003120: 2020 2020 2020 2020 2020 2020 2020 6c73                ls
-00003130: 7220 3d20 6c65 6674 202b 2073 202b 2072  r = left + s + r
-00003140: 6967 6874 0a20 2020 2020 2020 2020 2020  ight.           
-00003150: 2020 2020 2073 656c 662e 6173 7365 7274       self.assert
-00003160: 4571 7561 6c28 6269 672e 6d75 6c74 6973  Equal(big.multis
-00003170: 7472 6970 286c 7372 2c20 7365 7061 7261  trip(lsr, separa
-00003180: 746f 7273 2c20 6c65 6674 3d46 616c 7365  tors, left=False
-00003190: 2c20 7269 6768 743d 4661 6c73 6529 2c20  , right=False), 
-000031a0: 6c73 7229 0a20 2020 2020 2020 2020 2020  lsr).           
-000031b0: 2020 2020 2073 656c 662e 6173 7365 7274       self.assert
-000031c0: 4571 7561 6c28 6269 672e 6d75 6c74 6973  Equal(big.multis
-000031d0: 7472 6970 286c 7372 2c20 7365 7061 7261  trip(lsr, separa
-000031e0: 746f 7273 2c20 6c65 6674 3d46 616c 7365  tors, left=False
-000031f0: 2c20 7269 6768 743d 5472 7565 2029 2c20  , right=True ), 
-00003200: 6c73 290a 2020 2020 2020 2020 2020 2020  ls).            
-00003210: 2020 2020 7365 6c66 2e61 7373 6572 7445      self.assertE
-00003220: 7175 616c 2862 6967 2e6d 756c 7469 7374  qual(big.multist
-00003230: 7269 7028 6c73 722c 2073 6570 6172 6174  rip(lsr, separat
-00003240: 6f72 732c 206c 6566 743d 5472 7565 2c20  ors, left=True, 
-00003250: 2072 6967 6874 3d46 616c 7365 292c 2073   right=False), s
-00003260: 7229 0a20 2020 2020 2020 2020 2020 2020  r).             
-00003270: 2020 2073 656c 662e 6173 7365 7274 4571     self.assertEq
-00003280: 7561 6c28 6269 672e 6d75 6c74 6973 7472  ual(big.multistr
-00003290: 6970 286c 7372 2c20 7365 7061 7261 746f  ip(lsr, separato
-000032a0: 7273 2c20 6c65 6674 3d54 7275 652c 2020  rs, left=True,  
-000032b0: 7269 6768 743d 5472 7565 2029 2c20 7329  right=True ), s)
-000032c0: 0a0a 2020 2020 2020 2020 7465 7374 5f6d  ..        test_m
-000032d0: 756c 7469 7374 7269 7028 2220 5c74 205c  ultistrip(" \t \
-000032e0: 6e20 222c 2022 6162 6364 6522 2c20 2220  n ", "abcde", " 
-000032f0: 5c6e 205c 7420 222c 2022 205c 745c 6e22  \n \t ", " \t\n"
-00003300: 290a 2020 2020 2020 2020 7465 7374 5f6d  ).        test_m
-00003310: 756c 7469 7374 7269 7028 2220 5c74 205c  ultistrip(" \t \
-00003320: 6e20 222c 2022 6162 6364 6522 2c20 2220  n ", "abcde", " 
-00003330: 5c6e 205c 7420 222c 2062 6967 2e77 6869  \n \t ", big.whi
-00003340: 7465 7370 6163 6529 0a20 2020 2020 2020  tespace).       
-00003350: 2074 6573 745f 6d75 6c74 6973 7472 6970   test_multistrip
-00003360: 2822 5c72 5c6e 5c6e 5c72 222c 2022 6162  ("\r\n\n\r", "ab
-00003370: 6364 6522 2c20 225c 6e5c 725c 725c 6e22  cde", "\n\r\r\n"
-00003380: 2c20 6269 672e 6e65 776c 696e 6573 290a  , big.newlines).
-00003390: 2020 2020 2020 2020 7465 7374 5f6d 756c          test_mul
-000033a0: 7469 7374 7269 7028 225c 725c 6e5c 6e5c  tistrip("\r\n\n\
-000033b0: 7222 2c20 2261 6263 6465 222c 2022 5c6e  r", "abcde", "\n
-000033c0: 5c72 5c72 5c6e 222c 2062 6967 2e77 6869  \r\r\n", big.whi
-000033d0: 7465 7370 6163 6529 0a20 2020 2020 2020  tespace).       
-000033e0: 2074 6573 745f 6d75 6c74 6973 7472 6970   test_multistrip
-000033f0: 2822 7858 5878 7878 5878 222c 2022 6969  ("xXXxxxXx", "ii
-00003400: 6969 6969 6922 2c20 2279 7959 5959 7979  iiiii", "yyYYYyy
-00003410: 7979 7922 2c20 2278 7958 5922 290a 0a20  yyy", "xyXY").. 
-00003420: 2020 2020 2020 2023 2072 6567 7265 7373         # regress
-00003430: 696f 6e20 7465 7374 3a0a 2020 2020 2020  ion test:.      
-00003440: 2020 2320 7468 6520 6f6c 6420 6170 7072    # the old appr
-00003450: 6f61 6368 2068 6164 2061 2062 7567 2074  oach had a bug t
-00003460: 6861 7420 6861 6420 746f 2064 6f20 7769  hat had to do wi
-00003470: 7468 206f 7665 726c 6170 7069 6e67 2073  th overlapping s
-00003480: 6570 6172 6174 6f72 732e 0a20 2020 2020  eparators..     
-00003490: 2020 2023 2077 6520 7573 6564 2074 6f20     # we used to 
-000034a0: 7365 7061 7261 7465 6c79 206d 6561 7375  separately measu
-000034b0: 7265 2022 7768 6572 6520 646f 6573 2074  re "where does t
-000034c0: 6865 2062 6567 696e 6e69 6e67 2072 756e  he beginning run
-000034d0: 206f 6620 7365 7061 7261 746f 7273 2065   of separators e
-000034e0: 6e64 220a 2020 2020 2020 2020 2320 616e  nd".        # an
-000034f0: 6420 2277 6865 7265 2064 6f65 7320 7468  d "where does th
-00003500: 6520 656e 6469 6e67 2072 756e 206f 6620  e ending run of 
-00003510: 7365 7061 7261 746f 7273 2073 7461 7274  separators start
-00003520: 222c 2074 6865 6e20 6f6e 6c79 206b 6565  ", then only kee
-00003530: 700a 2020 2020 2020 2020 2320 7468 6520  p.        # the 
-00003540: 7061 7274 206f 6620 7468 6520 7374 7269  part of the stri
-00003550: 6e67 2069 6e20 7468 6520 6d69 6464 6c65  ng in the middle
-00003560: 2e20 2062 7574 2069 6620 796f 7572 2073  .  but if your s
-00003570: 7472 696e 6720 7761 7320 2220 7820 7820  tring was " x x 
-00003580: 220a 2020 2020 2020 2020 2320 616e 6420  ".        # and 
-00003590: 796f 7572 2073 6570 6172 6174 6f72 7320  your separators 
-000035a0: 7765 7265 2028 2220 7820 222c 292c 2074  were (" x ",), t
-000035b0: 6865 6e20 7468 6579 206f 7665 726c 6170  hen they overlap
-000035c0: 7065 643a 0a20 2020 2020 2020 2023 0a20  ped:.        #. 
-000035d0: 2020 2020 2020 2023 2020 2020 7676 7620         #    vvv 
-000035e0: 2020 7275 6e20 6f66 2065 6e64 696e 6720    run of ending 
-000035f0: 7365 7061 7261 746f 7273 0a20 2020 2020  separators.     
-00003600: 2020 2023 2022 2078 2078 2022 0a20 2020     # " x x ".   
-00003610: 2020 2020 2023 2020 5e5e 5e20 2020 2020       #  ^^^     
-00003620: 7275 6e20 6f66 2062 6567 696e 6e69 6e67  run of beginning
-00003630: 2073 6570 6172 6174 6f72 730a 2020 2020   separators.    
-00003640: 2020 2020 230a 2020 2020 2020 2020 2320      #.        # 
-00003650: 616e 642c 2077 686f 206b 6e6f 7773 2c20  and, who knows, 
-00003660: 6d61 7962 6520 7468 6174 2773 2077 6861  maybe that's wha
-00003670: 7420 796f 7520 7761 6e74 3f20 6275 7420  t you want? but 
-00003680: 7468 6174 2773 206e 6f74 2077 6861 7420  that's not what 
-00003690: 796f 7527 7265 2067 6f6e 6e61 2067 6574  you're gonna get
-000036a0: 2e0a 2020 2020 2020 2020 2320 6d75 6c74  ..        # mult
-000036b0: 692d 2a20 6675 6e63 7469 6f6e 7320 7072  i-* functions pr
-000036c0: 6566 6572 2074 6865 206c 6566 746d 6f73  efer the leftmos
-000036d0: 7420 696e 7374 616e 6365 206f 6620 6120  t instance of a 
-000036e0: 7365 7061 7261 746f 7220 2875 6e6c 6573  separator (unles
-000036f0: 7320 7265 7665 7273 650a 2020 2020 2020  s reverse.      
-00003700: 2020 2320 6973 2074 7275 6529 2e20 2073    # is true).  s
-00003710: 6f20 7468 6973 2073 686f 756c 6420 6561  o this should ea
-00003720: 7420 7468 6520 6c65 6674 206f 7665 726c  t the left overl
-00003730: 6170 7069 6e67 2073 6570 6172 6174 6f72  apping separator
-00003740: 2061 6e64 206c 6561 7665 2077 6861 740a   and leave what.
-00003750: 2020 2020 2020 2020 2320 7265 6d61 696e          # remain
-00003760: 7320 6f66 2074 6865 2072 6967 6874 206f  s of the right o
-00003770: 6e65 2e0a 2020 2020 2020 2020 7365 6c66  ne..        self
-00003780: 2e61 7373 6572 7445 7175 616c 2862 6967  .assertEqual(big
-00003790: 2e6d 756c 7469 7374 7269 7028 2720 7820  .multistrip(' x 
-000037a0: 7820 272c 2028 2720 7820 272c 2929 2c20  x ', (' x ',)), 
-000037b0: 2778 2027 290a 0a20 2020 2020 2020 2023  'x ')..        #
-000037c0: 2072 6567 7265 7373 696f 6e3a 206d 756c   regression: mul
-000037d0: 7469 7374 7269 7020 6469 646e 2774 2075  tistrip didn't u
-000037e0: 7365 6420 746f 2076 6572 6966 790a 2020  sed to verify.  
-000037f0: 2020 2020 2020 2320 7468 6174 2073 2077        # that s w
-00003800: 6173 2065 6974 6865 7220 7374 7220 6f72  as either str or
-00003810: 2062 7974 6573 2e0a 2020 2020 2020 2020   bytes..        
-00003820: 7769 7468 2073 656c 662e 6173 7365 7274  with self.assert
-00003830: 5261 6973 6573 2854 7970 6545 7272 6f72  Raises(TypeError
-00003840: 293a 0a20 2020 2020 2020 2020 2020 2062  ):.            b
-00003850: 6967 2e6d 756c 7469 7374 7269 7028 332e  ig.multistrip(3.
-00003860: 3134 3135 290a 2020 2020 2020 2020 7769  1415).        wi
-00003870: 7468 2073 656c 662e 6173 7365 7274 5261  th self.assertRa
-00003880: 6973 6573 2854 7970 6545 7272 6f72 293a  ises(TypeError):
-00003890: 0a20 2020 2020 2020 2020 2020 2062 6967  .            big
-000038a0: 2e6d 756c 7469 7374 7269 7028 332e 3134  .multistrip(3.14
-000038b0: 3135 2c20 2761 6263 2729 0a20 2020 2020  15, 'abc').     
-000038c0: 2020 2077 6974 6820 7365 6c66 2e61 7373     with self.ass
-000038d0: 6572 7452 6169 7365 7328 5479 7065 4572  ertRaises(TypeEr
-000038e0: 726f 7229 3a0a 2020 2020 2020 2020 2020  ror):.          
-000038f0: 2020 6269 672e 6d75 6c74 6973 7472 6970    big.multistrip
-00003900: 285b 2761 272c 2027 6227 2c20 2763 275d  (['a', 'b', 'c']
-00003910: 290a 2020 2020 2020 2020 7769 7468 2073  ).        with s
-00003920: 656c 662e 6173 7365 7274 5261 6973 6573  elf.assertRaises
-00003930: 2854 7970 6545 7272 6f72 293a 0a20 2020  (TypeError):.   
-00003940: 2020 2020 2020 2020 2062 6967 2e6d 756c           big.mul
-00003950: 7469 7374 7269 7028 5b62 2761 272c 2062  tistrip([b'a', b
-00003960: 2762 272c 2062 2763 275d 290a 2020 2020  'b', b'c']).    
-00003970: 2020 2020 7769 7468 2073 656c 662e 6173      with self.as
-00003980: 7365 7274 5261 6973 6573 2854 7970 6545  sertRaises(TypeE
-00003990: 7272 6f72 293a 0a20 2020 2020 2020 2020  rror):.         
-000039a0: 2020 2062 6967 2e6d 756c 7469 7374 7269     big.multistri
-000039b0: 7028 5b27 6127 2c20 2762 272c 2027 6327  p(['a', 'b', 'c'
-000039c0: 5d2c 2027 6127 290a 2020 2020 2020 2020  ], 'a').        
-000039d0: 7769 7468 2073 656c 662e 6173 7365 7274  with self.assert
-000039e0: 5261 6973 6573 2854 7970 6545 7272 6f72  Raises(TypeError
-000039f0: 293a 0a20 2020 2020 2020 2020 2020 2062  ):.            b
-00003a00: 6967 2e6d 756c 7469 7374 7269 7028 5b62  ig.multistrip([b
-00003a10: 2761 272c 2062 2762 272c 2062 2763 275d  'a', b'b', b'c']
-00003a20: 2c20 6227 6127 290a 0a20 2020 2020 2020  , b'a')..       
-00003a30: 2077 6974 6820 7365 6c66 2e61 7373 6572   with self.asser
-00003a40: 7452 6169 7365 7328 5479 7065 4572 726f  tRaises(TypeErro
-00003a50: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
-00003a60: 6269 672e 6d75 6c74 6973 7472 6970 2827  big.multistrip('
-00003a70: 7327 2c20 5b27 6127 2c20 6227 6227 2c20  s', ['a', b'b', 
-00003a80: 2763 275d 290a 2020 2020 2020 2020 7769  'c']).        wi
-00003a90: 7468 2073 656c 662e 6173 7365 7274 5261  th self.assertRa
-00003aa0: 6973 6573 2854 7970 6545 7272 6f72 293a  ises(TypeError):
-00003ab0: 0a20 2020 2020 2020 2020 2020 2062 6967  .            big
-00003ac0: 2e6d 756c 7469 7374 7269 7028 2773 272c  .multistrip('s',
-00003ad0: 205b 2761 272c 2031 3233 342c 2027 6327   ['a', 1234, 'c'
-00003ae0: 5d29 0a20 2020 2020 2020 2077 6974 6820  ]).        with 
-00003af0: 7365 6c66 2e61 7373 6572 7452 6169 7365  self.assertRaise
-00003b00: 7328 5479 7065 4572 726f 7229 3a0a 2020  s(TypeError):.  
-00003b10: 2020 2020 2020 2020 2020 6269 672e 6d75            big.mu
-00003b20: 6c74 6973 7472 6970 2862 2773 272c 205b  ltistrip(b's', [
-00003b30: 6227 6127 2c20 2762 272c 2062 2763 275d  b'a', 'b', b'c']
-00003b40: 290a 2020 2020 2020 2020 7769 7468 2073  ).        with s
-00003b50: 656c 662e 6173 7365 7274 5261 6973 6573  elf.assertRaises
-00003b60: 2854 7970 6545 7272 6f72 293a 0a20 2020  (TypeError):.   
-00003b70: 2020 2020 2020 2020 2062 6967 2e6d 756c           big.mul
-00003b80: 7469 7374 7269 7028 6227 7327 2c20 5b62  tistrip(b's', [b
-00003b90: 2761 272c 2031 3233 342c 2062 2763 275d  'a', 1234, b'c']
-00003ba0: 290a 0a20 2020 2020 2020 2077 6974 6820  )..        with 
-00003bb0: 7365 6c66 2e61 7373 6572 7452 6169 7365  self.assertRaise
-00003bc0: 7328 5479 7065 4572 726f 7229 3a0a 2020  s(TypeError):.  
-00003bd0: 2020 2020 2020 2020 2020 6269 672e 6d75            big.mu
-00003be0: 6c74 6973 7472 6970 2827 7327 2c20 6227  ltistrip('s', b'
-00003bf0: 6162 6327 290a 2020 2020 2020 2020 7769  abc').        wi
-00003c00: 7468 2073 656c 662e 6173 7365 7274 5261  th self.assertRa
-00003c10: 6973 6573 2854 7970 6545 7272 6f72 293a  ises(TypeError):
-00003c20: 0a20 2020 2020 2020 2020 2020 2062 6967  .            big
-00003c30: 2e6d 756c 7469 7374 7269 7028 6227 7327  .multistrip(b's'
-00003c40: 2c20 2761 6263 2729 0a0a 0a20 2020 2064  , 'abc')...    d
-00003c50: 6566 2074 6573 745f 6d75 6c74 6973 706c  ef test_multispl
-00003c60: 6974 2873 656c 6629 3a0a 2020 2020 2020  it(self):.      
-00003c70: 2020 666f 7220 6320 696e 2028 756e 6368    for c in (unch
-00003c80: 616e 6765 642c 2074 6f5f 6279 7465 7329  anged, to_bytes)
-00003c90: 3a0a 2020 2020 2020 2020 2020 2020 6e6f  :.            no
-00003ca0: 745f 6320 3d20 746f 5f62 7974 6573 2069  t_c = to_bytes i
-00003cb0: 6620 2863 203d 3d20 756e 6368 616e 6765  f (c == unchange
-00003cc0: 6429 2065 6c73 6520 756e 6368 616e 6765  d) else unchange
-00003cd0: 640a 2020 2020 2020 2020 2020 2020 6465  d.            de
-00003ce0: 6620 6c69 7374 5f6d 756c 7469 7370 6c69  f list_multispli
-00003cf0: 7428 2a61 2c20 2a2a 6b77 293a 2072 6574  t(*a, **kw): ret
-00003d00: 7572 6e20 6c69 7374 2862 6967 2e6d 756c  urn list(big.mul
-00003d10: 7469 7370 6c69 7428 2a61 2c20 2a2a 6b77  tisplit(*a, **kw
-00003d20: 2929 0a20 2020 2020 2020 2020 2020 2073  )).            s
-00003d30: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
-00003d40: 6c69 7374 5f6d 756c 7469 7370 6c69 7428  list_multisplit(
-00003d50: 6328 2761 6161 5861 6161 5961 6161 2729  c('aaaXaaaYaaa')
-00003d60: 2c20 6328 2761 6263 2729 2c20 7374 7269  , c('abc'), stri
-00003d70: 703d 5472 7565 2029 2c20 6328 5b27 5827  p=True ), c(['X'
-00003d80: 2c20 2759 275d 2929 0a20 2020 2020 2020  , 'Y'])).       
-00003d90: 2020 2020 2073 656c 662e 6173 7365 7274       self.assert
-00003da0: 4571 7561 6c28 6c69 7374 5f6d 756c 7469  Equal(list_multi
-00003db0: 7370 6c69 7428 6328 2761 6161 5861 6161  split(c('aaaXaaa
-00003dc0: 5961 6161 2729 2c20 6328 2761 6263 2729  Yaaa'), c('abc')
-00003dd0: 2c20 7374 7269 703d 4661 6c73 6529 2c20  , strip=False), 
-00003de0: 6328 5b27 272c 2027 5827 2c20 2759 272c  c(['', 'X', 'Y',
-00003df0: 2027 275d 2929 0a20 2020 2020 2020 2020   ''])).         
-00003e00: 2020 2073 656c 662e 6173 7365 7274 4571     self.assertEq
-00003e10: 7561 6c28 6c69 7374 5f6d 756c 7469 7370  ual(list_multisp
-00003e20: 6c69 7428 6328 2761 6263 5862 6361 5963  lit(c('abcXbcaYc
-00003e30: 6261 2729 2c20 6328 2761 6263 2729 2c20  ba'), c('abc'), 
-00003e40: 7374 7269 703d 5472 7565 2029 2c20 6328  strip=True ), c(
-00003e50: 5b27 5827 2c20 2759 275d 2929 0a20 2020  ['X', 'Y'])).   
-00003e60: 2020 2020 2020 2020 2073 656c 662e 6173           self.as
-00003e70: 7365 7274 4571 7561 6c28 6c69 7374 5f6d  sertEqual(list_m
-00003e80: 756c 7469 7370 6c69 7428 6328 2761 6263  ultisplit(c('abc
-00003e90: 5862 6361 5963 6261 2729 2c20 6328 2761  XbcaYcba'), c('a
-00003ea0: 6263 2729 2c20 7374 7269 703d 4661 6c73  bc'), strip=Fals
-00003eb0: 6529 2c20 6328 5b27 272c 2027 5827 2c20  e), c(['', 'X', 
-00003ec0: 2759 272c 2027 275d 2929 0a0a 2020 2020  'Y', '']))..    
-00003ed0: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
-00003ee0: 6572 7445 7175 616c 286c 6973 745f 6d75  ertEqual(list_mu
-00003ef0: 6c74 6973 706c 6974 2863 2827 2729 2c20  ltisplit(c(''), 
-00003f00: 6328 2761 6263 6465 2729 2c20 6d61 7873  c('abcde'), maxs
-00003f10: 706c 6974 3d4e 6f6e 6529 2c20 6328 5b27  plit=None), c(['
-00003f20: 275d 2929 0a20 2020 2020 2020 2020 2020  '])).           
-00003f30: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
-00003f40: 6c28 6c69 7374 5f6d 756c 7469 7370 6c69  l(list_multispli
-00003f50: 7428 6328 2761 6263 6465 2729 2c20 6328  t(c('abcde'), c(
-00003f60: 2766 6768 696a 2729 292c 2063 285b 2761  'fghij')), c(['a
-00003f70: 6263 6465 275d 2929 0a20 2020 2020 2020  bcde'])).       
-00003f80: 2020 2020 2073 656c 662e 6173 7365 7274       self.assert
-00003f90: 4571 7561 6c28 6c69 7374 5f6d 756c 7469  Equal(list_multi
-00003fa0: 7370 6c69 7428 6328 2761 6263 6465 2729  split(c('abcde')
-00003fb0: 2c20 6328 2766 6768 696a 6327 2929 2c20  , c('fghijc')), 
-00003fc0: 6328 5b27 6162 272c 2027 6465 275d 2929  c(['ab', 'de']))
-00003fd0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00003fe0: 662e 6173 7365 7274 4571 7561 6c28 6c69  f.assertEqual(li
-00003ff0: 7374 5f6d 756c 7469 7370 6c69 7428 6328  st_multisplit(c(
-00004000: 2731 6132 6233 6334 6435 6536 2729 2c20  '1a2b3c4d5e6'), 
-00004010: 6328 2761 6263 6465 2729 292c 2063 285b  c('abcde')), c([
-00004020: 2731 272c 2027 3227 2c20 2733 272c 2027  '1', '2', '3', '
-00004030: 3427 2c20 2735 272c 2027 3627 5d29 290a  4', '5', '6'])).
-00004040: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00004050: 662e 6173 7365 7274 4571 7561 6c28 6c69  f.assertEqual(li
-00004060: 7374 5f6d 756c 7469 7370 6c69 7428 6328  st_multisplit(c(
-00004070: 2761 623a 6364 2c65 6627 292c 2020 2063  'ab:cd,ef'),   c
-00004080: 2827 3a2c 2729 2c20 7374 7269 703d 5472  (':,'), strip=Tr
-00004090: 7565 2029 2c20 6328 5b22 6162 222c 2022  ue ), c(["ab", "
-000040a0: 6364 222c 2022 6566 225d 2929 0a20 2020  cd", "ef"])).   
-000040b0: 2020 2020 2020 2020 2073 656c 662e 6173           self.as
-000040c0: 7365 7274 4571 7561 6c28 6c69 7374 5f6d  sertEqual(list_m
-000040d0: 756c 7469 7370 6c69 7428 6328 2761 623a  ultisplit(c('ab:
-000040e0: 6364 2c65 6627 292c 2020 2063 2827 3a2c  cd,ef'),   c(':,
-000040f0: 2729 2c20 7374 7269 703d 4661 6c73 6529  '), strip=False)
-00004100: 2c20 6328 5b22 6162 222c 2022 6364 222c  , c(["ab", "cd",
-00004110: 2022 6566 225d 2929 0a20 2020 2020 2020   "ef"])).       
-00004120: 2020 2020 2073 656c 662e 6173 7365 7274       self.assert
-00004130: 4571 7561 6c28 6c69 7374 5f6d 756c 7469  Equal(list_multi
-00004140: 7370 6c69 7428 6328 2761 623a 6364 2c65  split(c('ab:cd,e
-00004150: 663a 2729 2c20 2063 2827 3a2c 2729 2c20  f:'),  c(':,'), 
-00004160: 7374 7269 703d 5472 7565 2029 2c20 6328  strip=True ), c(
-00004170: 5b22 6162 222c 2022 6364 222c 2022 6566  ["ab", "cd", "ef
-00004180: 225d 2929 0a20 2020 2020 2020 2020 2020  "])).           
-00004190: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
-000041a0: 6c28 6c69 7374 5f6d 756c 7469 7370 6c69  l(list_multispli
-000041b0: 7428 6328 2761 623a 6364 2c65 663a 2729  t(c('ab:cd,ef:')
-000041c0: 2c20 2063 2827 3a2c 2729 2c20 7374 7269  ,  c(':,'), stri
-000041d0: 703d 4661 6c73 6529 2c20 6328 5b22 6162  p=False), c(["ab
-000041e0: 222c 2022 6364 222c 2022 6566 222c 2022  ", "cd", "ef", "
-000041f0: 225d 2929 0a20 2020 2020 2020 2020 2020  "])).           
-00004200: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
-00004210: 6c28 6c69 7374 5f6d 756c 7469 7370 6c69  l(list_multispli
-00004220: 7428 6328 272c 6162 3a63 642c 6566 3a27  t(c(',ab:cd,ef:'
-00004230: 292c 2063 2827 3a2c 2729 2c20 7374 7269  ), c(':,'), stri
-00004240: 703d 5472 7565 2029 2c20 6328 5b22 6162  p=True ), c(["ab
-00004250: 222c 2022 6364 222c 2022 6566 225d 2929  ", "cd", "ef"]))
-00004260: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00004270: 662e 6173 7365 7274 4571 7561 6c28 6c69  f.assertEqual(li
-00004280: 7374 5f6d 756c 7469 7370 6c69 7428 6328  st_multisplit(c(
-00004290: 272c 6162 3a63 642c 6566 3a27 292c 2063  ',ab:cd,ef:'), c
-000042a0: 2827 3a2c 2729 2c20 7374 7269 703d 4661  (':,'), strip=Fa
-000042b0: 6c73 6529 2c20 6328 5b22 222c 2022 6162  lse), c(["", "ab
-000042c0: 222c 2022 6364 222c 2022 6566 222c 2022  ", "cd", "ef", "
-000042d0: 225d 2929 0a20 2020 2020 2020 2020 2020  "])).           
-000042e0: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
-000042f0: 6c28 6c69 7374 5f6d 756c 7469 7370 6c69  l(list_multispli
-00004300: 7428 6328 273a 6162 3a63 642c 6566 2729  t(c(':ab:cd,ef')
-00004310: 2c20 2063 2827 3a2c 2729 2c20 7374 7269  ,  c(':,'), stri
-00004320: 703d 5472 7565 2029 2c20 6328 5b22 6162  p=True ), c(["ab
-00004330: 222c 2022 6364 222c 2022 6566 225d 2929  ", "cd", "ef"]))
-00004340: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00004350: 662e 6173 7365 7274 4571 7561 6c28 6c69  f.assertEqual(li
-00004360: 7374 5f6d 756c 7469 7370 6c69 7428 6328  st_multisplit(c(
-00004370: 273a 6162 3a63 642c 6566 2729 2c20 2063  ':ab:cd,ef'),  c
-00004380: 2827 3a2c 2729 2c20 7374 7269 703d 4661  (':,'), strip=Fa
-00004390: 6c73 6529 2c20 6328 5b22 222c 2022 6162  lse), c(["", "ab
-000043a0: 222c 2022 6364 222c 2022 6566 225d 2929  ", "cd", "ef"]))
-000043b0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-000043c0: 662e 6173 7365 7274 4571 7561 6c28 6c69  f.assertEqual(li
-000043d0: 7374 5f6d 756c 7469 7370 6c69 7428 6328  st_multisplit(c(
-000043e0: 2757 5761 6258 5863 6459 5961 625a 5a27  'WWabXXcdYYabZZ'
-000043f0: 292c 2020 2063 2828 2761 6227 2c20 2763  ),   c(('ab', 'c
-00004400: 6427 2929 2c20 7374 7269 703d 5472 7565  d')), strip=True
-00004410: 2029 2c20 6328 5b27 5757 272c 2027 5858   ), c(['WW', 'XX
-00004420: 272c 2027 5959 272c 2027 5a5a 275d 2929  ', 'YY', 'ZZ']))
-00004430: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00004440: 662e 6173 7365 7274 4571 7561 6c28 6c69  f.assertEqual(li
-00004450: 7374 5f6d 756c 7469 7370 6c69 7428 6328  st_multisplit(c(
-00004460: 2757 5761 6258 5863 6459 5961 625a 5a27  'WWabXXcdYYabZZ'
-00004470: 292c 2020 2063 2828 2761 6227 2c20 2763  ),   c(('ab', 'c
-00004480: 6427 2929 2c20 7374 7269 703d 4661 6c73  d')), strip=Fals
-00004490: 6529 2c20 6328 5b27 5757 272c 2027 5858  e), c(['WW', 'XX
-000044a0: 272c 2027 5959 272c 2027 5a5a 275d 2929  ', 'YY', 'ZZ']))
-000044b0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-000044c0: 662e 6173 7365 7274 4571 7561 6c28 6c69  f.assertEqual(li
-000044d0: 7374 5f6d 756c 7469 7370 6c69 7428 6328  st_multisplit(c(
-000044e0: 2757 5761 6258 5863 6459 5961 625a 5a61  'WWabXXcdYYabZZa
-000044f0: 6227 292c 2063 2828 2761 6227 2c20 2763  b'), c(('ab', 'c
-00004500: 6427 2929 2c20 7374 7269 703d 5472 7565  d')), strip=True
-00004510: 2029 2c20 6328 5b27 5757 272c 2027 5858   ), c(['WW', 'XX
-00004520: 272c 2027 5959 272c 2027 5a5a 275d 2929  ', 'YY', 'ZZ']))
-00004530: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00004540: 662e 6173 7365 7274 4571 7561 6c28 6c69  f.assertEqual(li
-00004550: 7374 5f6d 756c 7469 7370 6c69 7428 6328  st_multisplit(c(
-00004560: 2757 5761 6258 5863 6459 5961 625a 5a61  'WWabXXcdYYabZZa
-00004570: 6227 292c 2063 2828 2761 6227 2c20 2763  b'), c(('ab', 'c
-00004580: 6427 2929 2c20 7374 7269 703d 4661 6c73  d')), strip=Fals
-00004590: 6529 2c20 6328 5b27 5757 272c 2027 5858  e), c(['WW', 'XX
-000045a0: 272c 2027 5959 272c 2027 5a5a 272c 2027  ', 'YY', 'ZZ', '
-000045b0: 275d 2929 0a20 2020 2020 2020 2020 2020  '])).           
-000045c0: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
-000045d0: 6c28 6c69 7374 5f6d 756c 7469 7370 6c69  l(list_multispli
-000045e0: 7428 6328 2761 6257 5761 6258 5863 6459  t(c('abWWabXXcdY
-000045f0: 5961 625a 5a27 292c 2063 2828 2761 6227  YabZZ'), c(('ab'
-00004600: 2c20 2763 6427 2929 2c20 7374 7269 703d  , 'cd')), strip=
-00004610: 5472 7565 2029 2c20 6328 5b27 5757 272c  True ), c(['WW',
-00004620: 2027 5858 272c 2027 5959 272c 2027 5a5a   'XX', 'YY', 'ZZ
-00004630: 275d 2929 0a20 2020 2020 2020 2020 2020  '])).           
-00004640: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
-00004650: 6c28 6c69 7374 5f6d 756c 7469 7370 6c69  l(list_multispli
-00004660: 7428 6328 2761 6257 5761 6258 5863 6459  t(c('abWWabXXcdY
-00004670: 5961 625a 5a27 292c 2063 2828 2761 6227  YabZZ'), c(('ab'
-00004680: 2c20 2763 6427 2929 2c20 7374 7269 703d  , 'cd')), strip=
-00004690: 4661 6c73 6529 2c20 6328 5b27 272c 2757  False), c(['','W
-000046a0: 5727 2c20 2758 5827 2c20 2759 5927 2c20  W', 'XX', 'YY', 
-000046b0: 275a 5a27 5d29 290a 2020 2020 2020 2020  'ZZ'])).        
-000046c0: 2020 2020 7365 6c66 2e61 7373 6572 7445      self.assertE
-000046d0: 7175 616c 286c 6973 745f 6d75 6c74 6973  qual(list_multis
-000046e0: 706c 6974 2863 2827 5757 6162 5858 6364  plit(c('WWabXXcd
-000046f0: 5959 6162 5a5a 6364 2729 2c20 6328 2827  YYabZZcd'), c(('
-00004700: 6162 272c 2027 6364 2729 292c 2073 7472  ab', 'cd')), str
-00004710: 6970 3d54 7275 6520 292c 2063 285b 2757  ip=True ), c(['W
-00004720: 5727 2c20 2758 5827 2c20 2759 5927 2c20  W', 'XX', 'YY', 
-00004730: 275a 5a27 5d29 290a 2020 2020 2020 2020  'ZZ'])).        
-00004740: 2020 2020 7365 6c66 2e61 7373 6572 7445      self.assertE
-00004750: 7175 616c 286c 6973 745f 6d75 6c74 6973  qual(list_multis
-00004760: 706c 6974 2863 2827 5757 6162 5858 6364  plit(c('WWabXXcd
-00004770: 5959 6162 5a5a 6364 2729 2c20 6328 2827  YYabZZcd'), c(('
-00004780: 6162 272c 2027 6364 2729 292c 2073 7472  ab', 'cd')), str
-00004790: 6970 3d46 616c 7365 292c 2063 285b 2757  ip=False), c(['W
-000047a0: 5727 2c20 2758 5827 2c20 2759 5927 2c20  W', 'XX', 'YY', 
-000047b0: 275a 5a27 2c20 2727 5d29 290a 2020 2020  'ZZ', ''])).    
-000047c0: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
-000047d0: 6572 7445 7175 616c 286c 6973 745f 6d75  ertEqual(list_mu
-000047e0: 6c74 6973 706c 6974 2863 2827 5858 6162  ltisplit(c('XXab
-000047f0: 6364 5959 2729 2c20 6328 2827 6127 2c20  cdYY'), c(('a', 
-00004800: 2761 6263 6427 2929 292c 2063 285b 2758  'abcd'))), c(['X
-00004810: 5827 2c20 2759 5927 5d29 290a 2020 2020  X', 'YY'])).    
-00004820: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
-00004830: 6572 7445 7175 616c 286c 6973 745f 6d75  ertEqual(list_mu
-00004840: 6c74 6973 706c 6974 2863 2827 5858 6162  ltisplit(c('XXab
-00004850: 6364 6162 6364 5959 2729 2c20 6328 2827  cdabcdYY'), c(('
-00004860: 6162 272c 2027 6364 2729 2929 2c20 6328  ab', 'cd'))), c(
-00004870: 5b27 5858 272c 2027 5959 275d 2929 0a20  ['XX', 'YY'])). 
-00004880: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00004890: 6173 7365 7274 4571 7561 6c28 6c69 7374  assertEqual(list
-000048a0: 5f6d 756c 7469 7370 6c69 7428 6328 2761  _multisplit(c('a
-000048b0: 6263 6458 5861 6263 6461 6263 6459 5961  bcdXXabcdabcdYYa
-000048c0: 6263 6427 292c 2063 2828 2761 6227 2c20  bcd'), c(('ab', 
-000048d0: 2763 6427 2929 2c20 7374 7269 703d 5472  'cd')), strip=Tr
-000048e0: 7565 2029 2c20 6328 5b27 5858 272c 2027  ue ), c(['XX', '
-000048f0: 5959 275d 2929 0a20 2020 2020 2020 2020  YY'])).         
-00004900: 2020 2073 656c 662e 6173 7365 7274 4571     self.assertEq
-00004910: 7561 6c28 6c69 7374 5f6d 756c 7469 7370  ual(list_multisp
-00004920: 6c69 7428 6328 2761 6263 6458 5861 6263  lit(c('abcdXXabc
-00004930: 6461 6263 6459 5961 6263 6427 292c 2063  dabcdYYabcd'), c
-00004940: 2828 2761 6227 2c20 2763 6427 2929 2c20  (('ab', 'cd')), 
-00004950: 7374 7269 703d 4661 6c73 6529 2c20 6328  strip=False), c(
-00004960: 5b27 272c 2027 5858 272c 2027 5959 272c  ['', 'XX', 'YY',
-00004970: 2027 275d 2929 0a20 2020 2020 2020 2020   ''])).         
-00004980: 2020 2073 656c 662e 6173 7365 7274 4571     self.assertEq
-00004990: 7561 6c28 6c69 7374 5f6d 756c 7469 7370  ual(list_multisp
-000049a0: 6c69 7428 6328 2761 6263 6458 5861 6263  lit(c('abcdXXabc
-000049b0: 6461 6263 6459 5961 6263 6427 292c 2063  dabcdYYabcd'), c
-000049c0: 2828 2761 6227 2c20 2763 6427 2929 2c20  (('ab', 'cd')), 
-000049d0: 7365 7061 7261 7465 3d54 7275 652c 2073  separate=True, s
-000049e0: 7472 6970 3d46 616c 7365 292c 2063 285b  trip=False), c([
-000049f0: 2727 2c20 2727 2c20 2758 5827 2c20 2727  '', '', 'XX', ''
-00004a00: 2c20 2727 2c20 2727 2c20 2759 5927 2c20  , '', '', 'YY', 
-00004a10: 2727 2c20 2727 5d29 290a 0a20 2020 2020  '', '']))..     
-00004a20: 2020 2020 2020 2073 656c 662e 6173 7365         self.asse
-00004a30: 7274 4571 7561 6c28 6c69 7374 5f6d 756c  rtEqual(list_mul
-00004a40: 7469 7370 6c69 7428 6328 2778 6178 6278  tisplit(c('xaxbx
-00004a50: 6378 6478 6578 2729 2c20 6328 2761 6263  cxdxex'), c('abc
-00004a60: 6465 2729 2c20 6d61 7873 706c 6974 3d30  de'), maxsplit=0
-00004a70: 292c 2063 285b 2778 6178 6278 6378 6478  ), c(['xaxbxcxdx
-00004a80: 6578 275d 2929 0a20 2020 2020 2020 2020  ex'])).         
-00004a90: 2020 2073 656c 662e 6173 7365 7274 4571     self.assertEq
-00004aa0: 7561 6c28 6c69 7374 5f6d 756c 7469 7370  ual(list_multisp
-00004ab0: 6c69 7428 6328 2778 6178 6278 6378 6478  lit(c('xaxbxcxdx
-00004ac0: 6578 2729 2c20 6328 2761 6263 6465 2729  ex'), c('abcde')
-00004ad0: 2c20 6d61 7873 706c 6974 3d31 292c 2063  , maxsplit=1), c
-00004ae0: 285b 2778 272c 2027 7862 7863 7864 7865  (['x', 'xbxcxdxe
-00004af0: 7827 5d29 290a 2020 2020 2020 2020 2020  x'])).          
-00004b00: 2020 7365 6c66 2e61 7373 6572 7445 7175    self.assertEqu
-00004b10: 616c 286c 6973 745f 6d75 6c74 6973 706c  al(list_multispl
-00004b20: 6974 2863 2827 7861 7862 7863 7864 7865  it(c('xaxbxcxdxe
-00004b30: 7827 292c 2063 2827 6162 6364 6527 292c  x'), c('abcde'),
-00004b40: 206d 6178 7370 6c69 743d 3229 2c20 6328   maxsplit=2), c(
-00004b50: 5b27 7827 2c20 2778 272c 2027 7863 7864  ['x', 'x', 'xcxd
-00004b60: 7865 7827 5d29 290a 2020 2020 2020 2020  xex'])).        
-00004b70: 2020 2020 7365 6c66 2e61 7373 6572 7445      self.assertE
-00004b80: 7175 616c 286c 6973 745f 6d75 6c74 6973  qual(list_multis
-00004b90: 706c 6974 2863 2827 7861 7862 7863 7864  plit(c('xaxbxcxd
-00004ba0: 7865 7827 292c 2063 2827 6162 6364 6527  xex'), c('abcde'
-00004bb0: 292c 206d 6178 7370 6c69 743d 3329 2c20  ), maxsplit=3), 
-00004bc0: 6328 5b27 7827 2c20 2778 272c 2027 7827  c(['x', 'x', 'x'
-00004bd0: 2c20 2778 6478 6578 275d 2929 0a20 2020  , 'xdxex'])).   
-00004be0: 2020 2020 2020 2020 2073 656c 662e 6173           self.as
-00004bf0: 7365 7274 4571 7561 6c28 6c69 7374 5f6d  sertEqual(list_m
-00004c00: 756c 7469 7370 6c69 7428 6328 2778 6178  ultisplit(c('xax
-00004c10: 6278 6378 6478 6578 2729 2c20 6328 2761  bxcxdxex'), c('a
-00004c20: 6263 6465 2729 2c20 6d61 7873 706c 6974  bcde'), maxsplit
-00004c30: 3d34 292c 2063 285b 2778 272c 2027 7827  =4), c(['x', 'x'
-00004c40: 2c20 2778 272c 2027 7827 2c20 2778 6578  , 'x', 'x', 'xex
-00004c50: 275d 2929 0a20 2020 2020 2020 2020 2020  '])).           
-00004c60: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
-00004c70: 6c28 6c69 7374 5f6d 756c 7469 7370 6c69  l(list_multispli
-00004c80: 7428 6328 2778 6178 6278 6378 6478 6578  t(c('xaxbxcxdxex
-00004c90: 2729 2c20 6328 2761 6263 6465 2729 2c20  '), c('abcde'), 
-00004ca0: 6d61 7873 706c 6974 3d35 292c 2063 285b  maxsplit=5), c([
-00004cb0: 2778 272c 2027 7827 2c20 2778 272c 2027  'x', 'x', 'x', '
-00004cc0: 7827 2c20 2778 272c 2027 7827 5d29 290a  x', 'x', 'x'])).
-00004cd0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00004ce0: 2e61 7373 6572 7445 7175 616c 286c 6973  .assertEqual(lis
-00004cf0: 745f 6d75 6c74 6973 706c 6974 2863 2827  t_multisplit(c('
-00004d00: 7861 7862 7863 7864 7865 7827 292c 2063  xaxbxcxdxex'), c
-00004d10: 2827 6162 6364 6527 292c 206d 6178 7370  ('abcde'), maxsp
-00004d20: 6c69 743d 3629 2c20 6328 5b27 7827 2c20  lit=6), c(['x', 
-00004d30: 2778 272c 2027 7827 2c20 2778 272c 2027  'x', 'x', 'x', '
-00004d40: 7827 2c20 2778 275d 2929 0a0a 2020 2020  x', 'x']))..    
-00004d50: 2020 2020 2020 2020 2320 7465 7374 3a20          # test: 
-00004d60: 6772 6565 6479 2073 6570 6172 6174 6f72  greedy separator
-00004d70: 730a 2020 2020 2020 2020 2020 2020 7365  s.            se
-00004d80: 6c66 2e61 7373 6572 7445 7175 616c 286c  lf.assertEqual(l
-00004d90: 6973 745f 6d75 6c74 6973 706c 6974 2863  ist_multisplit(c
-00004da0: 2827 2d61 6263 6465 2d61 6263 2d61 2d61  ('-abcde-abc-a-a
-00004db0: 6263 2d61 6263 6465 2d27 292c 0a20 2020  bc-abcde-'),.   
-00004dc0: 2020 2020 2020 2020 2020 2020 2063 285b               c([
-00004dd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00004de0: 2020 2020 2027 6127 2c20 2761 6227 2c20       'a', 'ab', 
-00004df0: 2761 6263 272c 2027 6162 6364 272c 2027  'abc', 'abcd', '
-00004e00: 6162 6364 6527 2c0a 2020 2020 2020 2020  abcde',.        
-00004e10: 2020 2020 2020 2020 2020 2020 2762 272c              'b',
-00004e20: 2027 6263 272c 2027 6263 6427 2c20 2762   'bc', 'bcd', 'b
-00004e30: 6364 6527 2c0a 2020 2020 2020 2020 2020  cde',.          
-00004e40: 2020 2020 2020 2020 2020 2763 272c 2027            'c', '
-00004e50: 6364 272c 2027 6364 6527 2c0a 2020 2020  cd', 'cde',.    
-00004e60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004e70: 2764 272c 2027 6465 272c 0a20 2020 2020  'd', 'de',.     
-00004e80: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-00004e90: 6527 0a20 2020 2020 2020 2020 2020 2020  e'.             
-00004ea0: 2020 205d 2929 2c0a 2020 2020 2020 2020     ])),.        
-00004eb0: 2020 2020 2020 2020 6328 5b27 2d27 2c20          c(['-', 
-00004ec0: 272d 272c 2027 2d27 2c20 272d 272c 2027  '-', '-', '-', '
-00004ed0: 2d27 2c20 272d 275d 2929 0a20 2020 2020  -', '-'])).     
-00004ee0: 2020 2020 2020 2023 2067 7265 6564 7920         # greedy 
-00004ef0: 776f 726b 7320 7468 6520 7361 6d65 2077  works the same w
-00004f00: 6865 6e20 7265 7665 7273 653d 5472 7565  hen reverse=True
-00004f10: 2c20 6576 656e 2069 6620 6974 206d 6179  , even if it may
-00004f20: 6265 2066 6565 6c73 2061 206c 6974 746c  be feels a littl
-00004f30: 6520 7374 7261 6e67 650a 2020 2020 2020  e strange.      
-00004f40: 2020 2020 2020 7365 6c66 2e61 7373 6572        self.asser
-00004f50: 7445 7175 616c 286c 6973 745f 6d75 6c74  tEqual(list_mult
-00004f60: 6973 706c 6974 2863 2827 2d61 6263 6465  isplit(c('-abcde
-00004f70: 2d61 6263 2d61 2d61 6263 2d61 6263 6465  -abc-a-abc-abcde
-00004f80: 2d27 292c 0a20 2020 2020 2020 2020 2020  -'),.           
-00004f90: 2020 2020 2063 285b 0a20 2020 2020 2020       c([.       
-00004fa0: 2020 2020 2020 2020 2020 2020 2027 6127               'a'
-00004fb0: 2c20 2761 6227 2c20 2761 6263 272c 2027  , 'ab', 'abc', '
-00004fc0: 6162 6364 272c 2027 6162 6364 6527 2c0a  abcd', 'abcde',.
-00004fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004fe0: 2020 2020 2762 272c 2027 6263 272c 2027      'b', 'bc', '
-00004ff0: 6263 6427 2c20 2762 6364 6527 2c0a 2020  bcd', 'bcde',.  
-00005000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005010: 2020 2763 272c 2027 6364 272c 2027 6364    'c', 'cd', 'cd
-00005020: 6527 2c0a 2020 2020 2020 2020 2020 2020  e',.            
-00005030: 2020 2020 2020 2020 2764 272c 2027 6465          'd', 'de
-00005040: 272c 0a20 2020 2020 2020 2020 2020 2020  ',.             
-00005050: 2020 2020 2020 2027 6527 0a20 2020 2020         'e'.     
-00005060: 2020 2020 2020 2020 2020 205d 292c 2072             ]), r
-00005070: 6576 6572 7365 3d54 7275 6529 2c0a 2020  everse=True),.  
-00005080: 2020 2020 2020 2020 2020 2020 2020 6328                c(
-00005090: 5b27 2d27 2c20 272d 272c 2027 2d27 2c20  ['-', '-', '-', 
-000050a0: 272d 272c 2027 2d27 2c20 272d 275d 2929  '-', '-', '-']))
-000050b0: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-000050c0: 7265 6772 6573 7369 6f6e 2074 6573 743a  regression test:
-000050d0: 202a 5945 532a 2c20 6966 2074 6865 2073   *YES*, if the s
-000050e0: 7472 696e 6720 796f 7527 7265 2073 706c  tring you're spl
-000050f0: 6974 7469 6e67 2065 6e64 7320 7769 7468  itting ends with
-00005100: 2061 2073 6570 6172 6174 6f72 2c0a 2020   a separator,.  
-00005110: 2020 2020 2020 2020 2020 2320 616e 6420            # and 
-00005120: 6b65 6570 3d62 6967 2e41 535f 5041 4952  keep=big.AS_PAIR
-00005130: 532c 2074 6865 2072 6573 756c 7420 656e  S, the result en
-00005140: 6473 2077 6974 6820 6120 7475 706c 6520  ds with a tuple 
-00005150: 636f 6e74 6169 6e69 6e67 2074 776f 2065  containing two e
-00005160: 6d70 7479 2073 7472 696e 6773 2e0a 2020  mpty strings..  
-00005170: 2020 2020 2020 2020 2020 7365 6c66 2e61            self.a
-00005180: 7373 6572 7445 7175 616c 286c 6973 745f  ssertEqual(list_
-00005190: 6d75 6c74 6973 706c 6974 2863 2827 5c6e  multisplit(c('\n
-000051a0: 615c 6e62 5c6e 635c 6e27 292c 2063 2828  a\nb\nc\n'), c((
-000051b0: 275c 6e27 2c29 292c 206b 6565 703d 6269  '\n',)), keep=bi
-000051c0: 672e 4153 5f50 4149 5253 2c20 7374 7269  g.AS_PAIRS, stri
-000051d0: 703d 4661 6c73 6529 2c20 6328 5b20 2827  p=False), c([ ('
-000051e0: 272c 2027 5c6e 2729 2c20 2827 6127 2c20  ', '\n'), ('a', 
-000051f0: 275c 6e27 292c 2028 2762 272c 2027 5c6e  '\n'), ('b', '\n
-00005200: 2729 2c20 2827 6327 2c20 275c 6e27 292c  '), ('c', '\n'),
-00005210: 2028 2727 2c20 2727 2920 5d29 290a 0a20   ('', '') ])).. 
-00005220: 2020 2020 2020 2020 2020 2023 2074 6573             # tes
-00005230: 743a 2070 726f 6772 6573 7369 7665 2073  t: progressive s
-00005240: 7472 6970 0a20 2020 2020 2020 2020 2020  trip.           
-00005250: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
-00005260: 6c28 6c69 7374 5f6d 756c 7469 7370 6c69  l(list_multispli
-00005270: 7428 6328 2720 2020 6120 6220 6320 2020  t(c('   a b c   
-00005280: 2729 2c20 6328 2827 2027 2c29 292c 206d  '), c((' ',)), m
-00005290: 6178 7370 6c69 743d 312c 2073 7472 6970  axsplit=1, strip
-000052a0: 3d62 6967 2e50 524f 4752 4553 5349 5645  =big.PROGRESSIVE
-000052b0: 292c 2063 285b 2027 6127 2c20 2762 2063  ), c([ 'a', 'b c
-000052c0: 2020 2027 5d29 290a 0a20 2020 2020 2020     ']))..       
-000052d0: 2020 2020 2023 2072 6567 7265 7373 696f       # regressio
-000052e0: 6e20 7465 7374 3a20 7768 656e 2074 6865  n test: when the
-000052f0: 7265 2061 7265 202a 6f76 6572 6c61 7070  re are *overlapp
-00005300: 696e 672a 2073 6570 6172 6174 6f72 732c  ing* separators,
-00005310: 0a20 2020 2020 2020 2020 2020 2023 206d  .            # m
-00005320: 756c 7469 7370 6c69 7420 7072 6566 6572  ultisplit prefer
-00005330: 7320 7468 6520 6c65 6674 6d6f 7374 206f  s the leftmost o
-00005340: 6e65 2873 292c 2062 7574 2070 6173 7369  ne(s), but passi
-00005350: 6e67 2069 6e0a 2020 2020 2020 2020 2020  ng in.          
-00005360: 2020 2320 7265 7665 7273 653d 5472 7565    # reverse=True
-00005370: 206d 616b 6573 2069 7420 7072 6566 6572   makes it prefer
-00005380: 2074 6865 202a 7269 6768 746d 6f73 742a   the *rightmost*
-00005390: 206f 6e65 732e 0a20 2020 2020 2020 2020   ones..         
-000053a0: 2020 2073 656c 662e 6173 7365 7274 4571     self.assertEq
-000053b0: 7561 6c28 6c69 7374 5f6d 756c 7469 7370  ual(list_multisp
-000053c0: 6c69 7428 6328 2720 7820 7820 2729 2c20  lit(c(' x x '), 
-000053d0: 6328 2827 2078 2027 2c29 292c 206b 6565  c((' x ',)), kee
-000053e0: 703d 6269 672e 414c 5445 524e 4154 494e  p=big.ALTERNATIN
-000053f0: 4729 2c0a 2020 2020 2020 2020 2020 2020  G),.            
-00005400: 2020 2020 6328 5b20 2727 2c20 2720 7820      c([ '', ' x 
-00005410: 272c 2027 7820 275d 2929 0a20 2020 2020  ', 'x '])).     
-00005420: 2020 2020 2020 2073 656c 662e 6173 7365         self.asse
-00005430: 7274 4571 7561 6c28 6c69 7374 5f6d 756c  rtEqual(list_mul
-00005440: 7469 7370 6c69 7428 6328 2720 7820 7820  tisplit(c(' x x 
-00005450: 2729 2c20 6328 2827 2078 2027 2c29 292c  '), c((' x ',)),
-00005460: 206b 6565 703d 6269 672e 414c 5445 524e   keep=big.ALTERN
-00005470: 4154 494e 472c 2072 6576 6572 7365 3d54  ATING, reverse=T
-00005480: 7275 6529 2c0a 2020 2020 2020 2020 2020  rue),.          
-00005490: 2020 2020 2020 6328 5b20 2720 7827 2c20        c([ ' x', 
-000054a0: 2720 7820 272c 2027 275d 2929 0a0a 2020  ' x ', '']))..  
-000054b0: 2020 2020 2020 2020 2020 2320 2727 2e73            # ''.s
-000054c0: 706c 6974 2829 2072 6574 7572 6e73 2061  plit() returns a
-000054d0: 6e20 656d 7074 7920 6c69 7374 2e0a 2020  n empty list..  
-000054e0: 2020 2020 2020 2020 2020 2320 6d75 6c74            # mult
-000054f0: 6973 706c 6974 2069 6e74 656e 7469 6f6e  isplit intention
-00005500: 616c 6c79 2064 6f65 7320 2a6e 6f74 2a20  ally does *not* 
-00005510: 7265 7072 6f64 7563 6520 7468 6973 2069  reproduce this i
-00005520: 6c6c 2d63 6f6e 6369 6576 6564 2062 6568  ll-concieved beh
-00005530: 6176 696f 722e 0a20 2020 2020 2020 2020  avior..         
-00005540: 2020 2023 206d 756c 7469 7370 6c69 7428     # multisplit(
-00005550: 732c 206c 6973 742d 6f66 2d73 6570 6172  s, list-of-separ
-00005560: 6174 6f72 732d 7468 6174 2d64 6f6e 2774  ators-that-don't
-00005570: 2d61 7070 6561 722d 696e 2d73 2920 616c  -appear-in-s) al
-00005580: 7761 7973 2072 6574 7572 6e73 205b 735d  ways returns [s]
-00005590: 2e0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-000055a0: 286f 722c 2072 6174 6865 722c 2061 6e20  (or, rather, an 
-000055b0: 6974 6572 6174 6f72 2074 6861 7420 7969  iterator that yi
-000055c0: 656c 6473 206f 6e6c 7920 7329 2e0a 2020  elds only s)..  
-000055d0: 2020 2020 2020 2020 2020 7365 6c66 2e61            self.a
-000055e0: 7373 6572 7445 7175 616c 286c 6973 745f  ssertEqual(list_
-000055f0: 6d75 6c74 6973 706c 6974 2863 2827 2729  multisplit(c('')
-00005600: 292c 2063 285b 2727 5d29 290a 2020 2020  ), c([''])).    
-00005610: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
-00005620: 6572 7445 7175 616c 286c 6973 745f 6d75  ertEqual(list_mu
-00005630: 6c74 6973 706c 6974 2863 2827 2729 2c20  ltisplit(c(''), 
-00005640: 7265 7665 7273 653d 5472 7565 292c 2063  reverse=True), c
-00005650: 285b 2727 5d29 290a 2020 2020 2020 2020  ([''])).        
-00005660: 2020 2020 2320 7369 6d69 6c61 726c 792c      # similarly,
-00005670: 2027 2020 2020 272e 7370 6c69 7428 2920   '    '.split() 
-00005680: 616c 736f 2072 6574 7572 6e73 2061 6e20  also returns an 
-00005690: 656d 7074 7920 6c69 7374 2c0a 2020 2020  empty list,.    
-000056a0: 2020 2020 2020 2020 2320 616e 6420 6d75          # and mu
-000056b0: 6c74 6973 706c 6974 2064 6f65 7320 6e6f  ltisplit does no
-000056c0: 742e 0a20 2020 2020 2020 2020 2020 2073  t..            s
-000056d0: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
-000056e0: 6c69 7374 5f6d 756c 7469 7370 6c69 7428  list_multisplit(
-000056f0: 6328 2720 2020 2729 292c 2063 285b 2727  c('   ')), c([''
-00005700: 2c20 2727 5d29 290a 2020 2020 2020 2020  , ''])).        
-00005710: 2020 2020 7365 6c66 2e61 7373 6572 7445      self.assertE
-00005720: 7175 616c 286c 6973 745f 6d75 6c74 6973  qual(list_multis
-00005730: 706c 6974 2863 2827 2020 2027 292c 2072  plit(c('   '), r
-00005740: 6576 6572 7365 3d54 7275 6529 2c20 6328  everse=True), c(
-00005750: 5b27 272c 2027 275d 2929 0a0a 2020 2020  ['', '']))..    
-00005760: 2020 2020 2020 2020 7769 7468 2073 656c          with sel
-00005770: 662e 6173 7365 7274 5261 6973 6573 2854  f.assertRaises(T
-00005780: 7970 6545 7272 6f72 293a 0a20 2020 2020  ypeError):.     
-00005790: 2020 2020 2020 2020 2020 206c 6973 745f             list_
-000057a0: 6d75 6c74 6973 706c 6974 2863 2827 7327  multisplit(c('s'
-000057b0: 292c 2033 2e31 3431 3529 0a20 2020 2020  ), 3.1415).     
-000057c0: 2020 2020 2020 2077 6974 6820 7365 6c66         with self
-000057d0: 2e61 7373 6572 7452 6169 7365 7328 5479  .assertRaises(Ty
-000057e0: 7065 4572 726f 7229 3a0a 2020 2020 2020  peError):.      
-000057f0: 2020 2020 2020 2020 2020 6c69 7374 5f6d            list_m
-00005800: 756c 7469 7370 6c69 7428 6328 2773 2729  ultisplit(c('s')
-00005810: 2c20 5b5d 290a 2020 2020 2020 2020 2020  , []).          
-00005820: 2020 7769 7468 2073 656c 662e 6173 7365    with self.asse
-00005830: 7274 5261 6973 6573 2854 7970 6545 7272  rtRaises(TypeErr
-00005840: 6f72 293a 0a20 2020 2020 2020 2020 2020  or):.           
-00005850: 2020 2020 206c 6973 745f 6d75 6c74 6973       list_multis
-00005860: 706c 6974 2863 2827 7327 292c 2028 2929  plit(c('s'), ())
-00005870: 0a20 2020 2020 2020 2020 2020 2077 6974  .            wit
-00005880: 6820 7365 6c66 2e61 7373 6572 7452 6169  h self.assertRai
-00005890: 7365 7328 5479 7065 4572 726f 7229 3a0a  ses(TypeError):.
-000058a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000058b0: 6c69 7374 5f6d 756c 7469 7370 6c69 7428  list_multisplit(
-000058c0: 6328 2773 2729 2c20 6328 2727 2929 0a0a  c('s'), c(''))..
-000058d0: 2020 2020 2020 2020 2020 2020 7769 7468              with
-000058e0: 2073 656c 662e 6173 7365 7274 5261 6973   self.assertRais
-000058f0: 6573 2854 7970 6545 7272 6f72 293a 0a20  es(TypeError):. 
-00005900: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-00005910: 6973 745f 6d75 6c74 6973 706c 6974 2863  ist_multisplit(c
-00005920: 2827 7327 292c 205b 6328 2761 2729 2c20  ('s'), [c('a'), 
-00005930: 6e6f 745f 6328 2762 2729 2c20 6328 2763  not_c('b'), c('c
-00005940: 2729 5d29 0a20 2020 2020 2020 2020 2020  ')]).           
-00005950: 2077 6974 6820 7365 6c66 2e61 7373 6572   with self.asser
-00005960: 7452 6169 7365 7328 5479 7065 4572 726f  tRaises(TypeErro
-00005970: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
-00005980: 2020 2020 6c69 7374 5f6d 756c 7469 7370      list_multisp
-00005990: 6c69 7428 6328 2773 2729 2c20 5b63 2827  lit(c('s'), [c('
-000059a0: 6127 292c 2031 3233 342c 2063 2827 6327  a'), 1234, c('c'
-000059b0: 295d 290a 0a20 2020 2020 2020 2077 6974  )])..        wit
-000059c0: 6820 7365 6c66 2e61 7373 6572 7452 6169  h self.assertRai
-000059d0: 7365 7328 5479 7065 4572 726f 7229 3a0a  ses(TypeError):.
-000059e0: 2020 2020 2020 2020 2020 2020 6c69 7374              list
-000059f0: 5f6d 756c 7469 7370 6c69 7428 2773 272c  _multisplit('s',
-00005a00: 2062 2761 6263 2729 0a20 2020 2020 2020   b'abc').       
-00005a10: 2077 6974 6820 7365 6c66 2e61 7373 6572   with self.asser
-00005a20: 7452 6169 7365 7328 5479 7065 4572 726f  tRaises(TypeErro
-00005a30: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
-00005a40: 6c69 7374 5f6d 756c 7469 7370 6c69 7428  list_multisplit(
-00005a50: 6227 7327 2c20 2761 6263 2729 0a0a 2020  b's', 'abc')..  
-00005a60: 2020 2020 2020 2320 6a75 7374 206d 616b        # just mak
-00005a70: 696e 6720 7375 7265 210a 2020 2020 2020  ing sure!.      
-00005a80: 2020 7769 7468 2073 656c 662e 6173 7365    with self.asse
-00005a90: 7274 5261 6973 6573 2854 7970 6545 7272  rtRaises(TypeErr
-00005aa0: 6f72 293a 0a20 2020 2020 2020 2020 2020  or):.           
-00005ab0: 206c 6973 745f 6d75 6c74 6973 706c 6974   list_multisplit
-00005ac0: 2827 7327 2c20 5b27 6127 2c20 6227 6227  ('s', ['a', b'b'
-00005ad0: 2c20 2763 275d 290a 2020 2020 2020 2020  , 'c']).        
-00005ae0: 7769 7468 2073 656c 662e 6173 7365 7274  with self.assert
-00005af0: 5261 6973 6573 2854 7970 6545 7272 6f72  Raises(TypeError
-00005b00: 293a 0a20 2020 2020 2020 2020 2020 206c  ):.            l
-00005b10: 6973 745f 6d75 6c74 6973 706c 6974 2862  ist_multisplit(b
-00005b20: 2773 272c 205b 6227 6127 2c20 2762 272c  's', [b'a', 'b',
-00005b30: 2062 2763 275d 290a 0a20 2020 2020 2020   b'c'])..       
-00005b40: 2023 2072 6567 7265 7373 696f 6e3a 206d   # regression: m
-00005b50: 756c 7469 7370 6c69 7420 6469 646e 2774  ultisplit didn't
-00005b60: 2075 7365 6420 746f 2076 6572 6966 790a   used to verify.
-00005b70: 2020 2020 2020 2020 2320 7468 6174 2073          # that s
-00005b80: 2077 6173 2065 6974 6865 7220 7374 7220   was either str 
-00005b90: 6f72 2062 7974 6573 2e0a 2020 2020 2020  or bytes..      
-00005ba0: 2020 7769 7468 2073 656c 662e 6173 7365    with self.asse
-00005bb0: 7274 5261 6973 6573 2854 7970 6545 7272  rtRaises(TypeErr
-00005bc0: 6f72 293a 0a20 2020 2020 2020 2020 2020  or):.           
-00005bd0: 206c 6973 745f 6d75 6c74 6973 706c 6974   list_multisplit
-00005be0: 2833 2e31 3431 3529 0a20 2020 2020 2020  (3.1415).       
-00005bf0: 2077 6974 6820 7365 6c66 2e61 7373 6572   with self.asser
-00005c00: 7452 6169 7365 7328 5479 7065 4572 726f  tRaises(TypeErro
-00005c10: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
-00005c20: 6c69 7374 5f6d 756c 7469 7370 6c69 7428  list_multisplit(
-00005c30: 332e 3134 3135 2c20 2761 6263 2729 0a20  3.1415, 'abc'). 
-00005c40: 2020 2020 2020 2077 6974 6820 7365 6c66         with self
-00005c50: 2e61 7373 6572 7452 6169 7365 7328 5479  .assertRaises(Ty
-00005c60: 7065 4572 726f 7229 3a0a 2020 2020 2020  peError):.      
-00005c70: 2020 2020 2020 6c69 7374 5f6d 756c 7469        list_multi
-00005c80: 7370 6c69 7428 5b27 6127 2c20 2762 272c  split(['a', 'b',
-00005c90: 2027 6327 5d29 0a20 2020 2020 2020 2077   'c']).        w
-00005ca0: 6974 6820 7365 6c66 2e61 7373 6572 7452  ith self.assertR
-00005cb0: 6169 7365 7328 5479 7065 4572 726f 7229  aises(TypeError)
-00005cc0: 3a0a 2020 2020 2020 2020 2020 2020 6c69  :.            li
-00005cd0: 7374 5f6d 756c 7469 7370 6c69 7428 5b27  st_multisplit(['
-00005ce0: 6127 2c20 2762 272c 2027 6327 5d2c 2027  a', 'b', 'c'], '
-00005cf0: 6127 290a 0a20 2020 2020 2020 2023 2072  a')..        # r
-00005d00: 6567 7265 7373 696f 6e3a 2069 6620 7265  egression: if re
-00005d10: 7665 7273 653d 5472 7565 2061 6e64 2073  verse=True and s
-00005d20: 6570 6172 6174 6f72 7320 7761 7320 6e6f  eparators was no
-00005d30: 7420 6861 7368 6162 6c65 2c0a 2020 2020  t hashable,.    
-00005d40: 2020 2020 2320 6d75 6c74 6973 706c 6974      # multisplit
-00005d50: 2077 6f75 6c64 2063 7261 7368 2e20 2066   would crash.  f
-00005d60: 6978 6564 2069 6e20 302e 362e 3137 2e0a  ixed in 0.6.17..
-00005d70: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
-00005d80: 6572 7445 7175 616c 286c 6973 745f 6d75  ertEqual(list_mu
-00005d90: 6c74 6973 706c 6974 2827 6178 6279 637a  ltisplit('axbycz
-00005da0: 6427 2c20 5b27 7827 2c20 2779 272c 2027  d', ['x', 'y', '
-00005db0: 7a27 5d2c 206d 6178 7370 6c69 743d 322c  z'], maxsplit=2,
-00005dc0: 2072 6576 6572 7365 3d54 7275 6529 2c20   reverse=True), 
-00005dd0: 5b27 6178 6227 2c20 2763 272c 2027 6427  ['axb', 'c', 'd'
-00005de0: 5d29 0a20 2020 2020 2020 2073 656c 662e  ]).        self.
-00005df0: 6173 7365 7274 4571 7561 6c28 6c69 7374  assertEqual(list
-00005e00: 5f6d 756c 7469 7370 6c69 7428 6227 6178  _multisplit(b'ax
-00005e10: 6279 637a 6427 2c20 5b62 2778 272c 2062  byczd', [b'x', b
-00005e20: 2779 272c 2062 277a 275d 2c20 6d61 7873  'y', b'z'], maxs
-00005e30: 706c 6974 3d32 2c20 7265 7665 7273 653d  plit=2, reverse=
-00005e40: 5472 7565 292c 205b 6227 6178 6227 2c20  True), [b'axb', 
-00005e50: 6227 6327 2c20 6227 6427 5d29 0a0a 2020  b'c', b'd'])..  
-00005e60: 2020 6465 6620 7465 7374 5f61 6476 616e    def test_advan
-00005e70: 6365 645f 6d75 6c74 6973 706c 6974 2873  ced_multisplit(s
-00005e80: 656c 6629 3a0a 2020 2020 2020 2020 6465  elf):.        de
-00005e90: 6620 7369 6d70 6c65 5f74 6573 745f 6d75  f simple_test_mu
-00005ea0: 6c74 6973 706c 6974 2873 2c20 7365 7061  ltisplit(s, sepa
-00005eb0: 7261 746f 7273 2c20 6578 7065 6374 6564  rators, expected
-00005ec0: 2c20 2a2a 6b77 6172 6773 293a 0a20 2020  , **kwargs):.   
-00005ed0: 2020 2020 2020 2020 2066 6f72 205f 2069           for _ i
-00005ee0: 6e20 7261 6e67 6528 3229 3a0a 2020 2020  n range(2):.    
-00005ef0: 2020 2020 2020 2020 2020 2020 6966 205f              if _
-00005f00: 203d 3d20 313a 0a20 2020 2020 2020 2020   == 1:.         
-00005f10: 2020 2020 2020 2020 2020 2023 2065 6e63             # enc
-00005f20: 6f64 6521 0a20 2020 2020 2020 2020 2020  ode!.           
-00005f30: 2020 2020 2020 2020 2073 203d 2073 2e65           s = s.e
-00005f40: 6e63 6f64 6528 2761 7363 6969 2729 0a20  ncode('ascii'). 
-00005f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005f60: 2020 2069 6620 7365 7061 7261 746f 7273     if separators
-00005f70: 203d 3d20 6269 672e 7768 6974 6573 7061   == big.whitespa
-00005f80: 6365 3a0a 2020 2020 2020 2020 2020 2020  ce:.            
-00005f90: 2020 2020 2020 2020 2020 2020 7365 7061              sepa
-00005fa0: 7261 746f 7273 203d 2062 6967 2e61 7363  rators = big.asc
-00005fb0: 6969 5f77 6869 7465 7370 6163 650a 2020  ii_whitespace.  
-00005fc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005fd0: 2020 656c 6966 2069 7369 6e73 7461 6e63    elif isinstanc
-00005fe0: 6528 7365 7061 7261 746f 7273 2c20 7374  e(separators, st
-00005ff0: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
-00006000: 2020 2020 2020 2020 2020 2020 7365 7061              sepa
-00006010: 7261 746f 7273 203d 2073 6570 6172 6174  rators = separat
-00006020: 6f72 732e 656e 636f 6465 2827 6173 6369  ors.encode('asci
-00006030: 6927 290a 2020 2020 2020 2020 2020 2020  i').            
-00006040: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00006050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006060: 2020 2020 2020 7365 7061 7261 746f 7273        separators
-00006070: 203d 2062 6967 2e74 6578 742e 5f63 6865   = big.text._che
-00006080: 6170 5f65 6e63 6f64 655f 6974 6572 6162  ap_encode_iterab
-00006090: 6c65 5f6f 665f 7374 7269 6e67 7328 7365  le_of_strings(se
-000060a0: 7061 7261 746f 7273 290a 2020 2020 2020  parators).      
-000060b0: 2020 2020 2020 2020 2020 2020 2020 6578                ex
-000060c0: 7065 6374 6564 203d 206c 6973 7428 6269  pected = list(bi
-000060d0: 672e 7465 7874 2e5f 6368 6561 705f 656e  g.text._cheap_en
-000060e0: 636f 6465 5f69 7465 7261 626c 655f 6f66  code_iterable_of
-000060f0: 5f73 7472 696e 6773 2865 7870 6563 7465  _strings(expecte
-00006100: 6429 290a 2020 2020 2020 2020 2020 2020  d)).            
-00006110: 2020 2020 2320 7072 696e 7428 290a 2020      # print().  
-00006120: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-00006130: 7072 696e 7428 6622 733d 7b73 7d20 6578  print(f"s={s} ex
-00006140: 7065 6374 6564 3d7b 6578 7065 6374 6564  pected={expected
-00006150: 7d5c 6e73 6570 6172 6174 6f72 733d 7b73  }\nseparators={s
-00006160: 6570 6172 6174 6f72 737d 2229 0a20 2020  eparators}").   
-00006170: 2020 2020 2020 2020 2020 2020 2072 6573               res
-00006180: 756c 7420 3d20 6c69 7374 2862 6967 2e6d  ult = list(big.m
-00006190: 756c 7469 7370 6c69 7428 732c 2073 6570  ultisplit(s, sep
-000061a0: 6172 6174 6f72 732c 202a 2a6b 7761 7267  arators, **kwarg
-000061b0: 7329 290a 2020 2020 2020 2020 2020 2020  s)).            
-000061c0: 2020 2020 7365 6c66 2e61 7373 6572 7445      self.assertE
-000061d0: 7175 616c 2872 6573 756c 742c 2065 7870  qual(result, exp
-000061e0: 6563 7465 6429 0a0a 2020 2020 2020 2020  ected)..        
-000061f0: 666f 7220 6920 696e 2072 616e 6765 2838  for i in range(8
-00006200: 293a 0a20 2020 2020 2020 2020 2020 2073  ):.            s
-00006210: 7061 6365 7320 3d20 2220 2220 2a20 690a  paces = " " * i.
-00006220: 2020 2020 2020 2020 2020 2020 7369 6d70              simp
-00006230: 6c65 5f74 6573 745f 6d75 6c74 6973 706c  le_test_multispl
-00006240: 6974 2873 7061 6365 7320 2b20 2261 2020  it(spaces + "a  
-00006250: 6220 2063 2220 2b20 7370 6163 6573 2c20  b  c" + spaces, 
-00006260: 2822 2022 2c29 2c20 5b27 6127 2c20 2762  (" ",), ['a', 'b
-00006270: 272c 2027 6327 5d2c 2073 7472 6970 3d54  ', 'c'], strip=T
-00006280: 7275 6529 0a20 2020 2020 2020 2020 2020  rue).           
-00006290: 2073 696d 706c 655f 7465 7374 5f6d 756c   simple_test_mul
-000062a0: 7469 7370 6c69 7428 7370 6163 6573 202b  tisplit(spaces +
-000062b0: 2022 6120 2062 2020 6322 202b 2073 7061   "a  b  c" + spa
-000062c0: 6365 732c 2062 6967 2e77 6869 7465 7370  ces, big.whitesp
-000062d0: 6163 652c 205b 2761 272c 2027 6227 2c20  ace, ['a', 'b', 
-000062e0: 2763 275d 2c20 7374 7269 703d 5472 7565  'c'], strip=True
-000062f0: 290a 0a0a 2020 2020 2020 2020 7369 6d70  )...        simp
-00006300: 6c65 5f74 6573 745f 6d75 6c74 6973 706c  le_test_multispl
-00006310: 6974 2822 6669 7273 7420 6c69 6e65 215c  it("first line!\
-00006320: 6e73 6563 6f6e 6420 6c69 6e65 2e5c 6e74  nsecond line.\nt
-00006330: 6869 7264 206c 696e 652e 222c 2062 6967  hird line.", big
-00006340: 2e6e 6577 6c69 6e65 732c 0a20 2020 2020  .newlines,.     
-00006350: 2020 2020 2020 205b 2266 6972 7374 206c         ["first l
-00006360: 696e 6521 222c 2022 7365 636f 6e64 206c  ine!", "second l
-00006370: 696e 652e 222c 2022 7468 6972 6420 6c69  ine.", "third li
-00006380: 6e65 2e22 5d29 0a20 2020 2020 2020 2073  ne."]).        s
-00006390: 696d 706c 655f 7465 7374 5f6d 756c 7469  imple_test_multi
-000063a0: 7370 6c69 7428 2266 6972 7374 206c 696e  split("first lin
-000063b0: 6521 5c6e 7365 636f 6e64 206c 696e 652e  e!\nsecond line.
-000063c0: 5c6e 7468 6972 6420 6c69 6e65 2e5c 6e22  \nthird line.\n"
-000063d0: 2c20 6269 672e 6e65 776c 696e 6573 2c0a  , big.newlines,.
-000063e0: 2020 2020 2020 2020 2020 2020 5b22 6669              ["fi
-000063f0: 7273 7420 6c69 6e65 215c 6e22 2c20 2273  rst line!\n", "s
-00006400: 6563 6f6e 6420 6c69 6e65 2e5c 6e22 2c20  econd line.\n", 
-00006410: 2274 6869 7264 206c 696e 652e 225d 2c20  "third line."], 
-00006420: 6b65 6570 3d54 7275 652c 2073 7472 6970  keep=True, strip
-00006430: 3d54 7275 6529 0a20 2020 2020 2020 2073  =True).        s
-00006440: 696d 706c 655f 7465 7374 5f6d 756c 7469  imple_test_multi
-00006450: 7370 6c69 7428 2266 6972 7374 206c 696e  split("first lin
-00006460: 6521 5c6e 7365 636f 6e64 206c 696e 652e  e!\nsecond line.
-00006470: 5c6e 7468 6972 6420 6c69 6e65 2e5c 6e22  \nthird line.\n"
-00006480: 2c20 6269 672e 6e65 776c 696e 6573 2c0a  , big.newlines,.
-00006490: 2020 2020 2020 2020 2020 2020 5b22 6669              ["fi
-000064a0: 7273 7420 6c69 6e65 215c 6e22 2c20 2273  rst line!\n", "s
-000064b0: 6563 6f6e 6420 6c69 6e65 2e5c 6e22 2c20  econd line.\n", 
-000064c0: 2274 6869 7264 206c 696e 652e 5c6e 222c  "third line.\n",
-000064d0: 2022 225d 2c20 6b65 6570 3d54 7275 652c   ""], keep=True,
-000064e0: 2073 7472 6970 3d46 616c 7365 290a 2020   strip=False).  
-000064f0: 2020 2020 2020 7369 6d70 6c65 5f74 6573        simple_tes
-00006500: 745f 6d75 6c74 6973 706c 6974 2822 6669  t_multisplit("fi
-00006510: 7273 7420 6c69 6e65 215c 6e5c 6e73 6563  rst line!\n\nsec
-00006520: 6f6e 6420 6c69 6e65 2e5c 6e5c 6e5c 6e74  ond line.\n\n\nt
-00006530: 6869 7264 206c 696e 652e 222c 2062 6967  hird line.", big
-00006540: 2e6e 6577 6c69 6e65 732c 0a20 2020 2020  .newlines,.     
-00006550: 2020 2020 2020 205b 2266 6972 7374 206c         ["first l
-00006560: 696e 6521 222c 2027 272c 2022 7365 636f  ine!", '', "seco
-00006570: 6e64 206c 696e 652e 222c 2027 272c 2027  nd line.", '', '
-00006580: 272c 2022 7468 6972 6420 6c69 6e65 2e22  ', "third line."
-00006590: 5d2c 2073 6570 6172 6174 653d 5472 7565  ], separate=True
-000065a0: 290a 2020 2020 2020 2020 7369 6d70 6c65  ).        simple
-000065b0: 5f74 6573 745f 6d75 6c74 6973 706c 6974  _test_multisplit
-000065c0: 2822 6669 7273 7420 6c69 6e65 215c 6e5c  ("first line!\n\
-000065d0: 6e73 6563 6f6e 6420 6c69 6e65 2e5c 6e5c  nsecond line.\n\
-000065e0: 6e5c 6e74 6869 7264 206c 696e 652e 222c  n\nthird line.",
-000065f0: 2062 6967 2e6e 6577 6c69 6e65 732c 0a20   big.newlines,. 
-00006600: 2020 2020 2020 2020 2020 205b 2266 6972             ["fir
-00006610: 7374 206c 696e 6521 5c6e 222c 2027 5c6e  st line!\n", '\n
-00006620: 272c 2022 7365 636f 6e64 206c 696e 652e  ', "second line.
-00006630: 5c6e 222c 2027 5c6e 272c 2027 5c6e 272c  \n", '\n', '\n',
-00006640: 2022 7468 6972 6420 6c69 6e65 2e22 5d2c   "third line."],
-00006650: 206b 6565 703d 5472 7565 2c20 7365 7061   keep=True, sepa
-00006660: 7261 7465 3d54 7275 6529 0a0a 0a20 2020  rate=True)...   
-00006670: 2020 2020 2073 696d 706c 655f 7465 7374       simple_test
-00006680: 5f6d 756c 7469 7370 6c69 7428 2261 2c62  _multisplit("a,b
-00006690: 2c2c 2c63 222c 2022 2c22 2c20 5b27 6127  ,,,c", ",", ['a'
-000066a0: 2c20 2762 272c 2027 272c 2027 272c 2027  , 'b', '', '', '
-000066b0: 6327 5d2c 2073 6570 6172 6174 653d 5472  c'], separate=Tr
-000066c0: 7565 290a 0a20 2020 2020 2020 2073 696d  ue)..        sim
-000066d0: 706c 655f 7465 7374 5f6d 756c 7469 7370  ple_test_multisp
-000066e0: 6c69 7428 2261 2c62 2c2c 2c63 222c 2028  lit("a,b,,,c", (
-000066f0: 222c 222c 292c 205b 2761 272c 2027 6227  ",",), ['a', 'b'
-00006700: 2c20 272c 2c63 275d 2c20 7365 7061 7261  , ',,c'], separa
-00006710: 7465 3d54 7275 652c 206d 6178 7370 6c69  te=True, maxspli
-00006720: 743d 3229 0a0a 2020 2020 2020 2020 7369  t=2)..        si
-00006730: 6d70 6c65 5f74 6573 745f 6d75 6c74 6973  mple_test_multis
-00006740: 706c 6974 2822 612c 622c 2c2c 6322 2c20  plit("a,b,,,c", 
-00006750: 2822 2c22 2c29 2c20 5b27 612c 622c 272c  (",",), ['a,b,',
-00006760: 2027 272c 2027 6327 5d2c 2073 6570 6172   '', 'c'], separ
-00006770: 6174 653d 5472 7565 2c20 6d61 7873 706c  ate=True, maxspl
-00006780: 6974 3d32 2c20 7265 7665 7273 653d 5472  it=2, reverse=Tr
-00006790: 7565 290a 0a20 2020 2064 6566 2074 6573  ue)..    def tes
-000067a0: 745f 6d75 6c74 6973 706c 6974 5f65 7868  t_multisplit_exh
-000067b0: 6175 7374 6976 656c 7928 7365 6c66 293a  austively(self):
-000067c0: 0a20 2020 2020 2020 2064 6566 206d 756c  .        def mul
-000067d0: 7469 7370 6c69 745f 7465 7374 6572 282a  tisplit_tester(*
-000067e0: 7365 676d 656e 7473 293a 0a20 2020 2020  segments):.     
-000067f0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00006800: 2020 2020 2020 2073 6567 6d65 6e74 7320         segments 
-00006810: 7265 7072 6573 656e 7420 7370 6c69 742d  represent split-
-00006820: 7570 2074 6578 7420 7365 676d 656e 7473  up text segments
-00006830: 2e0a 2020 2020 2020 2020 2020 2020 6561  ..            ea
-00006840: 6368 2073 6567 6d65 6e74 2069 7320 6569  ch segment is ei
-00006850: 7468 6572 0a20 2020 2020 2020 2020 2020  ther.           
-00006860: 2020 2061 2920 6120 7374 7269 6e67 2061     a) a string a
-00006870: 7070 6561 7269 6e67 2069 6e20 7365 7061  ppearing in sepa
-00006880: 7261 746f 7273 2c20 6f72 0a20 2020 2020  rators, or.     
-00006890: 2020 2020 2020 2020 2062 2920 636f 6e74           b) cont
-000068a0: 6169 6e73 206e 6f20 7365 7061 7261 746f  ains no separato
-000068b0: 7273 2061 7420 616c 6c2e 0a20 2020 2020  rs at all..     
-000068c0: 2020 2020 2020 2073 6567 6d65 6e74 7320         segments 
-000068d0: 2a6d 7573 742a 2061 6c74 6572 6e61 7465  *must* alternate
-000068e0: 2062 6574 7765 656e 2061 2920 616e 6420   between a) and 
-000068f0: 6229 2e0a 2020 2020 2020 2020 2020 2020  b)..            
-00006900: 7365 676d 656e 7473 2064 6f65 736e 2774  segments doesn't
-00006910: 206e 6565 6420 746f 2073 7461 7274 206f   need to start o
-00006920: 7220 656e 6420 7769 7468 2065 6d70 7479  r end with empty
-00006930: 2073 7472 696e 6773 2e0a 0a20 2020 2020   strings...     
-00006940: 2020 2020 2020 2074 6865 206c 6173 7420         the last 
-00006950: 706f 7369 7469 6f6e 616c 2061 7267 756d  positional argum
-00006960: 656e 7420 6973 2061 6374 7561 6c6c 7920  ent is actually 
-00006970: 2273 6570 6172 6174 6f72 7322 2e0a 2020  "separators"..  
-00006980: 2020 2020 2020 2020 2020 6173 2069 6e2c            as in,
-00006990: 2074 6865 2073 6570 6172 6174 6f72 7320   the separators 
-000069a0: 6172 6775 6d65 6e74 2066 6f72 206d 756c  argument for mul
-000069b0: 7469 7370 6c69 742e 0a0a 2020 2020 2020  tisplit...      
-000069c0: 2020 2020 2020 7465 7374 7320 4576 6572        tests Ever
-000069d0: 792e 2050 6f73 7369 626c 652e 2050 6572  y. Possible. Per
-000069e0: 6d75 7461 7469 6f6e 2e20 6f66 2069 6e70  mutation. of inp
-000069f0: 7574 7320 746f 206d 756c 7469 7370 6c69  uts to multispli
-00006a00: 7428 292c 0a20 2020 2020 2020 2020 2020  t(),.           
-00006a10: 2062 6173 6564 206f 6e20 7468 6520 7365   based on the se
-00006a20: 676d 656e 7473 2079 6f75 2070 6173 7320  gments you pass 
-00006a30: 696e 2e20 2074 6869 7320 696e 636c 7564  in.  this includ
-00006a40: 6573 0a20 2020 2020 2020 2020 2020 2020  es.             
-00006a50: 2020 202a 2061 7320 7374 7269 6e67 7320     * as strings 
-00006a60: 616e 6420 656e 636f 6465 6420 746f 2062  and encoded to b
-00006a70: 7974 6573 2028 6173 6369 6929 0a20 2020  ytes (ascii).   
-00006a80: 2020 2020 2020 2020 2020 2020 202a 2077               * w
-00006a90: 6974 6820 616e 6420 7769 7468 6f75 7420  ith and without 
-00006aa0: 7468 6520 6c65 6674 2073 6570 6172 6174  the left separat
-00006ab0: 6f72 730a 2020 2020 2020 2020 2020 2020  ors.            
-00006ac0: 2020 2020 2a20 7769 7468 2061 6e64 2077      * with and w
-00006ad0: 6974 686f 7574 2074 6865 2072 6967 6874  ithout the right
-00006ae0: 2073 6570 6172 6174 6f72 730a 2020 2020   separators.    
-00006af0: 2020 2020 2020 2020 2020 2020 2a20 7769              * wi
-00006b00: 7468 2065 7665 7279 2063 6f6d 6269 6e61  th every combina
-00006b10: 7469 6f6e 206f 6620 6576 6572 7920 7661  tion of every va
-00006b20: 6c75 6520 6f66 0a20 2020 2020 2020 2020  lue of.         
-00006b30: 2020 2020 2020 2020 2020 202a 206b 6565             * kee
-00006b40: 700a 2020 2020 2020 2020 2020 2020 2020  p.              
-00006b50: 2020 2020 2020 2a20 6d61 7873 706c 6974        * maxsplit
-00006b60: 2028 616c 6c20 7661 6c75 6573 2074 6861   (all values tha
-00006b70: 7420 7072 6f64 7563 6520 6469 6666 6572  t produce differ
-00006b80: 656e 7420 7265 7375 6c74 732c 2070 6c75  ent results, plu
-00006b90: 7320 6120 636f 7570 6c65 2065 7874 7261  s a couple extra
-00006ba0: 204a 7573 7420 496e 2043 6173 6529 0a20   Just In Case). 
-00006bb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006bc0: 2020 202a 2072 6576 6572 7365 0a20 2020     * reverse.   
-00006bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006be0: 202a 2073 6570 6172 6174 650a 2020 2020   * separate.    
-00006bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006c00: 2a20 7374 7269 700a 0a20 2020 2020 2020  * strip..       
-00006c10: 2020 2020 2070 2e73 2069 7427 7320 6120       p.s it's a 
-00006c20: 6c69 7474 6c65 2073 6c6f 7721 2020 6275  little slow!  bu
-00006c30: 7420 6974 2773 2064 6f69 6e67 2061 206c  t it's doing a l
-00006c40: 6f74 2e0a 2020 2020 2020 2020 2020 2020  ot..            
-00006c50: 2222 220a 0a20 2020 2020 2020 2020 2020  """..           
-00006c60: 2023 2077 616e 745f 7072 696e 7473 203d   # want_prints =
-00006c70: 2054 7275 650a 2020 2020 2020 2020 2020   True.          
-00006c80: 2020 7761 6e74 5f70 7269 6e74 7320 3d20    want_prints = 
-00006c90: 4661 6c73 650a 0a20 2020 2020 2020 2020  False..         
-00006ca0: 2020 2069 6620 7761 6e74 5f70 7269 6e74     if want_print
-00006cb0: 733a 2023 2070 7261 676d 613a 206e 6f20  s: # pragma: no 
-00006cc0: 636f 7665 720a 2020 2020 2020 2020 2020  cover.          
-00006cd0: 2020 2020 2020 7072 696e 7428 225f 2220        print("_" 
-00006ce0: 2a20 3639 290a 2020 2020 2020 2020 2020  * 69).          
-00006cf0: 2020 2020 2020 7072 696e 7428 290a 2020        print().  
-00006d00: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-00006d10: 696e 7428 2274 6573 7420 6578 6861 7573  int("test exhaus
-00006d20: 7469 7665 6c79 2229 0a20 2020 2020 2020  tively").       
-00006d30: 2020 2020 2020 2020 2070 7269 6e74 2822           print("
-00006d40: 5f22 202a 2036 3929 0a0a 2020 2020 2020  _" * 69)..      
-00006d50: 2020 2020 2020 7365 676d 656e 7473 203d        segments =
-00006d60: 206c 6973 7428 7365 676d 656e 7473 290a   list(segments).
-00006d70: 2020 2020 2020 2020 2020 2020 7365 7061              sepa
-00006d80: 7261 746f 7273 203d 2073 6567 6d65 6e74  rators = segment
-00006d90: 732e 706f 7028 290a 0a20 2020 2020 2020  s.pop()..       
-00006da0: 2020 2020 2069 6620 7365 7061 7261 746f       if separato
-00006db0: 7273 2069 7320 6e6f 7420 4e6f 6e65 3a0a  rs is not None:.
-00006dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006dd0: 7365 7061 7261 746f 7273 5f73 6574 203d  separators_set =
-00006de0: 2073 6574 2873 6570 6172 6174 6f72 7329   set(separators)
-00006df0: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
-00006e00: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00006e10: 2020 2073 6570 6172 6174 6f72 735f 7365     separators_se
-00006e20: 7420 3d20 7365 7428 6269 672e 7768 6974  t = set(big.whit
-00006e30: 6573 7061 6365 290a 2020 2020 2020 2020  espace).        
-00006e40: 2020 2020 6173 7365 7274 2027 2720 6e6f      assert '' no
-00006e50: 7420 696e 2073 6570 6172 6174 6f72 735f  t in separators_
-00006e60: 7365 740a 0a20 2020 2020 2020 2020 2020  set..           
-00006e70: 2023 2073 7472 6970 206f 6666 2074 6865   # strip off the
-00006e80: 206c 6561 6469 6e67 2061 6e64 2074 7261   leading and tra
-00006e90: 696c 696e 6720 7365 7061 7261 746f 7273  iling separators
-00006ea0: 2e0a 0a20 2020 2020 2020 2020 2020 2023  ...            #
-00006eb0: 206c 6561 6469 6e67 206c 6f6f 6b73 206c   leading looks l
-00006ec0: 696b 6520 7468 6973 3a0a 2020 2020 2020  ike this:.      
-00006ed0: 2020 2020 2020 2320 2020 5b20 2727 2c20        #   [ '', 
-00006ee0: 7365 7061 7261 746f 722c 2073 6570 6172  separator, separ
-00006ef0: 6174 6f72 2c20 7365 7061 7261 746f 722c  ator, separator,
-00006f00: 202e 2e2e 205d 0a20 2020 2020 2020 2020   ... ].         
-00006f10: 2020 2023 2079 6573 2c20 7468 6174 2069     # yes, that i
-00006f20: 7320 616c 7761 7973 2061 6e20 656d 7074  s always an empt
-00006f30: 7920 7374 7269 6e67 2c20 796f 7527 6c6c  y string, you'll
-00006f40: 2073 6565 2077 6879 0a20 2020 2020 2020   see why.       
-00006f50: 2020 2020 2023 2069 6e20 6120 6d6f 6d65       # in a mome
-00006f60: 6e74 2e0a 0a20 2020 2020 2020 2020 2020  nt...           
-00006f70: 206c 6561 6469 6e67 203d 205b 2727 5d0a   leading = [''].
-00006f80: 2020 2020 2020 2020 2020 2020 7768 696c              whil
-00006f90: 6520 5472 7565 3a0a 2020 2020 2020 2020  e True:.        
-00006fa0: 2020 2020 2020 2020 6966 2073 6567 6d65          if segme
-00006fb0: 6e74 735b 305d 206e 6f74 2069 6e20 7365  nts[0] not in se
-00006fc0: 7061 7261 746f 7273 5f73 6574 3a0a 2020  parators_set:.  
-00006fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006fe0: 2020 6272 6561 6b0a 2020 2020 2020 2020    break.        
-00006ff0: 2020 2020 2020 2020 6c65 6164 696e 672e          leading.
-00007000: 6170 7065 6e64 2873 6567 6d65 6e74 732e  append(segments.
-00007010: 706f 7028 3029 290a 0a20 2020 2020 2020  pop(0))..       
-00007020: 2020 2020 2023 2074 7261 696c 696e 6720       # trailing 
-00007030: 636f 6e74 6169 6e73 206a 7573 7420 7468  contains just th
-00007040: 6520 7472 6169 6c69 6e67 2028 7269 6768  e trailing (righ
-00007050: 7429 0a20 2020 2020 2020 2020 2020 2023  t).            #
-00007060: 2073 6570 6172 6174 6f72 732c 2061 7320   separators, as 
-00007070: 696e 6469 7669 6475 616c 2073 7472 696e  individual strin
-00007080: 6773 2e0a 2020 2020 2020 2020 2020 2020  gs..            
-00007090: 2320 7472 6169 6c69 6e67 206a 7573 7420  # trailing just 
-000070a0: 6c6f 6f6b 7320 6c69 6b65 2074 6869 733a  looks like this:
-000070b0: 0a20 2020 2020 2020 2020 2020 2023 2020  .            #  
-000070c0: 205b 2073 6570 6172 6174 6f72 2c20 7365   [ separator, se
-000070d0: 7061 7261 746f 722c 202e 2e2e 205d 0a0a  parator, ... ]..
-000070e0: 2020 2020 2020 2020 2020 2020 7472 6169              trai
-000070f0: 6c69 6e67 203d 205b 5d0a 2020 2020 2020  ling = [].      
-00007100: 2020 2020 2020 7768 696c 6520 5472 7565        while True
-00007110: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00007120: 2020 6966 2077 616e 745f 7072 696e 7473    if want_prints
-00007130: 3a20 2320 7072 6167 6d61 3a20 6e6f 2063  : # pragma: no c
-00007140: 6f76 6572 0a20 2020 2020 2020 2020 2020  over.           
-00007150: 2020 2020 2020 2020 2070 7269 6e74 2866           print(f
-00007160: 2273 706c 6974 7469 6e67 2073 6567 6d65  "splitting segme
-00007170: 6e74 733a 2073 6567 6d65 6e74 735b 2d31  nts: segments[-1
-00007180: 5d3d 7b73 6567 6d65 6e74 735b 2d31 5d7d  ]={segments[-1]}
-00007190: 2073 6570 6172 6174 6f72 735f 7365 743d   separators_set=
-000071a0: 7b73 6570 6172 6174 6f72 735f 7365 747d  {separators_set}
-000071b0: 206e 6f74 2069 6e3f 207b 7365 676d 656e   not in? {segmen
-000071c0: 7473 5b2d 315d 206e 6f74 2069 6e20 7365  ts[-1] not in se
-000071d0: 7061 7261 746f 7273 5f73 6574 7d22 290a  parators_set}").
-000071e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000071f0: 6966 2073 6567 6d65 6e74 735b 2d31 5d20  if segments[-1] 
-00007200: 6e6f 7420 696e 2073 6570 6172 6174 6f72  not in separator
-00007210: 735f 7365 743a 0a20 2020 2020 2020 2020  s_set:.         
-00007220: 2020 2020 2020 2020 2020 2062 7265 616b             break
-00007230: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007240: 2074 7261 696c 696e 672e 6170 7065 6e64   trailing.append
-00007250: 2873 6567 6d65 6e74 732e 706f 7028 2929  (segments.pop())
-00007260: 0a20 2020 2020 2020 2020 2020 2074 7261  .            tra
-00007270: 696c 696e 672e 7265 7665 7273 6528 290a  iling.reverse().
-00007280: 0a20 2020 2020 2020 2020 2020 2023 2073  .            # s
-00007290: 706c 6974 7320 6973 2061 206c 6973 7420  plits is a list 
-000072a0: 6f66 206c 6973 7473 2e20 2065 6163 6820  of lists.  each 
-000072b0: 7375 626c 6973 742c 206f 7220 2273 706c  sublist, or "spl
-000072c0: 6974 222c 0a20 2020 2020 2020 2020 2020  it",.           
-000072d0: 2023 2069 6e73 6964 6520 7370 6c69 7473   # inside splits
-000072e0: 2c20 6c6f 6f6b 7320 6c69 6b65 2074 6869  , looks like thi
-000072f0: 733a 0a20 2020 2020 2020 2020 2020 2023  s:.            #
-00007300: 2020 205b 206e 6f6e 2d73 6570 6172 6174     [ non-separat
-00007310: 6f72 2d73 7472 696e 672c 2073 6570 6172  or-string, separ
-00007320: 6174 6f72 2c20 7365 7061 7261 746f 722c  ator, separator,
-00007330: 202e 2e2e 205d 0a20 2020 2020 2020 2020   ... ].         
-00007340: 2020 2023 2028 7965 732c 206c 6561 6469     # (yes, leadi
-00007350: 6e67 2061 6e64 2061 6e20 696e 6469 7669  ng and an indivi
-00007360: 6475 616c 2073 706c 6974 206c 6973 7420  dual split list 
-00007370: 6c6f 6f6b 2069 6465 6e74 6963 616c 2c20  look identical, 
-00007380: 7468 6174 2773 2077 6879 2e29 0a20 2020  that's why.).   
-00007390: 2020 2020 2020 2020 2023 2065 7665 7279           # every
-000073a0: 2073 706c 6974 2069 6e20 7370 6c69 7473   split in splits
-000073b0: 2069 7320 6861 7320 6174 206c 6561 7374   is has at least
-000073c0: 206f 6e65 2073 6570 6172 6174 6f72 0a20   one separator. 
-000073d0: 2020 2020 2020 2020 2020 2023 2045 5843             # EXC
-000073e0: 4550 5420 7468 6520 6c61 7374 206f 6e65  EPT the last one
-000073f0: 2077 6869 6368 206f 6e6c 7920 6861 7320   which only has 
-00007400: 7468 6520 6e6f 6e2d 7365 7020 7374 7269  the non-sep stri
-00007410: 6e67 2e0a 2020 2020 2020 2020 2020 2020  ng..            
-00007420: 230a 2020 2020 2020 2020 2020 2020 2320  #.            # 
-00007430: 7468 6973 2069 7320 6f6e 6c79 2061 6e20  this is only an 
-00007440: 696e 7465 726d 6564 6961 7465 2066 6f72  intermediate for
-00007450: 6d2c 2077 6527 6c6c 206d 6173 7361 6765  m, we'll massage
-00007460: 2074 6869 730a 2020 2020 2020 2020 2020   this.          
-00007470: 2020 2320 696e 746f 2061 206d 6f72 6520    # into a more 
-00007480: 7573 6566 756c 2066 6f72 6d20 696e 2061  useful form in a
-00007490: 206d 696e 7574 652e 0a20 2020 2020 2020   minute..       
-000074a0: 2020 2020 2073 706c 6974 7320 3d20 5b5d       splits = []
-000074b0: 0a20 2020 2020 2020 2020 2020 2073 706c  .            spl
-000074c0: 6974 203d 205b 5d0a 2020 2020 2020 2020  it = [].        
-000074d0: 2020 2020 6465 6620 666c 7573 6828 293a      def flush():
-000074e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000074f0: 206e 6f6e 6c6f 6361 6c20 7370 6c69 740a   nonlocal split.
-00007500: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007510: 6966 2073 706c 6974 3a0a 2020 2020 2020  if split:.      
-00007520: 2020 2020 2020 2020 2020 2020 2020 7370                sp
-00007530: 6c69 7473 2e61 7070 656e 6428 7370 6c69  lits.append(spli
-00007540: 7429 0a20 2020 2020 2020 2020 2020 2020  t).             
-00007550: 2020 2020 2020 2073 706c 6974 203d 205b         split = [
-00007560: 5d0a 0a20 2020 2020 2020 2020 2020 2066  ]..            f
-00007570: 6f72 2073 6567 6d65 6e74 2069 6e20 7365  or segment in se
-00007580: 676d 656e 7473 3a0a 2020 2020 2020 2020  gments:.        
-00007590: 2020 2020 2020 2020 6966 2073 6567 6d65          if segme
-000075a0: 6e74 2069 6e20 7365 7061 7261 746f 7273  nt in separators
-000075b0: 5f73 6574 3a0a 2020 2020 2020 2020 2020  _set:.          
-000075c0: 2020 2020 2020 2020 2020 6173 7365 7274            assert
-000075d0: 2073 706c 6974 0a20 2020 2020 2020 2020   split.         
-000075e0: 2020 2020 2020 2020 2020 2073 706c 6974             split
-000075f0: 2e61 7070 656e 6428 7365 676d 656e 7429  .append(segment)
-00007600: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007610: 2020 2020 2063 6f6e 7469 6e75 650a 2020       continue.  
-00007620: 2020 2020 2020 2020 2020 2020 2020 6173                as
-00007630: 7365 7274 2028 6e6f 7420 7370 6c69 7429  sert (not split)
-00007640: 206f 7220 2873 706c 6974 5b2d 315d 2069   or (split[-1] i
-00007650: 6e20 7365 7061 7261 746f 7273 5f73 6574  n separators_set
-00007660: 292c 2066 2273 706c 6974 3d7b 7370 6c69  ), f"split={spli
-00007670: 747d 2073 706c 6974 5b2d 315d 3d7b 7370  t} split[-1]={sp
-00007680: 6c69 745b 2d31 5d7d 2073 6570 6172 6174  lit[-1]} separat
-00007690: 6f72 735f 7365 743d 7b73 6570 6172 6174  ors_set={separat
-000076a0: 6f72 735f 7365 747d 220a 2020 2020 2020  ors_set}".      
-000076b0: 2020 2020 2020 2020 2020 666c 7573 6828            flush(
-000076c0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-000076d0: 2020 7370 6c69 742e 6170 7065 6e64 2873    split.append(s
-000076e0: 6567 6d65 6e74 290a 2020 2020 2020 2020  egment).        
-000076f0: 2020 2020 666c 7573 6828 290a 0a20 2020      flush()..   
-00007700: 2020 2020 2020 2020 2069 6620 7761 6e74           if want
-00007710: 5f70 7269 6e74 733a 2023 2070 7261 676d  _prints: # pragm
-00007720: 613a 206e 6f20 636f 7665 720a 2020 2020  a: no cover.    
-00007730: 2020 2020 2020 2020 2020 2020 7072 696e              prin
-00007740: 7428 6622 6c65 6164 696e 673d 7b6c 6561  t(f"leading={lea
-00007750: 6469 6e67 7d22 290a 2020 2020 2020 2020  ding}").        
-00007760: 2020 2020 2020 2020 7072 696e 7428 6622          print(f"
-00007770: 7370 6c69 7473 3d7b 7370 6c69 7473 7d22  splits={splits}"
-00007780: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00007790: 2020 7072 696e 7428 6622 7472 6169 6c69    print(f"traili
-000077a0: 6e67 3d7b 7472 6169 6c69 6e67 7d22 290a  ng={trailing}").
-000077b0: 2020 2020 2020 2020 2020 2020 6173 7365              asse
-000077c0: 7274 2073 706c 6974 735b 2d31 5d5b 2d31  rt splits[-1][-1
-000077d0: 5d20 6e6f 7420 696e 2073 6570 6172 6174  ] not in separat
-000077e0: 6f72 735f 7365 742c 2066 2273 706c 6974  ors_set, f"split
-000077f0: 735b 2d31 5d5b 2d31 5d3d 7b73 706c 6974  s[-1][-1]={split
-00007800: 735b 2d31 5d5b 2d31 5d7d 2069 7320 696e  s[-1][-1]} is in
-00007810: 2073 6570 6172 6174 6f72 735f 7365 743d   separators_set=
-00007820: 7b73 6570 6172 6174 6f72 735f 7365 747d  {separators_set}
-00007830: 2122 0a0a 2020 2020 2020 2020 2020 2020  !"..            
-00007840: 2320 6c65 6164 696e 6720 616e 6420 7472  # leading and tr
-00007850: 6169 6c69 6e67 206d 7573 7420 626f 7468  ailing must both
-00007860: 2068 6176 6520 6174 206c 6561 7374 0a20   have at least. 
-00007870: 2020 2020 2020 2020 2020 2023 206f 6e65             # one
-00007880: 2073 6570 2073 7472 696e 672e 0a20 2020   sep string..   
-00007890: 2020 2020 2020 2020 2061 7373 6572 7420           assert 
-000078a0: 286c 656e 286c 6561 6469 6e67 2920 3e3d  (len(leading) >=
-000078b0: 2032 2920 616e 6420 7472 6169 6c69 6e67   2) and trailing
-000078c0: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-000078d0: 6e6f 7465 206f 6e65 2069 6e76 6172 6961  note one invaria
-000078e0: 6e74 3a20 6966 2079 6f75 206a 6f69 6e20  nt: if you join 
-000078f0: 6c65 6164 696e 672c 2073 706c 6974 732c  leading, splits,
-00007900: 2061 6e64 2074 7261 696c 696e 670a 2020   and trailing.  
-00007910: 2020 2020 2020 2020 2020 2320 746f 6765            # toge
-00007920: 7468 6572 2069 6e74 6f20 6f6e 6520 6269  ther into one bi
-00007930: 6720 7374 7269 6e67 2c20 6974 2069 7320  g string, it is 
-00007940: 6f75 7220 6f72 6967 696e 616c 2069 6e70  our original inp
-00007950: 7574 2073 7472 696e 672e 0a20 2020 2020  ut string..     
-00007960: 2020 2020 2020 2023 2074 6861 7420 7769         # that wi
-00007970: 6c6c 206e 6576 6572 2063 6861 6e67 652e  ll never change.
-00007980: 0a0a 2020 2020 2020 2020 2020 2020 6f72  ..            or
-00007990: 6967 696e 616c 7320 3d20 6c65 6164 696e  iginals = leadin
-000079a0: 672c 2073 706c 6974 732c 2074 7261 696c  g, splits, trail
-000079b0: 696e 670a 0a20 2020 2020 2020 2020 2020  ing..           
-000079c0: 2066 6f72 2061 735f 6279 7465 7320 696e   for as_bytes in
-000079d0: 2028 4661 6c73 652c 2054 7275 6529 3a0a   (False, True):.
-000079e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000079f0: 6966 2077 616e 745f 7072 696e 7473 3a20  if want_prints: 
-00007a00: 2320 7072 6167 6d61 3a20 6e6f 2063 6f76  # pragma: no cov
-00007a10: 6572 0a20 2020 2020 2020 2020 2020 2020  er.             
-00007a20: 2020 2020 2020 2070 7269 6e74 2866 225b         print(f"[
-00007a30: 6c6f 6f70 2030 5d20 6173 5f62 7974 6573  loop 0] as_bytes
-00007a40: 3d7b 6173 5f62 7974 6573 7d22 290a 2020  ={as_bytes}").  
-00007a50: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00007a60: 2061 735f 6279 7465 733a 0a20 2020 2020   as_bytes:.     
-00007a70: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-00007a80: 6561 6469 6e67 2c20 7370 6c69 7473 2c20  eading, splits, 
-00007a90: 7472 6169 6c69 6e67 203d 2063 6f70 792e  trailing = copy.
-00007aa0: 6465 6570 636f 7079 286f 7269 6769 6e61  deepcopy(origina
-00007ab0: 6c73 290a 2020 2020 2020 2020 2020 2020  ls).            
-00007ac0: 2020 2020 2020 2020 6c65 6164 696e 6720          leading 
-00007ad0: 3d20 6269 672e 7465 7874 2e5f 6368 6561  = big.text._chea
-00007ae0: 705f 656e 636f 6465 5f69 7465 7261 626c  p_encode_iterabl
-00007af0: 655f 6f66 5f73 7472 696e 6773 286c 6561  e_of_strings(lea
-00007b00: 6469 6e67 290a 2020 2020 2020 2020 2020  ding).          
-00007b10: 2020 2020 2020 2020 2020 7370 6c69 7473            splits
-00007b20: 203d 205b 6269 672e 7465 7874 2e5f 6368   = [big.text._ch
-00007b30: 6561 705f 656e 636f 6465 5f69 7465 7261  eap_encode_itera
-00007b40: 626c 655f 6f66 5f73 7472 696e 6773 2873  ble_of_strings(s
-00007b50: 706c 6974 2920 666f 7220 7370 6c69 7420  plit) for split 
-00007b60: 696e 2073 706c 6974 735d 0a20 2020 2020  in splits].     
-00007b70: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-00007b80: 7261 696c 696e 6720 3d20 6269 672e 7465  railing = big.te
-00007b90: 7874 2e5f 6368 6561 705f 656e 636f 6465  xt._cheap_encode
-00007ba0: 5f69 7465 7261 626c 655f 6f66 5f73 7472  _iterable_of_str
-00007bb0: 696e 6773 2874 7261 696c 696e 6729 0a20  ings(trailing). 
-00007bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007bd0: 2020 206f 7269 6769 6e61 6c73 203d 205b     originals = [
-00007be0: 6c65 6164 696e 672c 2073 706c 6974 732c  leading, splits,
-00007bf0: 2074 7261 696c 696e 675d 0a20 2020 2020   trailing].     
-00007c00: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-00007c10: 6d70 7479 203d 2062 2727 0a20 2020 2020  mpty = b''.     
-00007c20: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00007c30: 6620 7365 7061 7261 746f 7273 2069 7320  f separators is 
-00007c40: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-00007c50: 2020 2020 2020 2020 2020 2020 2020 7365                se
-00007c60: 7061 7261 746f 7273 5f73 6574 203d 2073  parators_set = s
-00007c70: 6574 2862 6967 2e61 7363 6969 5f77 6869  et(big.ascii_whi
-00007c80: 7465 7370 6163 6529 0a20 2020 2020 2020  tespace).       
-00007c90: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-00007ca0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00007cb0: 2020 2020 2020 2020 2020 2073 6570 6172             separ
-00007cc0: 6174 6f72 7320 3d20 6269 672e 7465 7874  ators = big.text
-00007cd0: 2e5f 6368 6561 705f 656e 636f 6465 5f69  ._cheap_encode_i
-00007ce0: 7465 7261 626c 655f 6f66 5f73 7472 696e  terable_of_strin
-00007cf0: 6773 2873 6570 6172 6174 6f72 7329 0a20  gs(separators). 
-00007d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007d10: 2020 2020 2020 2073 6570 6172 6174 6f72         separator
-00007d20: 735f 7365 7420 3d20 7365 7428 7365 7061  s_set = set(sepa
-00007d30: 7261 746f 7273 290a 2020 2020 2020 2020  rators).        
-00007d40: 2020 2020 2020 2020 2020 2020 6e6f 6e5f              non_
-00007d50: 7365 705f 6d61 726b 6572 203d 2062 2226  sep_marker = b"&
-00007d60: 4e4f 4e53 4550 2622 0a20 2020 2020 2020  NONSEP&".       
-00007d70: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-00007d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007d90: 2020 2065 6d70 7479 203d 2027 270a 2020     empty = ''.  
-00007da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007db0: 2020 6e6f 6e5f 7365 705f 6d61 726b 6572    non_sep_marker
-00007dc0: 203d 2022 264e 4f4e 5345 5026 220a 0a20   = "&NONSEP&".. 
-00007dd0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00007de0: 6f72 2075 7365 5f6c 6561 6469 6e67 2069  or use_leading i
-00007df0: 6e20 2846 616c 7365 2c20 5472 7565 293a  n (False, True):
-00007e00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007e10: 2020 2020 2066 6f72 2075 7365 5f74 7261       for use_tra
-00007e20: 696c 696e 6720 696e 2028 4661 6c73 652c  iling in (False,
-00007e30: 2054 7275 6529 3a0a 2020 2020 2020 2020   True):.        
-00007e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007e50: 2320 7765 2772 6520 676f 696e 6720 746f  # we're going to
-00007e60: 2068 6163 6b20 7570 2074 6865 7365 206c   hack up these l
-00007e70: 6973 7473 2c0a 2020 2020 2020 2020 2020  ists,.          
-00007e80: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-00007e90: 736f 2073 7461 7274 2077 6974 6820 636f  so start with co
-00007ea0: 7069 6573 2e0a 2020 2020 2020 2020 2020  pies..          
-00007eb0: 2020 2020 2020 2020 2020 2020 2020 6c65                le
-00007ec0: 6164 696e 672c 2073 706c 6974 732c 2074  ading, splits, t
-00007ed0: 7261 696c 696e 6720 3d20 636f 7079 2e64  railing = copy.d
-00007ee0: 6565 7063 6f70 7928 6f72 6967 696e 616c  eepcopy(original
-00007ef0: 7329 0a0a 2020 2020 2020 2020 2020 2020  s)..            
-00007f00: 2020 2020 2020 2020 2020 2020 6966 2077              if w
-00007f10: 616e 745f 7072 696e 7473 3a20 2320 7072  ant_prints: # pr
-00007f20: 6167 6d61 3a20 6e6f 2063 6f76 6572 0a20  agma: no cover. 
-00007f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007f40: 2020 2020 2020 2020 2020 2070 7269 6e74             print
-00007f50: 2866 225b 6c6f 6f70 2031 2c32 5d20 7573  (f"[loop 1,2] us
-00007f60: 655f 6c65 6164 696e 673d 7b75 7365 5f6c  e_leading={use_l
-00007f70: 6561 6469 6e67 7d20 7573 655f 7472 6169  eading} use_trai
-00007f80: 6c69 6e67 3d7b 7573 655f 7472 6169 6c69  ling={use_traili
-00007f90: 6e67 7d22 290a 2020 2020 2020 2020 2020  ng}").          
-00007fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007fb0: 2020 7072 696e 7428 6622 2020 2020 2020    print(f"      
-00007fc0: 2020 206c 6561 6469 6e67 3d7b 6c65 6164     leading={lead
-00007fd0: 696e 677d 2073 706c 6974 3d7b 7370 6c69  ing} split={spli
-00007fe0: 747d 2074 7261 696c 696e 673d 7b74 7261  t} trailing={tra
-00007ff0: 696c 696e 677d 2229 0a0a 2020 2020 2020  iling}")..      
-00008000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008010: 2020 696e 7075 745f 7374 7269 6e67 7320    input_strings 
-00008020: 3d20 5b5d 0a20 2020 2020 2020 2020 2020  = [].           
-00008030: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-00008040: 7573 655f 6c65 6164 696e 673a 0a20 2020  use_leading:.   
-00008050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008060: 2020 2020 2020 2020 2069 6e70 7574 5f73           input_s
-00008070: 7472 696e 6773 2e65 7874 656e 6428 6c65  trings.extend(le
-00008080: 6164 696e 6729 0a20 2020 2020 2020 2020  ading).         
-00008090: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-000080a0: 6f72 2073 706c 6974 2069 6e20 7370 6c69  or split in spli
-000080b0: 7473 3a0a 2020 2020 2020 2020 2020 2020  ts:.            
-000080c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000080d0: 696e 7075 745f 7374 7269 6e67 732e 6578  input_strings.ex
-000080e0: 7465 6e64 2873 706c 6974 290a 2020 2020  tend(split).    
-000080f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008100: 2020 2020 6966 2075 7365 5f74 7261 696c      if use_trail
-00008110: 696e 673a 0a20 2020 2020 2020 2020 2020  ing:.           
-00008120: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008130: 2069 6e70 7574 5f73 7472 696e 6773 2e65   input_strings.e
-00008140: 7874 656e 6428 7472 6169 6c69 6e67 290a  xtend(trailing).
-00008150: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008160: 2020 2020 2020 2020 2069 6e70 7574 5f73           input_s
-00008170: 7472 696e 6720 3d20 656d 7074 792e 6a6f  tring = empty.jo
-00008180: 696e 2869 6e70 7574 5f73 7472 696e 6773  in(input_strings
-00008190: 290a 0a20 2020 2020 2020 2020 2020 2020  )..             
-000081a0: 2020 2020 2020 2020 2020 2066 6f72 2073             for s
-000081b0: 6570 6172 6174 6520 696e 2028 4661 6c73  eparate in (Fals
-000081c0: 652c 2054 7275 6529 3a0a 2020 2020 2020  e, True):.      
-000081d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000081e0: 2020 2020 2020 6c65 6164 696e 672c 2073        leading, s
-000081f0: 706c 6974 732c 2074 7261 696c 696e 6720  plits, trailing 
-00008200: 3d20 636f 7079 2e64 6565 7063 6f70 7928  = copy.deepcopy(
-00008210: 6f72 6967 696e 616c 7329 0a20 2020 2020  originals).     
-00008220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008230: 2020 2020 2020 2023 206e 6f77 2077 6527         # now we'
-00008240: 7265 2067 6f69 6e67 2074 6f20 6368 616e  re going to chan
-00008250: 6765 206c 6561 6469 6e67 202f 2073 706c  ge leading / spl
-00008260: 6974 7320 2f20 7472 6169 6c69 6e67 0a20  its / trailing. 
-00008270: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008280: 2020 2020 2020 2020 2020 2023 2073 6f20             # so 
-00008290: 7468 6174 2074 6865 7920 636f 6c6c 6563  that they collec
-000082a0: 7469 7665 6c79 2061 6c74 6572 6e61 7465  tively alternate
-000082b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000082c0: 2020 2020 2020 2020 2020 2020 2023 2020               #  
-000082d0: 2020 6e6f 6e73 6570 2c20 7365 700a 0a20    nonsep, sep.. 
-000082e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000082f0: 2020 2020 2020 2020 2020 2069 6620 7761             if wa
-00008300: 6e74 5f70 7269 6e74 733a 2023 2070 7261  nt_prints: # pra
-00008310: 676d 613a 206e 6f20 636f 7665 720a 2020  gma: no cover.  
-00008320: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008330: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-00008340: 696e 7428 6622 5b6c 6f6f 7020 335d 2073  int(f"[loop 3] s
-00008350: 6570 6172 6174 653d 7b73 6570 6172 6174  eparate={separat
-00008360: 657d 2229 0a20 2020 2020 2020 2020 2020  e}").           
-00008370: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008380: 2020 2020 2070 7269 6e74 2866 2220 2020       print(f"   
-00008390: 206c 6561 6469 6e67 3d7b 6c65 6164 696e   leading={leadin
-000083a0: 677d 2073 706c 6974 733d 7b73 706c 6974  g} splits={split
-000083b0: 737d 2074 7261 696c 696e 673d 7b74 7261  s} trailing={tra
-000083c0: 696c 696e 677d 2229 0a0a 2020 2020 2020  iling}")..      
-000083d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000083e0: 2020 2020 2020 6966 206e 6f74 2073 6570        if not sep
-000083f0: 6172 6174 653a 0a20 2020 2020 2020 2020  arate:.         
-00008400: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008410: 2020 2020 2020 2023 2062 6c6f 6220 7468         # blob th
-00008420: 6520 7365 7061 7261 746f 7273 2074 6f67  e separators tog
-00008430: 6574 6865 720a 2020 2020 2020 2020 2020  ether.          
-00008440: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008450: 2020 2020 2020 6c32 203d 205b 656d 7074        l2 = [empt
-00008460: 795d 0a20 2020 2020 2020 2020 2020 2020  y].             
-00008470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008480: 2020 2069 6620 7761 6e74 5f70 7269 6e74     if want_print
-00008490: 733a 2023 2070 7261 676d 613a 206e 6f20  s: # pragma: no 
-000084a0: 636f 7665 720a 2020 2020 2020 2020 2020  cover.          
-000084b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000084c0: 2020 2020 2020 2020 2020 7072 696e 7428            print(
-000084d0: 6622 2020 2020 626c 6f62 2074 6f67 6574  f"    blob toget
-000084e0: 6865 7220 656d 7074 793d 7b65 6d70 7479  her empty={empty
-000084f0: 7d20 6c65 6164 696e 673d 7b6c 6561 6469  } leading={leadi
-00008500: 6e67 7d22 290a 2020 2020 2020 2020 2020  ng}").          
-00008510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008520: 2020 2020 2020 6c32 2e61 7070 656e 6428        l2.append(
-00008530: 656d 7074 792e 6a6f 696e 286c 6561 6469  empty.join(leadi
-00008540: 6e67 2929 0a20 2020 2020 2020 2020 2020  ng)).           
-00008550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008560: 2020 2020 206c 6561 6469 6e67 203d 206c       leading = l
-00008570: 320a 2020 2020 2020 2020 2020 2020 2020  2.              
-00008580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008590: 2020 6966 2077 616e 745f 7072 696e 7473    if want_prints
-000085a0: 3a20 2320 7072 6167 6d61 3a20 6e6f 2063  : # pragma: no c
-000085b0: 6f76 6572 0a20 2020 2020 2020 2020 2020  over.           
-000085c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000085d0: 2020 2020 2020 2020 2070 7269 6e74 2866           print(f
-000085e0: 2220 2020 2062 6c6f 6262 6564 206c 6561  "    blobbed lea
-000085f0: 6469 6e67 3d7b 6c65 6164 696e 677d 2229  ding={leading}")
-00008600: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00008610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008620: 2020 666f 7220 7370 6c69 7420 696e 2073    for split in s
-00008630: 706c 6974 733a 0a20 2020 2020 2020 2020  plits:.         
-00008640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008650: 2020 2020 2020 2020 2020 2069 6620 6c65             if le
-00008660: 6e28 7370 6c69 7429 203e 2031 3a0a 2020  n(split) > 1:.  
-00008670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008690: 2020 2020 2020 6a6f 696e 6564 203d 2065        joined = e
-000086a0: 6d70 7479 2e6a 6f69 6e28 7370 6c69 745b  mpty.join(split[
-000086b0: 313a 5d29 0a20 2020 2020 2020 2020 2020  1:]).           
-000086c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000086d0: 2020 2020 2020 2020 2020 2020 2064 656c               del
-000086e0: 2073 706c 6974 5b31 3a5d 0a20 2020 2020   split[1:].     
-000086f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008700: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008710: 2020 2073 706c 6974 2e61 7070 656e 6428     split.append(
-00008720: 6a6f 696e 6564 290a 0a20 2020 2020 2020  joined)..       
-00008730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008740: 2020 2020 2020 2020 2074 7261 696c 696e           trailin
-00008750: 6720 3d20 5b65 6d70 7479 2e6a 6f69 6e28  g = [empty.join(
-00008760: 7472 6169 6c69 6e67 292c 2065 6d70 7479  trailing), empty
-00008770: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-00008780: 2020 2020 2020 2020 2020 2020 2020 656c                el
-00008790: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-000087a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000087b0: 2020 2020 2320 7475 726e 206c 6561 6469      # turn leadi
-000087c0: 6e67 2c20 7370 6c69 7473 2c20 616e 6420  ng, splits, and 
-000087d0: 7472 6169 6c69 6e67 0a20 2020 2020 2020  trailing.       
-000087e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000087f0: 2020 2020 2020 2020 2023 2069 6e74 6f20           # into 
-00008800: 7375 6974 6162 6c65 2066 6f72 6d20 666f  suitable form fo
-00008810: 7220 7465 7374 696e 6720 7769 7468 2022  r testing with "
-00008820: 7365 7061 7261 7465 222e 0a20 2020 2020  separate"..     
-00008830: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008840: 2020 2020 2020 2020 2020 2023 2020 202a             #   *
-00008850: 2065 7665 7279 206c 6973 7420 6973 2061   every list is a
-00008860: 206c 6973 7420 6f66 2061 6c74 6572 6e61   list of alterna
-00008870: 7469 6e67 2073 6570 2061 6e64 206e 6f6e  ting sep and non
-00008880: 7365 702e 0a20 2020 2020 2020 2020 2020  sep..           
-00008890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000088a0: 2020 2020 2023 2020 202a 2073 706c 6974       #   * split
-000088b0: 7320 6e6f 7720 6861 7320 656d 7074 7920  s now has empty 
-000088c0: 7374 7269 6e67 7320 6265 7477 6565 6e20  strings between 
-000088d0: 7365 7020 616e 6420 6e6f 6e73 6570 2e0a  sep and nonsep..
-000088e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000088f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008900: 6173 7365 7274 206c 656e 286c 6561 6469  assert len(leadi
-00008910: 6e67 2920 3e3d 2032 0a20 2020 2020 2020  ng) >= 2.       
-00008920: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008930: 2020 2020 2020 2020 2073 6570 6172 6174           separat
-00008940: 655f 6c65 6164 696e 6720 3d20 6c69 7374  e_leading = list
-00008950: 286c 6561 6469 6e67 5b3a 325d 290a 2020  (leading[:2]).  
-00008960: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008970: 2020 2020 2020 2020 2020 2020 2020 666f                fo
-00008980: 7220 7320 696e 206c 6561 6469 6e67 5b32  r s in leading[2
-00008990: 3a5d 3a0a 2020 2020 2020 2020 2020 2020  :]:.            
-000089a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000089b0: 2020 2020 2020 2020 7365 7061 7261 7465          separate
-000089c0: 5f6c 6561 6469 6e67 2e61 7070 656e 6428  _leading.append(
-000089d0: 656d 7074 7929 0a20 2020 2020 2020 2020  empty).         
-000089e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000089f0: 2020 2020 2020 2020 2020 2073 6570 6172             separ
-00008a00: 6174 655f 6c65 6164 696e 672e 6170 7065  ate_leading.appe
-00008a10: 6e64 2873 290a 2020 2020 2020 2020 2020  nd(s).          
-00008a20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008a30: 2020 2020 2020 6c65 6164 696e 6720 3d20        leading = 
-00008a40: 7365 7061 7261 7465 5f6c 6561 6469 6e67  separate_leading
-00008a50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008a70: 2069 6620 7761 6e74 5f70 7269 6e74 733a   if want_prints:
-00008a80: 2023 2070 7261 676d 613a 206e 6f20 636f   # pragma: no co
-00008a90: 7665 720a 2020 2020 2020 2020 2020 2020  ver.            
-00008aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008ab0: 2020 2020 2020 2020 7072 696e 7428 6622          print(f"
-00008ac0: 2020 2020 6c65 6164 696e 673d 7b6c 6561      leading={lea
-00008ad0: 6469 6e67 7d22 290a 0a20 2020 2020 2020  ding}")..       
-00008ae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008af0: 2020 2020 2020 2020 2073 6570 6172 6174           separat
-00008b00: 655f 7370 6c69 7473 203d 205b 5d0a 2020  e_splits = [].  
-00008b10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008b20: 2020 2020 2020 2020 2020 2020 2020 666f                fo
-00008b30: 7220 7370 6c69 7420 696e 2073 706c 6974  r split in split
-00008b40: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
-00008b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008b60: 2020 2020 2020 2069 6620 6c65 6e28 7370         if len(sp
-00008b70: 6c69 7429 203d 3d20 313a 0a20 2020 2020  lit) == 1:.     
-00008b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008ba0: 2020 2061 7373 6572 7420 7370 6c69 7420     assert split 
-00008bb0: 3d3d 2073 706c 6974 735b 2d31 5d0a 2020  == splits[-1].  
-00008bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008be0: 2020 2020 2020 7365 7061 7261 7465 5f73        separate_s
-00008bf0: 706c 6974 732e 6170 7065 6e64 2873 706c  plits.append(spl
-00008c00: 6974 290a 2020 2020 2020 2020 2020 2020  it).            
-00008c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008c20: 2020 2020 2020 2020 2020 2020 6272 6561              brea
-00008c30: 6b0a 2020 2020 2020 2020 2020 2020 2020  k.              
-00008c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008c50: 2020 2020 2020 6173 7365 7274 206c 656e        assert len
-00008c60: 2873 706c 6974 2920 3e3d 2032 0a20 2020  (split) >= 2.   
-00008c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008c90: 2073 6570 6172 6174 655f 7370 6c69 7473   separate_splits
-00008ca0: 2e61 7070 656e 6428 6c69 7374 2873 706c  .append(list(spl
-00008cb0: 6974 5b3a 325d 2929 0a20 2020 2020 2020  it[:2])).       
-00008cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008cd0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
-00008ce0: 2073 2069 6e20 7370 6c69 745b 323a 5d3a   s in split[2:]:
-00008cf0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008d10: 2020 2020 2020 2020 2073 6570 6172 6174           separat
-00008d20: 655f 7370 6c69 7473 2e61 7070 656e 6428  e_splits.append(
-00008d30: 5b65 6d70 7479 2c20 735d 290a 2020 2020  [empty, s]).    
-00008d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008d50: 2020 2020 2020 2020 2020 2020 7370 6c69              spli
-00008d60: 7473 203d 2073 6570 6172 6174 655f 7370  ts = separate_sp
-00008d70: 6c69 7473 0a20 2020 2020 2020 2020 2020  lits.           
-00008d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008d90: 2020 2020 2069 6620 7761 6e74 5f70 7269       if want_pri
-00008da0: 6e74 733a 2023 2070 7261 676d 613a 206e  nts: # pragma: n
-00008db0: 6f20 636f 7665 720a 2020 2020 2020 2020  o cover.        
-00008dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008dd0: 2020 2020 2020 2020 2020 2020 7072 696e              prin
-00008de0: 7428 6622 2020 2020 7370 6c69 7473 3d7b  t(f"    splits={
-00008df0: 7370 6c69 7473 7d22 290a 0a20 2020 2020  splits}")..     
-00008e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008e10: 2020 2020 2020 2020 2020 2073 6570 6172             separ
-00008e20: 6174 655f 7472 6169 6c69 6e67 203d 205b  ate_trailing = [
-00008e30: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-00008e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008e50: 2020 666f 7220 7320 696e 2074 7261 696c    for s in trail
-00008e60: 696e 673a 0a20 2020 2020 2020 2020 2020  ing:.           
-00008e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008e80: 2020 2020 2020 2020 2069 6620 733a 2023           if s: #
-00008e90: 2073 6b69 7020 7468 6520 7472 6169 6c69   skip the traili
-00008ea0: 6e67 2065 6d70 7479 0a20 2020 2020 2020  ng empty.       
-00008eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000004a0: 696d 706f 7274 2073 7973 0a69 6d70 6f72  import sys.impor
+000004b0: 7420 756e 6974 7465 7374 0a0a 7472 793a  t unittest..try:
+000004c0: 0a20 2020 2066 726f 6d20 7265 2069 6d70  .    from re imp
+000004d0: 6f72 7420 5061 7474 6572 6e20 6173 2072  ort Pattern as r
+000004e0: 655f 5061 7474 6572 6e0a 6578 6365 7074  e_Pattern.except
+000004f0: 2049 6d70 6f72 7445 7272 6f72 3a20 2320   ImportError: # 
+00000500: 7072 6167 6d61 3a20 6e6f 2063 6f76 6572  pragma: no cover
+00000510: 0a20 2020 2072 655f 5061 7474 6572 6e20  .    re_Pattern 
+00000520: 3d20 7265 2e5f 7061 7474 6572 6e5f 7479  = re._pattern_ty
+00000530: 7065 0a0a 7472 793a 0a20 2020 2069 6d70  pe..try:.    imp
+00000540: 6f72 7420 7265 6765 780a 2020 2020 6861  ort regex.    ha
+00000550: 7665 5f72 6567 6578 203d 2054 7275 650a  ve_regex = True.
+00000560: 6578 6365 7074 2049 6d70 6f72 7445 7272  except ImportErr
+00000570: 6f72 3a20 2320 7072 6167 6d61 3a20 6e6f  or: # pragma: no
+00000580: 2063 6f76 6572 0a20 2020 2068 6176 655f   cover.    have_
+00000590: 7265 6765 7820 3d20 4661 6c73 650a 0a64  regex = False..d
+000005a0: 6566 2075 6e63 6861 6e67 6564 286f 293a  ef unchanged(o):
+000005b0: 0a20 2020 2072 6574 7572 6e20 6f0a 0a64  .    return o..d
+000005c0: 6566 2074 6f5f 6279 7465 7328 6f29 3a20  ef to_bytes(o): 
+000005d0: 2320 7072 6167 6d61 3a20 6e6f 2063 6f76  # pragma: no cov
+000005e0: 6572 0a20 2020 2069 6620 6f20 6973 204e  er.    if o is N
+000005f0: 6f6e 653a 0a20 2020 2020 2020 2072 6574  one:.        ret
+00000600: 7572 6e20 4e6f 6e65 0a20 2020 2069 6620  urn None.    if 
+00000610: 6973 696e 7374 616e 6365 286f 2c20 7374  isinstance(o, st
+00000620: 7229 3a0a 2020 2020 2020 2020 7265 7475  r):.        retu
+00000630: 726e 206f 2e65 6e63 6f64 6528 2761 7363  rn o.encode('asc
+00000640: 6969 2729 0a20 2020 2069 6620 6973 696e  ii').    if isin
+00000650: 7374 616e 6365 286f 2c20 6c69 7374 293a  stance(o, list):
+00000660: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00000670: 5b74 6f5f 6279 7465 7328 7829 2066 6f72  [to_bytes(x) for
+00000680: 2078 2069 6e20 6f5d 0a20 2020 2069 6620   x in o].    if 
+00000690: 6973 696e 7374 616e 6365 286f 2c20 7475  isinstance(o, tu
+000006a0: 706c 6529 3a0a 2020 2020 2020 2020 7265  ple):.        re
+000006b0: 7475 726e 2074 7570 6c65 2874 6f5f 6279  turn tuple(to_by
+000006c0: 7465 7328 7829 2066 6f72 2078 2069 6e20  tes(x) for x in 
+000006d0: 6f29 0a20 2020 2069 6620 6973 696e 7374  o).    if isinst
+000006e0: 616e 6365 286f 2c20 7265 5f50 6174 7465  ance(o, re_Patte
+000006f0: 726e 293a 0a20 2020 2020 2020 2066 6c61  rn):.        fla
+00000700: 6773 203d 206f 2e66 6c61 6773 0a20 2020  gs = o.flags.   
+00000710: 2020 2020 2069 6620 666c 6167 7320 2620       if flags & 
+00000720: 7265 2e55 4e49 434f 4445 3a0a 2020 2020  re.UNICODE:.    
+00000730: 2020 2020 2020 2020 666c 6167 7320 3d20          flags = 
+00000740: 666c 6167 7320 2d20 7265 2e55 4e49 434f  flags - re.UNICO
+00000750: 4445 0a20 2020 2020 2020 206f 203d 2072  DE.        o = r
+00000760: 652e 636f 6d70 696c 6528 746f 5f62 7974  e.compile(to_byt
+00000770: 6573 286f 2e70 6174 7465 726e 292c 2066  es(o.pattern), f
+00000780: 6c61 6773 3d66 6c61 6773 290a 2020 2020  lags=flags).    
+00000790: 7265 7475 726e 206f 0a0a 0a6b 6e6f 776e  return o...known
+000007a0: 5f73 6570 6172 6174 6f72 7320 3d20 5b0a  _separators = [.
+000007b0: 2020 2020 2862 6967 2e77 6869 7465 7370      (big.whitesp
+000007c0: 6163 652c 2022 6269 672e 7768 6974 6573  ace, "big.whites
+000007d0: 7061 6365 2229 2c0a 2020 2020 2862 6967  pace"),.    (big
+000007e0: 2e77 6869 7465 7370 6163 655f 7769 7468  .whitespace_with
+000007f0: 6f75 745f 646f 732c 2022 6269 672e 7768  out_dos, "big.wh
+00000800: 6974 6573 7061 6365 5f77 6974 686f 7574  itespace_without
+00000810: 5f64 6f73 2229 2c0a 2020 2020 2862 6967  _dos"),.    (big
+00000820: 2e6e 6577 6c69 6e65 732c 2020 2022 6269  .newlines,   "bi
+00000830: 672e 6e65 776c 696e 6573 2229 2c0a 2020  g.newlines"),.  
+00000840: 2020 2862 6967 2e6e 6577 6c69 6e65 735f    (big.newlines_
+00000850: 7769 7468 6f75 745f 646f 732c 2020 2022  without_dos,   "
+00000860: 6269 672e 6e65 776c 696e 6573 5f77 6974  big.newlines_wit
+00000870: 686f 7574 5f64 6f73 2229 2c0a 0a20 2020  hout_dos"),..   
+00000880: 2028 6269 672e 6173 6369 695f 7768 6974   (big.ascii_whit
+00000890: 6573 7061 6365 2c20 2262 6967 2e61 7363  espace, "big.asc
+000008a0: 6969 5f77 6869 7465 7370 6163 6522 292c  ii_whitespace"),
+000008b0: 0a20 2020 2028 6269 672e 6173 6369 695f  .    (big.ascii_
+000008c0: 7768 6974 6573 7061 6365 5f77 6974 686f  whitespace_witho
+000008d0: 7574 5f64 6f73 2c20 2262 6967 2e61 7363  ut_dos, "big.asc
+000008e0: 6969 5f77 6869 7465 7370 6163 655f 7769  ii_whitespace_wi
+000008f0: 7468 6f75 745f 646f 7322 292c 0a20 2020  thout_dos"),.   
+00000900: 2028 6269 672e 6173 6369 695f 6e65 776c   (big.ascii_newl
+00000910: 696e 6573 2c20 2020 2262 6967 2e61 7363  ines,   "big.asc
+00000920: 6969 5f6e 6577 6c69 6e65 7322 292c 0a20  ii_newlines"),. 
+00000930: 2020 2028 6269 672e 6173 6369 695f 6e65     (big.ascii_ne
+00000940: 776c 696e 6573 5f77 6974 686f 7574 5f64  wlines_without_d
+00000950: 6f73 2c20 2020 2262 6967 2e61 7363 6969  os,   "big.ascii
+00000960: 5f6e 6577 6c69 6e65 735f 7769 7468 6f75  _newlines_withou
+00000970: 745f 646f 7322 292c 0a0a 2020 2020 2862  t_dos"),..    (b
+00000980: 6967 2e75 7466 385f 7768 6974 6573 7061  ig.utf8_whitespa
+00000990: 6365 2c20 2262 6967 2e75 7466 385f 7768  ce, "big.utf8_wh
+000009a0: 6974 6573 7061 6365 2229 2c0a 2020 2020  itespace"),.    
+000009b0: 2862 6967 2e75 7466 385f 7768 6974 6573  (big.utf8_whites
+000009c0: 7061 6365 5f77 6974 686f 7574 5f64 6f73  pace_without_dos
+000009d0: 2c20 2262 6967 2e75 7466 385f 7768 6974  , "big.utf8_whit
+000009e0: 6573 7061 6365 5f77 6974 686f 7574 5f64  espace_without_d
+000009f0: 6f73 2229 2c0a 2020 2020 2862 6967 2e75  os"),.    (big.u
+00000a00: 7466 385f 6e65 776c 696e 6573 2c20 2020  tf8_newlines,   
+00000a10: 2262 6967 2e75 7466 385f 6e65 776c 696e  "big.utf8_newlin
+00000a20: 6573 2229 2c0a 2020 2020 2862 6967 2e75  es"),.    (big.u
+00000a30: 7466 385f 6e65 776c 696e 6573 5f77 6974  tf8_newlines_wit
+00000a40: 686f 7574 5f64 6f73 2c20 2020 2262 6967  hout_dos,   "big
+00000a50: 2e75 7466 385f 6e65 776c 696e 6573 5f77  .utf8_newlines_w
+00000a60: 6974 686f 7574 5f64 6f73 2229 2c0a 5d0a  ithout_dos"),.].
+00000a70: 0a64 6566 2070 7269 6e74 6162 6c65 5f73  .def printable_s
+00000a80: 6570 6172 6174 6f72 7328 7365 7061 7261  eparators(separa
+00000a90: 746f 7273 293a 0a20 2020 2066 6f72 206b  tors):.    for k
+00000aa0: 6e6f 776e 2c20 6e61 6d65 2069 6e20 6b6e  nown, name in kn
+00000ab0: 6f77 6e5f 7365 7061 7261 746f 7273 3a0a  own_separators:.
+00000ac0: 2020 2020 2020 2020 6966 2073 6570 6172          if separ
+00000ad0: 6174 6f72 7320 3d3d 206b 6e6f 776e 3a0a  ators == known:.
+00000ae0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00000af0: 726e 2066 227b 6e61 6d65 7d22 0a20 2020  rn f"{name}".   
+00000b00: 2072 6574 7572 6e20 7365 7061 7261 746f   return separato
+00000b10: 7273 0a0a 636c 6173 7320 5374 7253 7562  rs..class StrSub
+00000b20: 636c 6173 7328 7374 7229 3a0a 2020 2020  class(str):.    
+00000b30: 6465 6620 5f5f 7265 7072 5f5f 2873 656c  def __repr__(sel
+00000b40: 6629 3a20 2320 7072 6167 6d61 3a20 6e6f  f): # pragma: no
+00000b50: 2063 6f76 6572 0a20 2020 2020 2020 2072   cover.        r
+00000b60: 6574 7572 6e20 6622 3c53 7472 5375 6263  eturn f"<StrSubc
+00000b70: 6c61 7373 207b 7374 7228 7365 6c66 2921  lass {str(self)!
+00000b80: 727d 3e22 0a0a 636c 6173 7320 4469 6666  r}>"..class Diff
+00000b90: 6572 656e 7453 7472 5375 6263 6c61 7373  erentStrSubclass
+00000ba0: 2873 7472 293a 0a20 2020 2064 6566 205f  (str):.    def _
+00000bb0: 5f72 6570 725f 5f28 7365 6c66 293a 2023  _repr__(self): #
+00000bc0: 2070 7261 676d 613a 206e 6f20 636f 7665   pragma: no cove
+00000bd0: 720a 2020 2020 2020 2020 7265 7475 726e  r.        return
+00000be0: 2066 223c 4469 6666 6572 656e 7453 7472   f"<DifferentStr
+00000bf0: 5375 6263 6c61 7373 207b 7374 7228 7365  Subclass {str(se
+00000c00: 6c66 2921 727d 3e22 0a0a 636c 6173 7320  lf)!r}>"..class 
+00000c10: 4279 7465 7353 7562 636c 6173 7328 6279  BytesSubclass(by
+00000c20: 7465 7329 3a0a 2020 2020 6465 6620 5f5f  tes):.    def __
+00000c30: 7265 7072 5f5f 2873 656c 6629 3a20 2320  repr__(self): # 
+00000c40: 7072 6167 6d61 3a20 6e6f 2063 6f76 6572  pragma: no cover
+00000c50: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00000c60: 6622 3c42 7974 6573 5375 6263 6c61 7373  f"<BytesSubclass
+00000c70: 207b 6279 7465 7328 7365 6c66 2921 727d   {bytes(self)!r}
+00000c80: 3e22 0a0a 636c 6173 7320 4469 6666 6572  >"..class Differ
+00000c90: 656e 7442 7974 6573 5375 6263 6c61 7373  entBytesSubclass
+00000ca0: 2862 7974 6573 293a 0a20 2020 2064 6566  (bytes):.    def
+00000cb0: 205f 5f72 6570 725f 5f28 7365 6c66 293a   __repr__(self):
+00000cc0: 2023 2070 7261 676d 613a 206e 6f20 636f   # pragma: no co
+00000cd0: 7665 720a 2020 2020 2020 2020 7265 7475  ver.        retu
+00000ce0: 726e 2066 223c 4469 6666 6572 656e 7442  rn f"<DifferentB
+00000cf0: 7974 6573 5375 6263 6c61 7373 207b 6279  ytesSubclass {by
+00000d00: 7465 7328 7365 6c66 2921 727d 3e22 0a0a  tes(self)!r}>"..
+00000d10: 0a64 6566 2067 726f 7570 3028 7265 5f70  .def group0(re_p
+00000d20: 6172 7469 7469 6f6e 5f72 6573 756c 7429  artition_result)
+00000d30: 3a0a 2020 2020 7265 7375 6c74 203d 205b  :.    result = [
+00000d40: 5d0a 2020 2020 666f 7220 692c 206f 2069  ].    for i, o i
+00000d50: 6e20 656e 756d 6572 6174 6528 7265 5f70  n enumerate(re_p
+00000d60: 6172 7469 7469 6f6e 5f72 6573 756c 7429  artition_result)
+00000d70: 3a0a 2020 2020 2020 2020 6966 2028 6920  :.        if (i 
+00000d80: 2520 3229 2061 6e64 2028 6f20 6973 206e  % 2) and (o is n
+00000d90: 6f74 204e 6f6e 6529 3a0a 2020 2020 2020  ot None):.      
+00000da0: 2020 2020 2020 6f20 3d20 6f2e 6772 6f75        o = o.grou
+00000db0: 7028 3029 0a20 2020 2020 2020 2072 6573  p(0).        res
+00000dc0: 756c 742e 6170 7065 6e64 286f 290a 2020  ult.append(o).  
+00000dd0: 2020 7265 7475 726e 2074 7570 6c65 2872    return tuple(r
+00000de0: 6573 756c 7429 0a0a 6465 6620 6669 6e64  esult)..def find
+00000df0: 6974 6572 5f67 726f 7570 3028 6929 3a0a  iter_group0(i):.
+00000e00: 2020 2020 7265 7475 726e 2074 7570 6c65      return tuple
+00000e10: 286d 6174 6368 2e67 726f 7570 2830 2920  (match.group(0) 
+00000e20: 666f 7220 6d61 7463 6820 696e 2069 290a  for match in i).
+00000e30: 0a0a 636c 6173 7320 4269 6754 6578 7454  ..class BigTextT
+00000e40: 6573 7473 2875 6e69 7474 6573 742e 5465  ests(unittest.Te
+00000e50: 7374 4361 7365 293a 0a0a 2020 2020 6465  stCase):..    de
+00000e60: 6620 7465 7374 5f77 6869 7465 7370 6163  f test_whitespac
+00000e70: 655f 616e 645f 6e65 776c 696e 6573 2873  e_and_newlines(s
+00000e80: 656c 6629 3a0a 2020 2020 2020 2020 2320  elf):.        # 
+00000e90: 656e 7375 7265 2074 6861 7420 6269 672e  ensure that big.
+00000ea0: 7768 6974 6573 7061 6365 2061 6e64 2062  whitespace and b
+00000eb0: 6967 2e6e 6577 6c69 6e65 730a 2020 2020  ig.newlines.    
+00000ec0: 2020 2020 2320 636f 7272 6563 746c 7920      # correctly 
+00000ed0: 6d61 7463 6865 7320 7468 6520 6c69 7374  matches the list
+00000ee0: 206f 6620 6368 6172 6163 7465 7273 2074   of characters t
+00000ef0: 6861 740a 2020 2020 2020 2020 2320 5079  hat.        # Py
+00000f00: 7468 6f6e 2063 6f6e 7369 6465 7273 2077  thon considers w
+00000f10: 6869 7465 7370 6163 6520 2f20 6e65 776c  hitespace / newl
+00000f20: 696e 6573 2e0a 0a20 2020 2020 2020 2023  ines...        #
+00000f30: 2050 7974 686f 6e20 7768 6974 6573 7061   Python whitespa
+00000f40: 6365 206f 6e6c 7920 636f 6e73 6964 6572  ce only consider
+00000f50: 7320 696e 6469 7669 6475 616c 0a20 2020  s individual.   
+00000f60: 2020 2020 2023 2077 6869 7465 7370 6163       # whitespac
+00000f70: 6520 6368 6172 6374 6572 732c 2061 6e64  e charcters, and
+00000f80: 2064 6f65 736e 2774 2069 6e63 6c75 6465   doesn't include
+00000f90: 2074 6865 0a20 2020 2020 2020 2023 2044   the.        # D
+00000fa0: 4f53 2065 6e64 2d6f 662d 6c69 6e65 2073  OS end-of-line s
+00000fb0: 6571 7565 6e63 6520 275c 725c 6e27 2e20  equence '\r\n'. 
+00000fc0: 2073 6f20 7768 6174 2077 6527 7265 0a20   so what we're. 
+00000fd0: 2020 2020 2020 2023 2067 6f69 6e67 2074         # going t
+00000fe0: 6f20 7072 6f64 7563 6520 696e 2074 6865  o produce in the
+00000ff0: 2062 656c 6f77 206c 6973 7420 6973 2074   below list is t
+00001000: 6563 686e 6963 616c 6c79 0a20 2020 2020  echnically.     
+00001010: 2020 2023 2074 6865 2022 7769 7468 6f75     # the "withou
+00001020: 7420 444f 5322 2076 6572 7369 6f6e 732e  t DOS" versions.
+00001030: 0a20 2020 2020 2020 2070 7974 686f 6e5f  .        python_
+00001040: 7768 6974 6573 7061 6365 5f77 6974 686f  whitespace_witho
+00001050: 7574 5f64 6f73 203d 205b 5d0a 2020 2020  ut_dos = [].    
+00001060: 2020 2020 7079 7468 6f6e 5f6e 6577 6c69      python_newli
+00001070: 6e65 735f 7769 7468 6f75 745f 646f 7320  nes_without_dos 
+00001080: 3d20 5b5d 0a0a 2020 2020 2020 2020 2320  = []..        # 
+00001090: 7465 6368 6e69 6361 6c6c 7920 7765 2064  technically we d
+000010a0: 6f6e 2774 206e 6565 6420 746f 2063 6865  on't need to che
+000010b0: 636b 2074 6865 2073 7572 726f 6761 7465  ck the surrogate
+000010c0: 2070 6169 7220 6368 6172 6163 7465 7273   pair characters
+000010d0: 2e0a 2020 2020 2020 2020 2320 6275 7420  ..        # but 
+000010e0: 6974 2773 2066 6173 7465 7220 746f 206c  it's faster to l
+000010f0: 6561 7665 2074 6865 6d20 696e 2e0a 2020  eave them in..  
+00001100: 2020 2020 2020 756e 6963 6f64 655f 636f        unicode_co
+00001110: 6465 5f70 6f69 6e74 7320 3d20 322a 2a31  de_points = 2**1
+00001120: 3620 2b20 322a 2a32 300a 0a20 2020 2020  6 + 2**20..     
+00001130: 2020 2066 6f72 2069 2069 6e20 7261 6e67     for i in rang
+00001140: 6528 756e 6963 6f64 655f 636f 6465 5f70  e(unicode_code_p
+00001150: 6f69 6e74 7329 3a0a 2020 2020 2020 2020  oints):.        
+00001160: 2020 2020 6320 3d20 6368 7228 6929 0a20      c = chr(i). 
+00001170: 2020 2020 2020 2020 2020 2073 203d 2066             s = f
+00001180: 2261 7b63 7d62 220a 2020 2020 2020 2020  "a{c}b".        
+00001190: 2020 2020 6966 206c 656e 2873 2e73 706c      if len(s.spl
+000011a0: 6974 2829 2920 3d3d 2032 3a0a 2020 2020  it()) == 2:.    
+000011b0: 2020 2020 2020 2020 2020 2020 7079 7468              pyth
+000011c0: 6f6e 5f77 6869 7465 7370 6163 655f 7769  on_whitespace_wi
+000011d0: 7468 6f75 745f 646f 732e 6170 7065 6e64  thout_dos.append
+000011e0: 2863 290a 2020 2020 2020 2020 2020 2020  (c).            
+000011f0: 2020 2020 6966 206c 656e 2873 2e73 706c      if len(s.spl
+00001200: 6974 6c69 6e65 7328 2929 203d 3d20 323a  itlines()) == 2:
+00001210: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00001220: 2020 2020 2070 7974 686f 6e5f 6e65 776c       python_newl
+00001230: 696e 6573 5f77 6974 686f 7574 5f64 6f73  ines_without_dos
+00001240: 2e61 7070 656e 6428 6329 0a0a 2020 2020  .append(c)..    
+00001250: 2020 2020 7365 6c66 2e61 7373 6572 7445      self.assertE
+00001260: 7175 616c 2873 6574 2862 6967 2e77 6869  qual(set(big.whi
+00001270: 7465 7370 6163 655f 7769 7468 6f75 745f  tespace_without_
+00001280: 646f 7329 2c20 7365 7428 7079 7468 6f6e  dos), set(python
+00001290: 5f77 6869 7465 7370 6163 655f 7769 7468  _whitespace_with
+000012a0: 6f75 745f 646f 7329 290a 2020 2020 2020  out_dos)).      
+000012b0: 2020 7365 6c66 2e61 7373 6572 7445 7175    self.assertEqu
+000012c0: 616c 2873 6574 2862 6967 2e6e 6577 6c69  al(set(big.newli
+000012d0: 6e65 735f 7769 7468 6f75 745f 646f 7329  nes_without_dos)
+000012e0: 2c20 7365 7428 7079 7468 6f6e 5f6e 6577  , set(python_new
+000012f0: 6c69 6e65 735f 7769 7468 6f75 745f 646f  lines_without_do
+00001300: 7329 290a 0a20 2020 2020 2020 2070 7974  s))..        pyt
+00001310: 686f 6e5f 7768 6974 6573 7061 6365 203d  hon_whitespace =
+00001320: 206c 6973 7428 7079 7468 6f6e 5f77 6869   list(python_whi
+00001330: 7465 7370 6163 655f 7769 7468 6f75 745f  tespace_without_
+00001340: 646f 7329 0a20 2020 2020 2020 2070 7974  dos).        pyt
+00001350: 686f 6e5f 7768 6974 6573 7061 6365 2e61  hon_whitespace.a
+00001360: 7070 656e 6428 225c 725c 6e22 290a 2020  ppend("\r\n").  
+00001370: 2020 2020 2020 7079 7468 6f6e 5f6e 6577        python_new
+00001380: 6c69 6e65 7320 3d20 6c69 7374 2870 7974  lines = list(pyt
+00001390: 686f 6e5f 6e65 776c 696e 6573 5f77 6974  hon_newlines_wit
+000013a0: 686f 7574 5f64 6f73 290a 2020 2020 2020  hout_dos).      
+000013b0: 2020 7079 7468 6f6e 5f6e 6577 6c69 6e65    python_newline
+000013c0: 732e 6170 7065 6e64 2822 5c72 5c6e 2229  s.append("\r\n")
+000013d0: 0a20 2020 2020 2020 2073 656c 662e 6173  .        self.as
+000013e0: 7365 7274 4571 7561 6c28 7365 7428 6269  sertEqual(set(bi
+000013f0: 672e 7768 6974 6573 7061 6365 292c 2073  g.whitespace), s
+00001400: 6574 2870 7974 686f 6e5f 7768 6974 6573  et(python_whites
+00001410: 7061 6365 2929 0a20 2020 2020 2020 2073  pace)).        s
+00001420: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
+00001430: 7365 7428 6269 672e 6e65 776c 696e 6573  set(big.newlines
+00001440: 292c 2073 6574 2870 7974 686f 6e5f 6e65  ), set(python_ne
+00001450: 776c 696e 6573 2929 0a0a 2020 2020 2020  wlines))..      
+00001460: 2020 2320 6e6f 7720 7465 7374 2074 6865    # now test the
+00001470: 2075 7466 2d38 2061 6e64 2061 7363 6969   utf-8 and ascii
+00001480: 2076 6172 6961 6e74 7321 0a0a 2020 2020   variants!..    
+00001490: 2020 2020 7079 7468 6f6e 5f61 7363 6969      python_ascii
+000014a0: 5f77 6869 7465 7370 6163 6520 3d20 6269  _whitespace = bi
+000014b0: 672e 7465 7874 2e5f 6368 6561 705f 656e  g.text._cheap_en
+000014c0: 636f 6465 5f69 7465 7261 626c 655f 6f66  code_iterable_of
+000014d0: 5f73 7472 696e 6773 2870 7974 686f 6e5f  _strings(python_
+000014e0: 7768 6974 6573 7061 6365 2c20 2761 7363  whitespace, 'asc
+000014f0: 6969 2729 0a20 2020 2020 2020 2073 656c  ii').        sel
+00001500: 662e 6173 7365 7274 4571 7561 6c28 7365  f.assertEqual(se
+00001510: 7428 6269 672e 6173 6369 695f 7768 6974  t(big.ascii_whit
+00001520: 6573 7061 6365 292c 2073 6574 2870 7974  espace), set(pyt
+00001530: 686f 6e5f 6173 6369 695f 7768 6974 6573  hon_ascii_whites
+00001540: 7061 6365 2929 0a20 2020 2020 2020 2070  pace)).        p
+00001550: 7974 686f 6e5f 6173 6369 695f 7768 6974  ython_ascii_whit
+00001560: 6573 7061 6365 5f77 6974 686f 7574 5f64  espace_without_d
+00001570: 6f73 203d 2062 6967 2e74 6578 742e 5f63  os = big.text._c
+00001580: 6865 6170 5f65 6e63 6f64 655f 6974 6572  heap_encode_iter
+00001590: 6162 6c65 5f6f 665f 7374 7269 6e67 7328  able_of_strings(
+000015a0: 7079 7468 6f6e 5f77 6869 7465 7370 6163  python_whitespac
+000015b0: 655f 7769 7468 6f75 745f 646f 732c 2027  e_without_dos, '
+000015c0: 6173 6369 6927 290a 2020 2020 2020 2020  ascii').        
+000015d0: 7365 6c66 2e61 7373 6572 7445 7175 616c  self.assertEqual
+000015e0: 2873 6574 2862 6967 2e61 7363 6969 5f77  (set(big.ascii_w
+000015f0: 6869 7465 7370 6163 655f 7769 7468 6f75  hitespace_withou
+00001600: 745f 646f 7329 2c20 7365 7428 7079 7468  t_dos), set(pyth
+00001610: 6f6e 5f61 7363 6969 5f77 6869 7465 7370  on_ascii_whitesp
+00001620: 6163 655f 7769 7468 6f75 745f 646f 7329  ace_without_dos)
+00001630: 290a 2020 2020 2020 2020 7079 7468 6f6e  ).        python
+00001640: 5f61 7363 6969 5f6e 6577 6c69 6e65 7320  _ascii_newlines 
+00001650: 3d20 6269 672e 7465 7874 2e5f 6368 6561  = big.text._chea
+00001660: 705f 656e 636f 6465 5f69 7465 7261 626c  p_encode_iterabl
+00001670: 655f 6f66 5f73 7472 696e 6773 2870 7974  e_of_strings(pyt
+00001680: 686f 6e5f 6e65 776c 696e 6573 2c20 2761  hon_newlines, 'a
+00001690: 7363 6969 2729 0a20 2020 2020 2020 2073  scii').        s
+000016a0: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
+000016b0: 7365 7428 6269 672e 6173 6369 695f 6e65  set(big.ascii_ne
+000016c0: 776c 696e 6573 292c 2073 6574 2870 7974  wlines), set(pyt
+000016d0: 686f 6e5f 6173 6369 695f 6e65 776c 696e  hon_ascii_newlin
+000016e0: 6573 2929 0a20 2020 2020 2020 2070 7974  es)).        pyt
+000016f0: 686f 6e5f 6173 6369 695f 6e65 776c 696e  hon_ascii_newlin
+00001700: 6573 5f77 6974 686f 7574 5f64 6f73 203d  es_without_dos =
+00001710: 2062 6967 2e74 6578 742e 5f63 6865 6170   big.text._cheap
+00001720: 5f65 6e63 6f64 655f 6974 6572 6162 6c65  _encode_iterable
+00001730: 5f6f 665f 7374 7269 6e67 7328 7079 7468  _of_strings(pyth
+00001740: 6f6e 5f6e 6577 6c69 6e65 735f 7769 7468  on_newlines_with
+00001750: 6f75 745f 646f 732c 2027 6173 6369 6927  out_dos, 'ascii'
+00001760: 290a 2020 2020 2020 2020 7365 6c66 2e61  ).        self.a
+00001770: 7373 6572 7445 7175 616c 2873 6574 2862  ssertEqual(set(b
+00001780: 6967 2e61 7363 6969 5f6e 6577 6c69 6e65  ig.ascii_newline
+00001790: 735f 7769 7468 6f75 745f 646f 7329 2c20  s_without_dos), 
+000017a0: 7365 7428 7079 7468 6f6e 5f61 7363 6969  set(python_ascii
+000017b0: 5f6e 6577 6c69 6e65 735f 7769 7468 6f75  _newlines_withou
+000017c0: 745f 646f 7329 290a 0a20 2020 2020 2020  t_dos))..       
+000017d0: 2070 7974 686f 6e5f 7574 6638 5f77 6869   python_utf8_whi
+000017e0: 7465 7370 6163 6520 3d20 6269 672e 7465  tespace = big.te
+000017f0: 7874 2e5f 6368 6561 705f 656e 636f 6465  xt._cheap_encode
+00001800: 5f69 7465 7261 626c 655f 6f66 5f73 7472  _iterable_of_str
+00001810: 696e 6773 2870 7974 686f 6e5f 7768 6974  ings(python_whit
+00001820: 6573 7061 6365 2c20 2775 7466 3827 290a  espace, 'utf8').
+00001830: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
+00001840: 6572 7445 7175 616c 2873 6574 2862 6967  ertEqual(set(big
+00001850: 2e75 7466 385f 7768 6974 6573 7061 6365  .utf8_whitespace
+00001860: 292c 2073 6574 2870 7974 686f 6e5f 7574  ), set(python_ut
+00001870: 6638 5f77 6869 7465 7370 6163 6529 290a  f8_whitespace)).
+00001880: 2020 2020 2020 2020 7079 7468 6f6e 5f75          python_u
+00001890: 7466 385f 7768 6974 6573 7061 6365 5f77  tf8_whitespace_w
+000018a0: 6974 686f 7574 5f64 6f73 203d 2062 6967  ithout_dos = big
+000018b0: 2e74 6578 742e 5f63 6865 6170 5f65 6e63  .text._cheap_enc
+000018c0: 6f64 655f 6974 6572 6162 6c65 5f6f 665f  ode_iterable_of_
+000018d0: 7374 7269 6e67 7328 7079 7468 6f6e 5f77  strings(python_w
+000018e0: 6869 7465 7370 6163 655f 7769 7468 6f75  hitespace_withou
+000018f0: 745f 646f 732c 2027 7574 6638 2729 0a20  t_dos, 'utf8'). 
+00001900: 2020 2020 2020 2073 656c 662e 6173 7365         self.asse
+00001910: 7274 4571 7561 6c28 7365 7428 6269 672e  rtEqual(set(big.
+00001920: 7574 6638 5f77 6869 7465 7370 6163 655f  utf8_whitespace_
+00001930: 7769 7468 6f75 745f 646f 7329 2c20 7365  without_dos), se
+00001940: 7428 7079 7468 6f6e 5f75 7466 385f 7768  t(python_utf8_wh
+00001950: 6974 6573 7061 6365 5f77 6974 686f 7574  itespace_without
+00001960: 5f64 6f73 2929 0a20 2020 2020 2020 2070  _dos)).        p
+00001970: 7974 686f 6e5f 7574 6638 5f6e 6577 6c69  ython_utf8_newli
+00001980: 6e65 7320 3d20 6269 672e 7465 7874 2e5f  nes = big.text._
+00001990: 6368 6561 705f 656e 636f 6465 5f69 7465  cheap_encode_ite
+000019a0: 7261 626c 655f 6f66 5f73 7472 696e 6773  rable_of_strings
+000019b0: 2870 7974 686f 6e5f 6e65 776c 696e 6573  (python_newlines
+000019c0: 2c20 2775 7466 3827 290a 2020 2020 2020  , 'utf8').      
+000019d0: 2020 7365 6c66 2e61 7373 6572 7445 7175    self.assertEqu
+000019e0: 616c 2873 6574 2862 6967 2e75 7466 385f  al(set(big.utf8_
+000019f0: 6e65 776c 696e 6573 292c 2073 6574 2870  newlines), set(p
+00001a00: 7974 686f 6e5f 7574 6638 5f6e 6577 6c69  ython_utf8_newli
+00001a10: 6e65 7329 290a 2020 2020 2020 2020 7079  nes)).        py
+00001a20: 7468 6f6e 5f75 7466 385f 6e65 776c 696e  thon_utf8_newlin
+00001a30: 6573 5f77 6974 686f 7574 5f64 6f73 203d  es_without_dos =
+00001a40: 2062 6967 2e74 6578 742e 5f63 6865 6170   big.text._cheap
+00001a50: 5f65 6e63 6f64 655f 6974 6572 6162 6c65  _encode_iterable
+00001a60: 5f6f 665f 7374 7269 6e67 7328 7079 7468  _of_strings(pyth
+00001a70: 6f6e 5f6e 6577 6c69 6e65 735f 7769 7468  on_newlines_with
+00001a80: 6f75 745f 646f 732c 2027 7574 6638 2729  out_dos, 'utf8')
+00001a90: 0a20 2020 2020 2020 2073 656c 662e 6173  .        self.as
+00001aa0: 7365 7274 4571 7561 6c28 7365 7428 6269  sertEqual(set(bi
+00001ab0: 672e 7574 6638 5f6e 6577 6c69 6e65 735f  g.utf8_newlines_
+00001ac0: 7769 7468 6f75 745f 646f 7329 2c20 7365  without_dos), se
+00001ad0: 7428 7079 7468 6f6e 5f75 7466 385f 6e65  t(python_utf8_ne
+00001ae0: 776c 696e 6573 5f77 6974 686f 7574 5f64  wlines_without_d
+00001af0: 6f73 2929 0a0a 2020 2020 2020 2020 2320  os))..        # 
+00001b00: 6e6f 7720 7465 7374 2074 6865 2063 6163  now test the cac
+00001b10: 6865 6420 7265 7665 7273 6564 2062 7569  hed reversed bui
+00001b20: 6c74 696e 2073 6570 6172 6174 6f72 7321  ltin separators!
+00001b30: 0a20 2020 2020 2020 2066 6f72 2066 6f72  .        for for
+00001b40: 7761 7264 732c 2062 6163 6b77 6172 6473  wards, backwards
+00001b50: 2069 6e20 6269 672e 7465 7874 2e5f 7265   in big.text._re
+00001b60: 7665 7273 6564 5f62 7569 6c74 696e 5f73  versed_builtin_s
+00001b70: 6570 6172 6174 6f72 732e 6974 656d 7328  eparators.items(
+00001b80: 293a 0a20 2020 2020 2020 2020 2020 2073  ):.            s
+00001b90: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
+00001ba0: 7365 7428 6261 636b 7761 7264 7329 2c20  set(backwards), 
+00001bb0: 7365 7428 6269 672e 7465 7874 2e5f 6d75  set(big.text._mu
+00001bc0: 6c74 6973 706c 6974 5f72 6576 6572 7365  ltisplit_reverse
+00001bd0: 6428 666f 7277 6172 6473 2929 2c20 6622  d(forwards)), f"
+00001be0: 6661 696c 6564 206f 6e20 7b70 7269 6e74  failed on {print
+00001bf0: 6162 6c65 5f73 6570 6172 6174 6f72 7328  able_separators(
+00001c00: 666f 7277 6172 6473 297d 2229 0a0a 2020  forwards)}")..  
+00001c10: 2020 6465 6620 7465 7374 5f72 6576 6572    def test_rever
+00001c20: 7365 645f 7265 5f66 696e 6469 7465 7228  sed_re_finditer(
+00001c30: 7365 6c66 293a 0a20 2020 2020 2020 2023  self):.        #
+00001c40: 2043 7269 6262 6564 206f 6666 2074 6865   Cribbed off the
+00001c50: 2074 6573 7420 7375 6974 6520 6672 6f6d   test suite from
+00001c60: 2074 6865 2027 7265 6765 7827 2070 6163   the 'regex' pac
+00001c70: 6b61 6765 0a20 2020 2020 2020 2064 6566  kage.        def
+00001c80: 2074 6573 7428 7061 7474 6572 6e2c 2073   test(pattern, s
+00001c90: 7472 696e 672c 2065 7870 6563 7465 6429  tring, expected)
+00001ca0: 3a0a 2020 2020 2020 2020 2020 2020 7061  :.            pa
+00001cb0: 7474 6572 6e20 3d20 6328 7061 7474 6572  ttern = c(patter
+00001cc0: 6e29 0a20 2020 2020 2020 2020 2020 2073  n).            s
+00001cd0: 7472 696e 6720 3d20 6328 7374 7269 6e67  tring = c(string
+00001ce0: 290a 2020 2020 2020 2020 2020 2020 6578  ).            ex
+00001cf0: 7065 6374 6564 203d 2063 2865 7870 6563  pected = c(expec
+00001d00: 7465 6429 0a20 2020 2020 2020 2020 2020  ted).           
+00001d10: 2067 6f74 203d 2066 696e 6469 7465 725f   got = finditer_
+00001d20: 6772 6f75 7030 2862 6967 2e72 6576 6572  group0(big.rever
+00001d30: 7365 645f 7265 5f66 696e 6469 7465 7228  sed_re_finditer(
+00001d40: 7061 7474 6572 6e2c 2073 7472 696e 6729  pattern, string)
+00001d50: 290a 0a20 2020 2020 2020 2020 2020 2069  )..            i
+00001d60: 6620 6861 7665 5f72 6567 6578 3a0a 2020  f have_regex:.  
+00001d70: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+00001d80: 636f 6e66 6972 6d20 6669 7273 7420 7468  confirm first th
+00001d90: 6174 2077 6520 6d61 7463 6820 7265 6765  at we match rege
+00001da0: 7827 7320 6f75 7470 7574 0a20 2020 2020  x's output.     
+00001db0: 2020 2020 2020 2020 2020 2069 6620 6973             if is
+00001dc0: 696e 7374 616e 6365 2870 6174 7465 726e  instance(pattern
+00001dd0: 2c20 7265 5f50 6174 7465 726e 293a 0a20  , re_Pattern):. 
+00001de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001df0: 2020 2070 203d 2070 6174 7465 726e 2e70     p = pattern.p
+00001e00: 6174 7465 726e 0a20 2020 2020 2020 2020  attern.         
+00001e10: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00001e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001e30: 2070 203d 2070 6174 7465 726e 0a20 2020   p = pattern.   
+00001e40: 2020 2020 2020 2020 2020 2020 2070 203d               p =
+00001e50: 2072 6567 6578 2e63 6f6d 7069 6c65 2870   regex.compile(p
+00001e60: 2c20 7265 6765 782e 5245 5645 5253 4529  , regex.REVERSE)
+00001e70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00001e80: 2072 6567 6578 5f72 6573 756c 7420 3d20   regex_result = 
+00001e90: 6669 6e64 6974 6572 5f67 726f 7570 3028  finditer_group0(
+00001ea0: 702e 6669 6e64 6974 6572 2873 7472 696e  p.finditer(strin
+00001eb0: 6729 290a 2020 2020 2020 2020 2020 2020  g)).            
+00001ec0: 2020 2020 2320 7072 696e 7428 6622 7b70      # print(f"{p
+00001ed0: 6174 7465 726e 3d7d 207b 7374 7269 6e67  attern=} {string
+00001ee0: 3d7d 207b 7265 6765 785f 7265 7375 6c74  =} {regex_result
+00001ef0: 3d7d 207b 676f 743d 7d22 290a 2020 2020  =} {got=}").    
+00001f00: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00001f10: 2e61 7373 6572 7445 7175 616c 2872 6567  .assertEqual(reg
+00001f20: 6578 5f72 6573 756c 742c 2067 6f74 290a  ex_result, got).
+00001f30: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00001f40: 662e 6173 7365 7274 4571 7561 6c28 6578  f.assertEqual(ex
+00001f50: 7065 6374 6564 2c20 676f 7429 0a0a 2020  pected, got)..  
+00001f60: 2020 2020 2020 666f 7220 6320 696e 2028        for c in (
+00001f70: 756e 6368 616e 6765 642c 2074 6f5f 6279  unchanged, to_by
+00001f80: 7465 7329 3a0a 2020 2020 2020 2020 2020  tes):.          
+00001f90: 2020 7465 7374 2872 2761 6263 6465 6627    test(r'abcdef'
+00001fa0: 2c20 2761 6263 6465 6627 2c20 2827 6162  , 'abcdef', ('ab
+00001fb0: 6364 6566 272c 2929 0a20 2020 2020 2020  cdef',)).       
+00001fc0: 2020 2020 2074 6573 7428 272e 272c 2027       test('.', '
+00001fd0: 6162 6327 2c20 2827 6327 2c20 2762 272c  abc', ('c', 'b',
+00001fe0: 2027 6127 2929 0a20 2020 2020 2020 2020   'a')).         
+00001ff0: 2020 2074 6573 7428 272e 2e27 2c20 2761     test('..', 'a
+00002000: 6263 6465 272c 2028 2764 6527 2c20 2762  bcde', ('de', 'b
+00002010: 6327 2929 0a20 2020 2020 2020 2020 2020  c')).           
+00002020: 2074 6573 7428 272e 2d2e 272c 2027 612d   test('.-.', 'a-
+00002030: 622d 6327 2c20 2827 622d 6327 2c29 290a  b-c', ('b-c',)).
+00002040: 2020 2020 2020 2020 2020 2020 7465 7374              test
+00002050: 2827 617c 6227 2c20 2731 3131 6132 3232  ('a|b', '111a222
+00002060: 272c 2028 2761 272c 2929 0a20 2020 2020  ', ('a',)).     
+00002070: 2020 2020 2020 2074 6573 7428 7265 2e63         test(re.c
+00002080: 6f6d 7069 6c65 2827 627c 6127 292c 2027  ompile('b|a'), '
+00002090: 3131 3161 3232 3227 2c20 2827 6127 2c29  111a222', ('a',)
+000020a0: 290a 2020 2020 2020 2020 2020 2020 7465  ).            te
+000020b0: 7374 2827 787c 5827 2c20 2778 6178 6258  st('x|X', 'xaxbX
+000020c0: 6378 6427 2c20 2827 7827 2c20 2758 272c  cxd', ('x', 'X',
+000020d0: 2027 7827 2c20 2778 272c 2929 0a20 2020   'x', 'x',)).   
+000020e0: 2020 2020 2020 2020 2074 6573 7428 7227           test(r'
+000020f0: 6573 746f 6e69 615c 7727 2c20 2766 696e  estonia\w', 'fin
+00002100: 6520 6573 746f 6e69 616e 2077 6f72 6b65  e estonian worke
+00002110: 7273 272c 2028 2765 7374 6f6e 6961 6e27  rs', ('estonian'
+00002120: 2c29 290a 2020 2020 2020 2020 2020 2020  ,)).            
+00002130: 7465 7374 2872 275c 7765 7374 6f6e 6961  test(r'\westonia
+00002140: 272c 2027 6669 6e65 206e 6573 746f 6e69  ', 'fine nestoni
+00002150: 616e 2077 6f72 6b65 7273 272c 2028 276e  an workers', ('n
+00002160: 6573 746f 6e69 6127 2c29 290a 0a20 2020  estonia',))..   
+00002170: 2020 2020 2020 2020 2023 2074 6869 7320           # this 
+00002180: 7a65 726f 2d6c 656e 6774 6820 6d61 7463  zero-length matc
+00002190: 6820 7374 7566 6620 6973 2062 6c6f 7769  h stuff is blowi
+000021a0: 6e67 206d 7920 6d69 6e64 0a20 2020 2020  ng my mind.     
+000021b0: 2020 2020 2020 2074 6573 7428 7227 712a         test(r'q*
+000021c0: 272c 2027 7171 7765 272c 2020 2028 2727  ', 'qqwe',   (''
+000021d0: 2c20 2727 2c20 2771 7127 2c20 2727 2929  , '', 'qq', ''))
+000021e0: 0a20 2020 2020 2020 2020 2020 2074 6573  .            tes
+000021f0: 7428 7227 712a 272c 2027 7879 7171 7765  t(r'q*', 'xyqqwe
+00002200: 272c 2028 2727 2c20 2727 2c20 2771 7127  ', ('', '', 'qq'
+00002210: 2c20 2727 2c20 2727 2c20 2727 2929 0a20  , '', '', '')). 
+00002220: 2020 2020 2020 2020 2020 2074 6573 7428             test(
+00002230: 7227 712a 272c 2027 7879 7171 272c 2020  r'q*', 'xyqq',  
+00002240: 2028 2771 7127 2c20 2727 2c20 2727 2c20   ('qq', '', '', 
+00002250: 2727 2929 0a20 2020 2020 2020 2020 2020  '')).           
+00002260: 2074 6573 7428 7227 712a 272c 2027 7171   test(r'q*', 'qq
+00002270: 272c 2020 2020 2028 2771 7127 2c20 2727  ',     ('qq', ''
+00002280: 2929 0a20 2020 2020 2020 2020 2020 2074  )).            t
+00002290: 6573 7428 7227 712a 272c 2027 712d 7171  est(r'q*', 'q-qq
+000022a0: 7765 272c 2020 2028 2727 2c20 2727 2c20  we',   ('', '', 
+000022b0: 2771 7127 2c20 2727 2c20 2771 272c 2027  'qq', '', 'q', '
+000022c0: 2729 290a 2020 2020 2020 2020 2020 2020  ')).            
+000022d0: 7465 7374 2872 2771 2a27 2c20 2778 7971  test(r'q*', 'xyq
+000022e0: 2d71 7177 6527 2c20 2827 272c 2027 272c  -qqwe', ('', '',
+000022f0: 2027 7171 272c 2027 272c 2027 7127 2c20   'qq', '', 'q', 
+00002300: 2727 2c20 2727 2c20 2727 2929 0a20 2020  '', '', '')).   
+00002310: 2020 2020 2020 2020 2074 6573 7428 7227           test(r'
+00002320: 712a 272c 2027 7879 712d 7171 272c 2020  q*', 'xyq-qq',  
+00002330: 2028 2771 7127 2c20 2727 2c20 2771 272c   ('qq', '', 'q',
+00002340: 2027 272c 2027 272c 2027 2729 290a 2020   '', '', '')).  
+00002350: 2020 2020 2020 2020 2020 7465 7374 2872            test(r
+00002360: 2771 2a27 2c20 2771 2d71 7127 2c20 2020  'q*', 'q-qq',   
+00002370: 2020 2827 7171 272c 2027 272c 2027 7127    ('qq', '', 'q'
+00002380: 2c20 2727 2929 0a0a 2020 2020 2020 2020  , ''))..        
+00002390: 2020 2020 7465 7374 2872 2762 6364 7c63      test(r'bcd|c
+000023a0: 6465 272c 2027 6162 6364 6566 6727 2c20  de', 'abcdefg', 
+000023b0: 2020 2020 2827 6364 6527 2c29 290a 0a20      ('cde',)).. 
+000023c0: 2020 2020 2020 2020 2020 2023 2066 6f72             # for
+000023d0: 6365 2061 207a 6572 6f2d 6c65 6e67 7468  ce a zero-length
+000023e0: 206d 6174 6368 2074 6f20 6861 7665 2074   match to have t
+000023f0: 6865 2073 616d 6520 7374 6172 7420 6173  he same start as
+00002400: 2061 0a20 2020 2020 2020 2020 2020 2023   a.            #
+00002410: 2074 6573 7428 7227 712a 272c 2027 6171   test(r'q*', 'aq
+00002420: 7177 6527 2c20 2020 2827 272c 2027 272c  qwe',   ('', '',
+00002430: 2027 7171 272c 2027 272c 2027 2729 290a   'qq', '', '')).
+00002440: 0a20 2020 2020 2020 2020 2020 2074 6573  .            tes
+00002450: 7428 7227 2e7b 327d 272c 2027 6162 6327  t(r'.{2}', 'abc'
+00002460: 2c20 2827 6263 272c 2929 0a20 2020 2020  , ('bc',)).     
+00002470: 2020 2020 2020 2074 6573 7428 7227 5c77         test(r'\w
+00002480: 2b20 5c77 2b27 2c20 2766 6972 7374 2073  + \w+', 'first s
+00002490: 6563 6f6e 6420 7468 6972 6420 666f 7572  econd third four
+000024a0: 7468 2066 6966 7468 272c 2028 2766 6f75  th fifth', ('fou
+000024b0: 7274 6820 6669 6674 6827 2c20 2773 6563  rth fifth', 'sec
+000024c0: 6f6e 6420 7468 6972 6427 2929 0a0a 2020  ond third'))..  
+000024d0: 2020 2020 2020 2020 2020 2320 5079 7468            # Pyth
+000024e0: 6f6e 2033 2e37 2066 6978 6564 2061 206c  on 3.7 fixed a l
+000024f0: 6f6e 672d 7374 616e 6469 6e67 2062 7567  ong-standing bug
+00002500: 2077 6974 6820 7a65 726f 2d77 6964 7468   with zero-width
+00002510: 206d 6174 6368 696e 672e 0a20 2020 2020   matching..     
+00002520: 2020 2020 2020 2023 2053 6565 2068 7474         # See htt
+00002530: 7073 3a2f 2f67 6974 6875 622e 636f 6d2f  ps://github.com/
+00002540: 7079 7468 6f6e 2f63 7079 7468 6f6e 2f69  python/cpython/i
+00002550: 7373 7565 732f 3434 3531 390a 2020 2020  ssues/44519.    
+00002560: 2020 2020 2020 2020 6173 7365 7274 2073          assert s
+00002570: 7973 2e76 6572 7369 6f6e 5f69 6e66 6f2e  ys.version_info.
+00002580: 6d61 6a6f 7220 3e3d 2033 0a20 2020 2020  major >= 3.     
+00002590: 2020 2020 2020 2069 6620 2873 7973 2e76         if (sys.v
+000025a0: 6572 7369 6f6e 5f69 6e66 6f2e 6d61 6a6f  ersion_info.majo
+000025b0: 7220 3d3d 2033 2920 616e 6420 2873 7973  r == 3) and (sys
+000025c0: 2e76 6572 7369 6f6e 5f69 6e66 6f2e 6d69  .version_info.mi
+000025d0: 6e6f 7220 3c3d 2036 293a 2020 2320 7072  nor <= 6):  # pr
+000025e0: 6167 6d61 3a20 6e6f 2063 6f76 6572 0a20  agma: no cover. 
+000025f0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+00002600: 2077 726f 6e67 2c20 6275 7420 636f 6e73   wrong, but cons
+00002610: 6973 7465 6e74 0a20 2020 2020 2020 2020  istent.         
+00002620: 2020 2020 2020 2072 6573 756c 7420 3d20         result = 
+00002630: 2827 6261 7227 2c20 276f 6f27 2c20 2727  ('bar', 'oo', ''
+00002640: 290a 2020 2020 2020 2020 2020 2020 656c  ).            el
+00002650: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00002660: 2020 2020 2320 636f 7272 6563 740a 2020      # correct.  
+00002670: 2020 2020 2020 2020 2020 2020 2020 7265                re
+00002680: 7375 6c74 203d 2028 2762 6172 272c 2027  sult = ('bar', '
+00002690: 666f 6f27 2c20 2727 290a 2020 2020 2020  foo', '').      
+000026a0: 2020 2020 2020 7465 7374 2872 275e 7c5c        test(r'^|\
+000026b0: 772b 272c 2027 666f 6f20 6261 7227 2c20  w+', 'foo bar', 
+000026c0: 7265 7375 6c74 290a 0a20 2020 2020 2020  result)..       
+000026d0: 2020 2020 2023 2072 6567 7265 7373 696f       # regressio
+000026e0: 6e20 7465 7374 3a20 7468 6520 696e 6974  n test: the init
+000026f0: 6961 6c20 696d 706c 656d 656e 7461 7469  ial implementati
+00002700: 6f6e 2067 6f74 2074 6869 7320 7772 6f6e  on got this wron
+00002710: 672e 0a20 2020 2020 2020 2020 2020 2023  g..            #
+00002720: 2069 7420 6e65 7665 7220 7472 756e 6361   it never trunca
+00002730: 7465 640a 2020 2020 2020 2020 2020 2020  ted.            
+00002740: 7465 7374 2872 2763 6465 6667 6869 6a6b  test(r'cdefghijk
+00002750: 7c62 6364 7c66 6768 7c6a 6b6c 272c 2027  |bcd|fgh|jkl', '
+00002760: 6162 6364 6566 6768 696a 6b6c 6d6e 6f70  abcdefghijklmnop
+00002770: 7172 7374 7576 7778 797a 272c 2028 276a  qrstuvwxyz', ('j
+00002780: 6b6c 272c 2027 6667 6827 2c20 2762 6364  kl', 'fgh', 'bcd
+00002790: 2729 290a 0a20 2020 2064 6566 2074 6573  '))..    def tes
+000027a0: 745f 7265 5f70 6172 7469 7469 6f6e 2873  t_re_partition(s
+000027b0: 656c 6629 3a0a 2020 2020 2020 2020 6465  elf):.        de
+000027c0: 6620 7465 7374 5f72 655f 7061 7274 6974  f test_re_partit
+000027d0: 696f 6e28 732c 2070 6174 7465 726e 2c20  ion(s, pattern, 
+000027e0: 636f 756e 742c 2065 7870 6563 7465 6429  count, expected)
+000027f0: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
+00002800: 6c66 2e61 7373 6572 7445 7175 616c 2867  lf.assertEqual(g
+00002810: 726f 7570 3028 6269 672e 7265 5f70 6172  roup0(big.re_par
+00002820: 7469 7469 6f6e 2863 2873 292c 2063 2870  tition(c(s), c(p
+00002830: 6174 7465 726e 292c 2063 6f75 6e74 2929  attern), count))
+00002840: 2c20 6328 6578 7065 6374 6564 2929 0a0a  , c(expected))..
+00002850: 2020 2020 2020 2020 6465 6620 7465 7374          def test
+00002860: 5f72 655f 7270 6172 7469 7469 6f6e 2873  _re_rpartition(s
+00002870: 2c20 7061 7474 6572 6e2c 2063 6f75 6e74  , pattern, count
+00002880: 2c20 6578 7065 6374 6564 293a 0a20 2020  , expected):.   
+00002890: 2020 2020 2020 2020 2073 203d 2063 2873           s = c(s
+000028a0: 290a 2020 2020 2020 2020 2020 2020 7061  ).            pa
+000028b0: 7474 6572 6e20 3d20 6328 7061 7474 6572  ttern = c(patter
+000028c0: 6e29 0a20 2020 2020 2020 2020 2020 2065  n).            e
+000028d0: 7870 6563 7465 6420 3d20 6328 6578 7065  xpected = c(expe
+000028e0: 6374 6564 290a 0a20 2020 2020 2020 2020  cted)..         
+000028f0: 2020 2073 656c 662e 6173 7365 7274 4571     self.assertEq
+00002900: 7561 6c28 6772 6f75 7030 2862 6967 2e72  ual(group0(big.r
+00002910: 655f 7270 6172 7469 7469 6f6e 2873 2c20  e_rpartition(s, 
+00002920: 7061 7474 6572 6e2c 2063 6f75 6e74 2929  pattern, count))
+00002930: 2c20 6578 7065 6374 6564 290a 2020 2020  , expected).    
+00002940: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
+00002950: 6572 7445 7175 616c 2867 726f 7570 3028  ertEqual(group0(
+00002960: 6269 672e 7265 5f70 6172 7469 7469 6f6e  big.re_partition
+00002970: 2873 2c20 7061 7474 6572 6e2c 2063 6f75  (s, pattern, cou
+00002980: 6e74 2c20 7265 7665 7273 653d 5472 7565  nt, reverse=True
+00002990: 2929 2c20 6578 7065 6374 6564 290a 0a20  )), expected).. 
+000029a0: 2020 2020 2020 2020 2020 2023 2057 6520             # We 
+000029b0: 696d 706c 6963 6974 6c79 2074 6573 7420  implicitly test 
+000029c0: 7265 7665 7273 6564 5f72 655f 6669 6e64  reversed_re_find
+000029d0: 6974 6572 0a20 2020 2020 2020 2020 2020  iter.           
+000029e0: 2023 2065 7665 7279 2074 696d 6520 7765   # every time we
+000029f0: 2074 6573 7420 7265 5f72 7061 7274 6974   test re_rpartit
+00002a00: 696f 6e2e 0a20 2020 2020 2020 2020 2020  ion..           
+00002a10: 2023 0a20 2020 2020 2020 2020 2020 2023   #.            #
+00002a20: 2042 7574 2c20 6966 2072 6567 6578 2069   But, if regex i
+00002a30: 7320 696e 7374 616c 6c65 642c 206c 6574  s installed, let
+00002a40: 2773 2074 6872 6f77 0a20 2020 2020 2020  's throw.       
+00002a50: 2020 2020 2023 2069 6e20 616e 2065 7870       # in an exp
+00002a60: 6c69 6369 7420 7465 7374 2066 6f72 2072  licit test for r
+00002a70: 6576 6572 7365 645f 7265 5f66 696e 6469  eversed_re_findi
+00002a80: 7465 7220 746f 6f2e 0a20 2020 2020 2020  ter too..       
+00002a90: 2020 2020 2023 2057 6520 7275 6e20 6974       # We run it
+00002aa0: 2064 6972 6563 746c 7920 6f6e 2074 6865   directly on the
+00002ab0: 2070 6174 7465 726e 2026 2073 7472 696e   pattern & strin
+00002ac0: 670a 2020 2020 2020 2020 2020 2020 2320  g.            # 
+00002ad0: 696e 7075 7473 2077 6520 7573 6520 746f  inputs we use to
+00002ae0: 2074 6573 7420 7265 5f72 7061 7274 6974   test re_rpartit
+00002af0: 696f 6e2c 0a20 2020 2020 2020 2020 2020  ion,.           
+00002b00: 2023 2074 6865 6e20 636f 6d70 6172 6520   # then compare 
+00002b10: 6974 7320 6f75 7470 7574 2077 6974 6820  its output with 
+00002b20: 7468 6520 6f75 7470 7574 206f 660a 2020  the output of.  
+00002b30: 2020 2020 2020 2020 2020 2320 7468 6520            # the 
+00002b40: 7265 6765 7820 6c69 6272 6172 7920 7769  regex library wi
+00002b50: 7468 2052 4556 4552 5345 206d 6f64 6520  th REVERSE mode 
+00002b60: 7475 726e 6564 206f 6e2e 0a20 2020 2020  turned on..     
+00002b70: 2020 2020 2020 2069 6620 6861 7665 5f72         if have_r
+00002b80: 6567 6578 3a0a 2020 2020 2020 2020 2020  egex:.          
+00002b90: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
+00002ba0: 6e63 6528 7061 7474 6572 6e2c 2072 655f  nce(pattern, re_
+00002bb0: 5061 7474 6572 6e29 3a0a 2020 2020 2020  Pattern):.      
+00002bc0: 2020 2020 2020 2020 2020 2020 2020 7020                p 
+00002bd0: 3d20 7061 7474 6572 6e2e 7061 7474 6572  = pattern.patter
+00002be0: 6e0a 2020 2020 2020 2020 2020 2020 2020  n.              
+00002bf0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00002c00: 2020 2020 2020 2020 2020 2020 7020 3d20              p = 
+00002c10: 7061 7474 6572 6e0a 2020 2020 2020 2020  pattern.        
+00002c20: 2020 2020 2020 2020 7020 3d20 7265 6765          p = rege
+00002c30: 782e 636f 6d70 696c 6528 702c 2072 6567  x.compile(p, reg
+00002c40: 6578 2e52 4556 4552 5345 290a 2020 2020  ex.REVERSE).    
+00002c50: 2020 2020 2020 2020 2020 2020 7265 6765              rege
+00002c60: 785f 7265 7375 6c74 203d 2066 696e 6469  x_result = findi
+00002c70: 7465 725f 6772 6f75 7030 2870 2e66 696e  ter_group0(p.fin
+00002c80: 6469 7465 7228 7329 290a 2020 2020 2020  diter(s)).      
+00002c90: 2020 2020 2020 2020 2020 6269 675f 7265            big_re
+00002ca0: 7375 6c74 203d 2066 696e 6469 7465 725f  sult = finditer_
+00002cb0: 6772 6f75 7030 2862 6967 2e72 6576 6572  group0(big.rever
+00002cc0: 7365 645f 7265 5f66 696e 6469 7465 7228  sed_re_finditer(
+00002cd0: 7061 7474 6572 6e2c 2073 2929 0a20 2020  pattern, s)).   
+00002ce0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+00002cf0: 662e 6173 7365 7274 4571 7561 6c28 7265  f.assertEqual(re
+00002d00: 6765 785f 7265 7375 6c74 2c20 6269 675f  gex_result, big_
+00002d10: 7265 7375 6c74 290a 0a0a 2020 2020 2020  result)...      
+00002d20: 2020 666f 7220 6320 696e 2028 756e 6368    for c in (unch
+00002d30: 616e 6765 642c 2074 6f5f 6279 7465 7329  anged, to_bytes)
+00002d40: 3a0a 0a20 2020 2020 2020 2020 2020 2070  :..            p
+00002d50: 6174 7465 726e 203d 2063 2822 5b30 2d39  attern = c("[0-9
+00002d60: 5d2b 2229 0a0a 2020 2020 2020 2020 2020  ]+")..          
+00002d70: 2020 7320 3d20 2261 6263 3132 3364 6566    s = "abc123def
+00002d80: 3435 3667 6869 220a 2020 2020 2020 2020  456ghi".        
+00002d90: 2020 2020 7465 7374 5f72 655f 7061 7274      test_re_part
+00002da0: 6974 696f 6e28 2073 2c20 7061 7474 6572  ition( s, patter
+00002db0: 6e2c 2031 2c20 2822 6162 6322 2c20 2231  n, 1, ("abc", "1
+00002dc0: 3233 222c 2022 6465 6634 3536 6768 6922  23", "def456ghi"
+00002dd0: 2920 290a 2020 2020 2020 2020 2020 2020  ) ).            
+00002de0: 7465 7374 5f72 655f 7270 6172 7469 7469  test_re_rpartiti
+00002df0: 6f6e 2873 2c20 7061 7474 6572 6e2c 2031  on(s, pattern, 1
+00002e00: 2c20 2822 6162 6331 3233 6465 6622 2c20  , ("abc123def", 
+00002e10: 2234 3536 222c 2022 6768 6922 2920 290a  "456", "ghi") ).
+00002e20: 0a20 2020 2020 2020 2020 2020 2073 203d  .            s =
+00002e30: 2022 6162 6331 3233 3435 6465 6636 3738   "abc12345def678
+00002e40: 3930 6768 6922 0a20 2020 2020 2020 2020  90ghi".         
+00002e50: 2020 2074 6573 745f 7265 5f70 6172 7469     test_re_parti
+00002e60: 7469 6f6e 2820 732c 2070 6174 7465 726e  tion( s, pattern
+00002e70: 2c20 312c 2028 2261 6263 222c 2022 3132  , 1, ("abc", "12
+00002e80: 3334 3522 2c20 2264 6566 3637 3839 3067  345", "def67890g
+00002e90: 6869 2229 2029 0a20 2020 2020 2020 2020  hi") ).         
+00002ea0: 2020 2074 6573 745f 7265 5f72 7061 7274     test_re_rpart
+00002eb0: 6974 696f 6e28 732c 2070 6174 7465 726e  ition(s, pattern
+00002ec0: 2c20 312c 2028 2261 6263 3132 3334 3564  , 1, ("abc12345d
+00002ed0: 6566 222c 2022 3637 3839 3022 2c20 2267  ef", "67890", "g
+00002ee0: 6869 2229 2029 0a0a 2020 2020 2020 2020  hi") )..        
+00002ef0: 2020 2020 7061 7474 6572 6e20 3d20 7265      pattern = re
+00002f00: 2e63 6f6d 7069 6c65 2870 6174 7465 726e  .compile(pattern
+00002f10: 290a 2020 2020 2020 2020 2020 2020 7465  ).            te
+00002f20: 7374 5f72 655f 7061 7274 6974 696f 6e28  st_re_partition(
+00002f30: 2073 2c20 7061 7474 6572 6e2c 2031 2c20   s, pattern, 1, 
+00002f40: 2822 6162 6322 2c20 2231 3233 3435 222c  ("abc", "12345",
+00002f50: 2022 6465 6636 3738 3930 6768 6922 2920   "def67890ghi") 
+00002f60: 290a 2020 2020 2020 2020 2020 2020 7465  ).            te
+00002f70: 7374 5f72 655f 7270 6172 7469 7469 6f6e  st_re_rpartition
+00002f80: 2873 2c20 7061 7474 6572 6e2c 2031 2c20  (s, pattern, 1, 
+00002f90: 2822 6162 6331 3233 3435 6465 6622 2c20  ("abc12345def", 
+00002fa0: 2236 3738 3930 222c 2022 6768 6922 2920  "67890", "ghi") 
+00002fb0: 290a 0a20 2020 2020 2020 2020 2020 2070  )..            p
+00002fc0: 6174 7465 726e 203d 2063 2822 6661 2b72  attern = c("fa+r
+00002fd0: 6b22 290a 2020 2020 2020 2020 2020 2020  k").            
+00002fe0: 7465 7374 5f72 655f 7061 7274 6974 696f  test_re_partitio
+00002ff0: 6e28 2073 2c20 7061 7474 6572 6e2c 2031  n( s, pattern, 1
+00003000: 2c20 2822 6162 6331 3233 3435 6465 6636  , ("abc12345def6
+00003010: 3738 3930 6768 6922 2c20 4e6f 6e65 2c20  7890ghi", None, 
+00003020: 2222 2920 290a 2020 2020 2020 2020 2020  "") ).          
+00003030: 2020 7465 7374 5f72 655f 7270 6172 7469    test_re_rparti
+00003040: 7469 6f6e 2873 2c20 7061 7474 6572 6e2c  tion(s, pattern,
+00003050: 2031 2c20 2822 222c 204e 6f6e 652c 2022   1, ("", None, "
+00003060: 6162 6331 3233 3435 6465 6636 3738 3930  abc12345def67890
+00003070: 6768 6922 2920 290a 0a20 2020 2020 2020  ghi") )..       
+00003080: 2020 2020 2023 2074 6573 7420 6f76 6572       # test over
+00003090: 6c61 7070 696e 6720 6d61 7463 6865 730a  lapping matches.
+000030a0: 2020 2020 2020 2020 2020 2020 7061 7474              patt
+000030b0: 6572 6e20 3d20 6328 2274 6869 7341 4e44  ern = c("thisAND
+000030c0: 7468 6973 2229 0a20 2020 2020 2020 2020  this").         
+000030d0: 2020 2073 203d 2063 2822 7468 6973 414e     s = c("thisAN
+000030e0: 4474 6869 7341 4e44 7468 6973 2229 0a20  DthisANDthis"). 
+000030f0: 2020 2020 2020 2020 2020 2074 6573 745f             test_
+00003100: 7265 5f70 6172 7469 7469 6f6e 2820 732c  re_partition( s,
+00003110: 2070 6174 7465 726e 2c20 312c 2028 2222   pattern, 1, (""
+00003120: 2c20 2274 6869 7341 4e44 7468 6973 222c  , "thisANDthis",
+00003130: 2022 414e 4474 6869 7322 2920 290a 2020   "ANDthis") ).  
+00003140: 2020 2020 2020 2020 2020 7465 7374 5f72            test_r
+00003150: 655f 7270 6172 7469 7469 6f6e 2873 2c20  e_rpartition(s, 
+00003160: 7061 7474 6572 6e2c 2031 2c20 2822 7468  pattern, 1, ("th
+00003170: 6973 414e 4422 2c20 2274 6869 7341 4e44  isAND", "thisAND
+00003180: 7468 6973 222c 2022 2229 2029 0a0a 2020  this", "") )..  
+00003190: 2020 2020 2020 2020 2020 666f 7220 666e            for fn
+000031a0: 2069 6e20 2862 6967 2e72 655f 7061 7274   in (big.re_part
+000031b0: 6974 696f 6e2c 2062 6967 2e72 655f 7270  ition, big.re_rp
+000031c0: 6172 7469 7469 6f6e 293a 0a20 2020 2020  artition):.     
+000031d0: 2020 2020 2020 2020 2020 2073 203d 2063             s = c
+000031e0: 2822 4c65 7427 7320 6669 6e64 2074 6865  ("Let's find the
+000031f0: 206e 756d 6265 7220 3839 2069 6e20 7468   number 89 in th
+00003200: 6973 2073 7472 696e 6722 290a 2020 2020  is string").    
+00003210: 2020 2020 2020 2020 2020 2020 7061 7474              patt
+00003220: 6572 6e20 3d20 6328 7222 6e75 6d62 6572  ern = c(r"number
+00003230: 2028 5b30 2d39 5d2b 2922 290a 2020 2020   ([0-9]+)").    
+00003240: 2020 2020 2020 2020 2020 2020 7265 7375              resu
+00003250: 6c74 203d 2066 6e28 732c 2070 6174 7465  lt = fn(s, patte
+00003260: 726e 290a 2020 2020 2020 2020 2020 2020  rn).            
+00003270: 2020 2020 2320 7072 696e 7428 7265 7375      # print(resu
+00003280: 6c74 290a 2020 2020 2020 2020 2020 2020  lt).            
+00003290: 2020 2020 2320 7072 696e 7428 6772 6f75      # print(grou
+000032a0: 7030 2872 6573 756c 7429 290a 2020 2020  p0(result)).    
+000032b0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+000032c0: 2e61 7373 6572 7445 7175 616c 2867 726f  .assertEqual(gro
+000032d0: 7570 3028 7265 7375 6c74 292c 2063 2828  up0(result), c((
+000032e0: 224c 6574 2773 2066 696e 6420 7468 6520  "Let's find the 
+000032f0: 222c 2022 6e75 6d62 6572 2038 3922 2c20  ", "number 89", 
+00003300: 2220 696e 2074 6869 7320 7374 7269 6e67  " in this string
+00003310: 2229 2929 0a20 2020 2020 2020 2020 2020  "))).           
+00003320: 2020 2020 206d 6174 6368 203d 2072 6573       match = res
+00003330: 756c 745b 315d 0a20 2020 2020 2020 2020  ult[1].         
+00003340: 2020 2020 2020 2073 656c 662e 6173 7365         self.asse
+00003350: 7274 4571 7561 6c28 6d61 7463 682e 6772  rtEqual(match.gr
+00003360: 6f75 7028 3029 2c20 6328 226e 756d 6265  oup(0), c("numbe
+00003370: 7220 3839 2229 290a 2020 2020 2020 2020  r 89")).        
+00003380: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
+00003390: 6572 7445 7175 616c 286d 6174 6368 2e67  ertEqual(match.g
+000033a0: 726f 7570 2831 292c 2063 2822 3839 2229  roup(1), c("89")
+000033b0: 290a 0a20 2020 2020 2020 2020 2020 2074  )..            t
+000033c0: 6573 745f 7265 5f70 6172 7469 7469 6f6e  est_re_partition
+000033d0: 2822 613a 623a 633a 6422 2c20 223a 222c  ("a:b:c:d", ":",
+000033e0: 2030 2c20 2822 613a 623a 633a 6422 2c29   0, ("a:b:c:d",)
+000033f0: 2029 0a20 2020 2020 2020 2020 2020 2074   ).            t
+00003400: 6573 745f 7265 5f70 6172 7469 7469 6f6e  est_re_partition
+00003410: 2822 613a 623a 633a 6422 2c20 223a 222c  ("a:b:c:d", ":",
+00003420: 2031 2c20 2822 6122 2c20 2020 2020 2020   1, ("a",       
+00003430: 223a 222c 2020 2262 3a63 3a64 2220 2920  ":",  "b:c:d" ) 
+00003440: 290a 2020 2020 2020 2020 2020 2020 7465  ).            te
+00003450: 7374 5f72 655f 7061 7274 6974 696f 6e28  st_re_partition(
+00003460: 2261 3a62 3a63 3a64 222c 2022 3a22 2c20  "a:b:c:d", ":", 
+00003470: 322c 2028 2261 222c 2020 2020 2020 2022  2, ("a",       "
+00003480: 3a22 2c20 2022 6222 2c20 223a 222c 2020  :",  "b", ":",  
+00003490: 2263 3a64 2220 2920 290a 2020 2020 2020  "c:d" ) ).      
+000034a0: 2020 2020 2020 7465 7374 5f72 655f 7061        test_re_pa
+000034b0: 7274 6974 696f 6e28 2261 3a62 3a63 3a64  rtition("a:b:c:d
+000034c0: 222c 2022 3a22 2c20 332c 2028 2261 222c  ", ":", 3, ("a",
+000034d0: 2020 2020 2020 2022 3a22 2c20 2022 6222         ":",  "b"
+000034e0: 2c20 223a 222c 2020 2263 222c 2022 3a22  , ":",  "c", ":"
+000034f0: 2c20 2022 6422 2029 2029 0a20 2020 2020  ,  "d" ) ).     
+00003500: 2020 2020 2020 2074 6573 745f 7265 5f70         test_re_p
+00003510: 6172 7469 7469 6f6e 2822 613a 623a 633a  artition("a:b:c:
+00003520: 6422 2c20 223a 222c 2034 2c20 2822 6122  d", ":", 4, ("a"
+00003530: 2c20 2020 2020 2020 223a 222c 2020 2262  ,       ":",  "b
+00003540: 222c 2022 3a22 2c20 2022 6322 2c20 223a  ", ":",  "c", ":
+00003550: 222c 2020 2264 222c 204e 6f6e 652c 2027  ",  "d", None, '
+00003560: 2729 2029 0a20 2020 2020 2020 2020 2020  ') ).           
+00003570: 2074 6573 745f 7265 5f70 6172 7469 7469   test_re_partiti
+00003580: 6f6e 2822 613a 623a 633a 6422 2c20 223a  on("a:b:c:d", ":
+00003590: 222c 2035 2c20 2822 6122 2c20 2020 2020  ", 5, ("a",     
+000035a0: 2020 223a 222c 2020 2262 222c 2022 3a22    ":",  "b", ":"
+000035b0: 2c20 2022 6322 2c20 223a 222c 2020 2264  ,  "c", ":",  "d
+000035c0: 222c 204e 6f6e 652c 2027 272c 204e 6f6e  ", None, '', Non
+000035d0: 652c 2027 2729 2029 0a20 2020 2020 2020  e, '') ).       
+000035e0: 2020 2020 2074 6573 745f 7265 5f70 6172       test_re_par
+000035f0: 7469 7469 6f6e 2822 613a 623a 633a 6422  tition("a:b:c:d"
+00003600: 2c20 2278 222c 2035 2c20 2822 613a 623a  , "x", 5, ("a:b:
+00003610: 633a 6422 2c20 4e6f 6e65 2c20 2727 2c20  c:d", None, '', 
+00003620: 204e 6f6e 652c 2027 272c 2020 4e6f 6e65   None, '',  None
+00003630: 2c20 2727 2c20 204e 6f6e 652c 2027 272c  , '',  None, '',
+00003640: 204e 6f6e 652c 2027 2729 2029 0a0a 2020   None, '') )..  
+00003650: 2020 2020 2020 2020 2020 7465 7374 5f72            test_r
+00003660: 655f 7270 6172 7469 7469 6f6e 2822 613a  e_rpartition("a:
+00003670: 623a 633a 6422 2c20 223a 222c 2030 2c20  b:c:d", ":", 0, 
+00003680: 2822 613a 623a 633a 6422 2c29 2029 0a20  ("a:b:c:d",) ). 
+00003690: 2020 2020 2020 2020 2020 2074 6573 745f             test_
+000036a0: 7265 5f72 7061 7274 6974 696f 6e28 2261  re_rpartition("a
+000036b0: 3a62 3a63 3a64 222c 2022 3a22 2c20 312c  :b:c:d", ":", 1,
+000036c0: 2028 2261 3a62 3a63 222c 2027 3a27 2c20   ("a:b:c", ':', 
+000036d0: 2022 6422 2920 290a 2020 2020 2020 2020   "d") ).        
+000036e0: 2020 2020 7465 7374 5f72 655f 7270 6172      test_re_rpar
+000036f0: 7469 7469 6f6e 2822 613a 623a 633a 6422  tition("a:b:c:d"
+00003700: 2c20 223a 222c 2032 2c20 2822 613a 6222  , ":", 2, ("a:b"
+00003710: 2c20 2020 223a 222c 2020 2263 222c 2022  ,   ":",  "c", "
+00003720: 3a22 2c20 2022 6422 2920 290a 2020 2020  :",  "d") ).    
+00003730: 2020 2020 2020 2020 7465 7374 5f72 655f          test_re_
+00003740: 7270 6172 7469 7469 6f6e 2822 613a 623a  rpartition("a:b:
+00003750: 633a 6422 2c20 223a 222c 2033 2c20 2822  c:d", ":", 3, ("
+00003760: 6122 2c20 2020 2020 223a 222c 2020 2262  a",     ":",  "b
+00003770: 222c 2022 3a22 2c20 2022 6322 2c20 223a  ", ":",  "c", ":
+00003780: 222c 2020 2264 2229 2029 0a20 2020 2020  ",  "d") ).     
+00003790: 2020 2020 2020 2074 6573 745f 7265 5f72         test_re_r
+000037a0: 7061 7274 6974 696f 6e28 2261 3a62 3a63  partition("a:b:c
+000037b0: 3a64 222c 2022 3a22 2c20 342c 2028 2222  :d", ":", 4, (""
+000037c0: 2c20 2020 2020 204e 6f6e 652c 2022 6122  ,      None, "a"
+000037d0: 2c20 223a 222c 2020 2262 222c 2022 3a22  , ":",  "b", ":"
+000037e0: 2c20 2022 6322 2c20 223a 222c 2020 2264  ,  "c", ":",  "d
+000037f0: 2229 2029 0a20 2020 2020 2020 2020 2020  ") ).           
+00003800: 2074 6573 745f 7265 5f72 7061 7274 6974   test_re_rpartit
+00003810: 696f 6e28 2261 3a62 3a63 3a64 222c 2022  ion("a:b:c:d", "
+00003820: 3a22 2c20 352c 2028 2222 2c20 2020 2020  :", 5, ("",     
+00003830: 204e 6f6e 652c 2027 272c 2020 4e6f 6e65   None, '',  None
+00003840: 2c20 2261 222c 2022 3a22 2c20 2022 6222  , "a", ":",  "b"
+00003850: 2c20 223a 222c 2020 2263 222c 2022 3a22  , ":",  "c", ":"
+00003860: 2c20 2022 6422 2920 290a 2020 2020 2020  ,  "d") ).      
+00003870: 2020 2020 2020 7465 7374 5f72 655f 7270        test_re_rp
+00003880: 6172 7469 7469 6f6e 2822 613a 623a 633a  artition("a:b:c:
+00003890: 6422 2c20 2278 222c 2035 2c20 2827 272c  d", "x", 5, ('',
+000038a0: 2020 2020 2020 4e6f 6e65 2c20 2727 2c20        None, '', 
+000038b0: 204e 6f6e 652c 2027 272c 2020 4e6f 6e65   None, '',  None
+000038c0: 2c20 2727 2c20 204e 6f6e 652c 2027 272c  , '',  None, '',
+000038d0: 2020 4e6f 6e65 2c20 2261 3a62 3a63 3a64    None, "a:b:c:d
+000038e0: 2229 2029 0a0a 2020 2020 2020 2020 2020  ") )..          
+000038f0: 2020 2320 7265 7665 7273 6520 6d6f 6465    # reverse mode
+00003900: 2c20 6f76 6572 6c61 7070 696e 6720 6d61  , overlapping ma
+00003910: 7463 6865 7320 7465 7374 730a 2020 2020  tches tests.    
+00003920: 2020 2020 2020 2020 7465 7374 5f72 655f          test_re_
+00003930: 7270 6172 7469 7469 6f6e 2827 6162 6364  rpartition('abcd
+00003940: 6566 6768 272c 2027 2861 6263 6465 667c  efgh', '(abcdef|
+00003950: 6566 677c 6162 7c62 7c63 7c64 2927 2c20  efg|ab|b|c|d)', 
+00003960: 342c 2028 2727 2c20 2761 6227 2c20 2727  4, ('', 'ab', ''
+00003970: 2c20 2763 272c 2027 272c 2027 6427 2c20  , 'c', '', 'd', 
+00003980: 2727 2c20 2765 6667 272c 2027 6827 2920  '', 'efg', 'h') 
+00003990: 290a 2020 2020 2020 2020 2020 2020 7465  ).            te
+000039a0: 7374 5f72 655f 7270 6172 7469 7469 6f6e  st_re_rpartition
+000039b0: 2827 6162 6364 6566 6768 272c 2027 2861  ('abcdefgh', '(a
+000039c0: 6263 6465 667c 6566 677c 617c 627c 637c  bcdef|efg|a|b|c|
+000039d0: 6429 272c 2034 2c20 2028 2761 272c 2027  d)', 4,  ('a', '
+000039e0: 6227 2c20 2727 2c20 2763 272c 2027 272c  b', '', 'c', '',
+000039f0: 2027 6427 2c20 2727 2c20 2765 6667 272c   'd', '', 'efg',
+00003a00: 2027 6827 2920 290a 0a20 2020 2020 2020   'h') )..       
+00003a10: 2020 2020 2074 6573 745f 7265 5f72 7061       test_re_rpa
+00003a20: 7274 6974 696f 6e28 2761 6263 6465 6627  rtition('abcdef'
+00003a30: 2c20 2728 6263 647c 6364 657c 6364 2927  , '(bcd|cde|cd)'
+00003a40: 2c20 312c 2028 2761 6227 2c20 2763 6465  , 1, ('ab', 'cde
+00003a50: 272c 2027 6627 2920 290a 2020 2020 2020  ', 'f') ).      
+00003a60: 2020 2020 2020 7465 7374 5f72 655f 7270        test_re_rp
+00003a70: 6172 7469 7469 6f6e 2827 6162 6364 6566  artition('abcdef
+00003a80: 272c 2027 2862 6364 7c63 6429 272c 2020  ', '(bcd|cd)',  
+00003a90: 2020 2031 2c20 2827 6127 2c20 2762 6364     1, ('a', 'bcd
+00003aa0: 272c 2027 6566 2729 2029 0a0a 2020 2020  ', 'ef') )..    
+00003ab0: 2020 2020 2020 2020 2320 6164 6420 7827          # add x'
+00003ac0: 7320 746f 2074 6865 2062 6567 696e 6e69  s to the beginni
+00003ad0: 6e67 2061 6e64 2065 6e64 206f 6620 7320  ng and end of s 
+00003ae0: 3130 3020 7469 6d65 730a 2020 2020 2020  100 times.      
+00003af0: 2020 2020 2020 7061 7474 6572 6e20 3d20        pattern = 
+00003b00: 2728 6263 6465 6667 6869 6a6b 6c6d 6e7c  '(bcdefghijklmn|
+00003b10: 6e6f 7029 270a 2020 2020 2020 2020 2020  nop)'.          
+00003b20: 2020 7320 3d20 2761 6263 6465 6667 6869    s = 'abcdefghi
+00003b30: 6a6b 6c6d 6e6f 7071 270a 2020 2020 2020  jklmnopq'.      
+00003b40: 2020 2020 2020 6265 666f 7265 203d 2027        before = '
+00003b50: 6162 6364 6566 6768 696a 6b6c 6d27 0a20  abcdefghijklm'. 
+00003b60: 2020 2020 2020 2020 2020 2061 6674 6572             after
+00003b70: 203d 2027 7127 0a20 2020 2020 2020 2020   = 'q'.         
+00003b80: 2020 2066 6f72 2069 2069 6e20 7261 6e67     for i in rang
+00003b90: 6528 3130 3029 3a0a 2020 2020 2020 2020  e(100):.        
+00003ba0: 2020 2020 2020 2020 7465 7374 5f72 655f          test_re_
+00003bb0: 7270 6172 7469 7469 6f6e 2873 2c20 7061  rpartition(s, pa
+00003bc0: 7474 6572 6e2c 2031 2c20 2862 6566 6f72  ttern, 1, (befor
+00003bd0: 652c 2027 6e6f 7027 2c20 6166 7465 7229  e, 'nop', after)
+00003be0: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
+00003bf0: 2020 2073 203d 2027 7827 202b 2073 202b     s = 'x' + s +
+00003c00: 2027 7827 0a20 2020 2020 2020 2020 2020   'x'.           
+00003c10: 2020 2020 2062 6566 6f72 6520 3d20 2778       before = 'x
+00003c20: 2720 2b20 6265 666f 7265 0a20 2020 2020  ' + before.     
+00003c30: 2020 2020 2020 2020 2020 2061 6674 6572             after
+00003c40: 202b 3d20 2778 270a 0a20 2020 2020 2020   += 'x'..       
+00003c50: 2020 2020 2023 206d 6174 6368 2061 6761       # match aga
+00003c60: 696e 7374 2078 797a 2061 6e64 2061 206c  inst xyz and a l
+00003c70: 6f6e 6720 7374 7269 6e67 2c20 7765 2073  ong string, we s
+00003c80: 686f 756c 6420 616c 7761 7973 2070 7265  hould always pre
+00003c90: 6665 7220 7879 7a2c 0a20 2020 2020 2020  fer xyz,.       
+00003ca0: 2020 2020 2023 2070 726f 6772 6573 7369       # progressi
+00003cb0: 7665 6c79 2074 7275 6e63 6174 6520 6368  vely truncate ch
+00003cc0: 6172 6163 7465 7273 2066 726f 6d20 7468  aracters from th
+00003cd0: 6520 2a66 726f 6e74 2a20 6f66 2074 6865  e *front* of the
+00003ce0: 206c 6f6e 6720 7374 7269 6e67 0a20 2020   long string.   
+00003cf0: 2020 2020 2020 2020 2073 203d 2027 6162           s = 'ab
+00003d00: 6364 6566 6768 696a 6b6c 6d6e 6f70 7172  cdefghijklmnopqr
+00003d10: 7374 7576 7778 797a 270a 2020 2020 2020  stuvwxyz'.      
+00003d20: 2020 2020 2020 6669 7273 745f 7061 7474        first_patt
+00003d30: 6572 6e20 3d20 735b 3a2d 315d 0a20 2020  ern = s[:-1].   
+00003d40: 2020 2020 2020 2020 2077 6869 6c65 2066           while f
+00003d50: 6972 7374 5f70 6174 7465 726e 3a0a 2020  irst_pattern:.  
+00003d60: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00003d70: 206c 656e 2866 6972 7374 5f70 6174 7465   len(first_patte
+00003d80: 726e 2920 3e3d 2033 3a0a 2020 2020 2020  rn) >= 3:.      
+00003d90: 2020 2020 2020 2020 2020 2020 2020 7061                pa
+00003da0: 7474 6572 6e20 3d20 6627 287b 6669 7273  ttern = f'({firs
+00003db0: 745f 7061 7474 6572 6e7d 7c78 797a 2927  t_pattern}|xyz)'
+00003dc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003dd0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00003de0: 2020 2020 2020 2020 2020 2070 6174 7465             patte
+00003df0: 726e 203d 2066 2728 7879 7a7c 7b66 6972  rn = f'(xyz|{fir
+00003e00: 7374 5f70 6174 7465 726e 7d29 270a 2020  st_pattern})'.  
+00003e10: 2020 2020 2020 2020 2020 2020 2020 7465                te
+00003e20: 7374 5f72 655f 7270 6172 7469 7469 6f6e  st_re_rpartition
+00003e30: 2873 2c20 7061 7474 6572 6e2c 2031 2c20  (s, pattern, 1, 
+00003e40: 2827 6162 6364 6566 6768 696a 6b6c 6d6e  ('abcdefghijklmn
+00003e50: 6f70 7172 7374 7576 7727 2c20 2778 797a  opqrstuvw', 'xyz
+00003e60: 272c 2027 2729 290a 2020 2020 2020 2020  ', '')).        
+00003e70: 2020 2020 2020 2020 6669 7273 745f 7061          first_pa
+00003e80: 7474 6572 6e20 3d20 6669 7273 745f 7061  ttern = first_pa
+00003e90: 7474 6572 6e5b 313a 5d0a 0a20 2020 2020  ttern[1:]..     
+00003ea0: 2020 2020 2020 2023 206d 6174 6368 2061         # match a
+00003eb0: 6761 696e 7374 2078 797a 2061 6e64 2061  gainst xyz and a
+00003ec0: 206c 6f6e 6720 7374 7269 6e67 2c20 7765   long string, we
+00003ed0: 2073 686f 756c 6420 616c 7761 7973 2070   should always p
+00003ee0: 7265 6665 7220 7879 7a2c 0a20 2020 2020  refer xyz,.     
+00003ef0: 2020 2020 2020 2023 2070 726f 6772 6573         # progres
+00003f00: 7369 7665 6c79 2074 7275 6e63 6174 6520  sively truncate 
+00003f10: 6368 6172 6163 7465 7273 2066 726f 6d20  characters from 
+00003f20: 7468 6520 2a65 6e64 2a20 6f66 2074 6865  the *end* of the
+00003f30: 206c 6f6e 6720 7374 7269 6e67 0a20 2020   long string.   
+00003f40: 2020 2020 2020 2020 2073 203d 2027 6162           s = 'ab
+00003f50: 6364 6566 6768 696a 6b6c 6d6e 6f70 7172  cdefghijklmnopqr
+00003f60: 7374 7576 7778 797a 270a 2020 2020 2020  stuvwxyz'.      
+00003f70: 2020 2020 2020 6669 7273 745f 7061 7474        first_patt
+00003f80: 6572 6e20 3d20 735b 3a2d 315d 0a20 2020  ern = s[:-1].   
+00003f90: 2020 2020 2020 2020 2077 6869 6c65 2066           while f
+00003fa0: 6972 7374 5f70 6174 7465 726e 3a0a 2020  irst_pattern:.  
+00003fb0: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00003fc0: 206c 656e 2866 6972 7374 5f70 6174 7465   len(first_patte
+00003fd0: 726e 2920 3e3d 2033 3a0a 2020 2020 2020  rn) >= 3:.      
+00003fe0: 2020 2020 2020 2020 2020 2020 2020 7061                pa
+00003ff0: 7474 6572 6e20 3d20 6627 287b 6669 7273  ttern = f'({firs
+00004000: 745f 7061 7474 6572 6e7d 7c78 797a 2927  t_pattern}|xyz)'
+00004010: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004020: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00004030: 2020 2020 2020 2020 2020 2070 6174 7465             patte
+00004040: 726e 203d 2066 2728 7879 7a7c 7b66 6972  rn = f'(xyz|{fir
+00004050: 7374 5f70 6174 7465 726e 7d29 270a 2020  st_pattern})'.  
+00004060: 2020 2020 2020 2020 2020 2020 2020 7465                te
+00004070: 7374 5f72 655f 7270 6172 7469 7469 6f6e  st_re_rpartition
+00004080: 2873 2c20 7061 7474 6572 6e2c 2031 2c20  (s, pattern, 1, 
+00004090: 2827 6162 6364 6566 6768 696a 6b6c 6d6e  ('abcdefghijklmn
+000040a0: 6f70 7172 7374 7576 7727 2c20 2778 797a  opqrstuvw', 'xyz
+000040b0: 272c 2027 2729 290a 2020 2020 2020 2020  ', '')).        
+000040c0: 2020 2020 2020 2020 6669 7273 745f 7061          first_pa
+000040d0: 7474 6572 6e20 3d20 6669 7273 745f 7061  ttern = first_pa
+000040e0: 7474 6572 6e5b 3a2d 315d 0a0a 2020 2020  ttern[:-1]..    
+000040f0: 2020 2020 2020 2020 2320 2761 6263 6465          # 'abcde
+00004100: 6667 6869 6a27 2069 7320 7468 6520 6265  fghij' is the be
+00004110: 7374 206d 6174 6368 210a 2020 2020 2020  st match!.      
+00004120: 2020 2020 2020 2320 616c 6c20 7468 6520        # all the 
+00004130: 6f76 6572 6c61 7070 696e 6720 6d61 7463  overlapping matc
+00004140: 6865 7320 6172 6520 776f 7273 6521 0a20  hes are worse!. 
+00004150: 2020 2020 2020 2020 2020 2074 6573 745f             test_
+00004160: 7265 5f72 7061 7274 6974 696f 6e28 2761  re_rpartition('a
+00004170: 6263 6465 6667 6869 6a6b 272c 2027 2861  bcdefghijk', '(a
+00004180: 6263 6465 6667 6869 6a7c 6162 6364 657c  bcdefghij|abcde|
+00004190: 6162 6364 7c61 6263 7c61 627c 6263 7c63  abcd|abc|ab|bc|c
+000041a0: 647c 6465 7c65 667c 6667 7c67 687c 6869  d|de|ef|fg|gh|hi
+000041b0: 7c69 6a29 272c 2031 2c20 2827 272c 2027  |ij)', 1, ('', '
+000041c0: 6162 6364 6566 6768 696a 272c 2027 6b27  abcdefghij', 'k'
+000041d0: 2920 290a 0a20 2020 2020 2020 2020 2020  ) )..           
+000041e0: 2023 206f 6b61 792c 206e 6f77 206a 6b20   # okay, now jk 
+000041f0: 6973 2074 6865 2062 6573 7420 6d61 7463  is the best matc
+00004200: 682e 0a20 2020 2020 2020 2020 2020 2074  h..            t
+00004210: 6573 745f 7265 5f72 7061 7274 6974 696f  est_re_rpartitio
+00004220: 6e28 2761 6263 6465 6667 6869 6a6b 6c27  n('abcdefghijkl'
+00004230: 2c20 2728 6162 6364 6566 6768 696a 7c61  , '(abcdefghij|a
+00004240: 6263 6465 7c61 6263 647c 6162 637c 6162  bcde|abcd|abc|ab
+00004250: 7c62 637c 6364 7c64 657c 6566 7c66 677c  |bc|cd|de|ef|fg|
+00004260: 6768 7c68 697c 696a 7c6a 6b29 272c 2031  gh|hi|ij|jk)', 1
+00004270: 2c20 2827 6162 6364 6566 6768 6927 2c20  , ('abcdefghi', 
+00004280: 276a 6b27 2c20 276c 2729 2029 0a0a 2020  'jk', 'l') )..  
+00004290: 2020 2020 2020 2020 2020 7465 7374 5f72            test_r
+000042a0: 655f 7270 6172 7469 7469 6f6e 2827 6162  e_rpartition('ab
+000042b0: 6364 6566 6768 272c 2027 2862 6364 7c63  cdefgh', '(bcd|c
+000042c0: 6465 6667 687c 6465 2927 2c20 312c 2028  defgh|de)', 1, (
+000042d0: 2761 6227 2c20 2763 6465 6667 6827 2c20  'ab', 'cdefgh', 
+000042e0: 2727 2920 290a 2020 2020 2020 2020 2020  '') ).          
+000042f0: 2020 7465 7374 5f72 655f 7270 6172 7469    test_re_rparti
+00004300: 7469 6f6e 2827 6162 6364 6566 6768 272c  tion('abcdefgh',
+00004310: 2027 2861 6263 6465 667c 6566 677c 6662   '(abcdef|efg|fb
+00004320: 7c62 7c63 7c64 2927 2c20 342c 2028 2761  |b|c|d)', 4, ('a
+00004330: 272c 2027 6227 2c20 2727 2c20 2763 272c  ', 'b', '', 'c',
+00004340: 2027 272c 2027 6427 2c20 2727 2c20 2765   '', 'd', '', 'e
+00004350: 6667 272c 2027 6827 2920 290a 2020 2020  fg', 'h') ).    
+00004360: 2020 2020 2020 2020 7465 7374 5f72 655f          test_re_
+00004370: 7270 6172 7469 7469 6f6e 2827 6162 6364  rpartition('abcd
+00004380: 6566 6768 272c 2027 2861 6263 6465 667c  efgh', '(abcdef|
+00004390: 6566 677c 6162 7c62 7c63 7c64 2927 2c20  efg|ab|b|c|d)', 
+000043a0: 342c 2028 2727 2c20 2761 6227 2c20 2727  4, ('', 'ab', ''
+000043b0: 2c20 2763 272c 2027 272c 2027 6427 2c20  , 'c', '', 'd', 
+000043c0: 2727 2c20 2765 6667 272c 2027 6827 2920  '', 'efg', 'h') 
+000043d0: 290a 0a20 2020 2020 2020 2023 2064 6f20  )..        # do 
+000043e0: 6279 7465 7320 7673 2073 7472 2074 6573  bytes vs str tes
+000043f0: 7469 6e67 0a20 2020 2020 2020 2073 203d  ting.        s =
+00004400: 2022 6162 6331 3233 6465 6634 3536 6768   "abc123def456gh
+00004410: 6922 0a20 2020 2020 2020 2062 7974 6573  i".        bytes
+00004420: 5f70 6174 7465 726e 203d 2062 225b 302d  _pattern = b"[0-
+00004430: 395d 2b22 0a20 2020 2020 2020 2077 6974  9]+".        wit
+00004440: 6820 7365 6c66 2e61 7373 6572 7452 6169  h self.assertRai
+00004450: 7365 7328 5479 7065 4572 726f 7229 3a0a  ses(TypeError):.
+00004460: 2020 2020 2020 2020 2020 2020 6269 672e              big.
+00004470: 7265 5f70 6172 7469 7469 6f6e 2873 2c20  re_partition(s, 
+00004480: 6279 7465 735f 7061 7474 6572 6e29 0a20  bytes_pattern). 
+00004490: 2020 2020 2020 2077 6974 6820 7365 6c66         with self
+000044a0: 2e61 7373 6572 7452 6169 7365 7328 5479  .assertRaises(Ty
+000044b0: 7065 4572 726f 7229 3a0a 2020 2020 2020  peError):.      
+000044c0: 2020 2020 2020 6269 672e 7265 5f72 7061        big.re_rpa
+000044d0: 7274 6974 696f 6e28 732c 2062 7974 6573  rtition(s, bytes
+000044e0: 5f70 6174 7465 726e 290a 0a20 2020 2020  _pattern)..     
+000044f0: 2020 2062 7974 6573 5f70 6174 7465 726e     bytes_pattern
+00004500: 203d 2072 652e 636f 6d70 696c 6528 6279   = re.compile(by
+00004510: 7465 735f 7061 7474 6572 6e29 0a20 2020  tes_pattern).   
+00004520: 2020 2020 2077 6974 6820 7365 6c66 2e61       with self.a
+00004530: 7373 6572 7452 6169 7365 7328 5479 7065  ssertRaises(Type
+00004540: 4572 726f 7229 3a0a 2020 2020 2020 2020  Error):.        
+00004550: 2020 2020 6269 672e 7265 5f70 6172 7469      big.re_parti
+00004560: 7469 6f6e 2873 2c20 6279 7465 735f 7061  tion(s, bytes_pa
+00004570: 7474 6572 6e29 0a20 2020 2020 2020 2077  ttern).        w
+00004580: 6974 6820 7365 6c66 2e61 7373 6572 7452  ith self.assertR
+00004590: 6169 7365 7328 5479 7065 4572 726f 7229  aises(TypeError)
+000045a0: 3a0a 2020 2020 2020 2020 2020 2020 6269  :.            bi
+000045b0: 672e 7265 5f72 7061 7274 6974 696f 6e28  g.re_rpartition(
+000045c0: 732c 2062 7974 6573 5f70 6174 7465 726e  s, bytes_pattern
+000045d0: 290a 0a20 2020 2020 2020 2077 6974 6820  )..        with 
+000045e0: 7365 6c66 2e61 7373 6572 7452 6169 7365  self.assertRaise
+000045f0: 7328 5661 6c75 6545 7272 6f72 293a 0a20  s(ValueError):. 
+00004600: 2020 2020 2020 2020 2020 2062 6967 2e72             big.r
+00004610: 655f 7061 7274 6974 696f 6e28 2761 3a62  e_partition('a:b
+00004620: 272c 2027 3a27 2c20 2d31 290a 2020 2020  ', ':', -1).    
+00004630: 2020 2020 7769 7468 2073 656c 662e 6173      with self.as
+00004640: 7365 7274 5261 6973 6573 2856 616c 7565  sertRaises(Value
+00004650: 4572 726f 7229 3a0a 2020 2020 2020 2020  Error):.        
+00004660: 2020 2020 6269 672e 7265 5f70 6172 7469      big.re_parti
+00004670: 7469 6f6e 2862 2761 3a62 272c 2062 273a  tion(b'a:b', b':
+00004680: 272c 202d 3129 0a0a 2020 2020 2020 2020  ', -1)..        
+00004690: 7365 6c66 2e61 7373 6572 7445 7175 616c  self.assertEqual
+000046a0: 2867 726f 7570 3028 6269 672e 7265 5f70  (group0(big.re_p
+000046b0: 6172 7469 7469 6f6e 2853 7472 5375 6263  artition(StrSubc
+000046c0: 6c61 7373 2822 613a 623a 633a 6422 292c  lass("a:b:c:d"),
+000046d0: 2053 7472 5375 6263 6c61 7373 2822 3a22   StrSubclass(":"
+000046e0: 2929 292c 0a20 2020 2020 2020 2020 2020  ))),.           
+000046f0: 2028 2261 222c 2022 3a22 2c20 2262 3a63   ("a", ":", "b:c
+00004700: 3a64 2229 2029 0a20 2020 2020 2020 2073  :d") ).        s
+00004710: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
+00004720: 6772 6f75 7030 2862 6967 2e72 655f 7061  group0(big.re_pa
+00004730: 7274 6974 696f 6e28 5374 7253 7562 636c  rtition(StrSubcl
+00004740: 6173 7328 2261 3a62 3a63 3a64 2229 2c20  ass("a:b:c:d"), 
+00004750: 4469 6666 6572 656e 7453 7472 5375 6263  DifferentStrSubc
+00004760: 6c61 7373 2822 3a22 2929 292c 0a20 2020  lass(":"))),.   
+00004770: 2020 2020 2020 2020 2028 2261 222c 2022           ("a", "
+00004780: 3a22 2c20 2262 3a63 3a64 2229 2029 0a0a  :", "b:c:d") )..
+00004790: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
+000047a0: 6572 7445 7175 616c 2867 726f 7570 3028  ertEqual(group0(
+000047b0: 6269 672e 7265 5f70 6172 7469 7469 6f6e  big.re_partition
+000047c0: 2842 7974 6573 5375 6263 6c61 7373 2862  (BytesSubclass(b
+000047d0: 2261 3a62 3a63 3a64 2229 2c20 4279 7465  "a:b:c:d"), Byte
+000047e0: 7353 7562 636c 6173 7328 6222 3a22 2929  sSubclass(b":"))
+000047f0: 292c 0a20 2020 2020 2020 2020 2020 2028  ),.            (
+00004800: 6222 6122 2c20 6222 3a22 2c20 6222 623a  b"a", b":", b"b:
+00004810: 633a 6422 2920 290a 2020 2020 2020 2020  c:d") ).        
+00004820: 7365 6c66 2e61 7373 6572 7445 7175 616c  self.assertEqual
+00004830: 2867 726f 7570 3028 6269 672e 7265 5f70  (group0(big.re_p
+00004840: 6172 7469 7469 6f6e 2842 7974 6573 5375  artition(BytesSu
+00004850: 6263 6c61 7373 2862 2261 3a62 3a63 3a64  bclass(b"a:b:c:d
+00004860: 2229 2c20 4469 6666 6572 656e 7442 7974  "), DifferentByt
+00004870: 6573 5375 6263 6c61 7373 2862 223a 2229  esSubclass(b":")
+00004880: 2929 2c0a 2020 2020 2020 2020 2020 2020  )),.            
+00004890: 2862 2261 222c 2062 223a 222c 2062 2262  (b"a", b":", b"b
+000048a0: 3a63 3a64 2229 2029 0a0a 2020 2020 2020  :c:d") )..      
+000048b0: 2020 7769 7468 2073 656c 662e 6173 7365    with self.asse
+000048c0: 7274 5261 6973 6573 2856 616c 7565 4572  rtRaises(ValueEr
+000048d0: 726f 7229 3a0a 2020 2020 2020 2020 2020  ror):.          
+000048e0: 2020 6269 672e 7265 5f70 6172 7469 7469    big.re_partiti
+000048f0: 6f6e 2827 6162 2063 2064 6527 2c20 2720  on('ab c de', ' 
+00004900: 272c 2063 6f75 6e74 3d2d 3129 0a0a 2020  ', count=-1)..  
+00004910: 2020 2020 2020 7769 7468 2073 656c 662e        with self.
+00004920: 6173 7365 7274 5261 6973 6573 2856 616c  assertRaises(Val
+00004930: 7565 4572 726f 7229 3a0a 2020 2020 2020  ueError):.      
+00004940: 2020 2020 2020 6269 672e 7265 5f72 7061        big.re_rpa
+00004950: 7274 6974 696f 6e28 2761 6220 6320 6465  rtition('ab c de
+00004960: 272c 2027 2027 2c20 636f 756e 743d 2d31  ', ' ', count=-1
+00004970: 290a 0a0a 0a20 2020 2064 6566 2074 6573  )....    def tes
+00004980: 745f 6d75 6c74 6973 7472 6970 2873 656c  t_multistrip(sel
+00004990: 6629 3a0a 2020 2020 2020 2020 6465 6620  f):.        def 
+000049a0: 7465 7374 5f6d 756c 7469 7374 7269 7028  test_multistrip(
+000049b0: 6f72 6967 696e 616c 5f6c 6566 742c 206f  original_left, o
+000049c0: 7269 6769 6e61 6c5f 732c 206f 7269 6769  riginal_s, origi
+000049d0: 6e61 6c5f 7269 6768 742c 206f 7269 6769  nal_right, origi
+000049e0: 6e61 6c5f 7365 7061 7261 746f 7273 293a  nal_separators):
+000049f0: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
+00004a00: 2072 6f75 6e64 2069 6e20 7261 6e67 6528   round in range(
+00004a10: 3429 3a0a 2020 2020 2020 2020 2020 2020  4):.            
+00004a20: 2020 2020 6966 2072 6f75 6e64 203d 3d20      if round == 
+00004a30: 303a 0a20 2020 2020 2020 2020 2020 2020  0:.             
+00004a40: 2020 2020 2020 206c 6566 7420 3d20 6f72         left = or
+00004a50: 6967 696e 616c 5f6c 6566 740a 2020 2020  iginal_left.    
+00004a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004a70: 7320 3d20 6f72 6967 696e 616c 5f73 0a20  s = original_s. 
+00004a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004a90: 2020 2072 6967 6874 203d 206f 7269 6769     right = origi
+00004aa0: 6e61 6c5f 7269 6768 740a 2020 2020 2020  nal_right.      
+00004ab0: 2020 2020 2020 2020 2020 2020 2020 7365                se
+00004ac0: 7061 7261 746f 7273 203d 206f 7269 6769  parators = origi
+00004ad0: 6e61 6c5f 7365 7061 7261 746f 7273 0a20  nal_separators. 
+00004ae0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+00004af0: 6c69 6620 726f 756e 6420 3d3d 2031 3a0a  lif round == 1:.
+00004b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004b10: 2020 2020 6c65 6674 203d 2053 7472 5375      left = StrSu
+00004b20: 6263 6c61 7373 286c 6566 7429 0a20 2020  bclass(left).   
+00004b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004b40: 2073 203d 2053 7472 5375 6263 6c61 7373   s = StrSubclass
+00004b50: 2873 290a 2020 2020 2020 2020 2020 2020  (s).            
+00004b60: 2020 2020 2020 2020 7269 6768 7420 3d20          right = 
+00004b70: 5374 7253 7562 636c 6173 7328 7269 6768  StrSubclass(righ
+00004b80: 7429 0a20 2020 2020 2020 2020 2020 2020  t).             
+00004b90: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
+00004ba0: 616e 6365 2873 6570 6172 6174 6f72 732c  ance(separators,
+00004bb0: 2073 7472 293a 0a20 2020 2020 2020 2020   str):.         
+00004bc0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00004bd0: 6570 6172 6174 6f72 7320 3d20 5374 7253  eparators = StrS
+00004be0: 7562 636c 6173 7328 7365 7061 7261 746f  ubclass(separato
+00004bf0: 7273 290a 2020 2020 2020 2020 2020 2020  rs).            
+00004c00: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00004c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004c20: 2020 2020 2020 7365 7061 7261 746f 7273        separators
+00004c30: 203d 205b 5374 7253 7562 636c 6173 7328   = [StrSubclass(
+00004c40: 6f29 2066 6f72 206f 2069 6e20 7365 7061  o) for o in sepa
+00004c50: 7261 746f 7273 5d0a 2020 2020 2020 2020  rators].        
+00004c60: 2020 2020 2020 2020 656c 6966 2072 6f75          elif rou
+00004c70: 6e64 203d 3d20 323a 0a20 2020 2020 2020  nd == 2:.       
+00004c80: 2020 2020 2020 2020 2020 2020 206c 6566               lef
+00004c90: 7420 3d20 6f72 6967 696e 616c 5f6c 6566  t = original_lef
+00004ca0: 742e 656e 636f 6465 2827 6173 6369 6927  t.encode('ascii'
+00004cb0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00004cc0: 2020 2020 2020 7320 3d20 6f72 6967 696e        s = origin
+00004cd0: 616c 5f73 2e65 6e63 6f64 6528 2761 7363  al_s.encode('asc
+00004ce0: 6969 2729 0a20 2020 2020 2020 2020 2020  ii').           
+00004cf0: 2020 2020 2020 2020 2072 6967 6874 203d           right =
+00004d00: 206f 7269 6769 6e61 6c5f 7269 6768 742e   original_right.
+00004d10: 656e 636f 6465 2827 6173 6369 6927 290a  encode('ascii').
+00004d20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004d30: 2020 2020 6966 206f 7269 6769 6e61 6c5f      if original_
+00004d40: 7365 7061 7261 746f 7273 203d 3d20 6269  separators == bi
+00004d50: 672e 7768 6974 6573 7061 6365 3a0a 2020  g.whitespace:.  
+00004d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004d70: 2020 2020 2020 7365 7061 7261 746f 7273        separators
+00004d80: 203d 2062 6967 2e61 7363 6969 5f77 6869   = big.ascii_whi
+00004d90: 7465 7370 6163 650a 2020 2020 2020 2020  tespace.        
+00004da0: 2020 2020 2020 2020 2020 2020 656c 6966              elif
+00004db0: 206f 7269 6769 6e61 6c5f 7365 7061 7261   original_separa
+00004dc0: 746f 7273 203d 3d20 6269 672e 6e65 776c  tors == big.newl
+00004dd0: 696e 6573 3a0a 2020 2020 2020 2020 2020  ines:.          
+00004de0: 2020 2020 2020 2020 2020 2020 2020 7365                se
+00004df0: 7061 7261 746f 7273 203d 2062 6967 2e61  parators = big.a
+00004e00: 7363 6969 5f6e 6577 6c69 6e65 730a 2020  scii_newlines.  
+00004e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004e20: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00004e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004e40: 6173 7365 7274 2069 7369 6e73 7461 6e63  assert isinstanc
+00004e50: 6528 6f72 6967 696e 616c 5f73 6570 6172  e(original_separ
+00004e60: 6174 6f72 732c 2073 7472 290a 2020 2020  ators, str).    
+00004e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004e80: 2020 2020 7365 7061 7261 746f 7273 203d      separators =
+00004e90: 206f 7269 6769 6e61 6c5f 7365 7061 7261   original_separa
+00004ea0: 746f 7273 2e65 6e63 6f64 6528 2761 7363  tors.encode('asc
+00004eb0: 6969 2729 0a20 2020 2020 2020 2020 2020  ii').           
+00004ec0: 2020 2020 2065 6c69 6620 726f 756e 6420       elif round 
+00004ed0: 3d3d 2033 3a0a 2020 2020 2020 2020 2020  == 3:.          
+00004ee0: 2020 2020 2020 2020 2020 6c65 6674 203d            left =
+00004ef0: 2042 7974 6573 5375 6263 6c61 7373 286c   BytesSubclass(l
+00004f00: 6566 7429 0a20 2020 2020 2020 2020 2020  eft).           
+00004f10: 2020 2020 2020 2020 2073 203d 2042 7974           s = Byt
+00004f20: 6573 5375 6263 6c61 7373 2873 290a 2020  esSubclass(s).  
+00004f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004f40: 2020 7269 6768 7420 3d20 4279 7465 7353    right = BytesS
+00004f50: 7562 636c 6173 7328 7269 6768 7429 0a20  ubclass(right). 
+00004f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004f70: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
+00004f80: 2873 6570 6172 6174 6f72 732c 2062 7974  (separators, byt
+00004f90: 6573 293a 0a20 2020 2020 2020 2020 2020  es):.           
+00004fa0: 2020 2020 2020 2020 2020 2020 2073 6570               sep
+00004fb0: 6172 6174 6f72 7320 3d20 4279 7465 7353  arators = BytesS
+00004fc0: 7562 636c 6173 7328 7365 7061 7261 746f  ubclass(separato
+00004fd0: 7273 290a 2020 2020 2020 2020 2020 2020  rs).            
+00004fe0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00004ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005000: 2020 2020 2020 7365 7061 7261 746f 7273        separators
+00005010: 203d 2074 7570 6c65 2828 4279 7465 7353   = tuple((BytesS
+00005020: 7562 636c 6173 7328 6f29 2066 6f72 206f  ubclass(o) for o
+00005030: 2069 6e20 7365 7061 7261 746f 7273 2929   in separators))
+00005040: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+00005050: 2020 7365 6c66 2e61 7373 6572 7445 7175    self.assertEqu
+00005060: 616c 2862 6967 2e6d 756c 7469 7374 7269  al(big.multistri
+00005070: 7028 732c 2073 6570 6172 6174 6f72 732c  p(s, separators,
+00005080: 206c 6566 743d 4661 6c73 652c 2072 6967   left=False, rig
+00005090: 6874 3d46 616c 7365 292c 2073 290a 2020  ht=False), s).  
+000050a0: 2020 2020 2020 2020 2020 2020 2020 7365                se
+000050b0: 6c66 2e61 7373 6572 7445 7175 616c 2862  lf.assertEqual(b
+000050c0: 6967 2e6d 756c 7469 7374 7269 7028 732c  ig.multistrip(s,
+000050d0: 2073 6570 6172 6174 6f72 732c 206c 6566   separators, lef
+000050e0: 743d 4661 6c73 652c 2072 6967 6874 3d54  t=False, right=T
+000050f0: 7275 6520 292c 2073 290a 2020 2020 2020  rue ), s).      
+00005100: 2020 2020 2020 2020 2020 7365 6c66 2e61            self.a
+00005110: 7373 6572 7445 7175 616c 2862 6967 2e6d  ssertEqual(big.m
+00005120: 756c 7469 7374 7269 7028 732c 2073 6570  ultistrip(s, sep
+00005130: 6172 6174 6f72 732c 206c 6566 743d 5472  arators, left=Tr
+00005140: 7565 2c20 2072 6967 6874 3d46 616c 7365  ue,  right=False
+00005150: 292c 2073 290a 2020 2020 2020 2020 2020  ), s).          
+00005160: 2020 2020 2020 7365 6c66 2e61 7373 6572        self.asser
+00005170: 7445 7175 616c 2862 6967 2e6d 756c 7469  tEqual(big.multi
+00005180: 7374 7269 7028 732c 2073 6570 6172 6174  strip(s, separat
+00005190: 6f72 732c 206c 6566 743d 5472 7565 2c20  ors, left=True, 
+000051a0: 2072 6967 6874 3d54 7275 6520 292c 2073   right=True ), s
+000051b0: 290a 0a20 2020 2020 2020 2020 2020 2020  )..             
+000051c0: 2020 206c 7320 3d20 6c65 6674 202b 2073     ls = left + s
+000051d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000051e0: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
+000051f0: 6c28 6269 672e 6d75 6c74 6973 7472 6970  l(big.multistrip
+00005200: 286c 732c 2073 6570 6172 6174 6f72 732c  (ls, separators,
+00005210: 206c 6566 743d 4661 6c73 652c 2072 6967   left=False, rig
+00005220: 6874 3d46 616c 7365 292c 206c 7329 0a20  ht=False), ls). 
+00005230: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00005240: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
+00005250: 6269 672e 6d75 6c74 6973 7472 6970 286c  big.multistrip(l
+00005260: 732c 2073 6570 6172 6174 6f72 732c 206c  s, separators, l
+00005270: 6566 743d 4661 6c73 652c 2072 6967 6874  eft=False, right
+00005280: 3d54 7275 6520 292c 206c 7329 0a20 2020  =True ), ls).   
+00005290: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+000052a0: 662e 6173 7365 7274 4571 7561 6c28 6269  f.assertEqual(bi
+000052b0: 672e 6d75 6c74 6973 7472 6970 286c 732c  g.multistrip(ls,
+000052c0: 2073 6570 6172 6174 6f72 732c 206c 6566   separators, lef
+000052d0: 743d 5472 7565 2c20 2072 6967 6874 3d46  t=True,  right=F
+000052e0: 616c 7365 292c 2073 290a 2020 2020 2020  alse), s).      
+000052f0: 2020 2020 2020 2020 2020 7365 6c66 2e61            self.a
+00005300: 7373 6572 7445 7175 616c 2862 6967 2e6d  ssertEqual(big.m
+00005310: 756c 7469 7374 7269 7028 6c73 2c20 7365  ultistrip(ls, se
+00005320: 7061 7261 746f 7273 2c20 6c65 6674 3d54  parators, left=T
+00005330: 7275 652c 2020 7269 6768 743d 5472 7565  rue,  right=True
+00005340: 2029 2c20 7329 0a0a 2020 2020 2020 2020   ), s)..        
+00005350: 2020 2020 2020 2020 7372 203d 2073 202b          sr = s +
+00005360: 2072 6967 6874 0a20 2020 2020 2020 2020   right.         
+00005370: 2020 2020 2020 2073 656c 662e 6173 7365         self.asse
+00005380: 7274 4571 7561 6c28 6269 672e 6d75 6c74  rtEqual(big.mult
+00005390: 6973 7472 6970 2873 722c 2073 6570 6172  istrip(sr, separ
+000053a0: 6174 6f72 732c 206c 6566 743d 4661 6c73  ators, left=Fals
+000053b0: 652c 2072 6967 6874 3d46 616c 7365 292c  e, right=False),
+000053c0: 2073 7229 0a20 2020 2020 2020 2020 2020   sr).           
+000053d0: 2020 2020 2073 656c 662e 6173 7365 7274       self.assert
+000053e0: 4571 7561 6c28 6269 672e 6d75 6c74 6973  Equal(big.multis
+000053f0: 7472 6970 2873 722c 2073 6570 6172 6174  trip(sr, separat
+00005400: 6f72 732c 206c 6566 743d 4661 6c73 652c  ors, left=False,
+00005410: 2072 6967 6874 3d54 7275 6520 292c 2073   right=True ), s
+00005420: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00005430: 2020 7365 6c66 2e61 7373 6572 7445 7175    self.assertEqu
+00005440: 616c 2862 6967 2e6d 756c 7469 7374 7269  al(big.multistri
+00005450: 7028 7372 2c20 7365 7061 7261 746f 7273  p(sr, separators
+00005460: 2c20 6c65 6674 3d54 7275 652c 2020 7269  , left=True,  ri
+00005470: 6768 743d 4661 6c73 6529 2c20 7372 290a  ght=False), sr).
+00005480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005490: 7365 6c66 2e61 7373 6572 7445 7175 616c  self.assertEqual
+000054a0: 2862 6967 2e6d 756c 7469 7374 7269 7028  (big.multistrip(
+000054b0: 7372 2c20 7365 7061 7261 746f 7273 2c20  sr, separators, 
+000054c0: 6c65 6674 3d54 7275 652c 2020 7269 6768  left=True,  righ
+000054d0: 743d 5472 7565 2029 2c20 7329 0a0a 2020  t=True ), s)..  
+000054e0: 2020 2020 2020 2020 2020 2020 2020 6c73                ls
+000054f0: 7220 3d20 6c65 6674 202b 2073 202b 2072  r = left + s + r
+00005500: 6967 6874 0a20 2020 2020 2020 2020 2020  ight.           
+00005510: 2020 2020 2073 656c 662e 6173 7365 7274       self.assert
+00005520: 4571 7561 6c28 6269 672e 6d75 6c74 6973  Equal(big.multis
+00005530: 7472 6970 286c 7372 2c20 7365 7061 7261  trip(lsr, separa
+00005540: 746f 7273 2c20 6c65 6674 3d46 616c 7365  tors, left=False
+00005550: 2c20 7269 6768 743d 4661 6c73 6529 2c20  , right=False), 
+00005560: 6c73 7229 0a20 2020 2020 2020 2020 2020  lsr).           
+00005570: 2020 2020 2073 656c 662e 6173 7365 7274       self.assert
+00005580: 4571 7561 6c28 6269 672e 6d75 6c74 6973  Equal(big.multis
+00005590: 7472 6970 286c 7372 2c20 7365 7061 7261  trip(lsr, separa
+000055a0: 746f 7273 2c20 6c65 6674 3d46 616c 7365  tors, left=False
+000055b0: 2c20 7269 6768 743d 5472 7565 2029 2c20  , right=True ), 
+000055c0: 6c73 290a 2020 2020 2020 2020 2020 2020  ls).            
+000055d0: 2020 2020 7365 6c66 2e61 7373 6572 7445      self.assertE
+000055e0: 7175 616c 2862 6967 2e6d 756c 7469 7374  qual(big.multist
+000055f0: 7269 7028 6c73 722c 2073 6570 6172 6174  rip(lsr, separat
+00005600: 6f72 732c 206c 6566 743d 5472 7565 2c20  ors, left=True, 
+00005610: 2072 6967 6874 3d46 616c 7365 292c 2073   right=False), s
+00005620: 7229 0a20 2020 2020 2020 2020 2020 2020  r).             
+00005630: 2020 2073 656c 662e 6173 7365 7274 4571     self.assertEq
+00005640: 7561 6c28 6269 672e 6d75 6c74 6973 7472  ual(big.multistr
+00005650: 6970 286c 7372 2c20 7365 7061 7261 746f  ip(lsr, separato
+00005660: 7273 2c20 6c65 6674 3d54 7275 652c 2020  rs, left=True,  
+00005670: 7269 6768 743d 5472 7565 2029 2c20 7329  right=True ), s)
+00005680: 0a0a 2020 2020 2020 2020 7465 7374 5f6d  ..        test_m
+00005690: 756c 7469 7374 7269 7028 2220 5c74 205c  ultistrip(" \t \
+000056a0: 6e20 222c 2022 6162 6364 6522 2c20 2220  n ", "abcde", " 
+000056b0: 5c6e 205c 7420 222c 2022 205c 745c 6e22  \n \t ", " \t\n"
+000056c0: 290a 2020 2020 2020 2020 7465 7374 5f6d  ).        test_m
+000056d0: 756c 7469 7374 7269 7028 2220 5c74 205c  ultistrip(" \t \
+000056e0: 6e20 222c 2022 6162 6364 6522 2c20 2220  n ", "abcde", " 
+000056f0: 5c6e 205c 7420 222c 2062 6967 2e77 6869  \n \t ", big.whi
+00005700: 7465 7370 6163 6529 0a20 2020 2020 2020  tespace).       
+00005710: 2074 6573 745f 6d75 6c74 6973 7472 6970   test_multistrip
+00005720: 2822 5c72 5c6e 5c6e 5c72 222c 2022 6162  ("\r\n\n\r", "ab
+00005730: 6364 6522 2c20 225c 6e5c 725c 725c 6e22  cde", "\n\r\r\n"
+00005740: 2c20 6269 672e 6e65 776c 696e 6573 290a  , big.newlines).
+00005750: 2020 2020 2020 2020 7465 7374 5f6d 756c          test_mul
+00005760: 7469 7374 7269 7028 225c 725c 6e5c 6e5c  tistrip("\r\n\n\
+00005770: 7222 2c20 2261 6263 6465 222c 2022 5c6e  r", "abcde", "\n
+00005780: 5c72 5c72 5c6e 222c 2062 6967 2e77 6869  \r\r\n", big.whi
+00005790: 7465 7370 6163 6529 0a20 2020 2020 2020  tespace).       
+000057a0: 2074 6573 745f 6d75 6c74 6973 7472 6970   test_multistrip
+000057b0: 2822 7858 5878 7878 5878 222c 2022 6969  ("xXXxxxXx", "ii
+000057c0: 6969 6969 6922 2c20 2279 7959 5959 7979  iiiii", "yyYYYyy
+000057d0: 7979 7922 2c20 2278 7958 5922 290a 0a20  yyy", "xyXY").. 
+000057e0: 2020 2020 2020 2023 2074 6573 7420 6d69         # test mi
+000057f0: 7865 6420 7375 6263 6c61 7373 6573 206f  xed subclasses o
+00005800: 6620 7374 7220 616e 6420 6279 7465 730a  f str and bytes.
+00005810: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
+00005820: 6572 7445 7175 616c 2862 6967 2e6d 756c  ertEqual(big.mul
+00005830: 7469 7374 7269 7028 5374 7253 7562 636c  tistrip(StrSubcl
+00005840: 6173 7328 2720 2061 6263 6465 2020 2729  ass('  abcde  ')
+00005850: 2c20 4469 6666 6572 656e 7453 7472 5375  , DifferentStrSu
+00005860: 6263 6c61 7373 2827 2027 2929 2c20 2761  bclass(' ')), 'a
+00005870: 6263 6465 2729 0a20 2020 2020 2020 2073  bcde').        s
+00005880: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
+00005890: 6269 672e 6d75 6c74 6973 7472 6970 2842  big.multistrip(B
+000058a0: 7974 6573 5375 6263 6c61 7373 2862 2720  ytesSubclass(b' 
+000058b0: 2061 6263 6465 2020 2729 2c20 4469 6666   abcde  '), Diff
+000058c0: 6572 656e 7442 7974 6573 5375 6263 6c61  erentBytesSubcla
+000058d0: 7373 2862 2720 2729 292c 2062 2761 6263  ss(b' ')), b'abc
+000058e0: 6465 2729 0a0a 2020 2020 2020 2020 2320  de')..        # 
+000058f0: 7468 6973 2073 686f 756c 6420 6265 2063  this should be c
+00005900: 6f76 6572 6564 2069 6e20 7468 6520 6c6f  overed in the lo
+00005910: 6f70 2061 626f 7665 2c0a 2020 2020 2020  op above,.      
+00005920: 2020 2320 6275 7420 7765 276c 6c20 6578    # but we'll ex
+00005930: 706c 6963 6974 6c79 2063 6865 636b 2069  plicitly check i
+00005940: 7420 616e 7977 6179 3a0a 2020 2020 2020  t anyway:.      
+00005950: 2020 2320 6d75 6c74 6973 7472 6970 202a    # multistrip *
+00005960: 616c 7761 7973 2a20 7265 7475 726e 7320  always* returns 
+00005970: 6569 7468 6572 2073 7472 206f 7220 6279  either str or by
+00005980: 7465 730a 2020 2020 2020 2020 2320 6f62  tes.        # ob
+00005990: 6a65 6374 732c 2065 7665 6e20 7768 656e  jects, even when
+000059a0: 2069 7420 646f 6573 6e27 7420 7374 7269   it doesn't stri
+000059b0: 7020 616e 7974 6869 6e67 2e0a 2020 2020  p anything..    
+000059c0: 2020 2020 7365 6c66 2e61 7373 6572 7445      self.assertE
+000059d0: 7175 616c 2862 6967 2e6d 756c 7469 7374  qual(big.multist
+000059e0: 7269 7028 5374 7253 7562 636c 6173 7328  rip(StrSubclass(
+000059f0: 2761 6263 6465 2729 2c20 5374 7253 7562  'abcde'), StrSub
+00005a00: 636c 6173 7328 2720 2729 292c 2027 6162  class(' ')), 'ab
+00005a10: 6364 6527 290a 2020 2020 2020 2020 7365  cde').        se
+00005a20: 6c66 2e61 7373 6572 7445 7175 616c 2874  lf.assertEqual(t
+00005a30: 7970 6528 6269 672e 6d75 6c74 6973 7472  ype(big.multistr
+00005a40: 6970 2853 7472 5375 6263 6c61 7373 2827  ip(StrSubclass('
+00005a50: 6162 6364 6527 292c 2053 7472 5375 6263  abcde'), StrSubc
+00005a60: 6c61 7373 2827 2027 2929 292c 2053 7472  lass(' '))), Str
+00005a70: 5375 6263 6c61 7373 290a 2020 2020 2020  Subclass).      
+00005a80: 2020 7365 6c66 2e61 7373 6572 7445 7175    self.assertEqu
+00005a90: 616c 2862 6967 2e6d 756c 7469 7374 7269  al(big.multistri
+00005aa0: 7028 4279 7465 7353 7562 636c 6173 7328  p(BytesSubclass(
+00005ab0: 6227 6162 6364 6527 292c 2042 7974 6573  b'abcde'), Bytes
+00005ac0: 5375 6263 6c61 7373 2862 2720 2729 292c  Subclass(b' ')),
+00005ad0: 2062 2761 6263 6465 2729 0a20 2020 2020   b'abcde').     
+00005ae0: 2020 2073 656c 662e 6173 7365 7274 4571     self.assertEq
+00005af0: 7561 6c28 7479 7065 2862 6967 2e6d 756c  ual(type(big.mul
+00005b00: 7469 7374 7269 7028 4279 7465 7353 7562  tistrip(BytesSub
+00005b10: 636c 6173 7328 6227 6162 6364 6527 292c  class(b'abcde'),
+00005b20: 2042 7974 6573 5375 6263 6c61 7373 2862   BytesSubclass(b
+00005b30: 2720 2729 2929 2c20 4279 7465 7353 7562  ' '))), BytesSub
+00005b40: 636c 6173 7329 0a0a 2020 2020 2020 2020  class)..        
+00005b50: 2320 7265 6772 6573 7369 6f6e 2074 6573  # regression tes
+00005b60: 743a 0a20 2020 2020 2020 2023 2074 6865  t:.        # the
+00005b70: 206f 6c64 2061 7070 726f 6163 6820 6861   old approach ha
+00005b80: 6420 6120 6275 6720 7468 6174 2068 6164  d a bug that had
+00005b90: 2074 6f20 646f 2077 6974 6820 6f76 6572   to do with over
+00005ba0: 6c61 7070 696e 6720 7365 7061 7261 746f  lapping separato
+00005bb0: 7273 2e0a 2020 2020 2020 2020 2320 7768  rs..        # wh
+00005bc0: 6174 2069 6620 796f 7520 7374 7269 7020  at if you strip 
+00005bd0: 7468 6520 7374 7269 6e67 2027 2078 2078  the string ' x x
+00005be0: 2027 2077 6974 6820 7468 6520 7365 7061   ' with the sepa
+00005bf0: 7261 746f 7220 2720 7820 273f 0a20 2020  rator ' x '?.   
+00005c00: 2020 2020 2023 2049 7420 7368 6f75 6c64       # It should
+00005c10: 2065 6174 2074 6865 2069 6e69 7469 616c   eat the initial
+00005c20: 2073 6570 6172 6174 6f72 2c20 7768 6963   separator, whic
+00005c30: 6820 6c65 6176 6573 2062 6568 696e 6420  h leaves behind 
+00005c40: 2278 2022 2c20 7768 6963 6820 646f 6573  "x ", which does
+00005c50: 6e27 7420 6d61 7463 680a 2020 2020 2020  n't match.      
+00005c60: 2020 2320 7468 6520 7365 7061 7261 746f    # the separato
+00005c70: 722c 2073 6f20 6974 2073 686f 756c 646e  r, so it shouldn
+00005c80: 2774 2062 6520 7374 7269 7070 6564 2e0a  't be stripped..
+00005c90: 0a20 2020 2020 2020 2023 2077 6520 7573  .        # we us
+00005ca0: 6564 2074 6f20 7365 7061 7261 7465 6c79  ed to separately
+00005cb0: 206d 6561 7375 7265 2022 7768 6572 6520   measure "where 
+00005cc0: 646f 6573 2074 6865 2062 6567 696e 6e69  does the beginni
+00005cd0: 6e67 2072 756e 206f 6620 7365 7061 7261  ng run of separa
+00005ce0: 746f 7273 2065 6e64 220a 2020 2020 2020  tors end".      
+00005cf0: 2020 2320 616e 6420 2277 6865 7265 2064    # and "where d
+00005d00: 6f65 7320 7468 6520 656e 6469 6e67 2072  oes the ending r
+00005d10: 756e 206f 6620 7365 7061 7261 746f 7273  un of separators
+00005d20: 2073 7461 7274 222c 2074 6865 6e20 6f6e   start", then on
+00005d30: 6c79 206b 6565 700a 2020 2020 2020 2020  ly keep.        
+00005d40: 2320 7468 6520 7061 7274 206f 6620 7468  # the part of th
+00005d50: 6520 7374 7269 6e67 2069 6e20 7468 6520  e string in the 
+00005d60: 6d69 6464 6c65 2e20 2062 7574 2069 6620  middle.  but if 
+00005d70: 796f 7572 2073 7472 696e 6720 7761 7320  your string was 
+00005d80: 2220 7820 7820 220a 2020 2020 2020 2020  " x x ".        
+00005d90: 2320 616e 6420 796f 7572 2073 6570 6172  # and your separ
+00005da0: 6174 6f72 7320 7765 7265 2028 2220 7820  ators were (" x 
+00005db0: 222c 292c 2074 6865 6e20 7468 6579 206f  ",), then they o
+00005dc0: 7665 726c 6170 7065 643a 0a20 2020 2020  verlapped:.     
+00005dd0: 2020 2023 0a20 2020 2020 2020 2023 2020     #.        #  
+00005de0: 2020 7676 7620 2020 7275 6e20 6f66 2065    vvv   run of e
+00005df0: 6e64 696e 6720 7365 7061 7261 746f 7273  nding separators
+00005e00: 0a20 2020 2020 2020 2023 2022 2078 2078  .        # " x x
+00005e10: 2022 0a20 2020 2020 2020 2023 2020 5e5e   ".        #  ^^
+00005e20: 5e20 2020 2020 7275 6e20 6f66 2062 6567  ^     run of beg
+00005e30: 696e 6e69 6e67 2073 6570 6172 6174 6f72  inning separator
+00005e40: 730a 2020 2020 2020 2020 230a 2020 2020  s.        #.    
+00005e50: 2020 2020 2320 616e 642c 2077 686f 206b      # and, who k
+00005e60: 6e6f 7773 2c20 6d61 7962 6520 7468 6174  nows, maybe that
+00005e70: 2773 2077 6861 7420 796f 7520 7761 6e74  's what you want
+00005e80: 3f20 6275 7420 7468 6174 2773 206e 6f74  ? but that's not
+00005e90: 2077 6861 7420 796f 7527 7265 2067 6f6e   what you're gon
+00005ea0: 6e61 2067 6574 2e0a 2020 2020 2020 2020  na get..        
+00005eb0: 2320 6d75 6c74 692d 2a20 6675 6e63 7469  # multi-* functi
+00005ec0: 6f6e 7320 7072 6566 6572 2074 6865 206c  ons prefer the l
+00005ed0: 6566 746d 6f73 7420 696e 7374 616e 6365  eftmost instance
+00005ee0: 206f 6620 6120 7365 7061 7261 746f 7220   of a separator 
+00005ef0: 2875 6e6c 6573 7320 7265 7665 7273 650a  (unless reverse.
+00005f00: 2020 2020 2020 2020 2320 6973 2074 7275          # is tru
+00005f10: 6529 2e20 2073 6f20 7468 6973 2073 686f  e).  so this sho
+00005f20: 756c 6420 6561 7420 7468 6520 6c65 6674  uld eat the left
+00005f30: 206f 7665 726c 6170 7069 6e67 2073 6570   overlapping sep
+00005f40: 6172 6174 6f72 2061 6e64 206c 6561 7665  arator and leave
+00005f50: 2077 6861 740a 2020 2020 2020 2020 2320   what.        # 
+00005f60: 7265 6d61 696e 7320 6f66 2074 6865 2072  remains of the r
+00005f70: 6967 6874 206f 6e65 2e0a 2020 2020 2020  ight one..      
+00005f80: 2020 7365 6c66 2e61 7373 6572 7445 7175    self.assertEqu
+00005f90: 616c 2862 6967 2e6d 756c 7469 7374 7269  al(big.multistri
+00005fa0: 7028 2720 7820 7820 272c 2028 2720 7820  p(' x x ', (' x 
+00005fb0: 272c 2929 2c20 2778 2027 290a 0a20 2020  ',)), 'x ')..   
+00005fc0: 2020 2020 2023 2072 6567 7265 7373 696f       # regressio
+00005fd0: 6e3a 206d 756c 7469 7374 7269 7020 6469  n: multistrip di
+00005fe0: 646e 2774 2075 7365 6420 746f 2076 6572  dn't used to ver
+00005ff0: 6966 790a 2020 2020 2020 2020 2320 7468  ify.        # th
+00006000: 6174 2073 2077 6173 2065 6974 6865 7220  at s was either 
+00006010: 7374 7220 6f72 2062 7974 6573 2e0a 2020  str or bytes..  
+00006020: 2020 2020 2020 7769 7468 2073 656c 662e        with self.
+00006030: 6173 7365 7274 5261 6973 6573 2854 7970  assertRaises(Typ
+00006040: 6545 7272 6f72 293a 0a20 2020 2020 2020  eError):.       
+00006050: 2020 2020 2062 6967 2e6d 756c 7469 7374       big.multist
+00006060: 7269 7028 332e 3134 3135 290a 2020 2020  rip(3.1415).    
+00006070: 2020 2020 7769 7468 2073 656c 662e 6173      with self.as
+00006080: 7365 7274 5261 6973 6573 2854 7970 6545  sertRaises(TypeE
+00006090: 7272 6f72 293a 0a20 2020 2020 2020 2020  rror):.         
+000060a0: 2020 2062 6967 2e6d 756c 7469 7374 7269     big.multistri
+000060b0: 7028 332e 3134 3135 2c20 2761 6263 2729  p(3.1415, 'abc')
+000060c0: 0a20 2020 2020 2020 2077 6974 6820 7365  .        with se
+000060d0: 6c66 2e61 7373 6572 7452 6169 7365 7328  lf.assertRaises(
+000060e0: 5479 7065 4572 726f 7229 3a0a 2020 2020  TypeError):.    
+000060f0: 2020 2020 2020 2020 6269 672e 6d75 6c74          big.mult
+00006100: 6973 7472 6970 285b 2761 272c 2027 6227  istrip(['a', 'b'
+00006110: 2c20 2763 275d 290a 2020 2020 2020 2020  , 'c']).        
+00006120: 7769 7468 2073 656c 662e 6173 7365 7274  with self.assert
+00006130: 5261 6973 6573 2854 7970 6545 7272 6f72  Raises(TypeError
+00006140: 293a 0a20 2020 2020 2020 2020 2020 2062  ):.            b
+00006150: 6967 2e6d 756c 7469 7374 7269 7028 5b62  ig.multistrip([b
+00006160: 2761 272c 2062 2762 272c 2062 2763 275d  'a', b'b', b'c']
+00006170: 290a 2020 2020 2020 2020 7769 7468 2073  ).        with s
+00006180: 656c 662e 6173 7365 7274 5261 6973 6573  elf.assertRaises
+00006190: 2854 7970 6545 7272 6f72 293a 0a20 2020  (TypeError):.   
+000061a0: 2020 2020 2020 2020 2062 6967 2e6d 756c           big.mul
+000061b0: 7469 7374 7269 7028 5b27 6127 2c20 2762  tistrip(['a', 'b
+000061c0: 272c 2027 6327 5d2c 2027 6127 290a 2020  ', 'c'], 'a').  
+000061d0: 2020 2020 2020 7769 7468 2073 656c 662e        with self.
+000061e0: 6173 7365 7274 5261 6973 6573 2854 7970  assertRaises(Typ
+000061f0: 6545 7272 6f72 293a 0a20 2020 2020 2020  eError):.       
+00006200: 2020 2020 2062 6967 2e6d 756c 7469 7374       big.multist
+00006210: 7269 7028 5b62 2761 272c 2062 2762 272c  rip([b'a', b'b',
+00006220: 2062 2763 275d 2c20 6227 6127 290a 0a20   b'c'], b'a').. 
+00006230: 2020 2020 2020 2077 6974 6820 7365 6c66         with self
+00006240: 2e61 7373 6572 7452 6169 7365 7328 5479  .assertRaises(Ty
+00006250: 7065 4572 726f 7229 3a0a 2020 2020 2020  peError):.      
+00006260: 2020 2020 2020 6269 672e 6d75 6c74 6973        big.multis
+00006270: 7472 6970 2827 7327 2c20 5b27 6127 2c20  trip('s', ['a', 
+00006280: 6227 6227 2c20 2763 275d 290a 2020 2020  b'b', 'c']).    
+00006290: 2020 2020 7769 7468 2073 656c 662e 6173      with self.as
+000062a0: 7365 7274 5261 6973 6573 2854 7970 6545  sertRaises(TypeE
+000062b0: 7272 6f72 293a 0a20 2020 2020 2020 2020  rror):.         
+000062c0: 2020 2062 6967 2e6d 756c 7469 7374 7269     big.multistri
+000062d0: 7028 2773 272c 205b 2761 272c 2031 3233  p('s', ['a', 123
+000062e0: 342c 2027 6327 5d29 0a20 2020 2020 2020  4, 'c']).       
+000062f0: 2077 6974 6820 7365 6c66 2e61 7373 6572   with self.asser
+00006300: 7452 6169 7365 7328 5479 7065 4572 726f  tRaises(TypeErro
+00006310: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
+00006320: 6269 672e 6d75 6c74 6973 7472 6970 2862  big.multistrip(b
+00006330: 2773 272c 205b 6227 6127 2c20 2762 272c  's', [b'a', 'b',
+00006340: 2062 2763 275d 290a 2020 2020 2020 2020   b'c']).        
+00006350: 7769 7468 2073 656c 662e 6173 7365 7274  with self.assert
+00006360: 5261 6973 6573 2854 7970 6545 7272 6f72  Raises(TypeError
+00006370: 293a 0a20 2020 2020 2020 2020 2020 2062  ):.            b
+00006380: 6967 2e6d 756c 7469 7374 7269 7028 6227  ig.multistrip(b'
+00006390: 7327 2c20 5b62 2761 272c 2031 3233 342c  s', [b'a', 1234,
+000063a0: 2062 2763 275d 290a 0a20 2020 2020 2020   b'c'])..       
+000063b0: 2077 6974 6820 7365 6c66 2e61 7373 6572   with self.asser
+000063c0: 7452 6169 7365 7328 5479 7065 4572 726f  tRaises(TypeErro
+000063d0: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
+000063e0: 6269 672e 6d75 6c74 6973 7472 6970 2827  big.multistrip('
+000063f0: 7327 2c20 6227 6162 6327 290a 2020 2020  s', b'abc').    
+00006400: 2020 2020 7769 7468 2073 656c 662e 6173      with self.as
+00006410: 7365 7274 5261 6973 6573 2854 7970 6545  sertRaises(TypeE
+00006420: 7272 6f72 293a 0a20 2020 2020 2020 2020  rror):.         
+00006430: 2020 2062 6967 2e6d 756c 7469 7374 7269     big.multistri
+00006440: 7028 6227 7327 2c20 2761 6263 2729 0a0a  p(b's', 'abc')..
+00006450: 2020 2020 2020 2020 7769 7468 2073 656c          with sel
+00006460: 662e 6173 7365 7274 5261 6973 6573 2854  f.assertRaises(T
+00006470: 7970 6545 7272 6f72 293a 0a20 2020 2020  ypeError):.     
+00006480: 2020 2020 2020 2062 6967 2e6d 756c 7469         big.multi
+00006490: 7374 7269 7028 5374 7253 7562 636c 6173  strip(StrSubclas
+000064a0: 7328 6227 2020 6162 6364 6520 2027 292c  s(b'  abcde  '),
+000064b0: 2042 7974 6573 5375 6263 6c61 7373 2862   BytesSubclass(b
+000064c0: 2720 2729 290a 0a20 2020 2020 2020 2077  ' '))..        w
+000064d0: 6974 6820 7365 6c66 2e61 7373 6572 7452  ith self.assertR
+000064e0: 6169 7365 7328 5661 6c75 6545 7272 6f72  aises(ValueError
+000064f0: 293a 0a20 2020 2020 2020 2020 2020 2062  ):.            b
+00006500: 6967 2e6d 756c 7469 7374 7269 7028 2773  ig.multistrip('s
+00006510: 272c 2027 2729 0a20 2020 2020 2020 2077  ', '').        w
+00006520: 6974 6820 7365 6c66 2e61 7373 6572 7452  ith self.assertR
+00006530: 6169 7365 7328 5661 6c75 6545 7272 6f72  aises(ValueError
+00006540: 293a 0a20 2020 2020 2020 2020 2020 2062  ):.            b
+00006550: 6967 2e6d 756c 7469 7374 7269 7028 2773  ig.multistrip('s
+00006560: 272c 205b 5d29 0a20 2020 2020 2020 2077  ', []).        w
+00006570: 6974 6820 7365 6c66 2e61 7373 6572 7452  ith self.assertR
+00006580: 6169 7365 7328 5661 6c75 6545 7272 6f72  aises(ValueError
+00006590: 293a 0a20 2020 2020 2020 2020 2020 2062  ):.            b
+000065a0: 6967 2e6d 756c 7469 7374 7269 7028 2773  ig.multistrip('s
+000065b0: 272c 205b 5d29 0a20 2020 2020 2020 2077  ', []).        w
+000065c0: 6974 6820 7365 6c66 2e61 7373 6572 7452  ith self.assertR
+000065d0: 6169 7365 7328 5661 6c75 6545 7272 6f72  aises(ValueError
+000065e0: 293a 0a20 2020 2020 2020 2020 2020 2062  ):.            b
+000065f0: 6967 2e6d 756c 7469 7374 7269 7028 6227  ig.multistrip(b'
+00006600: 7327 2c20 6227 2729 0a20 2020 2020 2020  s', b'').       
+00006610: 2077 6974 6820 7365 6c66 2e61 7373 6572   with self.asser
+00006620: 7452 6169 7365 7328 5661 6c75 6545 7272  tRaises(ValueErr
+00006630: 6f72 293a 0a20 2020 2020 2020 2020 2020  or):.           
+00006640: 2062 6967 2e6d 756c 7469 7374 7269 7028   big.multistrip(
+00006650: 6227 7327 2c20 5b5d 290a 2020 2020 2020  b's', []).      
+00006660: 2020 7769 7468 2073 656c 662e 6173 7365    with self.asse
+00006670: 7274 5261 6973 6573 2856 616c 7565 4572  rtRaises(ValueEr
+00006680: 726f 7229 3a0a 2020 2020 2020 2020 2020  ror):.          
+00006690: 2020 6269 672e 6d75 6c74 6973 7472 6970    big.multistrip
+000066a0: 2862 2773 272c 2028 2929 0a0a 0a20 2020  (b's', ())...   
+000066b0: 2020 2020 2077 6974 6820 7365 6c66 2e61       with self.a
+000066c0: 7373 6572 7452 6169 7365 7328 5661 6c75  ssertRaises(Valu
+000066d0: 6545 7272 6f72 293a 0a20 2020 2020 2020  eError):.       
+000066e0: 2020 2020 2062 6967 2e6d 756c 7469 7374       big.multist
+000066f0: 7269 7028 2761 6263 6465 272c 2028 2763  rip('abcde', ('c
+00006700: 272c 2027 2729 290a 0a20 2020 2064 6566  ', ''))..    def
+00006710: 2074 6573 745f 6d75 6c74 6973 706c 6974   test_multisplit
+00006720: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00006730: 666f 7220 6320 696e 2028 756e 6368 616e  for c in (unchan
+00006740: 6765 642c 2074 6f5f 6279 7465 7329 3a0a  ged, to_bytes):.
+00006750: 2020 2020 2020 2020 2020 2020 6e6f 745f              not_
+00006760: 6320 3d20 746f 5f62 7974 6573 2069 6620  c = to_bytes if 
+00006770: 2863 203d 3d20 756e 6368 616e 6765 6429  (c == unchanged)
+00006780: 2065 6c73 6520 756e 6368 616e 6765 640a   else unchanged.
+00006790: 2020 2020 2020 2020 2020 2020 6465 6620              def 
+000067a0: 6c69 7374 5f6d 756c 7469 7370 6c69 7428  list_multisplit(
+000067b0: 2a61 2c20 2a2a 6b77 293a 2072 6574 7572  *a, **kw): retur
+000067c0: 6e20 6c69 7374 2862 6967 2e6d 756c 7469  n list(big.multi
+000067d0: 7370 6c69 7428 2a61 2c20 2a2a 6b77 2929  split(*a, **kw))
+000067e0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+000067f0: 662e 6173 7365 7274 4571 7561 6c28 6c69  f.assertEqual(li
+00006800: 7374 5f6d 756c 7469 7370 6c69 7428 6328  st_multisplit(c(
+00006810: 2761 6161 5861 6161 5961 6161 2729 2c20  'aaaXaaaYaaa'), 
+00006820: 6328 2761 6263 2729 2c20 7374 7269 703d  c('abc'), strip=
+00006830: 5472 7565 2029 2c20 6328 5b27 5827 2c20  True ), c(['X', 
+00006840: 2759 275d 2929 0a20 2020 2020 2020 2020  'Y'])).         
+00006850: 2020 2073 656c 662e 6173 7365 7274 4571     self.assertEq
+00006860: 7561 6c28 6c69 7374 5f6d 756c 7469 7370  ual(list_multisp
+00006870: 6c69 7428 6328 2761 6161 5861 6161 5961  lit(c('aaaXaaaYa
+00006880: 6161 2729 2c20 6328 2761 6263 2729 2c20  aa'), c('abc'), 
+00006890: 7374 7269 703d 4661 6c73 6529 2c20 6328  strip=False), c(
+000068a0: 5b27 272c 2027 5827 2c20 2759 272c 2027  ['', 'X', 'Y', '
+000068b0: 275d 2929 0a20 2020 2020 2020 2020 2020  '])).           
+000068c0: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
+000068d0: 6c28 6c69 7374 5f6d 756c 7469 7370 6c69  l(list_multispli
+000068e0: 7428 6328 2761 6263 5862 6361 5963 6261  t(c('abcXbcaYcba
+000068f0: 2729 2c20 6328 2761 6263 2729 2c20 7374  '), c('abc'), st
+00006900: 7269 703d 5472 7565 2029 2c20 6328 5b27  rip=True ), c(['
+00006910: 5827 2c20 2759 275d 2929 0a20 2020 2020  X', 'Y'])).     
+00006920: 2020 2020 2020 2073 656c 662e 6173 7365         self.asse
+00006930: 7274 4571 7561 6c28 6c69 7374 5f6d 756c  rtEqual(list_mul
+00006940: 7469 7370 6c69 7428 6328 2761 6263 5862  tisplit(c('abcXb
+00006950: 6361 5963 6261 2729 2c20 6328 2761 6263  caYcba'), c('abc
+00006960: 2729 2c20 7374 7269 703d 4661 6c73 6529  '), strip=False)
+00006970: 2c20 6328 5b27 272c 2027 5827 2c20 2759  , c(['', 'X', 'Y
+00006980: 272c 2027 275d 2929 0a0a 2020 2020 2020  ', '']))..      
+00006990: 2020 2020 2020 7365 6c66 2e61 7373 6572        self.asser
+000069a0: 7445 7175 616c 286c 6973 745f 6d75 6c74  tEqual(list_mult
+000069b0: 6973 706c 6974 2863 2827 2729 2c20 6328  isplit(c(''), c(
+000069c0: 2761 6263 6465 2729 2c20 6d61 7873 706c  'abcde'), maxspl
+000069d0: 6974 3d4e 6f6e 6529 2c20 6328 5b27 275d  it=None), c(['']
+000069e0: 2929 0a20 2020 2020 2020 2020 2020 2073  )).            s
+000069f0: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
+00006a00: 6c69 7374 5f6d 756c 7469 7370 6c69 7428  list_multisplit(
+00006a10: 6328 2761 6263 6465 2729 2c20 6328 2766  c('abcde'), c('f
+00006a20: 6768 696a 2729 292c 2063 285b 2761 6263  ghij')), c(['abc
+00006a30: 6465 275d 2929 0a20 2020 2020 2020 2020  de'])).         
+00006a40: 2020 2073 656c 662e 6173 7365 7274 4571     self.assertEq
+00006a50: 7561 6c28 6c69 7374 5f6d 756c 7469 7370  ual(list_multisp
+00006a60: 6c69 7428 6328 2761 6263 6465 2729 2c20  lit(c('abcde'), 
+00006a70: 6328 2766 6768 696a 6327 2929 2c20 6328  c('fghijc')), c(
+00006a80: 5b27 6162 272c 2027 6465 275d 2929 0a20  ['ab', 'de'])). 
+00006a90: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00006aa0: 6173 7365 7274 4571 7561 6c28 6c69 7374  assertEqual(list
+00006ab0: 5f6d 756c 7469 7370 6c69 7428 6328 2731  _multisplit(c('1
+00006ac0: 6132 6233 6334 6435 6536 2729 2c20 6328  a2b3c4d5e6'), c(
+00006ad0: 2761 6263 6465 2729 292c 2063 285b 2731  'abcde')), c(['1
+00006ae0: 272c 2027 3227 2c20 2733 272c 2027 3427  ', '2', '3', '4'
+00006af0: 2c20 2735 272c 2027 3627 5d29 290a 0a20  , '5', '6'])).. 
+00006b00: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00006b10: 6173 7365 7274 4571 7561 6c28 6c69 7374  assertEqual(list
+00006b20: 5f6d 756c 7469 7370 6c69 7428 6328 2761  _multisplit(c('a
+00006b30: 623a 6364 2c65 6627 292c 2020 2063 2827  b:cd,ef'),   c('
+00006b40: 3a2c 2729 2c20 7374 7269 703d 5472 7565  :,'), strip=True
+00006b50: 2029 2c20 6328 5b22 6162 222c 2022 6364   ), c(["ab", "cd
+00006b60: 222c 2022 6566 225d 2929 0a20 2020 2020  ", "ef"])).     
+00006b70: 2020 2020 2020 2073 656c 662e 6173 7365         self.asse
+00006b80: 7274 4571 7561 6c28 6c69 7374 5f6d 756c  rtEqual(list_mul
+00006b90: 7469 7370 6c69 7428 6328 2761 623a 6364  tisplit(c('ab:cd
+00006ba0: 2c65 6627 292c 2020 2063 2827 3a2c 2729  ,ef'),   c(':,')
+00006bb0: 2c20 7374 7269 703d 4661 6c73 6529 2c20  , strip=False), 
+00006bc0: 6328 5b22 6162 222c 2022 6364 222c 2022  c(["ab", "cd", "
+00006bd0: 6566 225d 2929 0a20 2020 2020 2020 2020  ef"])).         
+00006be0: 2020 2073 656c 662e 6173 7365 7274 4571     self.assertEq
+00006bf0: 7561 6c28 6c69 7374 5f6d 756c 7469 7370  ual(list_multisp
+00006c00: 6c69 7428 6328 2761 623a 6364 2c65 663a  lit(c('ab:cd,ef:
+00006c10: 2729 2c20 2063 2827 3a2c 2729 2c20 7374  '),  c(':,'), st
+00006c20: 7269 703d 5472 7565 2029 2c20 6328 5b22  rip=True ), c(["
+00006c30: 6162 222c 2022 6364 222c 2022 6566 225d  ab", "cd", "ef"]
+00006c40: 2929 0a20 2020 2020 2020 2020 2020 2073  )).            s
+00006c50: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
+00006c60: 6c69 7374 5f6d 756c 7469 7370 6c69 7428  list_multisplit(
+00006c70: 6328 2761 623a 6364 2c65 663a 2729 2c20  c('ab:cd,ef:'), 
+00006c80: 2063 2827 3a2c 2729 2c20 7374 7269 703d   c(':,'), strip=
+00006c90: 4661 6c73 6529 2c20 6328 5b22 6162 222c  False), c(["ab",
+00006ca0: 2022 6364 222c 2022 6566 222c 2022 225d   "cd", "ef", ""]
+00006cb0: 2929 0a20 2020 2020 2020 2020 2020 2073  )).            s
+00006cc0: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
+00006cd0: 6c69 7374 5f6d 756c 7469 7370 6c69 7428  list_multisplit(
+00006ce0: 6328 272c 6162 3a63 642c 6566 3a27 292c  c(',ab:cd,ef:'),
+00006cf0: 2063 2827 3a2c 2729 2c20 7374 7269 703d   c(':,'), strip=
+00006d00: 5472 7565 2029 2c20 6328 5b22 6162 222c  True ), c(["ab",
+00006d10: 2022 6364 222c 2022 6566 225d 2929 0a20   "cd", "ef"])). 
+00006d20: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00006d30: 6173 7365 7274 4571 7561 6c28 6c69 7374  assertEqual(list
+00006d40: 5f6d 756c 7469 7370 6c69 7428 6328 272c  _multisplit(c(',
+00006d50: 6162 3a63 642c 6566 3a27 292c 2063 2827  ab:cd,ef:'), c('
+00006d60: 3a2c 2729 2c20 7374 7269 703d 4661 6c73  :,'), strip=Fals
+00006d70: 6529 2c20 6328 5b22 222c 2022 6162 222c  e), c(["", "ab",
+00006d80: 2022 6364 222c 2022 6566 222c 2022 225d   "cd", "ef", ""]
+00006d90: 2929 0a20 2020 2020 2020 2020 2020 2073  )).            s
+00006da0: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
+00006db0: 6c69 7374 5f6d 756c 7469 7370 6c69 7428  list_multisplit(
+00006dc0: 6328 273a 6162 3a63 642c 6566 2729 2c20  c(':ab:cd,ef'), 
+00006dd0: 2063 2827 3a2c 2729 2c20 7374 7269 703d   c(':,'), strip=
+00006de0: 5472 7565 2029 2c20 6328 5b22 6162 222c  True ), c(["ab",
+00006df0: 2022 6364 222c 2022 6566 225d 2929 0a20   "cd", "ef"])). 
+00006e00: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00006e10: 6173 7365 7274 4571 7561 6c28 6c69 7374  assertEqual(list
+00006e20: 5f6d 756c 7469 7370 6c69 7428 6328 273a  _multisplit(c(':
+00006e30: 6162 3a63 642c 6566 2729 2c20 2063 2827  ab:cd,ef'),  c('
+00006e40: 3a2c 2729 2c20 7374 7269 703d 4661 6c73  :,'), strip=Fals
+00006e50: 6529 2c20 6328 5b22 222c 2022 6162 222c  e), c(["", "ab",
+00006e60: 2022 6364 222c 2022 6566 225d 2929 0a20   "cd", "ef"])). 
+00006e70: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00006e80: 6173 7365 7274 4571 7561 6c28 6c69 7374  assertEqual(list
+00006e90: 5f6d 756c 7469 7370 6c69 7428 6328 2757  _multisplit(c('W
+00006ea0: 5761 6258 5863 6459 5961 625a 5a27 292c  WabXXcdYYabZZ'),
+00006eb0: 2020 2063 2828 2761 6227 2c20 2763 6427     c(('ab', 'cd'
+00006ec0: 2929 2c20 7374 7269 703d 5472 7565 2029  )), strip=True )
+00006ed0: 2c20 6328 5b27 5757 272c 2027 5858 272c  , c(['WW', 'XX',
+00006ee0: 2027 5959 272c 2027 5a5a 275d 2929 0a20   'YY', 'ZZ'])). 
+00006ef0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00006f00: 6173 7365 7274 4571 7561 6c28 6c69 7374  assertEqual(list
+00006f10: 5f6d 756c 7469 7370 6c69 7428 6328 2757  _multisplit(c('W
+00006f20: 5761 6258 5863 6459 5961 625a 5a27 292c  WabXXcdYYabZZ'),
+00006f30: 2020 2063 2828 2761 6227 2c20 2763 6427     c(('ab', 'cd'
+00006f40: 2929 2c20 7374 7269 703d 4661 6c73 6529  )), strip=False)
+00006f50: 2c20 6328 5b27 5757 272c 2027 5858 272c  , c(['WW', 'XX',
+00006f60: 2027 5959 272c 2027 5a5a 275d 2929 0a20   'YY', 'ZZ'])). 
+00006f70: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00006f80: 6173 7365 7274 4571 7561 6c28 6c69 7374  assertEqual(list
+00006f90: 5f6d 756c 7469 7370 6c69 7428 6328 2757  _multisplit(c('W
+00006fa0: 5761 6258 5863 6459 5961 625a 5a61 6227  WabXXcdYYabZZab'
+00006fb0: 292c 2063 2828 2761 6227 2c20 2763 6427  ), c(('ab', 'cd'
+00006fc0: 2929 2c20 7374 7269 703d 5472 7565 2029  )), strip=True )
+00006fd0: 2c20 6328 5b27 5757 272c 2027 5858 272c  , c(['WW', 'XX',
+00006fe0: 2027 5959 272c 2027 5a5a 275d 2929 0a20   'YY', 'ZZ'])). 
+00006ff0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00007000: 6173 7365 7274 4571 7561 6c28 6c69 7374  assertEqual(list
+00007010: 5f6d 756c 7469 7370 6c69 7428 6328 2757  _multisplit(c('W
+00007020: 5761 6258 5863 6459 5961 625a 5a61 6227  WabXXcdYYabZZab'
+00007030: 292c 2063 2828 2761 6227 2c20 2763 6427  ), c(('ab', 'cd'
+00007040: 2929 2c20 7374 7269 703d 4661 6c73 6529  )), strip=False)
+00007050: 2c20 6328 5b27 5757 272c 2027 5858 272c  , c(['WW', 'XX',
+00007060: 2027 5959 272c 2027 5a5a 272c 2027 275d   'YY', 'ZZ', '']
+00007070: 2929 0a20 2020 2020 2020 2020 2020 2073  )).            s
+00007080: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
+00007090: 6c69 7374 5f6d 756c 7469 7370 6c69 7428  list_multisplit(
+000070a0: 6328 2761 6257 5761 6258 5863 6459 5961  c('abWWabXXcdYYa
+000070b0: 625a 5a27 292c 2063 2828 2761 6227 2c20  bZZ'), c(('ab', 
+000070c0: 2763 6427 2929 2c20 7374 7269 703d 5472  'cd')), strip=Tr
+000070d0: 7565 2029 2c20 6328 5b27 5757 272c 2027  ue ), c(['WW', '
+000070e0: 5858 272c 2027 5959 272c 2027 5a5a 275d  XX', 'YY', 'ZZ']
+000070f0: 2929 0a20 2020 2020 2020 2020 2020 2073  )).            s
+00007100: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
+00007110: 6c69 7374 5f6d 756c 7469 7370 6c69 7428  list_multisplit(
+00007120: 6328 2761 6257 5761 6258 5863 6459 5961  c('abWWabXXcdYYa
+00007130: 625a 5a27 292c 2063 2828 2761 6227 2c20  bZZ'), c(('ab', 
+00007140: 2763 6427 2929 2c20 7374 7269 703d 4661  'cd')), strip=Fa
+00007150: 6c73 6529 2c20 6328 5b27 272c 2757 5727  lse), c(['','WW'
+00007160: 2c20 2758 5827 2c20 2759 5927 2c20 275a  , 'XX', 'YY', 'Z
+00007170: 5a27 5d29 290a 2020 2020 2020 2020 2020  Z'])).          
+00007180: 2020 7365 6c66 2e61 7373 6572 7445 7175    self.assertEqu
+00007190: 616c 286c 6973 745f 6d75 6c74 6973 706c  al(list_multispl
+000071a0: 6974 2863 2827 5757 6162 5858 6364 5959  it(c('WWabXXcdYY
+000071b0: 6162 5a5a 6364 2729 2c20 6328 2827 6162  abZZcd'), c(('ab
+000071c0: 272c 2027 6364 2729 292c 2073 7472 6970  ', 'cd')), strip
+000071d0: 3d54 7275 6520 292c 2063 285b 2757 5727  =True ), c(['WW'
+000071e0: 2c20 2758 5827 2c20 2759 5927 2c20 275a  , 'XX', 'YY', 'Z
+000071f0: 5a27 5d29 290a 2020 2020 2020 2020 2020  Z'])).          
+00007200: 2020 7365 6c66 2e61 7373 6572 7445 7175    self.assertEqu
+00007210: 616c 286c 6973 745f 6d75 6c74 6973 706c  al(list_multispl
+00007220: 6974 2863 2827 5757 6162 5858 6364 5959  it(c('WWabXXcdYY
+00007230: 6162 5a5a 6364 2729 2c20 6328 2827 6162  abZZcd'), c(('ab
+00007240: 272c 2027 6364 2729 292c 2073 7472 6970  ', 'cd')), strip
+00007250: 3d46 616c 7365 292c 2063 285b 2757 5727  =False), c(['WW'
+00007260: 2c20 2758 5827 2c20 2759 5927 2c20 275a  , 'XX', 'YY', 'Z
+00007270: 5a27 2c20 2727 5d29 290a 2020 2020 2020  Z', ''])).      
+00007280: 2020 2020 2020 7365 6c66 2e61 7373 6572        self.asser
+00007290: 7445 7175 616c 286c 6973 745f 6d75 6c74  tEqual(list_mult
+000072a0: 6973 706c 6974 2863 2827 5858 6162 6364  isplit(c('XXabcd
+000072b0: 5959 2729 2c20 6328 2827 6127 2c20 2761  YY'), c(('a', 'a
+000072c0: 6263 6427 2929 292c 2063 285b 2758 5827  bcd'))), c(['XX'
+000072d0: 2c20 2759 5927 5d29 290a 2020 2020 2020  , 'YY'])).      
+000072e0: 2020 2020 2020 7365 6c66 2e61 7373 6572        self.asser
+000072f0: 7445 7175 616c 286c 6973 745f 6d75 6c74  tEqual(list_mult
+00007300: 6973 706c 6974 2863 2827 5858 6162 6364  isplit(c('XXabcd
+00007310: 6162 6364 5959 2729 2c20 6328 2827 6162  abcdYY'), c(('ab
+00007320: 272c 2027 6364 2729 2929 2c20 6328 5b27  ', 'cd'))), c(['
+00007330: 5858 272c 2027 5959 275d 2929 0a20 2020  XX', 'YY'])).   
+00007340: 2020 2020 2020 2020 2073 656c 662e 6173           self.as
+00007350: 7365 7274 4571 7561 6c28 6c69 7374 5f6d  sertEqual(list_m
+00007360: 756c 7469 7370 6c69 7428 6328 2761 6263  ultisplit(c('abc
+00007370: 6458 5861 6263 6461 6263 6459 5961 6263  dXXabcdabcdYYabc
+00007380: 6427 292c 2063 2828 2761 6227 2c20 2763  d'), c(('ab', 'c
+00007390: 6427 2929 2c20 7374 7269 703d 5472 7565  d')), strip=True
+000073a0: 2029 2c20 6328 5b27 5858 272c 2027 5959   ), c(['XX', 'YY
+000073b0: 275d 2929 0a20 2020 2020 2020 2020 2020  '])).           
+000073c0: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
+000073d0: 6c28 6c69 7374 5f6d 756c 7469 7370 6c69  l(list_multispli
+000073e0: 7428 6328 2761 6263 6458 5861 6263 6461  t(c('abcdXXabcda
+000073f0: 6263 6459 5961 6263 6427 292c 2063 2828  bcdYYabcd'), c((
+00007400: 2761 6227 2c20 2763 6427 2929 2c20 7374  'ab', 'cd')), st
+00007410: 7269 703d 4661 6c73 6529 2c20 6328 5b27  rip=False), c(['
+00007420: 272c 2027 5858 272c 2027 5959 272c 2027  ', 'XX', 'YY', '
+00007430: 275d 2929 0a20 2020 2020 2020 2020 2020  '])).           
+00007440: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
+00007450: 6c28 6c69 7374 5f6d 756c 7469 7370 6c69  l(list_multispli
+00007460: 7428 6328 2761 6263 6458 5861 6263 6461  t(c('abcdXXabcda
+00007470: 6263 6459 5961 6263 6427 292c 2063 2828  bcdYYabcd'), c((
+00007480: 2761 6227 2c20 2763 6427 2929 2c20 7365  'ab', 'cd')), se
+00007490: 7061 7261 7465 3d54 7275 652c 2073 7472  parate=True, str
+000074a0: 6970 3d46 616c 7365 292c 2063 285b 2727  ip=False), c([''
+000074b0: 2c20 2727 2c20 2758 5827 2c20 2727 2c20  , '', 'XX', '', 
+000074c0: 2727 2c20 2727 2c20 2759 5927 2c20 2727  '', '', 'YY', ''
+000074d0: 2c20 2727 5d29 290a 0a20 2020 2020 2020  , '']))..       
+000074e0: 2020 2020 2073 656c 662e 6173 7365 7274       self.assert
+000074f0: 4571 7561 6c28 6c69 7374 5f6d 756c 7469  Equal(list_multi
+00007500: 7370 6c69 7428 6328 2778 6178 6278 6378  split(c('xaxbxcx
+00007510: 6478 6578 2729 2c20 6328 2761 6263 6465  dxex'), c('abcde
+00007520: 2729 2c20 6d61 7873 706c 6974 3d30 292c  '), maxsplit=0),
+00007530: 2063 285b 2778 6178 6278 6378 6478 6578   c(['xaxbxcxdxex
+00007540: 275d 2929 0a20 2020 2020 2020 2020 2020  '])).           
+00007550: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
+00007560: 6c28 6c69 7374 5f6d 756c 7469 7370 6c69  l(list_multispli
+00007570: 7428 6328 2778 6178 6278 6378 6478 6578  t(c('xaxbxcxdxex
+00007580: 2729 2c20 6328 2761 6263 6465 2729 2c20  '), c('abcde'), 
+00007590: 6d61 7873 706c 6974 3d31 292c 2063 285b  maxsplit=1), c([
+000075a0: 2778 272c 2027 7862 7863 7864 7865 7827  'x', 'xbxcxdxex'
+000075b0: 5d29 290a 2020 2020 2020 2020 2020 2020  ])).            
+000075c0: 7365 6c66 2e61 7373 6572 7445 7175 616c  self.assertEqual
+000075d0: 286c 6973 745f 6d75 6c74 6973 706c 6974  (list_multisplit
+000075e0: 2863 2827 7861 7862 7863 7864 7865 7827  (c('xaxbxcxdxex'
+000075f0: 292c 2063 2827 6162 6364 6527 292c 206d  ), c('abcde'), m
+00007600: 6178 7370 6c69 743d 3229 2c20 6328 5b27  axsplit=2), c(['
+00007610: 7827 2c20 2778 272c 2027 7863 7864 7865  x', 'x', 'xcxdxe
+00007620: 7827 5d29 290a 2020 2020 2020 2020 2020  x'])).          
+00007630: 2020 7365 6c66 2e61 7373 6572 7445 7175    self.assertEqu
+00007640: 616c 286c 6973 745f 6d75 6c74 6973 706c  al(list_multispl
+00007650: 6974 2863 2827 7861 7862 7863 7864 7865  it(c('xaxbxcxdxe
+00007660: 7827 292c 2063 2827 6162 6364 6527 292c  x'), c('abcde'),
+00007670: 206d 6178 7370 6c69 743d 3329 2c20 6328   maxsplit=3), c(
+00007680: 5b27 7827 2c20 2778 272c 2027 7827 2c20  ['x', 'x', 'x', 
+00007690: 2778 6478 6578 275d 2929 0a20 2020 2020  'xdxex'])).     
+000076a0: 2020 2020 2020 2073 656c 662e 6173 7365         self.asse
+000076b0: 7274 4571 7561 6c28 6c69 7374 5f6d 756c  rtEqual(list_mul
+000076c0: 7469 7370 6c69 7428 6328 2778 6178 6278  tisplit(c('xaxbx
+000076d0: 6378 6478 6578 2729 2c20 6328 2761 6263  cxdxex'), c('abc
+000076e0: 6465 2729 2c20 6d61 7873 706c 6974 3d34  de'), maxsplit=4
+000076f0: 292c 2063 285b 2778 272c 2027 7827 2c20  ), c(['x', 'x', 
+00007700: 2778 272c 2027 7827 2c20 2778 6578 275d  'x', 'x', 'xex']
+00007710: 2929 0a20 2020 2020 2020 2020 2020 2073  )).            s
+00007720: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
+00007730: 6c69 7374 5f6d 756c 7469 7370 6c69 7428  list_multisplit(
+00007740: 6328 2778 6178 6278 6378 6478 6578 2729  c('xaxbxcxdxex')
+00007750: 2c20 6328 2761 6263 6465 2729 2c20 6d61  , c('abcde'), ma
+00007760: 7873 706c 6974 3d35 292c 2063 285b 2778  xsplit=5), c(['x
+00007770: 272c 2027 7827 2c20 2778 272c 2027 7827  ', 'x', 'x', 'x'
+00007780: 2c20 2778 272c 2027 7827 5d29 290a 2020  , 'x', 'x'])).  
+00007790: 2020 2020 2020 2020 2020 7365 6c66 2e61            self.a
+000077a0: 7373 6572 7445 7175 616c 286c 6973 745f  ssertEqual(list_
+000077b0: 6d75 6c74 6973 706c 6974 2863 2827 7861  multisplit(c('xa
+000077c0: 7862 7863 7864 7865 7827 292c 2063 2827  xbxcxdxex'), c('
+000077d0: 6162 6364 6527 292c 206d 6178 7370 6c69  abcde'), maxspli
+000077e0: 743d 3629 2c20 6328 5b27 7827 2c20 2778  t=6), c(['x', 'x
+000077f0: 272c 2027 7827 2c20 2778 272c 2027 7827  ', 'x', 'x', 'x'
+00007800: 2c20 2778 275d 2929 0a0a 2020 2020 2020  , 'x']))..      
+00007810: 2020 2020 2020 2320 7465 7374 3a20 6772        # test: gr
+00007820: 6565 6479 2073 6570 6172 6174 6f72 730a  eedy separators.
+00007830: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00007840: 2e61 7373 6572 7445 7175 616c 286c 6973  .assertEqual(lis
+00007850: 745f 6d75 6c74 6973 706c 6974 2863 2827  t_multisplit(c('
+00007860: 2d61 6263 6465 2d61 6263 2d61 2d61 6263  -abcde-abc-a-abc
+00007870: 2d61 6263 6465 2d27 292c 0a20 2020 2020  -abcde-'),.     
+00007880: 2020 2020 2020 2020 2020 2063 285b 0a20             c([. 
+00007890: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000078a0: 2020 2027 6127 2c20 2761 6227 2c20 2761     'a', 'ab', 'a
+000078b0: 6263 272c 2027 6162 6364 272c 2027 6162  bc', 'abcd', 'ab
+000078c0: 6364 6527 2c0a 2020 2020 2020 2020 2020  cde',.          
+000078d0: 2020 2020 2020 2020 2020 2762 272c 2027            'b', '
+000078e0: 6263 272c 2027 6263 6427 2c20 2762 6364  bc', 'bcd', 'bcd
+000078f0: 6527 2c0a 2020 2020 2020 2020 2020 2020  e',.            
+00007900: 2020 2020 2020 2020 2763 272c 2027 6364          'c', 'cd
+00007910: 272c 2027 6364 6527 2c0a 2020 2020 2020  ', 'cde',.      
+00007920: 2020 2020 2020 2020 2020 2020 2020 2764                'd
+00007930: 272c 2027 6465 272c 0a20 2020 2020 2020  ', 'de',.       
+00007940: 2020 2020 2020 2020 2020 2020 2027 6527               'e'
+00007950: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007960: 205d 2929 2c0a 2020 2020 2020 2020 2020   ])),.          
+00007970: 2020 2020 2020 6328 5b27 2d27 2c20 272d        c(['-', '-
+00007980: 272c 2027 2d27 2c20 272d 272c 2027 2d27  ', '-', '-', '-'
+00007990: 2c20 272d 275d 2929 0a20 2020 2020 2020  , '-'])).       
+000079a0: 2020 2020 2023 2067 7265 6564 7920 776f       # greedy wo
+000079b0: 726b 7320 7468 6520 7361 6d65 2077 6865  rks the same whe
+000079c0: 6e20 7265 7665 7273 653d 5472 7565 2c20  n reverse=True, 
+000079d0: 6576 656e 2069 6620 6974 206d 6179 6265  even if it maybe
+000079e0: 2066 6565 6c73 2061 206c 6974 746c 6520   feels a little 
+000079f0: 7374 7261 6e67 650a 2020 2020 2020 2020  strange.        
+00007a00: 2020 2020 7365 6c66 2e61 7373 6572 7445      self.assertE
+00007a10: 7175 616c 286c 6973 745f 6d75 6c74 6973  qual(list_multis
+00007a20: 706c 6974 2863 2827 2d61 6263 6465 2d61  plit(c('-abcde-a
+00007a30: 6263 2d61 2d61 6263 2d61 6263 6465 2d27  bc-a-abc-abcde-'
+00007a40: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+00007a50: 2020 2063 285b 0a20 2020 2020 2020 2020     c([.         
+00007a60: 2020 2020 2020 2020 2020 2027 6127 2c20             'a', 
+00007a70: 2761 6227 2c20 2761 6263 272c 2027 6162  'ab', 'abc', 'ab
+00007a80: 6364 272c 2027 6162 6364 6527 2c0a 2020  cd', 'abcde',.  
+00007a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007aa0: 2020 2762 272c 2027 6263 272c 2027 6263    'b', 'bc', 'bc
+00007ab0: 6427 2c20 2762 6364 6527 2c0a 2020 2020  d', 'bcde',.    
+00007ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007ad0: 2763 272c 2027 6364 272c 2027 6364 6527  'c', 'cd', 'cde'
+00007ae0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00007af0: 2020 2020 2020 2764 272c 2027 6465 272c        'd', 'de',
+00007b00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007b10: 2020 2020 2027 6527 0a20 2020 2020 2020       'e'.       
+00007b20: 2020 2020 2020 2020 205d 292c 2072 6576           ]), rev
+00007b30: 6572 7365 3d54 7275 6529 2c0a 2020 2020  erse=True),.    
+00007b40: 2020 2020 2020 2020 2020 2020 6328 5b27              c(['
+00007b50: 2d27 2c20 272d 272c 2027 2d27 2c20 272d  -', '-', '-', '-
+00007b60: 272c 2027 2d27 2c20 272d 275d 2929 0a0a  ', '-', '-']))..
+00007b70: 2020 2020 2020 2020 2020 2020 2320 7265              # re
+00007b80: 6772 6573 7369 6f6e 2074 6573 743a 202a  gression test: *
+00007b90: 5945 532a 2c20 6966 2074 6865 2073 7472  YES*, if the str
+00007ba0: 696e 6720 796f 7527 7265 2073 706c 6974  ing you're split
+00007bb0: 7469 6e67 2065 6e64 7320 7769 7468 2061  ting ends with a
+00007bc0: 2073 6570 6172 6174 6f72 2c0a 2020 2020   separator,.    
+00007bd0: 2020 2020 2020 2020 2320 616e 6420 6b65          # and ke
+00007be0: 6570 3d62 6967 2e41 535f 5041 4952 532c  ep=big.AS_PAIRS,
+00007bf0: 2074 6865 2072 6573 756c 7420 656e 6473   the result ends
+00007c00: 2077 6974 6820 6120 7475 706c 6520 636f   with a tuple co
+00007c10: 6e74 6169 6e69 6e67 2074 776f 2065 6d70  ntaining two emp
+00007c20: 7479 2073 7472 696e 6773 2e0a 2020 2020  ty strings..    
+00007c30: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
+00007c40: 6572 7445 7175 616c 286c 6973 745f 6d75  ertEqual(list_mu
+00007c50: 6c74 6973 706c 6974 2863 2827 5c6e 615c  ltisplit(c('\na\
+00007c60: 6e62 5c6e 635c 6e27 292c 2063 2828 275c  nb\nc\n'), c(('\
+00007c70: 6e27 2c29 292c 206b 6565 703d 6269 672e  n',)), keep=big.
+00007c80: 4153 5f50 4149 5253 2c20 7374 7269 703d  AS_PAIRS, strip=
+00007c90: 4661 6c73 6529 2c20 6328 5b20 2827 272c  False), c([ ('',
+00007ca0: 2027 5c6e 2729 2c20 2827 6127 2c20 275c   '\n'), ('a', '\
+00007cb0: 6e27 292c 2028 2762 272c 2027 5c6e 2729  n'), ('b', '\n')
+00007cc0: 2c20 2827 6327 2c20 275c 6e27 292c 2028  , ('c', '\n'), (
+00007cd0: 2727 2c20 2727 2920 5d29 290a 0a20 2020  '', '') ]))..   
+00007ce0: 2020 2020 2020 2020 2023 2074 6573 743a           # test:
+00007cf0: 2070 726f 6772 6573 7369 7665 2073 7472   progressive str
+00007d00: 6970 0a20 2020 2020 2020 2020 2020 2073  ip.            s
+00007d10: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
+00007d20: 6c69 7374 5f6d 756c 7469 7370 6c69 7428  list_multisplit(
+00007d30: 6328 2720 2020 6120 6220 6320 2020 2729  c('   a b c   ')
+00007d40: 2c20 6328 2827 2027 2c29 292c 206d 6178  , c((' ',)), max
+00007d50: 7370 6c69 743d 312c 2073 7472 6970 3d62  split=1, strip=b
+00007d60: 6967 2e50 524f 4752 4553 5349 5645 292c  ig.PROGRESSIVE),
+00007d70: 2063 285b 2027 6127 2c20 2762 2063 2020   c([ 'a', 'b c  
+00007d80: 2027 5d29 290a 0a20 2020 2020 2020 2020   ']))..         
+00007d90: 2020 2023 2072 6567 7265 7373 696f 6e20     # regression 
+00007da0: 7465 7374 3a20 7768 656e 2074 6865 7265  test: when there
+00007db0: 2061 7265 202a 6f76 6572 6c61 7070 696e   are *overlappin
+00007dc0: 672a 2073 6570 6172 6174 6f72 732c 0a20  g* separators,. 
+00007dd0: 2020 2020 2020 2020 2020 2023 206d 756c             # mul
+00007de0: 7469 7370 6c69 7420 7072 6566 6572 7320  tisplit prefers 
+00007df0: 7468 6520 6c65 6674 6d6f 7374 206f 6e65  the leftmost one
+00007e00: 2873 292c 2062 7574 2070 6173 7369 6e67  (s), but passing
+00007e10: 2069 6e0a 2020 2020 2020 2020 2020 2020   in.            
+00007e20: 2320 7265 7665 7273 653d 5472 7565 206d  # reverse=True m
+00007e30: 616b 6573 2069 7420 7072 6566 6572 2074  akes it prefer t
+00007e40: 6865 202a 7269 6768 746d 6f73 742a 206f  he *rightmost* o
+00007e50: 6e65 732e 0a20 2020 2020 2020 2020 2020  nes..           
+00007e60: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
+00007e70: 6c28 6c69 7374 5f6d 756c 7469 7370 6c69  l(list_multispli
+00007e80: 7428 6328 2720 7820 7820 2729 2c20 6328  t(c(' x x '), c(
+00007e90: 2827 2078 2027 2c29 292c 206b 6565 703d  (' x ',)), keep=
+00007ea0: 6269 672e 414c 5445 524e 4154 494e 4729  big.ALTERNATING)
+00007eb0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00007ec0: 2020 6328 5b20 2727 2c20 2720 7820 272c    c([ '', ' x ',
+00007ed0: 2027 7820 275d 2929 0a20 2020 2020 2020   'x '])).       
+00007ee0: 2020 2020 2073 656c 662e 6173 7365 7274       self.assert
+00007ef0: 4571 7561 6c28 6c69 7374 5f6d 756c 7469  Equal(list_multi
+00007f00: 7370 6c69 7428 6328 2720 7820 7820 2729  split(c(' x x ')
+00007f10: 2c20 6328 2827 2078 2027 2c29 292c 206b  , c((' x ',)), k
+00007f20: 6565 703d 6269 672e 414c 5445 524e 4154  eep=big.ALTERNAT
+00007f30: 494e 472c 2072 6576 6572 7365 3d54 7275  ING, reverse=Tru
+00007f40: 6529 2c0a 2020 2020 2020 2020 2020 2020  e),.            
+00007f50: 2020 2020 6328 5b20 2720 7827 2c20 2720      c([ ' x', ' 
+00007f60: 7820 272c 2027 275d 2929 0a0a 2020 2020  x ', '']))..    
+00007f70: 2020 2020 2020 2020 2320 2727 2e73 706c          # ''.spl
+00007f80: 6974 2829 2072 6574 7572 6e73 2061 6e20  it() returns an 
+00007f90: 656d 7074 7920 6c69 7374 2e0a 2020 2020  empty list..    
+00007fa0: 2020 2020 2020 2020 2320 6d75 6c74 6973          # multis
+00007fb0: 706c 6974 2069 6e74 656e 7469 6f6e 616c  plit intentional
+00007fc0: 6c79 2064 6f65 7320 2a6e 6f74 2a20 7265  ly does *not* re
+00007fd0: 7072 6f64 7563 6520 7468 6973 2069 6c6c  produce this ill
+00007fe0: 2d63 6f6e 6369 6576 6564 2062 6568 6176  -concieved behav
+00007ff0: 696f 722e 0a20 2020 2020 2020 2020 2020  ior..           
+00008000: 2023 206d 756c 7469 7370 6c69 7428 732c   # multisplit(s,
+00008010: 206c 6973 742d 6f66 2d73 6570 6172 6174   list-of-separat
+00008020: 6f72 732d 7468 6174 2d64 6f6e 2774 2d61  ors-that-don't-a
+00008030: 7070 6561 722d 696e 2d73 2920 616c 7761  ppear-in-s) alwa
+00008040: 7973 2072 6574 7572 6e73 205b 735d 2e0a  ys returns [s]..
+00008050: 2020 2020 2020 2020 2020 2020 2320 286f              # (o
+00008060: 722c 2072 6174 6865 722c 2061 6e20 6974  r, rather, an it
+00008070: 6572 6174 6f72 2074 6861 7420 7969 656c  erator that yiel
+00008080: 6473 206f 6e6c 7920 7329 2e0a 2020 2020  ds only s)..    
+00008090: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
+000080a0: 6572 7445 7175 616c 286c 6973 745f 6d75  ertEqual(list_mu
+000080b0: 6c74 6973 706c 6974 2863 2827 2729 292c  ltisplit(c('')),
+000080c0: 2063 285b 2727 5d29 290a 2020 2020 2020   c([''])).      
+000080d0: 2020 2020 2020 7365 6c66 2e61 7373 6572        self.asser
+000080e0: 7445 7175 616c 286c 6973 745f 6d75 6c74  tEqual(list_mult
+000080f0: 6973 706c 6974 2863 2827 2729 2c20 7265  isplit(c(''), re
+00008100: 7665 7273 653d 5472 7565 292c 2063 285b  verse=True), c([
+00008110: 2727 5d29 290a 2020 2020 2020 2020 2020  ''])).          
+00008120: 2020 2320 7369 6d69 6c61 726c 792c 2027    # similarly, '
+00008130: 2020 2020 272e 7370 6c69 7428 2920 616c      '.split() al
+00008140: 736f 2072 6574 7572 6e73 2061 6e20 656d  so returns an em
+00008150: 7074 7920 6c69 7374 2c0a 2020 2020 2020  pty list,.      
+00008160: 2020 2020 2020 2320 616e 6420 6d75 6c74        # and mult
+00008170: 6973 706c 6974 2064 6f65 7320 6e6f 742e  isplit does not.
+00008180: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00008190: 662e 6173 7365 7274 4571 7561 6c28 6c69  f.assertEqual(li
+000081a0: 7374 5f6d 756c 7469 7370 6c69 7428 6328  st_multisplit(c(
+000081b0: 2720 2020 2729 292c 2063 285b 2727 2c20  '   ')), c(['', 
+000081c0: 2727 5d29 290a 2020 2020 2020 2020 2020  ''])).          
+000081d0: 2020 7365 6c66 2e61 7373 6572 7445 7175    self.assertEqu
+000081e0: 616c 286c 6973 745f 6d75 6c74 6973 706c  al(list_multispl
+000081f0: 6974 2863 2827 2020 2027 292c 2072 6576  it(c('   '), rev
+00008200: 6572 7365 3d54 7275 6529 2c20 6328 5b27  erse=True), c(['
+00008210: 272c 2027 275d 2929 0a20 2020 2020 2020  ', ''])).       
+00008220: 2020 2020 2073 656c 662e 6173 7365 7274       self.assert
+00008230: 4571 7561 6c28 6c69 7374 5f6d 756c 7469  Equal(list_multi
+00008240: 7370 6c69 7428 6328 2720 2020 2729 2c20  split(c('   '), 
+00008250: 7374 7269 703d 5472 7565 292c 2063 285b  strip=True), c([
+00008260: 2727 5d29 290a 2020 2020 2020 2020 2020  ''])).          
+00008270: 2020 7365 6c66 2e61 7373 6572 7445 7175    self.assertEqu
+00008280: 616c 286c 6973 745f 6d75 6c74 6973 706c  al(list_multispl
+00008290: 6974 2863 2827 2020 2027 292c 2073 7472  it(c('   '), str
+000082a0: 6970 3d54 7275 652c 2072 6576 6572 7365  ip=True, reverse
+000082b0: 3d54 7275 6529 2c20 6328 5b27 275d 2929  =True), c(['']))
+000082c0: 0a0a 2020 2020 2020 2020 2020 2020 7769  ..            wi
+000082d0: 7468 2073 656c 662e 6173 7365 7274 5261  th self.assertRa
+000082e0: 6973 6573 2854 7970 6545 7272 6f72 293a  ises(TypeError):
+000082f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008300: 206c 6973 745f 6d75 6c74 6973 706c 6974   list_multisplit
+00008310: 2863 2827 7327 292c 2033 2e31 3431 3529  (c('s'), 3.1415)
+00008320: 0a20 2020 2020 2020 2020 2020 2077 6974  .            wit
+00008330: 6820 7365 6c66 2e61 7373 6572 7452 6169  h self.assertRai
+00008340: 7365 7328 5661 6c75 6545 7272 6f72 293a  ses(ValueError):
+00008350: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008360: 206c 6973 745f 6d75 6c74 6973 706c 6974   list_multisplit
+00008370: 2863 2827 7327 292c 205b 5d29 0a20 2020  (c('s'), []).   
+00008380: 2020 2020 2020 2020 2077 6974 6820 7365           with se
+00008390: 6c66 2e61 7373 6572 7452 6169 7365 7328  lf.assertRaises(
+000083a0: 5661 6c75 6545 7272 6f72 293a 0a20 2020  ValueError):.   
+000083b0: 2020 2020 2020 2020 2020 2020 206c 6973               lis
+000083c0: 745f 6d75 6c74 6973 706c 6974 2863 2827  t_multisplit(c('
+000083d0: 7327 292c 2028 2929 0a20 2020 2020 2020  s'), ()).       
+000083e0: 2020 2020 2077 6974 6820 7365 6c66 2e61       with self.a
+000083f0: 7373 6572 7452 6169 7365 7328 5479 7065  ssertRaises(Type
+00008400: 4572 726f 7229 3a0a 2020 2020 2020 2020  Error):.        
+00008410: 2020 2020 2020 2020 6c69 7374 5f6d 756c          list_mul
+00008420: 7469 7370 6c69 7428 6328 2773 2729 2c20  tisplit(c('s'), 
+00008430: 6e6f 745f 6328 2727 2929 0a20 2020 2020  not_c('')).     
+00008440: 2020 2020 2020 2077 6974 6820 7365 6c66         with self
+00008450: 2e61 7373 6572 7452 6169 7365 7328 5479  .assertRaises(Ty
+00008460: 7065 4572 726f 7229 3a0a 2020 2020 2020  peError):.      
+00008470: 2020 2020 2020 2020 2020 6c69 7374 5f6d            list_m
+00008480: 756c 7469 7370 6c69 7428 6328 2773 2729  ultisplit(c('s')
+00008490: 2c20 5b63 2827 6127 292c 206e 6f74 5f63  , [c('a'), not_c
+000084a0: 2827 6227 292c 2063 2827 6327 295d 290a  ('b'), c('c')]).
+000084b0: 2020 2020 2020 2020 2020 2020 7769 7468              with
+000084c0: 2073 656c 662e 6173 7365 7274 5261 6973   self.assertRais
+000084d0: 6573 2854 7970 6545 7272 6f72 293a 0a20  es(TypeError):. 
+000084e0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+000084f0: 6973 745f 6d75 6c74 6973 706c 6974 2863  ist_multisplit(c
+00008500: 2827 7327 292c 205b 6328 2761 2729 2c20  ('s'), [c('a'), 
+00008510: 3132 3334 2c20 6328 2763 2729 5d29 0a0a  1234, c('c')])..
+00008520: 2020 2020 2020 2020 666f 7220 7374 725f          for str_
+00008530: 7479 7065 5f31 2069 6e20 2873 7472 2c20  type_1 in (str, 
+00008540: 5374 7253 7562 636c 6173 732c 2044 6966  StrSubclass, Dif
+00008550: 6665 7265 6e74 5374 7253 7562 636c 6173  ferentStrSubclas
+00008560: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
+00008570: 666f 7220 7374 725f 7479 7065 5f32 2069  for str_type_2 i
+00008580: 6e20 2873 7472 2c20 5374 7253 7562 636c  n (str, StrSubcl
+00008590: 6173 732c 2044 6966 6665 7265 6e74 5374  ass, DifferentSt
+000085a0: 7253 7562 636c 6173 7329 3a0a 2020 2020  rSubclass):.    
+000085b0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+000085c0: 2e61 7373 6572 7445 7175 616c 286c 6973  .assertEqual(lis
+000085d0: 745f 6d75 6c74 6973 706c 6974 2873 7472  t_multisplit(str
+000085e0: 5f74 7970 655f 3128 2761 6263 6465 2729  _type_1('abcde')
+000085f0: 2c20 7374 725f 7479 7065 5f32 2827 6327  , str_type_2('c'
+00008600: 2929 2c20 5b27 6162 272c 2027 6465 275d  )), ['ab', 'de']
+00008610: 290a 0a20 2020 2020 2020 2066 6f72 2062  )..        for b
+00008620: 7974 6573 5f74 7970 655f 3120 696e 2028  ytes_type_1 in (
+00008630: 6279 7465 732c 2042 7974 6573 5375 6263  bytes, BytesSubc
+00008640: 6c61 7373 2c20 4469 6666 6572 656e 7442  lass, DifferentB
+00008650: 7974 6573 5375 6263 6c61 7373 293a 0a20  ytesSubclass):. 
+00008660: 2020 2020 2020 2020 2020 2066 6f72 2062             for b
+00008670: 7974 6573 5f74 7970 655f 3220 696e 2028  ytes_type_2 in (
+00008680: 6279 7465 732c 2042 7974 6573 5375 6263  bytes, BytesSubc
+00008690: 6c61 7373 2c20 4469 6666 6572 656e 7442  lass, DifferentB
+000086a0: 7974 6573 5375 6263 6c61 7373 293a 0a20  ytesSubclass):. 
+000086b0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+000086c0: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
+000086d0: 6c69 7374 5f6d 756c 7469 7370 6c69 7428  list_multisplit(
+000086e0: 6279 7465 735f 7479 7065 5f31 2862 2761  bytes_type_1(b'a
+000086f0: 6263 6465 2729 2c20 6279 7465 735f 7479  bcde'), bytes_ty
+00008700: 7065 5f32 2862 2763 2729 292c 205b 6227  pe_2(b'c')), [b'
+00008710: 6162 272c 2062 2764 6527 5d29 0a0a 2020  ab', b'de'])..  
+00008720: 2020 2020 2020 666f 7220 7374 725f 7479        for str_ty
+00008730: 7065 2069 6e20 2873 7472 2c20 5374 7253  pe in (str, StrS
+00008740: 7562 636c 6173 732c 2044 6966 6665 7265  ubclass, Differe
+00008750: 6e74 5374 7253 7562 636c 6173 7329 3a0a  ntStrSubclass):.
+00008760: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+00008770: 6279 7465 735f 7479 7065 2069 6e20 2862  bytes_type in (b
+00008780: 7974 6573 2c20 4279 7465 7353 7562 636c  ytes, BytesSubcl
+00008790: 6173 732c 2044 6966 6665 7265 6e74 4279  ass, DifferentBy
+000087a0: 7465 7353 7562 636c 6173 7329 3a0a 2020  tesSubclass):.  
+000087b0: 2020 2020 2020 2020 2020 2020 2020 7769                wi
+000087c0: 7468 2073 656c 662e 6173 7365 7274 5261  th self.assertRa
+000087d0: 6973 6573 2854 7970 6545 7272 6f72 293a  ises(TypeError):
+000087e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000087f0: 2020 2020 206c 6973 745f 6d75 6c74 6973       list_multis
+00008800: 706c 6974 2873 7472 5f74 7970 6528 2773  plit(str_type('s
+00008810: 2729 2c20 6279 7465 735f 7479 7065 2862  '), bytes_type(b
+00008820: 2761 6263 2729 290a 2020 2020 2020 2020  'abc')).        
+00008830: 2020 2020 2020 2020 7769 7468 2073 656c          with sel
+00008840: 662e 6173 7365 7274 5261 6973 6573 2854  f.assertRaises(T
+00008850: 7970 6545 7272 6f72 293a 0a20 2020 2020  ypeError):.     
+00008860: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+00008870: 6973 745f 6d75 6c74 6973 706c 6974 2862  ist_multisplit(b
+00008880: 7974 6573 5f74 7970 6528 6227 7327 292c  ytes_type(b's'),
+00008890: 2073 7472 5f74 7970 6528 2761 6263 2729   str_type('abc')
+000088a0: 290a 0a20 2020 2020 2020 2020 2020 2020  )..             
+000088b0: 2020 2023 206a 7573 7420 6d61 6b69 6e67     # just making
+000088c0: 2073 7572 6521 0a20 2020 2020 2020 2020   sure!.         
+000088d0: 2020 2020 2020 2077 6974 6820 7365 6c66         with self
+000088e0: 2e61 7373 6572 7452 6169 7365 7328 5479  .assertRaises(Ty
+000088f0: 7065 4572 726f 7229 3a0a 2020 2020 2020  peError):.      
+00008900: 2020 2020 2020 2020 2020 2020 2020 6c69                li
+00008910: 7374 5f6d 756c 7469 7370 6c69 7428 7374  st_multisplit(st
+00008920: 725f 7479 7065 2827 7327 292c 205b 7374  r_type('s'), [st
+00008930: 725f 7479 7065 2827 6127 292c 2062 7974  r_type('a'), byt
+00008940: 6573 5f74 7970 6528 6227 6227 292c 2073  es_type(b'b'), s
+00008950: 7472 5f74 7970 6528 2763 2729 5d29 0a20  tr_type('c')]). 
+00008960: 2020 2020 2020 2020 2020 2020 2020 2077                 w
+00008970: 6974 6820 7365 6c66 2e61 7373 6572 7452  ith self.assertR
+00008980: 6169 7365 7328 5479 7065 4572 726f 7229  aises(TypeError)
+00008990: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000089a0: 2020 2020 2020 6c69 7374 5f6d 756c 7469        list_multi
+000089b0: 7370 6c69 7428 6279 7465 735f 7479 7065  split(bytes_type
+000089c0: 2862 2773 2729 2c20 5b62 7974 6573 5f74  (b's'), [bytes_t
+000089d0: 7970 6528 6227 6127 292c 2073 7472 5f74  ype(b'a'), str_t
+000089e0: 7970 6528 2762 2729 2c20 6279 7465 735f  ype('b'), bytes_
+000089f0: 7479 7065 2862 2763 2729 5d29 0a0a 2020  type(b'c')])..  
+00008a00: 2020 2020 2020 2320 7265 6772 6573 7369        # regressi
+00008a10: 6f6e 3a20 6d75 6c74 6973 706c 6974 2064  on: multisplit d
+00008a20: 6964 6e27 7420 7573 6564 2074 6f20 7665  idn't used to ve
+00008a30: 7269 6679 0a20 2020 2020 2020 2023 2074  rify.        # t
+00008a40: 6861 7420 7320 7761 7320 6569 7468 6572  hat s was either
+00008a50: 2073 7472 206f 7220 6279 7465 732e 0a20   str or bytes.. 
+00008a60: 2020 2020 2020 2077 6974 6820 7365 6c66         with self
+00008a70: 2e61 7373 6572 7452 6169 7365 7328 5479  .assertRaises(Ty
+00008a80: 7065 4572 726f 7229 3a0a 2020 2020 2020  peError):.      
+00008a90: 2020 2020 2020 6c69 7374 5f6d 756c 7469        list_multi
+00008aa0: 7370 6c69 7428 332e 3134 3135 290a 2020  split(3.1415).  
+00008ab0: 2020 2020 2020 7769 7468 2073 656c 662e        with self.
+00008ac0: 6173 7365 7274 5261 6973 6573 2854 7970  assertRaises(Typ
+00008ad0: 6545 7272 6f72 293a 0a20 2020 2020 2020  eError):.       
+00008ae0: 2020 2020 206c 6973 745f 6d75 6c74 6973       list_multis
+00008af0: 706c 6974 2833 2e31 3431 352c 2027 6162  plit(3.1415, 'ab
+00008b00: 6327 290a 2020 2020 2020 2020 7769 7468  c').        with
+00008b10: 2073 656c 662e 6173 7365 7274 5261 6973   self.assertRais
+00008b20: 6573 2854 7970 6545 7272 6f72 293a 0a20  es(TypeError):. 
+00008b30: 2020 2020 2020 2020 2020 206c 6973 745f             list_
+00008b40: 6d75 6c74 6973 706c 6974 285b 2761 272c  multisplit(['a',
+00008b50: 2027 6227 2c20 2763 275d 290a 2020 2020   'b', 'c']).    
+00008b60: 2020 2020 7769 7468 2073 656c 662e 6173      with self.as
+00008b70: 7365 7274 5261 6973 6573 2854 7970 6545  sertRaises(TypeE
+00008b80: 7272 6f72 293a 0a20 2020 2020 2020 2020  rror):.         
+00008b90: 2020 206c 6973 745f 6d75 6c74 6973 706c     list_multispl
+00008ba0: 6974 285b 2761 272c 2027 6227 2c20 2763  it(['a', 'b', 'c
+00008bb0: 275d 2c20 2761 2729 0a0a 2020 2020 2020  '], 'a')..      
+00008bc0: 2020 2320 7265 6772 6573 7369 6f6e 3a20    # regression: 
+00008bd0: 6966 2072 6576 6572 7365 3d54 7275 6520  if reverse=True 
+00008be0: 616e 6420 7365 7061 7261 746f 7273 2077  and separators w
+00008bf0: 6173 206e 6f74 2068 6173 6861 626c 652c  as not hashable,
+00008c00: 0a20 2020 2020 2020 2023 206d 756c 7469  .        # multi
+00008c10: 7370 6c69 7420 776f 756c 6420 6372 6173  split would cras
+00008c20: 682e 2020 6669 7865 6420 696e 2030 2e36  h.  fixed in 0.6
+00008c30: 2e31 372e 0a20 2020 2020 2020 2073 656c  .17..        sel
+00008c40: 662e 6173 7365 7274 4571 7561 6c28 6c69  f.assertEqual(li
+00008c50: 7374 5f6d 756c 7469 7370 6c69 7428 2761  st_multisplit('a
+00008c60: 7862 7963 7a64 272c 205b 2778 272c 2027  xbyczd', ['x', '
+00008c70: 7927 2c20 277a 275d 2c20 6d61 7873 706c  y', 'z'], maxspl
+00008c80: 6974 3d32 2c20 7265 7665 7273 653d 5472  it=2, reverse=Tr
+00008c90: 7565 292c 205b 2761 7862 272c 2027 6327  ue), ['axb', 'c'
+00008ca0: 2c20 2764 275d 290a 2020 2020 2020 2020  , 'd']).        
+00008cb0: 7365 6c66 2e61 7373 6572 7445 7175 616c  self.assertEqual
+00008cc0: 286c 6973 745f 6d75 6c74 6973 706c 6974  (list_multisplit
+00008cd0: 2862 2761 7862 7963 7a64 272c 205b 6227  (b'axbyczd', [b'
+00008ce0: 7827 2c20 6227 7927 2c20 6227 7a27 5d2c  x', b'y', b'z'],
+00008cf0: 206d 6178 7370 6c69 743d 322c 2072 6576   maxsplit=2, rev
+00008d00: 6572 7365 3d54 7275 6529 2c20 5b62 2761  erse=True), [b'a
+00008d10: 7862 272c 2062 2763 272c 2062 2764 275d  xb', b'c', b'd']
+00008d20: 290a 0a20 2020 2064 6566 2074 6573 745f  )..    def test_
+00008d30: 6164 7661 6e63 6564 5f6d 756c 7469 7370  advanced_multisp
+00008d40: 6c69 7428 7365 6c66 293a 0a20 2020 2020  lit(self):.     
+00008d50: 2020 2064 6566 2073 696d 706c 655f 7465     def simple_te
+00008d60: 7374 5f6d 756c 7469 7370 6c69 7428 732c  st_multisplit(s,
+00008d70: 2073 6570 6172 6174 6f72 732c 2065 7870   separators, exp
+00008d80: 6563 7465 642c 202a 2a6b 7761 7267 7329  ected, **kwargs)
+00008d90: 3a0a 2020 2020 2020 2020 2020 2020 666f  :.            fo
+00008da0: 7220 5f20 696e 2072 616e 6765 2832 293a  r _ in range(2):
+00008db0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008dc0: 2069 6620 5f20 3d3d 2031 3a0a 2020 2020   if _ == 1:.    
+00008dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008de0: 2320 656e 636f 6465 210a 2020 2020 2020  # encode!.      
+00008df0: 2020 2020 2020 2020 2020 2020 2020 7320                s 
+00008e00: 3d20 732e 656e 636f 6465 2827 6173 6369  = s.encode('asci
+00008e10: 6927 290a 2020 2020 2020 2020 2020 2020  i').            
+00008e20: 2020 2020 2020 2020 6966 2073 6570 6172          if separ
+00008e30: 6174 6f72 7320 3d3d 2062 6967 2e77 6869  ators == big.whi
+00008e40: 7465 7370 6163 653a 0a20 2020 2020 2020  tespace:.       
+00008e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008e60: 2073 6570 6172 6174 6f72 7320 3d20 6269   separators = bi
+00008e70: 672e 6173 6369 695f 7768 6974 6573 7061  g.ascii_whitespa
+00008e80: 6365 0a20 2020 2020 2020 2020 2020 2020  ce.             
+00008e90: 2020 2020 2020 2065 6c69 6620 7365 7061         elif sepa
+00008ea0: 7261 746f 7273 203d 3d20 6269 672e 6e65  rators == big.ne
+00008eb0: 776c 696e 6573 3a0a 2020 2020 2020 2020  wlines:.        
 00008ec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008ed0: 2073 6570 6172 6174 655f 7472 6169 6c69   separate_traili
-00008ee0: 6e67 2e61 7070 656e 6428 7329 0a20 2020  ng.append(s).   
+00008ed0: 7365 7061 7261 746f 7273 203d 2062 6967  separators = big
+00008ee0: 2e61 7363 6969 5f6e 6577 6c69 6e65 730a  .ascii_newlines.
 00008ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008f10: 2020 2020 2073 6570 6172 6174 655f 7472       separate_tr
-00008f20: 6169 6c69 6e67 2e61 7070 656e 6428 656d  ailing.append(em
-00008f30: 7074 7929 0a20 2020 2020 2020 2020 2020  pty).           
-00008f40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008f50: 2020 2020 2074 7261 696c 696e 6720 3d20       trailing = 
-00008f60: 7365 7061 7261 7465 5f74 7261 696c 696e  separate_trailin
-00008f70: 670a 2020 2020 2020 2020 2020 2020 2020  g.              
-00008f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008f90: 2020 6966 2077 616e 745f 7072 696e 7473    if want_prints
-00008fa0: 3a20 2320 7072 6167 6d61 3a20 6e6f 2063  : # pragma: no c
-00008fb0: 6f76 6572 0a20 2020 2020 2020 2020 2020  over.           
-00008fc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008fd0: 2020 2020 2020 2020 2070 7269 6e74 2866           print(f
-00008fe0: 2220 2020 2074 7261 696c 696e 673d 7b74  "    trailing={t
-00008ff0: 7261 696c 696e 677d 2229 0a0a 2020 2020  railing}")..    
-00009000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009010: 2020 2020 2020 2020 2320 7469 6d65 2074          # time t
-00009020: 6f20 6368 6563 6b21 2020 6576 6572 7920  o check!  every 
-00009030: 6c69 7374 206f 7220 7375 626c 6973 740a  list or sublist.
-00009040: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009050: 2020 2020 2020 2020 2020 2020 2320 7368              # sh
-00009060: 6f75 6c64 206e 6f77 2068 6176 6520 616e  ould now have an
-00009070: 2065 7665 6e20 6c65 6e67 7468 2c0a 2020   even length,.  
-00009080: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009090: 2020 2020 2020 2020 2020 2320 4558 4345            # EXCE
-000090a0: 5054 2073 706c 6974 735b 2d31 5d20 7768  PT splits[-1] wh
-000090b0: 6963 6820 6973 206c 656e 6774 6820 312e  ich is length 1.
-000090c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000090d0: 2020 2020 2020 2020 2020 2020 2061 7373               ass
-000090e0: 6572 7420 6c65 6e28 6c65 6164 696e 6729  ert len(leading)
-000090f0: 2025 2032 203d 3d20 300a 2020 2020 2020   % 2 == 0.      
-00009100: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009110: 2020 2020 2020 666f 7220 7370 6c69 7420        for split 
-00009120: 696e 2073 706c 6974 735b 3a2d 315d 3a0a  in splits[:-1]:.
-00009130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009140: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009150: 6173 7365 7274 206c 656e 2873 706c 6974  assert len(split
-00009160: 2920 2520 3220 3d3d 2030 0a20 2020 2020  ) % 2 == 0.     
-00009170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009180: 2020 2020 2020 2061 7373 6572 7420 6c65         assert le
-00009190: 6e28 7370 6c69 7473 5b2d 315d 2920 3d3d  n(splits[-1]) ==
-000091a0: 2031 0a20 2020 2020 2020 2020 2020 2020   1.             
-000091b0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-000091c0: 7373 6572 7420 6c65 6e28 7472 6169 6c69  ssert len(traili
-000091d0: 6e67 2920 2520 3220 3d3d 2030 0a0a 2020  ng) % 2 == 0..  
-000091e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000091f0: 2020 2020 2020 2020 2020 666f 7220 7374            for st
-00009200: 7269 7020 696e 2028 4661 6c73 652c 2062  rip in (False, b
-00009210: 6967 2e4c 4546 542c 2062 6967 2e52 4947  ig.LEFT, big.RIG
-00009220: 4854 2c20 5472 7565 293a 0a20 2020 2020  HT, True):.     
-00009230: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009240: 2020 2020 2020 2020 2020 2065 7870 6563             expec
-00009250: 7465 6420 3d20 5b5d 0a20 2020 2020 2020  ted = [].       
-00009260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009270: 2020 2020 2020 2020 2069 6620 7761 6e74           if want
-00009280: 5f70 7269 6e74 733a 2023 2070 7261 676d  _prints: # pragm
-00009290: 613a 206e 6f20 636f 7665 720a 2020 2020  a: no cover.    
-000092a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000092b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000092c0: 7072 696e 7428 6622 5b6c 6f6f 7020 345d  print(f"[loop 4]
-000092d0: 2073 7472 6970 3d7b 7374 7269 707d 2229   strip={strip}")
-000092e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000092f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009300: 2020 2020 2070 7269 6e74 2866 2220 2020       print(f"   
-00009310: 2020 2020 2020 6c65 6164 696e 673d 7b6c        leading={l
-00009320: 6561 6469 6e67 7d20 7370 6c69 7473 3d7b  eading} splits={
-00009330: 7370 6c69 7473 7d20 7472 6169 6c69 6e67  splits} trailing
-00009340: 3d7b 7472 6169 6c69 6e67 7d22 290a 0a20  ={trailing}").. 
-00009350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009360: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00009370: 6620 7573 655f 6c65 6164 696e 6720 616e  f use_leading an
-00009380: 6420 2873 7472 6970 2069 6e20 2846 616c  d (strip in (Fal
-00009390: 7365 2c20 6269 672e 5249 4748 5429 293a  se, big.RIGHT)):
-000093a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000093b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000093c0: 2020 2020 2065 7870 6563 7465 642e 6578       expected.ex
-000093d0: 7465 6e64 286c 6561 6469 6e67 290a 2020  tend(leading).  
-000093e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000093f0: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00009400: 2077 616e 745f 7072 696e 7473 3a20 2320   want_prints: # 
-00009410: 7072 6167 6d61 3a20 6e6f 2063 6f76 6572  pragma: no cover
-00009420: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00009430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009440: 2020 2020 2070 7269 6e74 2866 2220 2020       print(f"   
-00009450: 2020 6c65 6164 696e 673a 2065 7870 6563    leading: expec
-00009460: 7465 643d 7b65 7870 6563 7465 647d 2229  ted={expected}")
-00009470: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00009480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009490: 2020 666f 7220 7370 6c69 7420 696e 2073    for split in s
-000094a0: 706c 6974 733a 0a20 2020 2020 2020 2020  plits:.         
-000094b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000094c0: 2020 2020 2020 2020 2020 2065 7870 6563             expec
-000094d0: 7465 642e 6578 7465 6e64 2873 706c 6974  ted.extend(split
-000094e0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-000094f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009500: 2020 6966 2077 616e 745f 7072 696e 7473    if want_prints
-00009510: 3a20 2320 7072 6167 6d61 3a20 6e6f 2063  : # pragma: no c
-00009520: 6f76 6572 0a20 2020 2020 2020 2020 2020  over.           
-00009530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009540: 2020 2020 2020 2020 2070 7269 6e74 2866           print(f
-00009550: 2220 2020 2020 2073 706c 6974 733a 2065  "      splits: e
-00009560: 7870 6563 7465 643d 7b65 7870 6563 7465  xpected={expecte
-00009570: 647d 2229 0a0a 2020 2020 2020 2020 2020  d}")..          
-00009580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009590: 2020 2020 2020 6966 2075 7365 5f74 7261        if use_tra
-000095a0: 696c 696e 6720 616e 6420 2873 7472 6970  iling and (strip
-000095b0: 2069 6e20 2846 616c 7365 2c20 6269 672e   in (False, big.
-000095c0: 4c45 4654 2929 3a0a 2020 2020 2020 2020  LEFT)):.        
-000095d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000095e0: 2020 2020 2020 2020 2020 2020 6578 7065              expe
-000095f0: 6374 6564 2e65 7874 656e 6428 7472 6169  cted.extend(trai
-00009600: 6c69 6e67 290a 2020 2020 2020 2020 2020  ling).          
-00009610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009620: 2020 2020 2020 6966 2077 616e 745f 7072        if want_pr
-00009630: 696e 7473 3a20 2320 7072 6167 6d61 3a20  ints: # pragma: 
-00009640: 6e6f 2063 6f76 6572 0a20 2020 2020 2020  no cover.       
-00009650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009660: 2020 2020 2020 2020 2020 2020 2070 7269               pri
-00009670: 6e74 2866 2220 2020 2074 7261 696c 696e  nt(f"    trailin
-00009680: 673a 2065 7870 6563 7465 643d 7b65 7870  g: expected={exp
-00009690: 6563 7465 647d 2229 0a0a 2020 2020 2020  ected}")..      
-000096a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000096b0: 2020 2020 2020 2020 2020 2320 6578 7065            # expe
-000096c0: 6374 6564 206e 6f77 206c 6f6f 6b73 206c  cted now looks l
-000096d0: 696b 6520 7468 6973 3a0a 2020 2020 2020  ike this:.      
-000096e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000096f0: 2020 2020 2020 2020 2020 2320 2020 2a20            #   * 
-00009700: 6974 2068 6173 2061 6e20 6f64 6420 6e75  it has an odd nu
-00009710: 6d62 6572 206f 6620 6974 656d 730a 2020  mber of items.  
-00009720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009730: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-00009740: 2020 2a20 6576 656e 206e 756d 6265 7265    * even numbere
-00009750: 6420 6974 656d 7320 6172 6520 6e6f 6e73  d items are nons
-00009760: 6570 0a20 2020 2020 2020 2020 2020 2020  ep.             
-00009770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009780: 2020 2023 2020 202a 206f 6464 206e 756d     #   * odd num
-00009790: 6265 7265 6420 6974 656d 7320 6172 6520  bered items are 
-000097a0: 7365 700a 2020 2020 2020 2020 2020 2020  sep.            
-000097b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000097c0: 2020 2020 6173 7365 7274 206c 656e 2865      assert len(e
-000097d0: 7870 6563 7465 6429 2025 2032 203d 3d20  xpected) % 2 == 
-000097e0: 312c 2066 2265 7870 6563 7465 643d 7b65  1, f"expected={e
-000097f0: 7870 6563 7465 647d 2064 6f65 736e 2774  xpected} doesn't
-00009800: 2068 6176 6520 616e 206f 6464 2023 206f   have an odd # o
-00009810: 6620 656c 656d 656e 7473 2122 0a20 2020  f elements!".   
-00009820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009830: 2020 2020 2020 2020 2020 2020 2066 6f72               for
-00009840: 2069 2069 6e20 7261 6e67 6528 302c 206c   i in range(0, l
-00009850: 656e 2865 7870 6563 7465 6429 2c20 3229  en(expected), 2)
-00009860: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00009870: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009880: 2020 2020 2020 6173 7365 7274 2065 7870        assert exp
-00009890: 6563 7465 645b 695d 206e 6f74 2069 6e20  ected[i] not in 
-000098a0: 7365 7061 7261 746f 7273 5f73 6574 0a20  separators_set. 
-000098b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000098c0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-000098d0: 6f72 2069 2069 6e20 7261 6e67 6528 312c  or i in range(1,
-000098e0: 206c 656e 2865 7870 6563 7465 6429 2c20   len(expected), 
-000098f0: 3229 3a0a 2020 2020 2020 2020 2020 2020  2):.            
-00009900: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009910: 2020 2020 2020 2020 6173 7365 7274 206e          assert n
-00009920: 6f74 2062 6967 2e6d 756c 7469 7374 7269  ot big.multistri
-00009930: 7028 6578 7065 6374 6564 5b69 5d2c 2073  p(expected[i], s
-00009940: 6570 6172 6174 6f72 735f 7365 7429 2c20  eparators_set), 
-00009950: 6622 6578 7065 6374 6564 5b7b 697d 5d3d  f"expected[{i}]=
-00009960: 7b65 7870 6563 7465 645b 695d 2172 7d20  {expected[i]!r} 
-00009970: 6e6f 7420 696e 2073 6570 6172 6174 6f72  not in separator
-00009980: 735f 7365 743d 7b73 6570 6172 6174 6f72  s_set={separator
-00009990: 735f 7365 747d 2021 220a 0a20 2020 2020  s_set} !"..     
-000099a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000099b0: 2020 2020 2020 2020 2020 2023 2068 6f77             # how
-000099c0: 206d 616e 7920 7370 6c69 7473 2063 616e   many splits can
-000099d0: 2077 6520 6861 7665 3f0a 2020 2020 2020   we have?.      
-000099e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000099f0: 2020 2020 2020 2020 2020 2320 5465 6368            # Tech
-00009a00: 6e69 6361 6c6c 7920 7468 6520 6d61 7869  nically the maxi
-00009a10: 6d75 6d20 6e75 6d62 6572 206f 6620 7370  mum number of sp
-00009a20: 6c69 7473 2070 6f73 7369 626c 650a 2020  lits possible.  
-00009a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009a40: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-00009a50: 6973 0a20 2020 2020 2020 2020 2020 2020  is.             
+00008f00: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00008f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008f20: 2020 7365 7061 7261 746f 7273 203d 2074    separators = t
+00008f30: 6f5f 6279 7465 7328 7365 7061 7261 746f  o_bytes(separato
+00008f40: 7273 290a 2020 2020 2020 2020 2020 2020  rs).            
+00008f50: 2020 2020 2020 2020 6578 7065 6374 6564          expected
+00008f60: 203d 2074 6f5f 6279 7465 7328 6578 7065   = to_bytes(expe
+00008f70: 6374 6564 290a 2020 2020 2020 2020 2020  cted).          
+00008f80: 2020 2020 2020 2320 7072 696e 7428 290a        # print().
+00008f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008fa0: 2320 7072 696e 7428 6622 733d 7b73 7d20  # print(f"s={s} 
+00008fb0: 6578 7065 6374 6564 3d7b 6578 7065 6374  expected={expect
+00008fc0: 6564 7d5c 6e73 6570 6172 6174 6f72 733d  ed}\nseparators=
+00008fd0: 7b73 6570 6172 6174 6f72 737d 2229 0a20  {separators}"). 
+00008fe0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00008ff0: 6573 756c 7420 3d20 6c69 7374 2862 6967  esult = list(big
+00009000: 2e6d 756c 7469 7370 6c69 7428 732c 2073  .multisplit(s, s
+00009010: 6570 6172 6174 6f72 732c 202a 2a6b 7761  eparators, **kwa
+00009020: 7267 7329 290a 2020 2020 2020 2020 2020  rgs)).          
+00009030: 2020 2020 2020 7365 6c66 2e61 7373 6572        self.asser
+00009040: 7445 7175 616c 2872 6573 756c 742c 2065  tEqual(result, e
+00009050: 7870 6563 7465 6429 0a0a 2020 2020 2020  xpected)..      
+00009060: 2020 666f 7220 6920 696e 2072 616e 6765    for i in range
+00009070: 2838 293a 0a20 2020 2020 2020 2020 2020  (8):.           
+00009080: 2073 7061 6365 7320 3d20 2220 2220 2a20   spaces = " " * 
+00009090: 690a 2020 2020 2020 2020 2020 2020 7369  i.            si
+000090a0: 6d70 6c65 5f74 6573 745f 6d75 6c74 6973  mple_test_multis
+000090b0: 706c 6974 2873 7061 6365 7320 2b20 2261  plit(spaces + "a
+000090c0: 2020 6220 2063 2220 2b20 7370 6163 6573    b  c" + spaces
+000090d0: 2c20 2822 2022 2c29 2c20 5b27 6127 2c20  , (" ",), ['a', 
+000090e0: 2762 272c 2027 6327 5d2c 2073 7472 6970  'b', 'c'], strip
+000090f0: 3d54 7275 6529 0a20 2020 2020 2020 2020  =True).         
+00009100: 2020 2073 696d 706c 655f 7465 7374 5f6d     simple_test_m
+00009110: 756c 7469 7370 6c69 7428 7370 6163 6573  ultisplit(spaces
+00009120: 202b 2022 6120 2062 2020 6322 202b 2073   + "a  b  c" + s
+00009130: 7061 6365 732c 2062 6967 2e77 6869 7465  paces, big.white
+00009140: 7370 6163 652c 205b 2761 272c 2027 6227  space, ['a', 'b'
+00009150: 2c20 2763 275d 2c20 7374 7269 703d 5472  , 'c'], strip=Tr
+00009160: 7565 290a 0a0a 2020 2020 2020 2020 7369  ue)...        si
+00009170: 6d70 6c65 5f74 6573 745f 6d75 6c74 6973  mple_test_multis
+00009180: 706c 6974 2822 6669 7273 7420 6c69 6e65  plit("first line
+00009190: 215c 6e73 6563 6f6e 6420 6c69 6e65 2e5c  !\nsecond line.\
+000091a0: 6e74 6869 7264 206c 696e 652e 222c 2062  nthird line.", b
+000091b0: 6967 2e6e 6577 6c69 6e65 732c 0a20 2020  ig.newlines,.   
+000091c0: 2020 2020 2020 2020 205b 2266 6972 7374           ["first
+000091d0: 206c 696e 6521 222c 2022 7365 636f 6e64   line!", "second
+000091e0: 206c 696e 652e 222c 2022 7468 6972 6420   line.", "third 
+000091f0: 6c69 6e65 2e22 5d29 0a20 2020 2020 2020  line."]).       
+00009200: 2073 696d 706c 655f 7465 7374 5f6d 756c   simple_test_mul
+00009210: 7469 7370 6c69 7428 2266 6972 7374 206c  tisplit("first l
+00009220: 696e 6521 5c6e 7365 636f 6e64 206c 696e  ine!\nsecond lin
+00009230: 652e 5c6e 7468 6972 6420 6c69 6e65 2e5c  e.\nthird line.\
+00009240: 6e22 2c20 6269 672e 6e65 776c 696e 6573  n", big.newlines
+00009250: 2c0a 2020 2020 2020 2020 2020 2020 5b22  ,.            ["
+00009260: 6669 7273 7420 6c69 6e65 215c 6e22 2c20  first line!\n", 
+00009270: 2273 6563 6f6e 6420 6c69 6e65 2e5c 6e22  "second line.\n"
+00009280: 2c20 2274 6869 7264 206c 696e 652e 225d  , "third line."]
+00009290: 2c20 6b65 6570 3d54 7275 652c 2073 7472  , keep=True, str
+000092a0: 6970 3d54 7275 6529 0a20 2020 2020 2020  ip=True).       
+000092b0: 2073 696d 706c 655f 7465 7374 5f6d 756c   simple_test_mul
+000092c0: 7469 7370 6c69 7428 2266 6972 7374 206c  tisplit("first l
+000092d0: 696e 6521 5c6e 7365 636f 6e64 206c 696e  ine!\nsecond lin
+000092e0: 652e 5c6e 7468 6972 6420 6c69 6e65 2e5c  e.\nthird line.\
+000092f0: 6e22 2c20 6269 672e 6e65 776c 696e 6573  n", big.newlines
+00009300: 2c0a 2020 2020 2020 2020 2020 2020 5b22  ,.            ["
+00009310: 6669 7273 7420 6c69 6e65 215c 6e22 2c20  first line!\n", 
+00009320: 2273 6563 6f6e 6420 6c69 6e65 2e5c 6e22  "second line.\n"
+00009330: 2c20 2274 6869 7264 206c 696e 652e 5c6e  , "third line.\n
+00009340: 222c 2022 225d 2c20 6b65 6570 3d54 7275  ", ""], keep=Tru
+00009350: 652c 2073 7472 6970 3d46 616c 7365 290a  e, strip=False).
+00009360: 2020 2020 2020 2020 7369 6d70 6c65 5f74          simple_t
+00009370: 6573 745f 6d75 6c74 6973 706c 6974 2822  est_multisplit("
+00009380: 6669 7273 7420 6c69 6e65 215c 6e5c 6e73  first line!\n\ns
+00009390: 6563 6f6e 6420 6c69 6e65 2e5c 6e5c 6e5c  econd line.\n\n\
+000093a0: 6e74 6869 7264 206c 696e 652e 222c 2062  nthird line.", b
+000093b0: 6967 2e6e 6577 6c69 6e65 732c 0a20 2020  ig.newlines,.   
+000093c0: 2020 2020 2020 2020 205b 2266 6972 7374           ["first
+000093d0: 206c 696e 6521 222c 2027 272c 2022 7365   line!", '', "se
+000093e0: 636f 6e64 206c 696e 652e 222c 2027 272c  cond line.", '',
+000093f0: 2027 272c 2022 7468 6972 6420 6c69 6e65   '', "third line
+00009400: 2e22 5d2c 2073 6570 6172 6174 653d 5472  ."], separate=Tr
+00009410: 7565 290a 2020 2020 2020 2020 7369 6d70  ue).        simp
+00009420: 6c65 5f74 6573 745f 6d75 6c74 6973 706c  le_test_multispl
+00009430: 6974 2822 6669 7273 7420 6c69 6e65 215c  it("first line!\
+00009440: 6e5c 6e73 6563 6f6e 6420 6c69 6e65 2e5c  n\nsecond line.\
+00009450: 6e5c 6e5c 6e74 6869 7264 206c 696e 652e  n\n\nthird line.
+00009460: 222c 2062 6967 2e6e 6577 6c69 6e65 732c  ", big.newlines,
+00009470: 0a20 2020 2020 2020 2020 2020 205b 2266  .            ["f
+00009480: 6972 7374 206c 696e 6521 5c6e 222c 2027  irst line!\n", '
+00009490: 5c6e 272c 2022 7365 636f 6e64 206c 696e  \n', "second lin
+000094a0: 652e 5c6e 222c 2027 5c6e 272c 2027 5c6e  e.\n", '\n', '\n
+000094b0: 272c 2022 7468 6972 6420 6c69 6e65 2e22  ', "third line."
+000094c0: 5d2c 206b 6565 703d 5472 7565 2c20 7365  ], keep=True, se
+000094d0: 7061 7261 7465 3d54 7275 6529 0a0a 0a20  parate=True)... 
+000094e0: 2020 2020 2020 2073 696d 706c 655f 7465         simple_te
+000094f0: 7374 5f6d 756c 7469 7370 6c69 7428 2261  st_multisplit("a
+00009500: 2c62 2c2c 2c63 222c 2022 2c22 2c20 5b27  ,b,,,c", ",", ['
+00009510: 6127 2c20 2762 272c 2027 272c 2027 272c  a', 'b', '', '',
+00009520: 2027 6327 5d2c 2073 6570 6172 6174 653d   'c'], separate=
+00009530: 5472 7565 290a 0a20 2020 2020 2020 2073  True)..        s
+00009540: 696d 706c 655f 7465 7374 5f6d 756c 7469  imple_test_multi
+00009550: 7370 6c69 7428 2261 2c62 2c2c 2c63 222c  split("a,b,,,c",
+00009560: 2028 222c 222c 292c 205b 2761 272c 2027   (",",), ['a', '
+00009570: 6227 2c20 272c 2c63 275d 2c20 7365 7061  b', ',,c'], sepa
+00009580: 7261 7465 3d54 7275 652c 206d 6178 7370  rate=True, maxsp
+00009590: 6c69 743d 3229 0a0a 2020 2020 2020 2020  lit=2)..        
+000095a0: 7369 6d70 6c65 5f74 6573 745f 6d75 6c74  simple_test_mult
+000095b0: 6973 706c 6974 2822 612c 622c 2c2c 6322  isplit("a,b,,,c"
+000095c0: 2c20 2822 2c22 2c29 2c20 5b27 612c 622c  , (",",), ['a,b,
+000095d0: 272c 2027 272c 2027 6327 5d2c 2073 6570  ', '', 'c'], sep
+000095e0: 6172 6174 653d 5472 7565 2c20 6d61 7873  arate=True, maxs
+000095f0: 706c 6974 3d32 2c20 7265 7665 7273 653d  plit=2, reverse=
+00009600: 5472 7565 290a 0a20 2020 2064 6566 2074  True)..    def t
+00009610: 6573 745f 6d75 6c74 6973 706c 6974 5f65  est_multisplit_e
+00009620: 7868 6175 7374 6976 656c 7928 7365 6c66  xhaustively(self
+00009630: 293a 0a20 2020 2020 2020 2064 6566 206d  ):.        def m
+00009640: 756c 7469 7370 6c69 745f 7465 7374 6572  ultisplit_tester
+00009650: 282a 7365 676d 656e 7473 293a 0a20 2020  (*segments):.   
+00009660: 2020 2020 2020 2020 2022 2222 0a20 2020           """.   
+00009670: 2020 2020 2020 2020 2073 6567 6d65 6e74           segment
+00009680: 7320 7265 7072 6573 656e 7420 7370 6c69  s represent spli
+00009690: 742d 7570 2074 6578 7420 7365 676d 656e  t-up text segmen
+000096a0: 7473 2e0a 2020 2020 2020 2020 2020 2020  ts..            
+000096b0: 6561 6368 2073 6567 6d65 6e74 2069 7320  each segment is 
+000096c0: 6569 7468 6572 0a20 2020 2020 2020 2020  either.         
+000096d0: 2020 2020 2061 2920 6120 7374 7269 6e67       a) a string
+000096e0: 2061 7070 6561 7269 6e67 2069 6e20 7365   appearing in se
+000096f0: 7061 7261 746f 7273 2c20 6f72 0a20 2020  parators, or.   
+00009700: 2020 2020 2020 2020 2020 2062 2920 636f             b) co
+00009710: 6e74 6169 6e73 206e 6f20 7365 7061 7261  ntains no separa
+00009720: 746f 7273 2061 7420 616c 6c2e 0a20 2020  tors at all..   
+00009730: 2020 2020 2020 2020 2073 6567 6d65 6e74           segment
+00009740: 7320 2a6d 7573 742a 2061 6c74 6572 6e61  s *must* alterna
+00009750: 7465 2062 6574 7765 656e 2061 2920 616e  te between a) an
+00009760: 6420 6229 2e0a 2020 2020 2020 2020 2020  d b)..          
+00009770: 2020 7365 676d 656e 7473 2064 6f65 736e    segments doesn
+00009780: 2774 206e 6565 6420 746f 2073 7461 7274  't need to start
+00009790: 206f 7220 656e 6420 7769 7468 2065 6d70   or end with emp
+000097a0: 7479 2073 7472 696e 6773 2e0a 0a20 2020  ty strings...   
+000097b0: 2020 2020 2020 2020 2074 6865 206c 6173           the las
+000097c0: 7420 706f 7369 7469 6f6e 616c 2061 7267  t positional arg
+000097d0: 756d 656e 7420 6973 2061 6374 7561 6c6c  ument is actuall
+000097e0: 7920 2273 6570 6172 6174 6f72 7322 2e0a  y "separators"..
+000097f0: 2020 2020 2020 2020 2020 2020 6173 2069              as i
+00009800: 6e2c 2074 6865 2073 6570 6172 6174 6f72  n, the separator
+00009810: 7320 6172 6775 6d65 6e74 2066 6f72 206d  s argument for m
+00009820: 756c 7469 7370 6c69 742e 0a0a 2020 2020  ultisplit...    
+00009830: 2020 2020 2020 2020 7465 7374 7320 4576          tests Ev
+00009840: 6572 792e 2050 6f73 7369 626c 652e 2050  ery. Possible. P
+00009850: 6572 6d75 7461 7469 6f6e 2e20 6f66 2069  ermutation. of i
+00009860: 6e70 7574 7320 746f 206d 756c 7469 7370  nputs to multisp
+00009870: 6c69 7428 292c 0a20 2020 2020 2020 2020  lit(),.         
+00009880: 2020 2062 6173 6564 206f 6e20 7468 6520     based on the 
+00009890: 7365 676d 656e 7473 2079 6f75 2070 6173  segments you pas
+000098a0: 7320 696e 2e20 2074 6869 7320 696e 636c  s in.  this incl
+000098b0: 7564 6573 0a20 2020 2020 2020 2020 2020  udes.           
+000098c0: 2020 2020 202a 2061 7320 7374 7269 6e67       * as string
+000098d0: 7320 616e 6420 656e 636f 6465 6420 746f  s and encoded to
+000098e0: 2062 7974 6573 2028 6173 6369 6929 0a20   bytes (ascii). 
+000098f0: 2020 2020 2020 2020 2020 2020 2020 202a                 *
+00009900: 2077 6974 6820 616e 6420 7769 7468 6f75   with and withou
+00009910: 7420 7468 6520 6c65 6674 2073 6570 6172  t the left separ
+00009920: 6174 6f72 730a 2020 2020 2020 2020 2020  ators.          
+00009930: 2020 2020 2020 2a20 7769 7468 2061 6e64        * with and
+00009940: 2077 6974 686f 7574 2074 6865 2072 6967   without the rig
+00009950: 6874 2073 6570 6172 6174 6f72 730a 2020  ht separators.  
+00009960: 2020 2020 2020 2020 2020 2020 2020 2a20                * 
+00009970: 7769 7468 2065 7665 7279 2063 6f6d 6269  with every combi
+00009980: 6e61 7469 6f6e 206f 6620 6576 6572 7920  nation of every 
+00009990: 7661 6c75 6520 6f66 0a20 2020 2020 2020  value of.       
+000099a0: 2020 2020 2020 2020 2020 2020 202a 206b               * k
+000099b0: 6565 700a 2020 2020 2020 2020 2020 2020  eep.            
+000099c0: 2020 2020 2020 2020 2a20 6d61 7873 706c          * maxspl
+000099d0: 6974 2028 616c 6c20 7661 6c75 6573 2074  it (all values t
+000099e0: 6861 7420 7072 6f64 7563 6520 6469 6666  hat produce diff
+000099f0: 6572 656e 7420 7265 7375 6c74 732c 2070  erent results, p
+00009a00: 6c75 7320 6120 636f 7570 6c65 2065 7874  lus a couple ext
+00009a10: 7261 204a 7573 7420 496e 2043 6173 6529  ra Just In Case)
+00009a20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009a30: 2020 2020 202a 2072 6576 6572 7365 0a20       * reverse. 
+00009a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009a50: 2020 202a 2073 6570 6172 6174 650a 2020     * separate.  
 00009a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009a70: 2020 2023 2020 2020 286c 656e 2865 7870     #    (len(exp
-00009a80: 6563 7465 6429 202f 2f20 3229 202d 2031  ected) // 2) - 1
-00009a90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00009aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009ab0: 2023 2027 6120 6220 6320 6420 6527 2077   # 'a b c d e' w
-00009ac0: 6f75 6c64 2073 706c 6974 2062 7920 7768  ould split by wh
-00009ad0: 6974 6573 7061 6365 2069 6e74 6f20 3920  itespace into 9 
-00009ae0: 656c 656d 656e 7473 2c0a 2020 2020 2020  elements,.      
-00009af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009b00: 2020 2020 2020 2020 2020 2320 6f6e 6c79            # only
-00009b10: 2075 7369 6e67 2066 6f75 7220 7370 6c69   using four spli
-00009b20: 7473 2e0a 2020 2020 2020 2020 2020 2020  ts..            
-00009b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009b40: 2020 2020 2320 416e 7977 6179 2077 6520      # Anyway we 
-00009b50: 7465 7374 2061 2063 6f75 706c 6520 7375  test a couple su
-00009b60: 7065 726e 756d 6572 6172 7920 6d61 7873  pernumerary maxs
-00009b70: 706c 6974 2076 616c 7565 732e 0a20 2020  plit values..   
-00009b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009b90: 2020 2020 2020 2020 2020 2020 206d 6178               max
-00009ba0: 5f6d 6178 7370 6c69 7420 3d20 286c 656e  _maxsplit = (len
-00009bb0: 2865 7870 6563 7465 6429 202f 2f20 3229  (expected) // 2)
-00009bc0: 202b 2031 0a0a 2020 2020 2020 2020 2020   + 1..          
-00009bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009be0: 2020 2020 2020 6578 7065 6374 6564 5f6f        expected_o
-00009bf0: 7269 6769 6e61 6c20 3d20 6578 7065 6374  riginal = expect
-00009c00: 6564 0a0a 2020 2020 2020 2020 2020 2020  ed..            
-00009c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009c20: 2020 2020 6966 2077 616e 745f 7072 696e      if want_prin
-00009c30: 7473 3a20 2320 7072 6167 6d61 3a20 6e6f  ts: # pragma: no
-00009c40: 2063 6f76 6572 0a20 2020 2020 2020 2020   cover.         
-00009c50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009c60: 2020 2020 2020 2020 2020 2070 7269 6e74             print
-00009c70: 2866 2220 2020 2065 7870 6563 7465 645f  (f"    expected_
-00009c80: 6f72 6967 696e 616c 3d7b 6578 7065 6374  original={expect
-00009c90: 6564 5f6f 7269 6769 6e61 6c7d 2229 0a0a  ed_original}")..
-00009ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009cc0: 666f 7220 7265 7665 7273 6520 696e 2028  for reverse in (
-00009cd0: 4661 6c73 652c 2054 7275 6529 3a0a 2020  False, True):.  
-00009ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009cf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009d00: 2020 666f 7220 6d61 7873 706c 6974 2069    for maxsplit i
-00009d10: 6e20 7261 6e67 6528 2d31 2c20 6d61 785f  n range(-1, max_
-00009d20: 6d61 7873 706c 6974 293a 0a20 2020 2020  maxsplit):.     
-00009d30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009d50: 2020 2065 7870 6563 7465 6420 3d20 6c69     expected = li
-00009d60: 7374 2865 7870 6563 7465 645f 6f72 6967  st(expected_orig
-00009d70: 696e 616c 290a 2020 2020 2020 2020 2020  inal).          
-00009d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009d90: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00009da0: 2077 616e 745f 7072 696e 7473 3a20 2320   want_prints: # 
-00009db0: 7072 6167 6d61 3a20 6e6f 2063 6f76 6572  pragma: no cover
-00009dc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00009dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009de0: 2020 2020 2020 2020 2020 2020 2070 7269               pri
-00009df0: 6e74 2866 225b 6c6f 6f70 2035 2c36 5d20  nt(f"[loop 5,6] 
-00009e00: 7265 7665 7273 653d 7b72 6576 6572 7365  reverse={reverse
-00009e10: 7d20 6d61 7873 706c 6974 3d7b 6d61 7873  } maxsplit={maxs
-00009e20: 706c 6974 7d20 2f2f 2065 7870 6563 7465  plit} // expecte
-00009e30: 643d 7b65 7870 6563 7465 647d 2229 0a20  d={expected}"). 
+00009a70: 2020 2a20 7374 7269 700a 0a20 2020 2020    * strip..     
+00009a80: 2020 2020 2020 2070 2e73 2069 7427 7320         p.s it's 
+00009a90: 6120 6c69 7474 6c65 2073 6c6f 7721 2020  a little slow!  
+00009aa0: 6275 7420 6974 2773 2064 6f69 6e67 2061  but it's doing a
+00009ab0: 206c 6f74 2e0a 2020 2020 2020 2020 2020   lot..          
+00009ac0: 2020 2222 220a 0a20 2020 2020 2020 2020    """..         
+00009ad0: 2020 2023 2077 616e 745f 7072 696e 7473     # want_prints
+00009ae0: 203d 2054 7275 650a 2020 2020 2020 2020   = True.        
+00009af0: 2020 2020 7761 6e74 5f70 7269 6e74 7320      want_prints 
+00009b00: 3d20 4661 6c73 650a 0a20 2020 2020 2020  = False..       
+00009b10: 2020 2020 2069 6620 7761 6e74 5f70 7269       if want_pri
+00009b20: 6e74 733a 2023 2070 7261 676d 613a 206e  nts: # pragma: n
+00009b30: 6f20 636f 7665 720a 2020 2020 2020 2020  o cover.        
+00009b40: 2020 2020 2020 2020 7072 696e 7428 225f          print("_
+00009b50: 2220 2a20 3639 290a 2020 2020 2020 2020  " * 69).        
+00009b60: 2020 2020 2020 2020 7072 696e 7428 290a          print().
+00009b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009b80: 7072 696e 7428 2274 6573 7420 6578 6861  print("test exha
+00009b90: 7573 7469 7665 6c79 2229 0a20 2020 2020  ustively").     
+00009ba0: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+00009bb0: 2822 5f22 202a 2036 3929 0a0a 2020 2020  ("_" * 69)..    
+00009bc0: 2020 2020 2020 2020 7365 676d 656e 7473          segments
+00009bd0: 203d 206c 6973 7428 7365 676d 656e 7473   = list(segments
+00009be0: 290a 2020 2020 2020 2020 2020 2020 7365  ).            se
+00009bf0: 7061 7261 746f 7273 203d 2073 6567 6d65  parators = segme
+00009c00: 6e74 732e 706f 7028 290a 0a20 2020 2020  nts.pop()..     
+00009c10: 2020 2020 2020 2069 6620 7365 7061 7261         if separa
+00009c20: 746f 7273 2069 7320 6e6f 7420 4e6f 6e65  tors is not None
+00009c30: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00009c40: 2020 7365 7061 7261 746f 7273 5f73 6574    separators_set
+00009c50: 203d 2073 6574 2873 6570 6172 6174 6f72   = set(separator
+00009c60: 7329 0a20 2020 2020 2020 2020 2020 2065  s).            e
+00009c70: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00009c80: 2020 2020 2073 6570 6172 6174 6f72 735f       separators_
+00009c90: 7365 7420 3d20 7365 7428 6269 672e 7768  set = set(big.wh
+00009ca0: 6974 6573 7061 6365 290a 2020 2020 2020  itespace).      
+00009cb0: 2020 2020 2020 6173 7365 7274 2027 2720        assert '' 
+00009cc0: 6e6f 7420 696e 2073 6570 6172 6174 6f72  not in separator
+00009cd0: 735f 7365 740a 0a20 2020 2020 2020 2020  s_set..         
+00009ce0: 2020 2023 2073 7472 6970 206f 6666 2074     # strip off t
+00009cf0: 6865 206c 6561 6469 6e67 2061 6e64 2074  he leading and t
+00009d00: 7261 696c 696e 6720 7365 7061 7261 746f  railing separato
+00009d10: 7273 2e0a 0a20 2020 2020 2020 2020 2020  rs...           
+00009d20: 2023 206c 6561 6469 6e67 206c 6f6f 6b73   # leading looks
+00009d30: 206c 696b 6520 7468 6973 3a0a 2020 2020   like this:.    
+00009d40: 2020 2020 2020 2020 2320 2020 5b20 2727          #   [ ''
+00009d50: 2c20 7365 7061 7261 746f 722c 2073 6570  , separator, sep
+00009d60: 6172 6174 6f72 2c20 7365 7061 7261 746f  arator, separato
+00009d70: 722c 202e 2e2e 205d 0a20 2020 2020 2020  r, ... ].       
+00009d80: 2020 2020 2023 2079 6573 2c20 7468 6174       # yes, that
+00009d90: 2069 7320 616c 7761 7973 2061 6e20 656d   is always an em
+00009da0: 7074 7920 7374 7269 6e67 2c20 796f 7527  pty string, you'
+00009db0: 6c6c 2073 6565 2077 6879 0a20 2020 2020  ll see why.     
+00009dc0: 2020 2020 2020 2023 2069 6e20 6120 6d6f         # in a mo
+00009dd0: 6d65 6e74 2e0a 0a20 2020 2020 2020 2020  ment...         
+00009de0: 2020 206c 6561 6469 6e67 203d 205b 2727     leading = [''
+00009df0: 5d0a 2020 2020 2020 2020 2020 2020 7768  ].            wh
+00009e00: 696c 6520 5472 7565 3a0a 2020 2020 2020  ile True:.      
+00009e10: 2020 2020 2020 2020 2020 6966 2073 6567            if seg
+00009e20: 6d65 6e74 735b 305d 206e 6f74 2069 6e20  ments[0] not in 
+00009e30: 7365 7061 7261 746f 7273 5f73 6574 3a0a  separators_set:.
 00009e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009e60: 2020 2020 2020 2069 6620 6d61 7873 706c         if maxspl
-00009e70: 6974 203d 3d20 303a 0a20 2020 2020 2020  it == 0:.       
-00009e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009ea0: 2020 2020 206a 6f69 6e65 6420 3d20 656d       joined = em
-00009eb0: 7074 792e 6a6f 696e 2865 7870 6563 7465  pty.join(expecte
-00009ec0: 6429 0a20 2020 2020 2020 2020 2020 2020  d).             
-00009ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009ee0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-00009ef0: 7870 6563 7465 6420 3d20 5b6a 6f69 6e65  xpected = [joine
-00009f00: 645d 0a20 2020 2020 2020 2020 2020 2020  d].             
-00009f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009f20: 2020 2020 2020 2020 2020 2065 6c69 6620             elif 
-00009f30: 6d61 7873 706c 6974 203e 2030 3a0a 2020  maxsplit > 0:.  
-00009f40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009f60: 2020 2020 2020 2020 2020 6966 206e 6f74            if not
-00009f70: 2072 6576 6572 7365 3a0a 2020 2020 2020   reverse:.      
-00009f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009fa0: 2020 2020 2020 2020 2020 2320 7765 2772            # we'r
-00009fb0: 6520 696e 2022 616c 7465 726e 6174 696e  e in "alternatin
-00009fc0: 6722 206d 6f64 652c 0a20 2020 2020 2020  g" mode,.       
-00009fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009fe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009ff0: 2020 2020 2020 2020 2023 2073 6f20 6f64           # so od
-0000a000: 642d 6e75 6d62 6572 6564 2069 6e64 6578  d-numbered index
-0000a010: 6573 2061 7265 0a20 2020 2020 2020 2020  es are.         
-0000a020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a030: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a040: 2020 2020 2020 2023 2073 706c 6974 730a         # splits.
-0000a050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a060: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a080: 230a 2020 2020 2020 2020 2020 2020 2020  #.              
-0000a090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a0b0: 2020 2320 6c65 6e67 7468 2037 0a20 2020    # length 7.   
-0000a0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a0d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a0e0: 2020 2020 2020 2020 2020 2020 2023 2020               #  
-0000a0f0: 3020 2020 2031 2020 2020 3220 2020 2033  0    1    2    3
-0000a100: 2020 2020 3420 2020 2035 2020 2020 3620      4    5    6 
-0000a110: 2020 696e 6465 780a 2020 2020 2020 2020    index.        
-0000a120: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a140: 2020 2020 2020 2020 2320 5b27 6127 2c20          # ['a', 
-0000a150: 2720 272c 2027 6227 2c20 2720 272c 2027  ' ', 'b', ' ', '
-0000a160: 6327 2c20 2720 272c 2027 6427 5d0a 2020  c', ' ', 'd'].  
-0000a170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a190: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0000a1a0: 2030 2020 2020 2020 2020 2031 2020 2020   0         1    
-0000a1b0: 2020 2020 2020 3220 2020 2020 2020 2033        2        3
-0000a1c0: 2020 206d 6178 7370 6c69 740a 2020 2020     maxsplit.    
-0000a1d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a1e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a1f0: 2020 2020 2020 2020 2020 2020 7374 6172              star
-0000a200: 7420 3d20 6d61 7873 706c 6974 202a 2032  t = maxsplit * 2
-0000a210: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a230: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a240: 2065 6e64 203d 206c 656e 2865 7870 6563   end = len(expec
-0000a250: 7465 6429 0a20 2020 2020 2020 2020 2020  ted).           
-0000a260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a270: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a280: 2020 2020 2069 6620 7374 6172 7420 3c20       if start < 
-0000a290: 656e 643a 0a20 2020 2020 2020 2020 2020  end:.           
-0000a2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a2b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a2c0: 2020 2020 2020 2020 2069 6620 7761 6e74           if want
-0000a2d0: 5f70 7269 6e74 733a 2023 2070 7261 676d  _prints: # pragm
-0000a2e0: 613a 206e 6f20 636f 7665 720a 2020 2020  a: no cover.    
-0000a2f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a320: 2020 2020 7072 696e 7428 6622 2020 2020      print(f"    
-0000a330: 6e6f 7420 7265 7665 7273 653a 2065 7870  not reverse: exp
-0000a340: 6563 7465 645b 7b73 7461 7274 7d3a 7b65  ected[{start}:{e
-0000a350: 6e64 7d5d 203d 207b 6578 7065 6374 6564  nd}] = {expected
-0000a360: 5b73 7461 7274 3a65 6e64 5d7d 2229 0a20  [start:end]}"). 
-0000a370: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009e50: 2020 2020 6272 6561 6b0a 2020 2020 2020      break.      
+00009e60: 2020 2020 2020 2020 2020 6c65 6164 696e            leadin
+00009e70: 672e 6170 7065 6e64 2873 6567 6d65 6e74  g.append(segment
+00009e80: 732e 706f 7028 3029 290a 0a20 2020 2020  s.pop(0))..     
+00009e90: 2020 2020 2020 2023 2074 7261 696c 696e         # trailin
+00009ea0: 6720 636f 6e74 6169 6e73 206a 7573 7420  g contains just 
+00009eb0: 7468 6520 7472 6169 6c69 6e67 2028 7269  the trailing (ri
+00009ec0: 6768 7429 0a20 2020 2020 2020 2020 2020  ght).           
+00009ed0: 2023 2073 6570 6172 6174 6f72 732c 2061   # separators, a
+00009ee0: 7320 696e 6469 7669 6475 616c 2073 7472  s individual str
+00009ef0: 696e 6773 2e0a 2020 2020 2020 2020 2020  ings..          
+00009f00: 2020 2320 7472 6169 6c69 6e67 206a 7573    # trailing jus
+00009f10: 7420 6c6f 6f6b 7320 6c69 6b65 2074 6869  t looks like thi
+00009f20: 733a 0a20 2020 2020 2020 2020 2020 2023  s:.            #
+00009f30: 2020 205b 2073 6570 6172 6174 6f72 2c20     [ separator, 
+00009f40: 7365 7061 7261 746f 722c 202e 2e2e 205d  separator, ... ]
+00009f50: 0a0a 2020 2020 2020 2020 2020 2020 7472  ..            tr
+00009f60: 6169 6c69 6e67 203d 205b 5d0a 2020 2020  ailing = [].    
+00009f70: 2020 2020 2020 2020 7768 696c 6520 5472          while Tr
+00009f80: 7565 3a0a 2020 2020 2020 2020 2020 2020  ue:.            
+00009f90: 2020 2020 6966 2077 616e 745f 7072 696e      if want_prin
+00009fa0: 7473 3a20 2320 7072 6167 6d61 3a20 6e6f  ts: # pragma: no
+00009fb0: 2063 6f76 6572 0a20 2020 2020 2020 2020   cover.         
+00009fc0: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+00009fd0: 2866 2273 706c 6974 7469 6e67 2073 6567  (f"splitting seg
+00009fe0: 6d65 6e74 733a 2073 6567 6d65 6e74 735b  ments: segments[
+00009ff0: 2d31 5d3d 7b73 6567 6d65 6e74 735b 2d31  -1]={segments[-1
+0000a000: 5d7d 2073 6570 6172 6174 6f72 735f 7365  ]} separators_se
+0000a010: 743d 7b73 6570 6172 6174 6f72 735f 7365  t={separators_se
+0000a020: 747d 206e 6f74 2069 6e3f 207b 7365 676d  t} not in? {segm
+0000a030: 656e 7473 5b2d 315d 206e 6f74 2069 6e20  ents[-1] not in 
+0000a040: 7365 7061 7261 746f 7273 5f73 6574 7d22  separators_set}"
+0000a050: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000a060: 2020 6966 2073 6567 6d65 6e74 735b 2d31    if segments[-1
+0000a070: 5d20 6e6f 7420 696e 2073 6570 6172 6174  ] not in separat
+0000a080: 6f72 735f 7365 743a 0a20 2020 2020 2020  ors_set:.       
+0000a090: 2020 2020 2020 2020 2020 2020 2062 7265               bre
+0000a0a0: 616b 0a20 2020 2020 2020 2020 2020 2020  ak.             
+0000a0b0: 2020 2074 7261 696c 696e 672e 6170 7065     trailing.appe
+0000a0c0: 6e64 2873 6567 6d65 6e74 732e 706f 7028  nd(segments.pop(
+0000a0d0: 2929 0a20 2020 2020 2020 2020 2020 2074  )).            t
+0000a0e0: 7261 696c 696e 672e 7265 7665 7273 6528  railing.reverse(
+0000a0f0: 290a 0a20 2020 2020 2020 2020 2020 2023  )..            #
+0000a100: 2073 706c 6974 7320 6973 2061 206c 6973   splits is a lis
+0000a110: 7420 6f66 206c 6973 7473 2e20 2065 6163  t of lists.  eac
+0000a120: 6820 7375 626c 6973 742c 206f 7220 2273  h sublist, or "s
+0000a130: 706c 6974 222c 0a20 2020 2020 2020 2020  plit",.         
+0000a140: 2020 2023 2069 6e73 6964 6520 7370 6c69     # inside spli
+0000a150: 7473 2c20 6c6f 6f6b 7320 6c69 6b65 2074  ts, looks like t
+0000a160: 6869 733a 0a20 2020 2020 2020 2020 2020  his:.           
+0000a170: 2023 2020 205b 206e 6f6e 2d73 6570 6172   #   [ non-separ
+0000a180: 6174 6f72 2d73 7472 696e 672c 2073 6570  ator-string, sep
+0000a190: 6172 6174 6f72 2c20 7365 7061 7261 746f  arator, separato
+0000a1a0: 722c 202e 2e2e 205d 0a20 2020 2020 2020  r, ... ].       
+0000a1b0: 2020 2020 2023 2028 7965 732c 206c 6561       # (yes, lea
+0000a1c0: 6469 6e67 2061 6e64 2061 6e20 696e 6469  ding and an indi
+0000a1d0: 7669 6475 616c 2073 706c 6974 206c 6973  vidual split lis
+0000a1e0: 7420 6c6f 6f6b 2069 6465 6e74 6963 616c  t look identical
+0000a1f0: 2c20 7468 6174 2773 2077 6879 2e29 0a20  , that's why.). 
+0000a200: 2020 2020 2020 2020 2020 2023 2065 7665             # eve
+0000a210: 7279 2073 706c 6974 2069 6e20 7370 6c69  ry split in spli
+0000a220: 7473 2069 7320 6861 7320 6174 206c 6561  ts is has at lea
+0000a230: 7374 206f 6e65 2073 6570 6172 6174 6f72  st one separator
+0000a240: 0a20 2020 2020 2020 2020 2020 2023 2045  .            # E
+0000a250: 5843 4550 5420 7468 6520 6c61 7374 206f  XCEPT the last o
+0000a260: 6e65 2077 6869 6368 206f 6e6c 7920 6861  ne which only ha
+0000a270: 7320 7468 6520 6e6f 6e2d 7365 7020 7374  s the non-sep st
+0000a280: 7269 6e67 2e0a 2020 2020 2020 2020 2020  ring..          
+0000a290: 2020 230a 2020 2020 2020 2020 2020 2020    #.            
+0000a2a0: 2320 7468 6973 2069 7320 6f6e 6c79 2061  # this is only a
+0000a2b0: 6e20 696e 7465 726d 6564 6961 7465 2066  n intermediate f
+0000a2c0: 6f72 6d2c 2077 6527 6c6c 206d 6173 7361  orm, we'll massa
+0000a2d0: 6765 2074 6869 730a 2020 2020 2020 2020  ge this.        
+0000a2e0: 2020 2020 2320 696e 746f 2061 206d 6f72      # into a mor
+0000a2f0: 6520 7573 6566 756c 2066 6f72 6d20 696e  e useful form in
+0000a300: 2061 206d 696e 7574 652e 0a20 2020 2020   a minute..     
+0000a310: 2020 2020 2020 2073 706c 6974 7320 3d20         splits = 
+0000a320: 5b5d 0a20 2020 2020 2020 2020 2020 2073  [].            s
+0000a330: 706c 6974 203d 205b 5d0a 2020 2020 2020  plit = [].      
+0000a340: 2020 2020 2020 6465 6620 666c 7573 6828        def flush(
+0000a350: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000a360: 2020 206e 6f6e 6c6f 6361 6c20 7370 6c69     nonlocal spli
+0000a370: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
+0000a380: 2020 6966 2073 706c 6974 3a0a 2020 2020    if split:.    
 0000a390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a3a0: 2020 206a 6f69 6e65 6420 3d20 6e6f 6e5f     joined = non_
-0000a3b0: 7365 705f 6d61 726b 6572 202b 2065 6d70  sep_marker + emp
-0000a3c0: 7479 2e6a 6f69 6e28 6578 7065 6374 6564  ty.join(expected
-0000a3d0: 5b73 7461 7274 3a65 6e64 5d29 0a20 2020  [start:end]).   
-0000a3e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a400: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a410: 2064 656c 2065 7870 6563 7465 645b 7374   del expected[st
-0000a420: 6172 743a 656e 645d 0a20 2020 2020 2020  art:end].       
-0000a430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a440: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a450: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000a460: 7761 6e74 5f70 7269 6e74 733a 2023 2070  want_prints: # p
-0000a470: 7261 676d 613a 206e 6f20 636f 7665 720a  ragma: no cover.
-0000a480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a3a0: 7370 6c69 7473 2e61 7070 656e 6428 7370  splits.append(sp
+0000a3b0: 6c69 7429 0a20 2020 2020 2020 2020 2020  lit).           
+0000a3c0: 2020 2020 2020 2020 2073 706c 6974 203d           split =
+0000a3d0: 205b 5d0a 0a20 2020 2020 2020 2020 2020   []..           
+0000a3e0: 2066 6f72 2073 6567 6d65 6e74 2069 6e20   for segment in 
+0000a3f0: 7365 676d 656e 7473 3a0a 2020 2020 2020  segments:.      
+0000a400: 2020 2020 2020 2020 2020 6966 2073 6567            if seg
+0000a410: 6d65 6e74 2069 6e20 7365 7061 7261 746f  ment in separato
+0000a420: 7273 5f73 6574 3a0a 2020 2020 2020 2020  rs_set:.        
+0000a430: 2020 2020 2020 2020 2020 2020 6173 7365              asse
+0000a440: 7274 2073 706c 6974 0a20 2020 2020 2020  rt split.       
+0000a450: 2020 2020 2020 2020 2020 2020 2073 706c               spl
+0000a460: 6974 2e61 7070 656e 6428 7365 676d 656e  it.append(segmen
+0000a470: 7429 0a20 2020 2020 2020 2020 2020 2020  t).             
+0000a480: 2020 2020 2020 2063 6f6e 7469 6e75 650a         continue.
 0000a490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a4a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a4b0: 2020 2020 2020 2020 7072 696e 7428 6622          print(f"
-0000a4c0: 2020 2020 6578 7065 6374 6564 3d7b 6578      expected={ex
-0000a4d0: 7065 6374 6564 7d20 6a6f 696e 6564 3d7b  pected} joined={
-0000a4e0: 6a6f 696e 6564 7d20 656d 7074 793d 7b65  joined} empty={e
-0000a4f0: 6d70 7479 7d22 290a 2020 2020 2020 2020  mpty}").        
-0000a500: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a520: 2020 2020 2020 2020 2020 2020 6578 7065              expe
-0000a530: 6374 6564 2e61 7070 656e 6428 6a6f 696e  cted.append(join
-0000a540: 6564 290a 2020 2020 2020 2020 2020 2020  ed).            
-0000a550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a570: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-0000a580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a590: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a5a0: 2020 2020 2020 2320 7265 7665 7273 6520        # reverse 
-0000a5b0: 616e 6420 6d61 7873 706c 6974 0a20 2020  and maxsplit.   
-0000a5c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a5d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a5e0: 2020 2020 2020 2020 2020 2020 2023 0a20               #. 
-0000a5f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a610: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0000a620: 206c 656e 6774 6820 370a 2020 2020 2020   length 7.      
-0000a630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a650: 2020 2020 2020 2020 2020 2320 2030 2020            #  0  
-0000a660: 2020 3120 2020 2032 2020 2020 3320 2020    1    2    3   
-0000a670: 2034 2020 2020 3520 2020 2036 2020 2069   4    5    6   i
-0000a680: 6e64 6578 0a20 2020 2020 2020 2020 2020  ndex.           
-0000a690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a6a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a6b0: 2020 2020 2023 205b 2761 272c 2027 2027       # ['a', ' '
-0000a6c0: 2c20 2762 272c 2027 2027 2c20 2763 272c  , 'b', ' ', 'c',
-0000a6d0: 2027 2027 2c20 2764 272c 2020 5d0a 2020   ' ', 'd',  ].  
-0000a6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a6f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a700: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0000a710: 2020 2020 2020 3320 2020 2020 2020 2020        3         
-0000a720: 3220 2020 2020 2020 2020 3120 2020 2020  2         1     
-0000a730: 2020 2020 3020 2020 6d61 7873 706c 6974      0   maxsplit
-0000a740: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a750: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a770: 2073 7461 7274 203d 2030 0a20 2020 2020   start = 0.     
-0000a780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a790: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a7a0: 2020 2020 2020 2020 2020 2065 6e64 203d             end =
-0000a7b0: 206c 656e 2865 7870 6563 7465 6429 202d   len(expected) -
-0000a7c0: 2028 6d61 7873 706c 6974 202a 2032 290a   (maxsplit * 2).
-0000a7d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a7f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a800: 6a6f 696e 6564 203d 206e 6f6e 5f73 6570  joined = non_sep
-0000a810: 5f6d 6172 6b65 7220 2b20 656d 7074 792e  _marker + empty.
-0000a820: 6a6f 696e 2865 7870 6563 7465 645b 7374  join(expected[st
-0000a830: 6172 743a 656e 645d 290a 2020 2020 2020  art:end]).      
-0000a840: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a860: 2020 2020 2020 2020 2020 6966 2077 616e            if wan
-0000a870: 745f 7072 696e 7473 3a20 2320 7072 6167  t_prints: # prag
-0000a880: 6d61 3a20 6e6f 2063 6f76 6572 0a20 2020  ma: no cover.   
-0000a890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a8a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a8b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a8c0: 2070 7269 6e74 2866 2220 2020 2072 6576   print(f"    rev
-0000a8d0: 6572 7365 3a20 6578 7065 6374 6564 5b7b  erse: expected[{
-0000a8e0: 7374 6172 747d 3a7b 656e 647d 5d20 3d20  start}:{end}] = 
-0000a8f0: 7b65 7870 6563 7465 645b 7374 6172 743a  {expected[start:
-0000a900: 656e 645d 7d20 202f 2f2f 206a 6f69 6e65  end]}  /// joine
-0000a910: 643d 7b6a 6f69 6e65 647d 2229 0a20 2020  d={joined}").   
-0000a920: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a940: 2020 2020 2020 2020 2020 2020 2064 656c               del
-0000a950: 2065 7870 6563 7465 645b 7374 6172 743a   expected[start:
-0000a960: 656e 645d 0a20 2020 2020 2020 2020 2020  end].           
-0000a970: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a990: 2020 2020 2069 6620 7761 6e74 5f70 7269       if want_pri
-0000a9a0: 6e74 733a 2023 2070 7261 676d 613a 206e  nts: # pragma: n
-0000a9b0: 6f20 636f 7665 720a 2020 2020 2020 2020  o cover.        
-0000a9c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a9d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a9e0: 2020 2020 2020 2020 2020 2020 7072 696e              prin
-0000a9f0: 7428 6622 2020 2020 6578 7065 6374 6564  t(f"    expected
-0000aa00: 3d7b 6578 7065 6374 6564 7d20 6a6f 696e  ={expected} join
-0000aa10: 6564 3d7b 6a6f 696e 6564 7d22 290a 2020  ed={joined}").  
-0000aa20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aa30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aa40: 2020 2020 2020 2020 2020 2020 2020 6578                ex
-0000aa50: 7065 6374 6564 2e69 6e73 6572 7428 302c  pected.insert(0,
-0000aa60: 206a 6f69 6e65 6429 0a20 2020 2020 2020   joined).       
+0000a4a0: 6173 7365 7274 2028 6e6f 7420 7370 6c69  assert (not spli
+0000a4b0: 7429 206f 7220 2873 706c 6974 5b2d 315d  t) or (split[-1]
+0000a4c0: 2069 6e20 7365 7061 7261 746f 7273 5f73   in separators_s
+0000a4d0: 6574 292c 2066 2273 706c 6974 3d7b 7370  et), f"split={sp
+0000a4e0: 6c69 747d 2073 706c 6974 5b2d 315d 3d7b  lit} split[-1]={
+0000a4f0: 7370 6c69 745b 2d31 5d7d 2073 6570 6172  split[-1]} separ
+0000a500: 6174 6f72 735f 7365 743d 7b73 6570 6172  ators_set={separ
+0000a510: 6174 6f72 735f 7365 747d 220a 2020 2020  ators_set}".    
+0000a520: 2020 2020 2020 2020 2020 2020 666c 7573              flus
+0000a530: 6828 290a 2020 2020 2020 2020 2020 2020  h().            
+0000a540: 2020 2020 7370 6c69 742e 6170 7065 6e64      split.append
+0000a550: 2873 6567 6d65 6e74 290a 2020 2020 2020  (segment).      
+0000a560: 2020 2020 2020 666c 7573 6828 290a 0a20        flush().. 
+0000a570: 2020 2020 2020 2020 2020 2069 6620 7761             if wa
+0000a580: 6e74 5f70 7269 6e74 733a 2023 2070 7261  nt_prints: # pra
+0000a590: 676d 613a 206e 6f20 636f 7665 720a 2020  gma: no cover.  
+0000a5a0: 2020 2020 2020 2020 2020 2020 2020 7072                pr
+0000a5b0: 696e 7428 6622 6c65 6164 696e 673d 7b6c  int(f"leading={l
+0000a5c0: 6561 6469 6e67 7d22 290a 2020 2020 2020  eading}").      
+0000a5d0: 2020 2020 2020 2020 2020 7072 696e 7428            print(
+0000a5e0: 6622 7370 6c69 7473 3d7b 7370 6c69 7473  f"splits={splits
+0000a5f0: 7d22 290a 2020 2020 2020 2020 2020 2020  }").            
+0000a600: 2020 2020 7072 696e 7428 6622 7472 6169      print(f"trai
+0000a610: 6c69 6e67 3d7b 7472 6169 6c69 6e67 7d22  ling={trailing}"
+0000a620: 290a 2020 2020 2020 2020 2020 2020 6173  ).            as
+0000a630: 7365 7274 2073 706c 6974 735b 2d31 5d5b  sert splits[-1][
+0000a640: 2d31 5d20 6e6f 7420 696e 2073 6570 6172  -1] not in separ
+0000a650: 6174 6f72 735f 7365 742c 2066 2273 706c  ators_set, f"spl
+0000a660: 6974 735b 2d31 5d5b 2d31 5d3d 7b73 706c  its[-1][-1]={spl
+0000a670: 6974 735b 2d31 5d5b 2d31 5d7d 2069 7320  its[-1][-1]} is 
+0000a680: 696e 2073 6570 6172 6174 6f72 735f 7365  in separators_se
+0000a690: 743d 7b73 6570 6172 6174 6f72 735f 7365  t={separators_se
+0000a6a0: 747d 2122 0a0a 2020 2020 2020 2020 2020  t}!"..          
+0000a6b0: 2020 2320 6c65 6164 696e 6720 616e 6420    # leading and 
+0000a6c0: 7472 6169 6c69 6e67 206d 7573 7420 626f  trailing must bo
+0000a6d0: 7468 2068 6176 6520 6174 206c 6561 7374  th have at least
+0000a6e0: 0a20 2020 2020 2020 2020 2020 2023 206f  .            # o
+0000a6f0: 6e65 2073 6570 2073 7472 696e 672e 0a20  ne sep string.. 
+0000a700: 2020 2020 2020 2020 2020 2061 7373 6572             asser
+0000a710: 7420 286c 656e 286c 6561 6469 6e67 2920  t (len(leading) 
+0000a720: 3e3d 2032 2920 616e 6420 7472 6169 6c69  >= 2) and traili
+0000a730: 6e67 0a0a 2020 2020 2020 2020 2020 2020  ng..            
+0000a740: 2320 6e6f 7465 206f 6e65 2069 6e76 6172  # note one invar
+0000a750: 6961 6e74 3a20 6966 2079 6f75 206a 6f69  iant: if you joi
+0000a760: 6e20 6c65 6164 696e 672c 2073 706c 6974  n leading, split
+0000a770: 732c 2061 6e64 2074 7261 696c 696e 670a  s, and trailing.
+0000a780: 2020 2020 2020 2020 2020 2020 2320 746f              # to
+0000a790: 6765 7468 6572 2069 6e74 6f20 6f6e 6520  gether into one 
+0000a7a0: 6269 6720 7374 7269 6e67 2c20 6974 2069  big string, it i
+0000a7b0: 7320 6f75 7220 6f72 6967 696e 616c 2069  s our original i
+0000a7c0: 6e70 7574 2073 7472 696e 672e 0a20 2020  nput string..   
+0000a7d0: 2020 2020 2020 2020 2023 2074 6861 7420           # that 
+0000a7e0: 7769 6c6c 206e 6576 6572 2063 6861 6e67  will never chang
+0000a7f0: 652e 0a0a 2020 2020 2020 2020 2020 2020  e...            
+0000a800: 6f72 6967 696e 616c 7320 3d20 6c65 6164  originals = lead
+0000a810: 696e 672c 2073 706c 6974 732c 2074 7261  ing, splits, tra
+0000a820: 696c 696e 670a 0a20 2020 2020 2020 2020  iling..         
+0000a830: 2020 2066 6f72 2061 735f 6279 7465 7320     for as_bytes 
+0000a840: 696e 2028 4661 6c73 652c 2054 7275 6529  in (False, True)
+0000a850: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000a860: 2020 6966 2077 616e 745f 7072 696e 7473    if want_prints
+0000a870: 3a20 2320 7072 6167 6d61 3a20 6e6f 2063  : # pragma: no c
+0000a880: 6f76 6572 0a20 2020 2020 2020 2020 2020  over.           
+0000a890: 2020 2020 2020 2020 2070 7269 6e74 2866           print(f
+0000a8a0: 225b 6c6f 6f70 2030 5d20 6173 5f62 7974  "[loop 0] as_byt
+0000a8b0: 6573 3d7b 6173 5f62 7974 6573 7d22 290a  es={as_bytes}").
+0000a8c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a8d0: 6966 2061 735f 6279 7465 733a 0a20 2020  if as_bytes:.   
+0000a8e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a8f0: 206c 6561 6469 6e67 2c20 7370 6c69 7473   leading, splits
+0000a900: 2c20 7472 6169 6c69 6e67 203d 2063 6f70  , trailing = cop
+0000a910: 792e 6465 6570 636f 7079 286f 7269 6769  y.deepcopy(origi
+0000a920: 6e61 6c73 290a 2020 2020 2020 2020 2020  nals).          
+0000a930: 2020 2020 2020 2020 2020 6c65 6164 696e            leadin
+0000a940: 6720 3d20 6269 672e 7465 7874 2e5f 6368  g = big.text._ch
+0000a950: 6561 705f 656e 636f 6465 5f69 7465 7261  eap_encode_itera
+0000a960: 626c 655f 6f66 5f73 7472 696e 6773 286c  ble_of_strings(l
+0000a970: 6561 6469 6e67 290a 2020 2020 2020 2020  eading).        
+0000a980: 2020 2020 2020 2020 2020 2020 7370 6c69              spli
+0000a990: 7473 203d 205b 6269 672e 7465 7874 2e5f  ts = [big.text._
+0000a9a0: 6368 6561 705f 656e 636f 6465 5f69 7465  cheap_encode_ite
+0000a9b0: 7261 626c 655f 6f66 5f73 7472 696e 6773  rable_of_strings
+0000a9c0: 2873 706c 6974 2920 666f 7220 7370 6c69  (split) for spli
+0000a9d0: 7420 696e 2073 706c 6974 735d 0a20 2020  t in splits].   
+0000a9e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a9f0: 2074 7261 696c 696e 6720 3d20 6269 672e   trailing = big.
+0000aa00: 7465 7874 2e5f 6368 6561 705f 656e 636f  text._cheap_enco
+0000aa10: 6465 5f69 7465 7261 626c 655f 6f66 5f73  de_iterable_of_s
+0000aa20: 7472 696e 6773 2874 7261 696c 696e 6729  trings(trailing)
+0000aa30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000aa40: 2020 2020 206f 7269 6769 6e61 6c73 203d       originals =
+0000aa50: 205b 6c65 6164 696e 672c 2073 706c 6974   [leading, split
+0000aa60: 732c 2074 7261 696c 696e 675d 0a20 2020  s, trailing].   
 0000aa70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aa80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aa90: 2065 7870 6563 7465 645f 6f72 6967 696e   expected_origin
-0000aaa0: 616c 3220 3d20 6578 7065 6374 6564 0a20  al2 = expected. 
-0000aab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aa80: 2065 6d70 7479 203d 2062 2727 0a20 2020   empty = b''.   
+0000aa90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aaa0: 2069 6620 7365 7061 7261 746f 7273 2069   if separators i
+0000aab0: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
 0000aac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aad0: 2020 2020 2020 2066 6f72 206b 6565 7020         for keep 
-0000aae0: 696e 2028 4661 6c73 652c 2054 7275 652c  in (False, True,
-0000aaf0: 2062 6967 2e41 4c54 4552 4e41 5449 4e47   big.ALTERNATING
-0000ab00: 2c20 6269 672e 4153 5f50 4149 5253 293a  , big.AS_PAIRS):
-0000ab10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000ab20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ab30: 2020 2020 2020 2020 2020 2020 2065 7870               exp
-0000ab40: 6563 7465 6420 3d20 6c69 7374 2865 7870  ected = list(exp
-0000ab50: 6563 7465 645f 6f72 6967 696e 616c 3229  ected_original2)
-0000ab60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000ab70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ab80: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000ab90: 7761 6e74 5f70 7269 6e74 733a 2023 2070  want_prints: # p
-0000aba0: 7261 676d 613a 206e 6f20 636f 7665 720a  ragma: no cover.
-0000abb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000abc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000abd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000abe0: 7072 696e 7428 6622 5b6c 6f6f 7020 375d  print(f"[loop 7]
-0000abf0: 206b 6565 703d 7b6b 6565 707d 202f 2f20   keep={keep} // 
-0000ac00: 6578 7065 6374 6564 3d7b 6578 7065 6374  expected={expect
-0000ac10: 6564 7d22 290a 2020 2020 2020 2020 2020  ed}").          
-0000ac20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ac30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ac40: 2020 6966 206e 6f74 206b 6565 703a 0a20    if not keep:. 
-0000ac50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ac60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ac70: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-0000ac80: 7870 6563 7465 6420 3d20 5b73 2e72 6570  xpected = [s.rep
-0000ac90: 6c61 6365 286e 6f6e 5f73 6570 5f6d 6172  lace(non_sep_mar
-0000aca0: 6b65 722c 2065 6d70 7479 2920 666f 7220  ker, empty) for 
-0000acb0: 692c 2073 2069 6e20 656e 756d 6572 6174  i, s in enumerat
-0000acc0: 6528 6578 7065 6374 6564 2920 6966 2069  e(expected) if i
-0000acd0: 2025 2032 203d 3d20 305d 0a20 2020 2020   % 2 == 0].     
-0000ace0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aad0: 7365 7061 7261 746f 7273 5f73 6574 203d  separators_set =
+0000aae0: 2073 6574 2862 6967 2e61 7363 6969 5f77   set(big.ascii_w
+0000aaf0: 6869 7465 7370 6163 6529 0a20 2020 2020  hitespace).     
+0000ab00: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0000ab10: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000ab20: 2020 2020 2020 2020 2020 2020 2073 6570               sep
+0000ab30: 6172 6174 6f72 7320 3d20 6269 672e 7465  arators = big.te
+0000ab40: 7874 2e5f 6368 6561 705f 656e 636f 6465  xt._cheap_encode
+0000ab50: 5f69 7465 7261 626c 655f 6f66 5f73 7472  _iterable_of_str
+0000ab60: 696e 6773 2873 6570 6172 6174 6f72 7329  ings(separators)
+0000ab70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000ab80: 2020 2020 2020 2020 2073 6570 6172 6174           separat
+0000ab90: 6f72 735f 7365 7420 3d20 7365 7428 7365  ors_set = set(se
+0000aba0: 7061 7261 746f 7273 290a 2020 2020 2020  parators).      
+0000abb0: 2020 2020 2020 2020 2020 2020 2020 6e6f                no
+0000abc0: 6e5f 7365 705f 6d61 726b 6572 203d 2062  n_sep_marker = b
+0000abd0: 2226 4e4f 4e53 4550 2622 0a20 2020 2020  "&NONSEP&".     
+0000abe0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+0000abf0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000ac00: 2020 2020 2065 6d70 7479 203d 2027 270a       empty = ''.
+0000ac10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ac20: 2020 2020 6e6f 6e5f 7365 705f 6d61 726b      non_sep_mark
+0000ac30: 6572 203d 2022 264e 4f4e 5345 5026 220a  er = "&NONSEP&".
+0000ac40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000ac50: 2066 6f72 2075 7365 5f6c 6561 6469 6e67   for use_leading
+0000ac60: 2069 6e20 2846 616c 7365 2c20 5472 7565   in (False, True
+0000ac70: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000ac80: 2020 2020 2020 2066 6f72 2075 7365 5f74         for use_t
+0000ac90: 7261 696c 696e 6720 696e 2028 4661 6c73  railing in (Fals
+0000aca0: 652c 2054 7275 6529 3a0a 2020 2020 2020  e, True):.      
+0000acb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000acc0: 2020 2320 7765 2772 6520 676f 696e 6720    # we're going 
+0000acd0: 746f 2068 6163 6b20 7570 2074 6865 7365  to hack up these
+0000ace0: 206c 6973 7473 2c0a 2020 2020 2020 2020   lists,.        
 0000acf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ad00: 2020 2020 2020 2065 6c69 6620 6b65 6570         elif keep
-0000ad10: 203d 3d20 6269 672e 4153 5f50 4149 5253   == big.AS_PAIRS
-0000ad20: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000ad30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ad40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ad50: 2020 6e65 775f 6578 7065 6374 6564 203d    new_expected =
-0000ad60: 205b 5d0a 2020 2020 2020 2020 2020 2020   [].            
-0000ad70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ad80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ad90: 2020 2020 7761 6974 696e 6720 3d20 4e6f      waiting = No
-0000ada0: 6e65 0a20 2020 2020 2020 2020 2020 2020  ne.             
-0000adb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000adc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000add0: 2020 2064 6566 2061 7070 656e 6428 7329     def append(s)
-0000ade0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000adf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ae00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ae10: 2020 2020 2020 6e6f 6e6c 6f63 616c 2077        nonlocal w
-0000ae20: 6169 7469 6e67 0a20 2020 2020 2020 2020  aiting.         
-0000ae30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ae40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ae50: 2020 2020 2020 2020 2020 2073 203d 2073             s = s
-0000ae60: 2e72 6570 6c61 6365 286e 6f6e 5f73 6570  .replace(non_sep
-0000ae70: 5f6d 6172 6b65 722c 2065 6d70 7479 290a  _marker, empty).
-0000ae80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ae90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aeb0: 2020 2020 6966 2077 6169 7469 6e67 2069      if waiting i
-0000aec0: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
-0000aed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000af00: 7761 6974 696e 6720 3d20 730a 2020 2020  waiting = s.    
-0000af10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000af20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ad00: 2320 736f 2073 7461 7274 2077 6974 6820  # so start with 
+0000ad10: 636f 7069 6573 2e0a 2020 2020 2020 2020  copies..        
+0000ad20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ad30: 6c65 6164 696e 672c 2073 706c 6974 732c  leading, splits,
+0000ad40: 2074 7261 696c 696e 6720 3d20 636f 7079   trailing = copy
+0000ad50: 2e64 6565 7063 6f70 7928 6f72 6967 696e  .deepcopy(origin
+0000ad60: 616c 7329 0a0a 2020 2020 2020 2020 2020  als)..          
+0000ad70: 2020 2020 2020 2020 2020 2020 2020 6966                if
+0000ad80: 2077 616e 745f 7072 696e 7473 3a20 2320   want_prints: # 
+0000ad90: 7072 6167 6d61 3a20 6e6f 2063 6f76 6572  pragma: no cover
+0000ada0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000adb0: 2020 2020 2020 2020 2020 2020 2070 7269               pri
+0000adc0: 6e74 2866 225b 6c6f 6f70 2031 2c32 5d20  nt(f"[loop 1,2] 
+0000add0: 7573 655f 6c65 6164 696e 673d 7b75 7365  use_leading={use
+0000ade0: 5f6c 6561 6469 6e67 7d20 7573 655f 7472  _leading} use_tr
+0000adf0: 6169 6c69 6e67 3d7b 7573 655f 7472 6169  ailing={use_trai
+0000ae00: 6c69 6e67 7d22 290a 2020 2020 2020 2020  ling}").        
+0000ae10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ae20: 2020 2020 7072 696e 7428 6622 2020 2020      print(f"    
+0000ae30: 2020 2020 206c 6561 6469 6e67 3d7b 6c65       leading={le
+0000ae40: 6164 696e 677d 2073 706c 6974 3d7b 7370  ading} split={sp
+0000ae50: 6c69 747d 2074 7261 696c 696e 673d 7b74  lit} trailing={t
+0000ae60: 7261 696c 696e 677d 2229 0a0a 2020 2020  railing}")..    
+0000ae70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ae80: 2020 2020 696e 7075 745f 7374 7269 6e67      input_string
+0000ae90: 7320 3d20 5b5d 0a20 2020 2020 2020 2020  s = [].         
+0000aea0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000aeb0: 6620 7573 655f 6c65 6164 696e 673a 0a20  f use_leading:. 
+0000aec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aed0: 2020 2020 2020 2020 2020 2069 6e70 7574             input
+0000aee0: 5f73 7472 696e 6773 2e65 7874 656e 6428  _strings.extend(
+0000aef0: 6c65 6164 696e 6729 0a20 2020 2020 2020  leading).       
+0000af00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000af10: 2066 6f72 2073 706c 6974 2069 6e20 7370   for split in sp
+0000af20: 6c69 7473 3a0a 2020 2020 2020 2020 2020  lits:.          
 0000af30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000af40: 2020 2020 7265 7475 726e 0a20 2020 2020      return.     
-0000af50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000af40: 2020 696e 7075 745f 7374 7269 6e67 732e    input_strings.
+0000af50: 6578 7465 6e64 2873 706c 6974 290a 2020  extend(split).  
 0000af60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000af70: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-0000af80: 6577 5f65 7870 6563 7465 642e 6170 7065  ew_expected.appe
-0000af90: 6e64 2828 7761 6974 696e 672c 2073 2929  nd((waiting, s))
-0000afa0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000afb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000afc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000afd0: 2020 2020 2077 6169 7469 6e67 203d 204e       waiting = N
-0000afe0: 6f6e 650a 2020 2020 2020 2020 2020 2020  one.            
-0000aff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b010: 2020 2020 666f 7220 7320 696e 2065 7870      for s in exp
-0000b020: 6563 7465 643a 0a20 2020 2020 2020 2020  ected:.         
-0000b030: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000af70: 2020 2020 2020 6966 2075 7365 5f74 7261        if use_tra
+0000af80: 696c 696e 673a 0a20 2020 2020 2020 2020  iling:.         
+0000af90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000afa0: 2020 2069 6e70 7574 5f73 7472 696e 6773     input_strings
+0000afb0: 2e65 7874 656e 6428 7472 6169 6c69 6e67  .extend(trailing
+0000afc0: 290a 0a20 2020 2020 2020 2020 2020 2020  )..             
+0000afd0: 2020 2020 2020 2020 2020 2069 6e70 7574             input
+0000afe0: 5f73 7472 696e 6720 3d20 656d 7074 792e  _string = empty.
+0000aff0: 6a6f 696e 2869 6e70 7574 5f73 7472 696e  join(input_strin
+0000b000: 6773 290a 0a20 2020 2020 2020 2020 2020  gs)..           
+0000b010: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+0000b020: 2073 6570 6172 6174 6520 696e 2028 4661   separate in (Fa
+0000b030: 6c73 652c 2054 7275 6529 3a0a 2020 2020  lse, True):.    
 0000b040: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b050: 2020 2020 2020 2020 2020 2061 7070 656e             appen
-0000b060: 6428 7329 0a20 2020 2020 2020 2020 2020  d(s).           
-0000b070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b080: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b090: 2020 2020 2023 206d 616e 7561 6c20 666c       # manual fl
-0000b0a0: 7573 680a 2020 2020 2020 2020 2020 2020  ush.            
-0000b0b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b0d0: 2020 2020 6966 2077 6169 7469 6e67 2069      if waiting i
-0000b0e0: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
-0000b0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b100: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b110: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b120: 6170 7065 6e64 2865 6d70 7479 290a 2020  append(empty).  
-0000b130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b140: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b150: 2020 2020 2020 2020 2020 2020 2020 6578                ex
-0000b160: 7065 6374 6564 203d 206e 6577 5f65 7870  pected = new_exp
-0000b170: 6563 7465 640a 2020 2020 2020 2020 2020  ected.          
-0000b180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b050: 2020 2020 2020 2020 6c65 6164 696e 672c          leading,
+0000b060: 2073 706c 6974 732c 2074 7261 696c 696e   splits, trailin
+0000b070: 6720 3d20 636f 7079 2e64 6565 7063 6f70  g = copy.deepcop
+0000b080: 7928 6f72 6967 696e 616c 7329 0a20 2020  y(originals).   
+0000b090: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b0a0: 2020 2020 2020 2020 2023 206e 6f77 2077           # now w
+0000b0b0: 6527 7265 2067 6f69 6e67 2074 6f20 6368  e're going to ch
+0000b0c0: 616e 6765 206c 6561 6469 6e67 202f 2073  ange leading / s
+0000b0d0: 706c 6974 7320 2f20 7472 6169 6c69 6e67  plits / trailing
+0000b0e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000b0f0: 2020 2020 2020 2020 2020 2020 2023 2073               # s
+0000b100: 6f20 7468 6174 2074 6865 7920 636f 6c6c  o that they coll
+0000b110: 6563 7469 7665 6c79 2061 6c74 6572 6e61  ectively alterna
+0000b120: 7465 0a20 2020 2020 2020 2020 2020 2020  te.             
+0000b130: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000b140: 2020 2020 6e6f 6e73 6570 2c20 7365 700a      nonsep, sep.
+0000b150: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000b160: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000b170: 7761 6e74 5f70 7269 6e74 733a 2023 2070  want_prints: # p
+0000b180: 7261 676d 613a 206e 6f20 636f 7665 720a  ragma: no cover.
 0000b190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b1a0: 2020 656c 6966 206b 6565 7020 3d3d 2062    elif keep == b
-0000b1b0: 6967 2e41 4c54 4552 4e41 5449 4e47 3a0a  ig.ALTERNATING:.
-0000b1c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b1d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b1a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b1b0: 7072 696e 7428 6622 5b6c 6f6f 7020 335d  print(f"[loop 3]
+0000b1c0: 2073 6570 6172 6174 653d 7b73 6570 6172   separate={separ
+0000b1d0: 6174 657d 2229 0a20 2020 2020 2020 2020  ate}").         
 0000b1e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b1f0: 2320 7374 7269 7020 6e6f 6e5f 7365 705f  # strip non_sep_
-0000b200: 6d61 726b 6572 2068 6163 6b0a 2020 2020  marker hack.    
-0000b210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b230: 2020 2020 2020 2020 2020 2020 6578 7065              expe
-0000b240: 6374 6564 203d 205b 732e 7265 706c 6163  cted = [s.replac
-0000b250: 6528 6e6f 6e5f 7365 705f 6d61 726b 6572  e(non_sep_marker
-0000b260: 2c20 656d 7074 7929 2066 6f72 2073 2069  , empty) for s i
-0000b270: 6e20 6578 7065 6374 6564 5d0a 2020 2020  n expected].    
-0000b280: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b290: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b2a0: 2020 2020 2020 2020 656c 6966 206b 6565          elif kee
-0000b2b0: 703a 0a20 2020 2020 2020 2020 2020 2020  p:.             
-0000b2c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b2d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b2e0: 2020 206e 6577 5f65 7870 6563 7465 6420     new_expected 
-0000b2f0: 3d20 5b5d 0a20 2020 2020 2020 2020 2020  = [].           
-0000b300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b320: 2020 2020 2077 6169 7469 6e67 203d 204e       waiting = N
-0000b330: 6f6e 650a 2020 2020 2020 2020 2020 2020  one.            
-0000b340: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b360: 2020 2020 6465 6620 6170 7065 6e64 2873      def append(s
-0000b370: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000b1f0: 2020 2020 2020 2070 7269 6e74 2866 2220         print(f" 
+0000b200: 2020 206c 6561 6469 6e67 3d7b 6c65 6164     leading={lead
+0000b210: 696e 677d 2073 706c 6974 733d 7b73 706c  ing} splits={spl
+0000b220: 6974 737d 2074 7261 696c 696e 673d 7b74  its} trailing={t
+0000b230: 7261 696c 696e 677d 2229 0a0a 2020 2020  railing}")..    
+0000b240: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b250: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
+0000b260: 6570 6172 6174 653a 0a20 2020 2020 2020  eparate:.       
+0000b270: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b280: 2020 2020 2020 2020 2023 2062 6c6f 6220           # blob 
+0000b290: 7468 6520 7365 7061 7261 746f 7273 2074  the separators t
+0000b2a0: 6f67 6574 6865 720a 2020 2020 2020 2020  ogether.        
+0000b2b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b2c0: 2020 2020 2020 2020 6c32 203d 205b 656d          l2 = [em
+0000b2d0: 7074 795d 0a20 2020 2020 2020 2020 2020  pty].           
+0000b2e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b2f0: 2020 2020 2069 6620 7761 6e74 5f70 7269       if want_pri
+0000b300: 6e74 733a 2023 2070 7261 676d 613a 206e  nts: # pragma: n
+0000b310: 6f20 636f 7665 720a 2020 2020 2020 2020  o cover.        
+0000b320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b330: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+0000b340: 7428 6622 2020 2020 626c 6f62 2074 6f67  t(f"    blob tog
+0000b350: 6574 6865 7220 656d 7074 793d 7b65 6d70  ether empty={emp
+0000b360: 7479 7d20 6c65 6164 696e 673d 7b6c 6561  ty} leading={lea
+0000b370: 6469 6e67 7d22 290a 2020 2020 2020 2020  ding}").        
 0000b380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b3a0: 2020 2020 2020 206e 6f6e 6c6f 6361 6c20         nonlocal 
-0000b3b0: 7761 6974 696e 670a 2020 2020 2020 2020  waiting.        
+0000b390: 2020 2020 2020 2020 6c32 2e61 7070 656e          l2.appen
+0000b3a0: 6428 656d 7074 792e 6a6f 696e 286c 6561  d(empty.join(lea
+0000b3b0: 6469 6e67 2929 0a20 2020 2020 2020 2020  ding)).         
 0000b3c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b3d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b3e0: 2020 2020 2020 2020 2020 2020 6973 5f73              is_s
-0000b3f0: 6570 203d 2073 2069 6e20 7365 7061 7261  ep = s in separa
-0000b400: 746f 7273 5f73 6574 0a20 2020 2020 2020  tors_set.       
-0000b410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b420: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b430: 2020 2020 2020 2020 2020 2020 2073 203d               s =
-0000b440: 2073 2e72 6570 6c61 6365 286e 6f6e 5f73   s.replace(non_s
-0000b450: 6570 5f6d 6172 6b65 722c 2065 6d70 7479  ep_marker, empty
-0000b460: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0000b470: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b3d0: 2020 2020 2020 206c 6561 6469 6e67 203d         leading =
+0000b3e0: 206c 320a 2020 2020 2020 2020 2020 2020   l2.            
+0000b3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b400: 2020 2020 6966 2077 616e 745f 7072 696e      if want_prin
+0000b410: 7473 3a20 2320 7072 6167 6d61 3a20 6e6f  ts: # pragma: no
+0000b420: 2063 6f76 6572 0a20 2020 2020 2020 2020   cover.         
+0000b430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b440: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+0000b450: 2866 2220 2020 2062 6c6f 6262 6564 206c  (f"    blobbed l
+0000b460: 6561 6469 6e67 3d7b 6c65 6164 696e 677d  eading={leading}
+0000b470: 2229 0a0a 2020 2020 2020 2020 2020 2020  ")..            
 0000b480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b490: 2020 2020 2020 6966 2028 7761 6974 696e        if (waitin
-0000b4a0: 6720 6973 204e 6f6e 6529 2061 6e64 2028  g is None) and (
-0000b4b0: 6e6f 7420 6973 5f73 6570 293a 0a20 2020  not is_sep):.   
-0000b4c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b4d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b490: 2020 2020 666f 7220 7370 6c69 7420 696e      for split in
+0000b4a0: 2073 706c 6974 733a 0a20 2020 2020 2020   splits:.       
+0000b4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b4c0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000b4d0: 6c65 6e28 7370 6c69 7429 203e 2031 3a0a  len(split) > 1:.
 0000b4e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b4f0: 2020 2020 2077 6169 7469 6e67 203d 2073       waiting = s
-0000b500: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000b510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b520: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b530: 2020 2020 2020 2020 2072 6574 7572 6e0a           return.
-0000b540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b550: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b500: 2020 2020 2020 2020 6a6f 696e 6564 203d          joined =
+0000b510: 2065 6d70 7479 2e6a 6f69 6e28 7370 6c69   empty.join(spli
+0000b520: 745b 313a 5d29 0a20 2020 2020 2020 2020  t[1:]).         
+0000b530: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b540: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+0000b550: 656c 2073 706c 6974 5b31 3a5d 0a20 2020  el split[1:].   
 0000b560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b570: 2020 2020 6966 2077 6169 7469 6e67 2069      if waiting i
-0000b580: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
-0000b590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b580: 2020 2020 2073 706c 6974 2e61 7070 656e       split.appen
+0000b590: 6428 6a6f 696e 6564 290a 0a20 2020 2020  d(joined)..     
 0000b5a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b5b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b5c0: 2020 2020 7320 3d20 7761 6974 696e 6720      s = waiting 
-0000b5d0: 2b20 730a 2020 2020 2020 2020 2020 2020  + s.            
-0000b5e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b5b0: 2020 2020 2020 2020 2020 2074 7261 696c             trail
+0000b5c0: 696e 6720 3d20 5b65 6d70 7479 2e6a 6f69  ing = [empty.joi
+0000b5d0: 6e28 7472 6169 6c69 6e67 292c 2065 6d70  n(trailing), emp
+0000b5e0: 7479 5d0a 2020 2020 2020 2020 2020 2020  ty].            
 0000b5f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b600: 2020 2020 2020 2020 6e65 775f 6578 7065          new_expe
-0000b610: 6374 6564 2e61 7070 656e 6428 7329 0a20  cted.append(s). 
-0000b620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b650: 2020 2077 6169 7469 6e67 203d 204e 6f6e     waiting = Non
-0000b660: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
-0000b670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b690: 2020 666f 7220 7320 696e 2065 7870 6563    for s in expec
-0000b6a0: 7465 643a 0a20 2020 2020 2020 2020 2020  ted:.           
-0000b6b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b6c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b6d0: 2020 2020 2020 2020 2061 7070 656e 6428           append(
-0000b6e0: 7329 0a20 2020 2020 2020 2020 2020 2020  s).             
-0000b6f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b600: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0000b610: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b620: 2020 2020 2020 2320 7475 726e 206c 6561        # turn lea
+0000b630: 6469 6e67 2c20 7370 6c69 7473 2c20 616e  ding, splits, an
+0000b640: 6420 7472 6169 6c69 6e67 0a20 2020 2020  d trailing.     
+0000b650: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b660: 2020 2020 2020 2020 2020 2023 2069 6e74             # int
+0000b670: 6f20 7375 6974 6162 6c65 2066 6f72 6d20  o suitable form 
+0000b680: 666f 7220 7465 7374 696e 6720 7769 7468  for testing with
+0000b690: 2022 7365 7061 7261 7465 222e 0a20 2020   "separate"..   
+0000b6a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b6b0: 2020 2020 2020 2020 2020 2020 2023 2020               #  
+0000b6c0: 202a 2065 7665 7279 206c 6973 7420 6973   * every list is
+0000b6d0: 2061 206c 6973 7420 6f66 2061 6c74 6572   a list of alter
+0000b6e0: 6e61 7469 6e67 2073 6570 2061 6e64 206e  nating sep and n
+0000b6f0: 6f6e 7365 702e 0a20 2020 2020 2020 2020  onsep..         
 0000b700: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b710: 2020 2023 206d 616e 7561 6c20 666c 7573     # manual flus
-0000b720: 680a 2020 2020 2020 2020 2020 2020 2020  h.              
-0000b730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b750: 2020 6966 2077 6169 7469 6e67 2069 7320    if waiting is 
-0000b760: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
-0000b770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b790: 2020 2020 2020 2020 2020 2020 2020 6e65                ne
-0000b7a0: 775f 6578 7065 6374 6564 2e61 7070 656e  w_expected.appen
-0000b7b0: 6428 7761 6974 696e 6729 0a20 2020 2020  d(waiting).     
-0000b7c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b710: 2020 2020 2020 2023 2020 202a 2073 706c         #   * spl
+0000b720: 6974 7320 6e6f 7720 6861 7320 656d 7074  its now has empt
+0000b730: 7920 7374 7269 6e67 7320 6265 7477 6565  y strings betwee
+0000b740: 6e20 7365 7020 616e 6420 6e6f 6e73 6570  n sep and nonsep
+0000b750: 2e0a 2020 2020 2020 2020 2020 2020 2020  ..              
+0000b760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b770: 2020 6173 7365 7274 206c 656e 286c 6561    assert len(lea
+0000b780: 6469 6e67 2920 3e3d 2032 0a20 2020 2020  ding) >= 2.     
+0000b790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b7a0: 2020 2020 2020 2020 2020 2073 6570 6172             separ
+0000b7b0: 6174 655f 6c65 6164 696e 6720 3d20 6c69  ate_leading = li
+0000b7c0: 7374 286c 6561 6469 6e67 5b3a 325d 290a  st(leading[:2]).
 0000b7d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b7e0: 2020 2020 2020 2020 2020 2065 7870 6563             expec
-0000b7f0: 7465 6420 3d20 6e65 775f 6578 7065 6374  ted = new_expect
-0000b800: 6564 0a20 2020 2020 2020 2020 2020 2020  ed.             
+0000b7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b7f0: 666f 7220 7320 696e 206c 6561 6469 6e67  for s in leading
+0000b800: 5b32 3a5d 3a0a 2020 2020 2020 2020 2020  [2:]:.          
 0000b810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b830: 2020 2069 6620 7761 6e74 5f70 7269 6e74     if want_print
-0000b840: 733a 2023 2070 7261 676d 613a 206e 6f20  s: # pragma: no 
-0000b850: 636f 7665 720a 2020 2020 2020 2020 2020  cover.          
-0000b860: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b870: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b880: 2020 2020 2020 2020 2020 7072 696e 7428            print(
-0000b890: 6622 2020 2020 6e6f 7720 6578 7065 6374  f"    now expect
-0000b8a0: 6564 3d7b 6578 7065 6374 6564 7d22 290a  ed={expected}").
-0000b8b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000b8c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b8d0: 2020 2020 2020 2020 2020 2020 2072 6573               res
-0000b8e0: 756c 7420 3d20 6c69 7374 2862 6967 2e6d  ult = list(big.m
-0000b8f0: 756c 7469 7370 6c69 7428 696e 7075 745f  ultisplit(input_
-0000b900: 7374 7269 6e67 2c20 7365 7061 7261 746f  string, separato
-0000b910: 7273 2c0a 2020 2020 2020 2020 2020 2020  rs,.            
-0000b920: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b940: 2020 2020 6b65 6570 3d6b 6565 702c 0a20      keep=keep,. 
+0000b820: 2020 2020 2020 2020 2020 7365 7061 7261            separa
+0000b830: 7465 5f6c 6561 6469 6e67 2e61 7070 656e  te_leading.appen
+0000b840: 6428 656d 7074 7929 0a20 2020 2020 2020  d(empty).       
+0000b850: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b860: 2020 2020 2020 2020 2020 2020 2073 6570               sep
+0000b870: 6172 6174 655f 6c65 6164 696e 672e 6170  arate_leading.ap
+0000b880: 7065 6e64 2873 290a 2020 2020 2020 2020  pend(s).        
+0000b890: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b8a0: 2020 2020 2020 2020 6c65 6164 696e 6720          leading 
+0000b8b0: 3d20 7365 7061 7261 7465 5f6c 6561 6469  = separate_leadi
+0000b8c0: 6e67 0a20 2020 2020 2020 2020 2020 2020  ng.             
+0000b8d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b8e0: 2020 2069 6620 7761 6e74 5f70 7269 6e74     if want_print
+0000b8f0: 733a 2023 2070 7261 676d 613a 206e 6f20  s: # pragma: no 
+0000b900: 636f 7665 720a 2020 2020 2020 2020 2020  cover.          
+0000b910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b920: 2020 2020 2020 2020 2020 7072 696e 7428            print(
+0000b930: 6622 2020 2020 6c65 6164 696e 673d 7b6c  f"    leading={l
+0000b940: 6561 6469 6e67 7d22 290a 0a20 2020 2020  eading}")..     
 0000b950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b960: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b970: 2020 2020 2020 2020 2020 2020 2020 206d                 m
-0000b980: 6178 7370 6c69 743d 6d61 7873 706c 6974  axsplit=maxsplit
-0000b990: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0000b9a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b9b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b9c0: 2020 7265 7665 7273 653d 7265 7665 7273    reverse=revers
-0000b9d0: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
-0000b9e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b960: 2020 2020 2020 2020 2020 2073 6570 6172             separ
+0000b970: 6174 655f 7370 6c69 7473 203d 205b 5d0a  ate_splits = [].
+0000b980: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b990: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b9a0: 666f 7220 7370 6c69 7420 696e 2073 706c  for split in spl
+0000b9b0: 6974 733a 0a20 2020 2020 2020 2020 2020  its:.           
+0000b9c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b9d0: 2020 2020 2020 2020 2069 6620 6c65 6e28           if len(
+0000b9e0: 7370 6c69 7429 203d 3d20 313a 0a20 2020  split) == 1:.   
 0000b9f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ba00: 2020 2073 6570 6172 6174 653d 7365 7061     separate=sepa
-0000ba10: 7261 7465 2c0a 2020 2020 2020 2020 2020  rate,.          
-0000ba20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ba00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ba10: 2020 2020 2061 7373 6572 7420 7370 6c69       assert spli
+0000ba20: 7420 3d3d 2073 706c 6974 735b 2d31 5d0a  t == splits[-1].
 0000ba30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ba40: 2020 2020 2020 7374 7269 703d 7374 7269        strip=stri
-0000ba50: 702c 0a20 2020 2020 2020 2020 2020 2020  p,.             
-0000ba60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ba70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ba80: 2020 2029 290a 2020 2020 2020 2020 2020     )).          
-0000ba90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000baa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bab0: 2020 6966 2077 616e 745f 7072 696e 7473    if want_prints
-0000bac0: 3a20 2320 7072 6167 6d61 3a20 6e6f 2063  : # pragma: no c
-0000bad0: 6f76 6572 0a20 2020 2020 2020 2020 2020  over.           
+0000ba40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ba50: 2020 2020 2020 2020 7365 7061 7261 7465          separate
+0000ba60: 5f73 706c 6974 732e 6170 7065 6e64 2873  _splits.append(s
+0000ba70: 706c 6974 290a 2020 2020 2020 2020 2020  plit).          
+0000ba80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ba90: 2020 2020 2020 2020 2020 2020 2020 6272                br
+0000baa0: 6561 6b0a 2020 2020 2020 2020 2020 2020  eak.            
+0000bab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bac0: 2020 2020 2020 2020 6173 7365 7274 206c          assert l
+0000bad0: 656e 2873 706c 6974 2920 3e3d 2032 0a20  en(split) >= 2. 
 0000bae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000baf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bb00: 2020 2020 2070 7269 6e74 2866 2261 735f       print(f"as_
-0000bb10: 6279 7465 733d 7b61 735f 6279 7465 737d  bytes={as_bytes}
-0000bb20: 2075 7365 5f6c 6561 6469 6e67 3d7b 7573   use_leading={us
-0000bb30: 655f 6c65 6164 696e 677d 2075 7365 5f74  e_leading} use_t
-0000bb40: 7261 696c 696e 673d 7b75 7365 5f74 7261  railing={use_tra
-0000bb50: 696c 696e 677d 2229 0a20 2020 2020 2020  iling}").       
-0000bb60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bb00: 2020 2073 6570 6172 6174 655f 7370 6c69     separate_spli
+0000bb10: 7473 2e61 7070 656e 6428 6c69 7374 2873  ts.append(list(s
+0000bb20: 706c 6974 5b3a 325d 2929 0a20 2020 2020  plit[:2])).     
+0000bb30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bb40: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+0000bb50: 6f72 2073 2069 6e20 7370 6c69 745b 323a  or s in split[2:
+0000bb60: 5d3a 0a20 2020 2020 2020 2020 2020 2020  ]:.             
 0000bb70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bb80: 2020 2020 2020 2020 2070 7269 6e74 2866           print(f
-0000bb90: 226d 756c 7469 7370 6c69 7428 7b69 6e70  "multisplit({inp
-0000bba0: 7574 5f73 7472 696e 6721 727d 2c20 7365  ut_string!r}, se
-0000bbb0: 7061 7261 746f 7273 3d7b 7072 696e 7461  parators={printa
-0000bbc0: 626c 655f 7365 7061 7261 746f 7273 2873  ble_separators(s
-0000bbd0: 6570 6172 6174 6f72 7329 7d2c 206b 6565  eparators)}, kee
-0000bbe0: 703d 7b6b 6565 707d 2c20 7365 7061 7261  p={keep}, separa
-0000bbf0: 7465 3d7b 7365 7061 7261 7465 7d2c 2073  te={separate}, s
-0000bc00: 7472 6970 3d7b 7374 7269 707d 2c20 7265  trip={strip}, re
-0000bc10: 7665 7273 653d 7b72 6576 6572 7365 7d2c  verse={reverse},
-0000bc20: 206d 6178 7370 6c69 743d 7b6d 6178 7370   maxsplit={maxsp
-0000bc30: 6c69 747d 2922 290a 2020 2020 2020 2020  lit})").        
-0000bc40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bc50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bc60: 2020 2020 2020 2020 7072 696e 7428 6622          print(f"
-0000bc70: 2020 7265 7375 6c74 3d7b 7265 7375 6c74    result={result
-0000bc80: 7d22 290a 2020 2020 2020 2020 2020 2020  }").            
-0000bc90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bcb0: 2020 2020 7072 696e 7428 6622 6578 7065      print(f"expe
-0000bcc0: 6374 6564 3d7b 6578 7065 6374 6564 7d22  cted={expected}"
-0000bcd0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000bb80: 2020 2020 2020 2020 2020 2073 6570 6172             separ
+0000bb90: 6174 655f 7370 6c69 7473 2e61 7070 656e  ate_splits.appen
+0000bba0: 6428 5b65 6d70 7479 2c20 735d 290a 2020  d([empty, s]).  
+0000bbb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bbc0: 2020 2020 2020 2020 2020 2020 2020 7370                sp
+0000bbd0: 6c69 7473 203d 2073 6570 6172 6174 655f  lits = separate_
+0000bbe0: 7370 6c69 7473 0a20 2020 2020 2020 2020  splits.         
+0000bbf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bc00: 2020 2020 2020 2069 6620 7761 6e74 5f70         if want_p
+0000bc10: 7269 6e74 733a 2023 2070 7261 676d 613a  rints: # pragma:
+0000bc20: 206e 6f20 636f 7665 720a 2020 2020 2020   no cover.      
+0000bc30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bc40: 2020 2020 2020 2020 2020 2020 2020 7072                pr
+0000bc50: 696e 7428 6622 2020 2020 7370 6c69 7473  int(f"    splits
+0000bc60: 3d7b 7370 6c69 7473 7d22 290a 0a20 2020  ={splits}")..   
+0000bc70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bc80: 2020 2020 2020 2020 2020 2020 2073 6570               sep
+0000bc90: 6172 6174 655f 7472 6169 6c69 6e67 203d  arate_trailing =
+0000bca0: 205b 5d0a 2020 2020 2020 2020 2020 2020   [].            
+0000bcb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bcc0: 2020 2020 666f 7220 7320 696e 2074 7261      for s in tra
+0000bcd0: 696c 696e 673a 0a20 2020 2020 2020 2020  iling:.         
 0000bce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bcf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bd00: 2020 7072 696e 7428 225f 5f5f 5f5f 5f5f    print("_______
-0000bd10: 5f22 290a 2020 2020 2020 2020 2020 2020  _").            
+0000bcf0: 2020 2020 2020 2020 2020 2069 6620 733a             if s:
+0000bd00: 2023 2073 6b69 7020 7468 6520 7472 6169   # skip the trai
+0000bd10: 6c69 6e67 2065 6d70 7479 0a20 2020 2020  ling empty.     
 0000bd20: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000bd30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bd40: 2020 2020 7072 696e 7428 290a 2020 2020      print().    
-0000bd50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bd40: 2020 2073 6570 6172 6174 655f 7472 6169     separate_trai
+0000bd50: 6c69 6e67 2e61 7070 656e 6428 7329 0a20  ling.append(s). 
 0000bd60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bd70: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
-0000bd80: 6572 7445 7175 616c 2872 6573 756c 742c  ertEqual(result,
-0000bd90: 2065 7870 6563 7465 642c 2066 2261 735f   expected, f"as_
-0000bda0: 6279 7465 733d 7b61 735f 6279 7465 737d  bytes={as_bytes}
-0000bdb0: 2075 7365 5f6c 6561 6469 6e67 3d7b 7573   use_leading={us
-0000bdc0: 655f 6c65 6164 696e 677d 2075 7365 5f74  e_leading} use_t
-0000bdd0: 7261 696c 696e 673d 7b75 7365 5f74 7261  railing={use_tra
-0000bde0: 696c 696e 677d 206d 756c 7469 7370 6c69  iling} multispli
-0000bdf0: 7428 696e 7075 745f 7374 7269 6e67 3d7b  t(input_string={
-0000be00: 696e 7075 745f 7374 7269 6e67 7d2c 2073  input_string}, s
-0000be10: 6570 6172 6174 6f72 733d 7b70 7269 6e74  eparators={print
-0000be20: 6162 6c65 5f73 6570 6172 6174 6f72 7328  able_separators(
-0000be30: 7365 7061 7261 746f 7273 297d 2c20 6b65  separators)}, ke
-0000be40: 6570 3d7b 6b65 6570 7d2c 2073 6570 6172  ep={keep}, separ
-0000be50: 6174 653d 7b73 6570 6172 6174 657d 2c20  ate={separate}, 
-0000be60: 7374 7269 703d 7b73 7472 6970 7d2c 2072  strip={strip}, r
-0000be70: 6576 6572 7365 3d7b 7265 7665 7273 657d  everse={reverse}
-0000be80: 2c20 6d61 7873 706c 6974 3d7b 6d61 7873  , maxsplit={maxs
-0000be90: 706c 6974 7d29 2229 0a0a 0a20 2020 2020  plit})")...     
-0000bea0: 2020 2074 6573 745f 7374 7269 6e67 203d     test_string =
-0000beb0: 205b 0a20 2020 2020 2020 2020 2020 2027   [.            '
-0000bec0: 2027 2c0a 2020 2020 2020 2020 2020 2020   ',.            
-0000bed0: 2761 272c 0a20 2020 2020 2020 2020 2020  'a',.           
-0000bee0: 2027 2027 2c0a 2020 2020 2020 2020 2020   ' ',.          
-0000bef0: 2020 2762 272c 0a20 2020 2020 2020 2020    'b',.         
-0000bf00: 2020 2027 2027 2c0a 2020 2020 2020 2020     ' ',.        
-0000bf10: 2020 2020 2763 272c 0a20 2020 2020 2020      'c',.       
-0000bf20: 2020 2020 2027 2027 2c0a 2020 2020 2020       ' ',.      
-0000bf30: 2020 2020 2020 5d0a 0a20 2020 2020 2020        ]..       
-0000bf40: 206d 756c 7469 7370 6c69 745f 7465 7374   multisplit_test
-0000bf50: 6572 280a 2020 2020 2020 2020 2020 2020  er(.            
-0000bf60: 2a74 6573 745f 7374 7269 6e67 2c0a 2020  *test_string,.  
-0000bf70: 2020 2020 2020 2020 2020 2827 2027 2c29            (' ',)
-0000bf80: 2c0a 2020 2020 2020 2020 2020 2020 290a  ,.            ).
-0000bf90: 0a20 2020 2020 2020 206d 756c 7469 7370  .        multisp
-0000bfa0: 6c69 745f 7465 7374 6572 280a 2020 2020  lit_tester(.    
-0000bfb0: 2020 2020 2020 2020 2a74 6573 745f 7374          *test_st
-0000bfc0: 7269 6e67 2c0a 2020 2020 2020 2020 2020  ring,.          
-0000bfd0: 2020 4e6f 6e65 2c0a 2020 2020 2020 2020    None,.        
-0000bfe0: 2020 2020 290a 0a0a 2020 2020 2020 2020      )...        
-0000bff0: 6d75 6c74 6973 706c 6974 5f74 6573 7465  multisplit_teste
-0000c000: 7228 0a20 2020 2020 2020 2020 2020 2027  r(.            '
-0000c010: 2027 2c0a 2020 2020 2020 2020 2020 2020   ',.            
-0000c020: 275c 7427 2c0a 2020 2020 2020 2020 2020  '\t',.          
-0000c030: 2020 2720 272c 0a20 2020 2020 2020 2020    ' ',.         
-0000c040: 2020 2027 5c6e 272c 0a20 2020 2020 2020     '\n',.       
-0000c050: 2020 2020 2027 2027 2c0a 0a20 2020 2020       ' ',..     
-0000c060: 2020 2020 2020 2027 6127 2c0a 0a20 2020         'a',..   
-0000c070: 2020 2020 2020 2020 2027 2027 2c0a 2020           ' ',.  
-0000c080: 2020 2020 2020 2020 2020 275c 7427 2c0a            '\t',.
-0000c090: 2020 2020 2020 2020 2020 2020 2720 272c              ' ',
-0000c0a0: 0a20 2020 2020 2020 2020 2020 2027 5c6e  .            '\n
-0000c0b0: 272c 0a0a 2020 2020 2020 2020 2020 2020  ',..            
-0000c0c0: 2762 272c 0a0a 2020 2020 2020 2020 2020  'b',..          
-0000c0d0: 2020 275c 7427 2c0a 2020 2020 2020 2020    '\t',.        
-0000c0e0: 2020 2020 2720 272c 0a20 2020 2020 2020      ' ',.       
-0000c0f0: 2020 2020 2027 5c6e 272c 0a0a 2020 2020       '\n',..    
-0000c100: 2020 2020 2020 2020 2763 272c 0a0a 2020          'c',..  
-0000c110: 2020 2020 2020 2020 2020 2720 272c 0a20            ' ',. 
-0000c120: 2020 2020 2020 2020 2020 2027 2027 2c0a             ' ',.
-0000c130: 2020 2020 2020 2020 2020 2020 275c 6e27              '\n'
-0000c140: 2c0a 0a20 2020 2020 2020 2020 2020 2062  ,..            b
-0000c150: 6967 2e77 6869 7465 7370 6163 652c 0a20  ig.whitespace,. 
-0000c160: 2020 2020 2020 2020 2020 2029 0a0a 0a20             )... 
-0000c170: 2020 2020 2020 206d 756c 7469 7370 6c69         multispli
-0000c180: 745f 7465 7374 6572 280a 2020 2020 2020  t_tester(.      
-0000c190: 2020 2020 2020 2778 272c 0a20 2020 2020        'x',.     
-0000c1a0: 2020 2020 2020 2027 7927 2c0a 2020 2020         'y',.    
-0000c1b0: 2020 2020 2020 2020 2778 272c 0a20 2020          'x',.   
-0000c1c0: 2020 2020 2020 2020 2027 7927 2c0a 0a20           'y',.. 
-0000c1d0: 2020 2020 2020 2020 2020 2027 6127 2c0a             'a',.
-0000c1e0: 0a20 2020 2020 2020 2020 2020 2027 7827  .            'x'
-0000c1f0: 2c0a 2020 2020 2020 2020 2020 2020 2779  ,.            'y
-0000c200: 272c 0a20 2020 2020 2020 2020 2020 2027  ',.            '
-0000c210: 7827 2c0a 2020 2020 2020 2020 2020 2020  x',.            
-0000c220: 2779 272c 0a20 2020 2020 2020 2020 2020  'y',.           
-0000c230: 2027 7827 2c0a 0a20 2020 2020 2020 2020   'x',..         
-0000c240: 2020 2027 6227 2c0a 0a20 2020 2020 2020     'b',..       
-0000c250: 2020 2020 2027 7927 2c0a 0a20 2020 2020       'y',..     
-0000c260: 2020 2020 2020 2027 6327 2c0a 0a20 2020         'c',..   
-0000c270: 2020 2020 2020 2020 2027 7827 2c0a 2020           'x',.  
-0000c280: 2020 2020 2020 2020 2020 2779 272c 0a20            'y',. 
-0000c290: 2020 2020 2020 2020 2020 2027 7827 2c0a             'x',.
-0000c2a0: 2020 2020 2020 2020 2020 2020 2779 272c              'y',
-0000c2b0: 0a20 2020 2020 2020 2020 2020 2027 7827  .            'x'
-0000c2c0: 2c0a 2020 2020 2020 2020 2020 2020 2779  ,.            'y
-0000c2d0: 272c 0a0a 2020 2020 2020 2020 2020 2020  ',..            
-0000c2e0: 2764 272c 0a0a 2020 2020 2020 2020 2020  'd',..          
-0000c2f0: 2020 2779 272c 0a20 2020 2020 2020 2020    'y',.         
-0000c300: 2020 2027 7827 2c0a 0a20 2020 2020 2020     'x',..       
-0000c310: 2020 2020 2027 6527 2c0a 0a20 2020 2020       'e',..     
-0000c320: 2020 2020 2020 2027 7927 2c0a 2020 2020         'y',.    
-0000c330: 2020 2020 2020 2020 2779 272c 0a20 2020          'y',.   
-0000c340: 2020 2020 2020 2020 2027 7927 2c0a 2020           'y',.  
-0000c350: 2020 2020 2020 2020 2020 2779 272c 0a0a            'y',..
-0000c360: 2020 2020 2020 2020 2020 2020 2766 272c              'f',
-0000c370: 0a0a 2020 2020 2020 2020 2020 2020 2778  ..            'x
-0000c380: 272c 0a20 2020 2020 2020 2020 2020 2027  ',.            '
-0000c390: 7827 2c0a 2020 2020 2020 2020 2020 2020  x',.            
-0000c3a0: 2778 272c 0a20 2020 2020 2020 2020 2020  'x',.           
-0000c3b0: 2027 7827 2c0a 2020 2020 2020 2020 2020   'x',.          
-0000c3c0: 2020 2778 272c 0a20 2020 2020 2020 2020    'x',.         
-0000c3d0: 2020 2027 7827 2c0a 0a20 2020 2020 2020     'x',..       
-0000c3e0: 2020 2020 2028 2778 272c 2027 7927 292c       ('x', 'y'),
-0000c3f0: 0a20 2020 2020 2020 2020 2020 2029 0a0a  .            )..
-0000c400: 2020 2020 6465 6620 7465 7374 5f6d 756c      def test_mul
-0000c410: 7469 7061 7274 6974 696f 6e28 7365 6c66  tipartition(self
-0000c420: 293a 0a20 2020 2020 2020 2064 6566 2074  ):.        def t
-0000c430: 6573 745f 6d75 6c74 6970 6172 7469 7469  est_multipartiti
-0000c440: 6f6e 2873 2c20 7365 7061 7261 746f 722c  on(s, separator,
-0000c450: 2063 6f75 6e74 2c20 6578 7065 6374 6564   count, expected
-0000c460: 2c20 2a2c 2072 6576 6572 7365 3d46 616c  , *, reverse=Fal
-0000c470: 7365 293a 0a20 2020 2020 2020 2020 2020  se):.           
-0000c480: 2066 6f72 205f 2069 6e20 7261 6e67 6528   for _ in range(
-0000c490: 3229 3a0a 2020 2020 2020 2020 2020 2020  2):.            
-0000c4a0: 2020 2020 6966 205f 203d 3d20 313a 0a20      if _ == 1:. 
-0000c4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c4c0: 2020 2023 2065 6e63 6f64 6521 0a20 2020     # encode!.   
-0000c4d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c4e0: 2073 203d 2073 2e65 6e63 6f64 6528 2761   s = s.encode('a
-0000c4f0: 7363 6969 2729 0a20 2020 2020 2020 2020  scii').         
-0000c500: 2020 2020 2020 2020 2020 2023 2069 6620             # if 
-0000c510: 7365 7061 7261 746f 7220 3d3d 2062 6967  separator == big
-0000c520: 2e77 6869 7465 7370 6163 653a 0a20 2020  .whitespace:.   
-0000c530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c540: 2023 2020 2020 2073 6570 6172 6174 6f72   #     separator
-0000c550: 203d 2062 6967 2e61 7363 6969 5f77 6869   = big.ascii_whi
-0000c560: 7465 7370 6163 650a 2020 2020 2020 2020  tespace.        
-0000c570: 2020 2020 2020 2020 2020 2020 6966 2069              if i
-0000c580: 7369 6e73 7461 6e63 6528 7365 7061 7261  sinstance(separa
-0000c590: 746f 722c 2073 7472 293a 0a20 2020 2020  tor, str):.     
+0000bd70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bd80: 2020 2020 2020 2073 6570 6172 6174 655f         separate_
+0000bd90: 7472 6169 6c69 6e67 2e61 7070 656e 6428  trailing.append(
+0000bda0: 656d 7074 7929 0a20 2020 2020 2020 2020  empty).         
+0000bdb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bdc0: 2020 2020 2020 2074 7261 696c 696e 6720         trailing 
+0000bdd0: 3d20 7365 7061 7261 7465 5f74 7261 696c  = separate_trail
+0000bde0: 696e 670a 2020 2020 2020 2020 2020 2020  ing.            
+0000bdf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000be00: 2020 2020 6966 2077 616e 745f 7072 696e      if want_prin
+0000be10: 7473 3a20 2320 7072 6167 6d61 3a20 6e6f  ts: # pragma: no
+0000be20: 2063 6f76 6572 0a20 2020 2020 2020 2020   cover.         
+0000be30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000be40: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+0000be50: 2866 2220 2020 2074 7261 696c 696e 673d  (f"    trailing=
+0000be60: 7b74 7261 696c 696e 677d 2229 0a0a 2020  {trailing}")..  
+0000be70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000be80: 2020 2020 2020 2020 2020 2320 7469 6d65            # time
+0000be90: 2074 6f20 6368 6563 6b21 2020 6576 6572   to check!  ever
+0000bea0: 7920 6c69 7374 206f 7220 7375 626c 6973  y list or sublis
+0000beb0: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
+0000bec0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+0000bed0: 7368 6f75 6c64 206e 6f77 2068 6176 6520  should now have 
+0000bee0: 616e 2065 7665 6e20 6c65 6e67 7468 2c0a  an even length,.
+0000bef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bf00: 2020 2020 2020 2020 2020 2020 2320 4558              # EX
+0000bf10: 4345 5054 2073 706c 6974 735b 2d31 5d20  CEPT splits[-1] 
+0000bf20: 7768 6963 6820 6973 206c 656e 6774 6820  which is length 
+0000bf30: 312e 0a20 2020 2020 2020 2020 2020 2020  1..             
+0000bf40: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+0000bf50: 7373 6572 7420 6c65 6e28 6c65 6164 696e  ssert len(leadin
+0000bf60: 6729 2025 2032 203d 3d20 300a 2020 2020  g) % 2 == 0.    
+0000bf70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bf80: 2020 2020 2020 2020 666f 7220 7370 6c69          for spli
+0000bf90: 7420 696e 2073 706c 6974 735b 3a2d 315d  t in splits[:-1]
+0000bfa0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000bfb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bfc0: 2020 6173 7365 7274 206c 656e 2873 706c    assert len(spl
+0000bfd0: 6974 2920 2520 3220 3d3d 2030 0a20 2020  it) % 2 == 0.   
+0000bfe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bff0: 2020 2020 2020 2020 2061 7373 6572 7420           assert 
+0000c000: 6c65 6e28 7370 6c69 7473 5b2d 315d 2920  len(splits[-1]) 
+0000c010: 3d3d 2031 0a20 2020 2020 2020 2020 2020  == 1.           
+0000c020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c030: 2061 7373 6572 7420 6c65 6e28 7472 6169   assert len(trai
+0000c040: 6c69 6e67 2920 2520 3220 3d3d 2030 0a0a  ling) % 2 == 0..
+0000c050: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c060: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+0000c070: 7374 7269 7020 696e 2028 4661 6c73 652c  strip in (False,
+0000c080: 2062 6967 2e4c 4546 542c 2062 6967 2e52   big.LEFT, big.R
+0000c090: 4947 4854 2c20 5472 7565 293a 0a20 2020  IGHT, True):.   
+0000c0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c0b0: 2020 2020 2020 2020 2020 2020 2065 7870               exp
+0000c0c0: 6563 7465 6420 3d20 5b5d 0a20 2020 2020  ected = [].     
+0000c0d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c0e0: 2020 2020 2020 2020 2020 2069 6620 7761             if wa
+0000c0f0: 6e74 5f70 7269 6e74 733a 2023 2070 7261  nt_prints: # pra
+0000c100: 676d 613a 206e 6f20 636f 7665 720a 2020  gma: no cover.  
+0000c110: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c120: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c130: 2020 7072 696e 7428 6622 5b6c 6f6f 7020    print(f"[loop 
+0000c140: 345d 2073 7472 6970 3d7b 7374 7269 707d  4] strip={strip}
+0000c150: 2229 0a20 2020 2020 2020 2020 2020 2020  ").             
+0000c160: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c170: 2020 2020 2020 2070 7269 6e74 2866 2220         print(f" 
+0000c180: 2020 2020 2020 2020 6c65 6164 696e 673d          leading=
+0000c190: 7b6c 6561 6469 6e67 7d20 7370 6c69 7473  {leading} splits
+0000c1a0: 3d7b 7370 6c69 7473 7d20 7472 6169 6c69  ={splits} traili
+0000c1b0: 6e67 3d7b 7472 6169 6c69 6e67 7d22 290a  ng={trailing}").
+0000c1c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c1d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c1e0: 2069 6620 7573 655f 6c65 6164 696e 6720   if use_leading 
+0000c1f0: 616e 6420 2873 7472 6970 2069 6e20 2846  and (strip in (F
+0000c200: 616c 7365 2c20 6269 672e 5249 4748 5429  alse, big.RIGHT)
+0000c210: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000c220: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c230: 2020 2020 2020 2065 7870 6563 7465 642e         expected.
+0000c240: 6578 7465 6e64 286c 6561 6469 6e67 290a  extend(leading).
+0000c250: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c260: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c270: 6966 2077 616e 745f 7072 696e 7473 3a20  if want_prints: 
+0000c280: 2320 7072 6167 6d61 3a20 6e6f 2063 6f76  # pragma: no cov
+0000c290: 6572 0a20 2020 2020 2020 2020 2020 2020  er.             
+0000c2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c2b0: 2020 2020 2020 2070 7269 6e74 2866 2220         print(f" 
+0000c2c0: 2020 2020 6c65 6164 696e 673a 2065 7870      leading: exp
+0000c2d0: 6563 7465 643d 7b65 7870 6563 7465 647d  ected={expected}
+0000c2e0: 2229 0a0a 2020 2020 2020 2020 2020 2020  ")..            
+0000c2f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c300: 2020 2020 666f 7220 7370 6c69 7420 696e      for split in
+0000c310: 2073 706c 6974 733a 0a20 2020 2020 2020   splits:.       
+0000c320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c330: 2020 2020 2020 2020 2020 2020 2065 7870               exp
+0000c340: 6563 7465 642e 6578 7465 6e64 2873 706c  ected.extend(spl
+0000c350: 6974 290a 2020 2020 2020 2020 2020 2020  it).            
+0000c360: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c370: 2020 2020 6966 2077 616e 745f 7072 696e      if want_prin
+0000c380: 7473 3a20 2320 7072 6167 6d61 3a20 6e6f  ts: # pragma: no
+0000c390: 2063 6f76 6572 0a20 2020 2020 2020 2020   cover.         
+0000c3a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c3b0: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+0000c3c0: 2866 2220 2020 2020 2073 706c 6974 733a  (f"      splits:
+0000c3d0: 2065 7870 6563 7465 643d 7b65 7870 6563   expected={expec
+0000c3e0: 7465 647d 2229 0a0a 2020 2020 2020 2020  ted}")..        
+0000c3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c400: 2020 2020 2020 2020 6966 2075 7365 5f74          if use_t
+0000c410: 7261 696c 696e 6720 616e 6420 2873 7472  railing and (str
+0000c420: 6970 2069 6e20 2846 616c 7365 2c20 6269  ip in (False, bi
+0000c430: 672e 4c45 4654 2929 3a0a 2020 2020 2020  g.LEFT)):.      
+0000c440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c450: 2020 2020 2020 2020 2020 2020 2020 6578                ex
+0000c460: 7065 6374 6564 2e65 7874 656e 6428 7472  pected.extend(tr
+0000c470: 6169 6c69 6e67 290a 2020 2020 2020 2020  ailing).        
+0000c480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c490: 2020 2020 2020 2020 6966 2077 616e 745f          if want_
+0000c4a0: 7072 696e 7473 3a20 2320 7072 6167 6d61  prints: # pragma
+0000c4b0: 3a20 6e6f 2063 6f76 6572 0a20 2020 2020  : no cover.     
+0000c4c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c4d0: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+0000c4e0: 7269 6e74 2866 2220 2020 2074 7261 696c  rint(f"    trail
+0000c4f0: 696e 673a 2065 7870 6563 7465 643d 7b65  ing: expected={e
+0000c500: 7870 6563 7465 647d 2229 0a0a 2020 2020  xpected}")..    
+0000c510: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c520: 2020 2020 2020 2020 2020 2020 2320 6578              # ex
+0000c530: 7065 6374 6564 206e 6f77 206c 6f6f 6b73  pected now looks
+0000c540: 206c 696b 6520 7468 6973 3a0a 2020 2020   like this:.    
+0000c550: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c560: 2020 2020 2020 2020 2020 2020 2320 2020              #   
+0000c570: 2a20 6974 2068 6173 2061 6e20 6f64 6420  * it has an odd 
+0000c580: 6e75 6d62 6572 206f 6620 6974 656d 730a  number of items.
+0000c590: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000c5a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c5b0: 2020 2073 6570 6172 6174 6f72 203d 2073     separator = s
-0000c5c0: 6570 6172 6174 6f72 2e65 6e63 6f64 6528  eparator.encode(
-0000c5d0: 2761 7363 6969 2729 0a20 2020 2020 2020  'ascii').       
-0000c5e0: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-0000c5f0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0000c600: 2020 2020 2020 2020 2020 2073 6570 6172             separ
-0000c610: 6174 6f72 203d 2062 6967 2e74 6578 742e  ator = big.text.
-0000c620: 5f63 6865 6170 5f65 6e63 6f64 655f 6974  _cheap_encode_it
-0000c630: 6572 6162 6c65 5f6f 665f 7374 7269 6e67  erable_of_string
-0000c640: 7328 7365 7061 7261 746f 7229 0a20 2020  s(separator).   
-0000c650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c660: 2065 7870 6563 7465 6420 3d20 6269 672e   expected = big.
-0000c670: 7465 7874 2e5f 6368 6561 705f 656e 636f  text._cheap_enco
-0000c680: 6465 5f69 7465 7261 626c 655f 6f66 5f73  de_iterable_of_s
-0000c690: 7472 696e 6773 2865 7870 6563 7465 6429  trings(expected)
-0000c6a0: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000c6b0: 2020 2320 7072 696e 7428 290a 2020 2020    # print().    
-0000c6c0: 2020 2020 2020 2020 2020 2020 6966 2069              if i
-0000c6d0: 7369 6e73 7461 6e63 6528 7365 7061 7261  sinstance(separa
-0000c6e0: 746f 722c 2028 7374 722c 2062 7974 6573  tor, (str, bytes
-0000c6f0: 2929 3a0a 2020 2020 2020 2020 2020 2020  )):.            
-0000c700: 2020 2020 2020 2020 7365 7061 7261 746f          separato
-0000c710: 7273 203d 2028 7365 7061 7261 746f 722c  rs = (separator,
-0000c720: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0000c730: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-0000c740: 2020 2020 2020 2020 2020 2020 7365 7061              sepa
-0000c750: 7261 746f 7273 203d 2073 6570 6172 6174  rators = separat
-0000c760: 6f72 0a0a 2020 2020 2020 2020 2020 2020  or..            
-0000c770: 2020 2020 676f 7420 3d20 6269 672e 6d75      got = big.mu
-0000c780: 6c74 6970 6172 7469 7469 6f6e 2873 2c20  ltipartition(s, 
-0000c790: 7365 7061 7261 746f 7273 2c20 636f 756e  separators, coun
-0000c7a0: 742c 2072 6576 6572 7365 3d72 6576 6572  t, reverse=rever
-0000c7b0: 7365 290a 2020 2020 2020 2020 2020 2020  se).            
-0000c7c0: 2020 2020 2320 7072 696e 7428 6622 2020      # print(f"  
-0000c7d0: 2020 7b67 6f74 2172 7d22 290a 2020 2020    {got!r}").    
-0000c7e0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0000c7f0: 2e61 7373 6572 7445 7175 616c 2865 7870  .assertEqual(exp
-0000c800: 6563 7465 642c 2067 6f74 290a 0a20 2020  ected, got)..   
-0000c810: 2020 2020 2020 2020 2020 2020 2067 6f74               got
-0000c820: 3220 3d20 6269 672e 6d75 6c74 6972 7061  2 = big.multirpa
-0000c830: 7274 6974 696f 6e28 732c 2073 6570 6172  rtition(s, separ
-0000c840: 6174 6f72 732c 2063 6f75 6e74 2c20 7265  ators, count, re
-0000c850: 7665 7273 653d 6e6f 7420 7265 7665 7273  verse=not revers
-0000c860: 6529 0a20 2020 2020 2020 2020 2020 2020  e).             
-0000c870: 2020 2023 2070 7269 6e74 2866 2220 2020     # print(f"   
-0000c880: 207b 676f 7432 2172 7d22 290a 2020 2020   {got2!r}").    
-0000c890: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0000c8a0: 2e61 7373 6572 7445 7175 616c 2865 7870  .assertEqual(exp
-0000c8b0: 6563 7465 642c 2067 6f74 3229 0a0a 2020  ected, got2)..  
-0000c8c0: 2020 2020 2020 7465 7374 5f6d 756c 7469        test_multi
-0000c8d0: 7061 7274 6974 696f 6e28 2261 3a62 3a63  partition("a:b:c
-0000c8e0: 3a64 222c 2022 3a22 2c20 302c 2028 2261  :d", ":", 0, ("a
-0000c8f0: 3a62 3a63 3a64 222c 2929 0a20 2020 2020  :b:c:d",)).     
-0000c900: 2020 2074 6573 745f 6d75 6c74 6970 6172     test_multipar
-0000c910: 7469 7469 6f6e 2822 613a 623a 633a 6422  tition("a:b:c:d"
-0000c920: 2c20 223a 222c 2031 2c20 2822 6122 2c20  , ":", 1, ("a", 
-0000c930: 223a 222c 2022 623a 633a 6422 2929 0a20  ":", "b:c:d")). 
-0000c940: 2020 2020 2020 2074 6573 745f 6d75 6c74         test_mult
-0000c950: 6970 6172 7469 7469 6f6e 2822 613a 623a  ipartition("a:b:
-0000c960: 633a 6422 2c20 223a 222c 2032 2c20 2822  c:d", ":", 2, ("
-0000c970: 6122 2c20 223a 222c 2022 6222 2c20 223a  a", ":", "b", ":
-0000c980: 222c 2022 633a 6422 2929 0a20 2020 2020  ", "c:d")).     
-0000c990: 2020 2074 6573 745f 6d75 6c74 6970 6172     test_multipar
-0000c9a0: 7469 7469 6f6e 2822 613a 623a 633a 6422  tition("a:b:c:d"
-0000c9b0: 2c20 223a 222c 2033 2c20 2822 6122 2c20  , ":", 3, ("a", 
-0000c9c0: 223a 222c 2022 6222 2c20 223a 222c 2022  ":", "b", ":", "
-0000c9d0: 6322 2c20 223a 222c 2022 6422 2929 0a20  c", ":", "d")). 
-0000c9e0: 2020 2020 2020 2074 6573 745f 6d75 6c74         test_mult
-0000c9f0: 6970 6172 7469 7469 6f6e 2822 613a 623a  ipartition("a:b:
-0000ca00: 633a 6422 2c20 223a 222c 2034 2c20 2822  c:d", ":", 4, ("
-0000ca10: 6122 2c20 223a 222c 2022 6222 2c20 223a  a", ":", "b", ":
-0000ca20: 222c 2022 6322 2c20 223a 222c 2022 6422  ", "c", ":", "d"
-0000ca30: 2c20 2727 2c20 2727 2929 0a20 2020 2020  , '', '')).     
-0000ca40: 2020 2074 6573 745f 6d75 6c74 6970 6172     test_multipar
-0000ca50: 7469 7469 6f6e 2822 613a 623a 633a 6422  tition("a:b:c:d"
-0000ca60: 2c20 223a 222c 2035 2c20 2822 6122 2c20  , ":", 5, ("a", 
-0000ca70: 223a 222c 2022 6222 2c20 223a 222c 2022  ":", "b", ":", "
-0000ca80: 6322 2c20 223a 222c 2022 6422 2c20 2727  c", ":", "d", ''
-0000ca90: 2c20 2727 2c20 2727 2c20 2727 2929 0a0a  , '', '', ''))..
-0000caa0: 2020 2020 2020 2020 7465 7374 5f6d 756c          test_mul
-0000cab0: 7469 7061 7274 6974 696f 6e28 2261 3a62  tipartition("a:b
-0000cac0: 3a63 3a64 222c 2022 3a22 2c20 302c 2028  :c:d", ":", 0, (
-0000cad0: 2261 3a62 3a63 3a64 222c 292c 2072 6576  "a:b:c:d",), rev
-0000cae0: 6572 7365 3d54 7275 6529 0a20 2020 2020  erse=True).     
-0000caf0: 2020 2074 6573 745f 6d75 6c74 6970 6172     test_multipar
-0000cb00: 7469 7469 6f6e 2822 613a 623a 633a 6422  tition("a:b:c:d"
-0000cb10: 2c20 223a 222c 2031 2c20 2822 613a 623a  , ":", 1, ("a:b:
-0000cb20: 6322 2c20 273a 2720 2c22 6422 292c 2072  c", ':' ,"d"), r
-0000cb30: 6576 6572 7365 3d54 7275 6529 0a20 2020  everse=True).   
-0000cb40: 2020 2020 2074 6573 745f 6d75 6c74 6970       test_multip
-0000cb50: 6172 7469 7469 6f6e 2822 613a 623a 633a  artition("a:b:c:
-0000cb60: 6422 2c20 223a 222c 2032 2c20 2822 613a  d", ":", 2, ("a:
-0000cb70: 6222 2c20 223a 222c 2022 6322 2c20 273a  b", ":", "c", ':
-0000cb80: 2720 2c22 6422 292c 2072 6576 6572 7365  ' ,"d"), reverse
-0000cb90: 3d54 7275 6529 0a20 2020 2020 2020 2074  =True).        t
-0000cba0: 6573 745f 6d75 6c74 6970 6172 7469 7469  est_multipartiti
-0000cbb0: 6f6e 2822 613a 623a 633a 6422 2c20 223a  on("a:b:c:d", ":
-0000cbc0: 222c 2033 2c20 2822 6122 2c20 223a 222c  ", 3, ("a", ":",
-0000cbd0: 2022 6222 2c20 223a 222c 2022 6322 2c20   "b", ":", "c", 
-0000cbe0: 273a 2720 2c22 6422 292c 2072 6576 6572  ':' ,"d"), rever
-0000cbf0: 7365 3d54 7275 6529 0a20 2020 2020 2020  se=True).       
-0000cc00: 2074 6573 745f 6d75 6c74 6970 6172 7469   test_multiparti
-0000cc10: 7469 6f6e 2822 613a 623a 633a 6422 2c20  tion("a:b:c:d", 
-0000cc20: 223a 222c 2034 2c20 2822 222c 2022 222c  ":", 4, ("", "",
-0000cc30: 2022 6122 2c20 223a 222c 2022 6222 2c20   "a", ":", "b", 
-0000cc40: 223a 222c 2022 6322 2c20 273a 2720 2c22  ":", "c", ':' ,"
-0000cc50: 6422 292c 2072 6576 6572 7365 3d54 7275  d"), reverse=Tru
-0000cc60: 6529 0a20 2020 2020 2020 2074 6573 745f  e).        test_
-0000cc70: 6d75 6c74 6970 6172 7469 7469 6f6e 2822  multipartition("
-0000cc80: 613a 623a 633a 6422 2c20 223a 222c 2035  a:b:c:d", ":", 5
-0000cc90: 2c20 2822 222c 2022 222c 2022 222c 2022  , ("", "", "", "
-0000cca0: 222c 2022 6122 2c20 223a 222c 2022 6222  ", "a", ":", "b"
-0000ccb0: 2c20 223a 222c 2022 6322 2c20 273a 2720  , ":", "c", ':' 
-0000ccc0: 2c22 6422 292c 2072 6576 6572 7365 3d54  ,"d"), reverse=T
-0000ccd0: 7275 6529 0a0a 2020 2020 2020 2020 7465  rue)..        te
-0000cce0: 7374 5f6d 756c 7469 7061 7274 6974 696f  st_multipartitio
-0000ccf0: 6e28 2261 3a62 3a63 3a64 222c 2022 7822  n("a:b:c:d", "x"
-0000cd00: 2c20 312c 2028 2261 3a62 3a63 3a64 222c  , 1, ("a:b:c:d",
-0000cd10: 2022 222c 2022 2229 290a 2020 2020 2020   "", "")).      
-0000cd20: 2020 7465 7374 5f6d 756c 7469 7061 7274    test_multipart
-0000cd30: 6974 696f 6e28 2261 3a62 3a63 3a64 222c  ition("a:b:c:d",
-0000cd40: 2022 7822 2c20 302c 2028 2261 3a62 3a63   "x", 0, ("a:b:c
-0000cd50: 3a64 222c 2929 0a20 2020 2020 2020 2074  :d",)).        t
-0000cd60: 6573 745f 6d75 6c74 6970 6172 7469 7469  est_multipartiti
-0000cd70: 6f6e 2822 613a 623a 633a 6422 2c20 2278  on("a:b:c:d", "x
-0000cd80: 222c 2032 2c20 2822 613a 623a 633a 6422  ", 2, ("a:b:c:d"
-0000cd90: 2c20 2222 2c20 2222 2c20 2222 2c20 2222  , "", "", "", ""
-0000cda0: 2929 0a20 2020 2020 2020 2074 6573 745f  )).        test_
-0000cdb0: 6d75 6c74 6970 6172 7469 7469 6f6e 2822  multipartition("
-0000cdc0: 613a 623a 633a 6422 2c20 2278 222c 2033  a:b:c:d", "x", 3
-0000cdd0: 2c20 2822 613a 623a 633a 6422 2c20 2222  , ("a:b:c:d", ""
-0000cde0: 2c20 2222 2c20 2222 2c20 2222 2c20 2222  , "", "", "", ""
-0000cdf0: 2c20 2222 2929 0a0a 2020 2020 2020 2020  , ""))..        
-0000ce00: 7465 7374 5f6d 756c 7469 7061 7274 6974  test_multipartit
-0000ce10: 696f 6e28 2261 3a62 3a63 3a64 222c 2022  ion("a:b:c:d", "
-0000ce20: 7822 2c20 302c 2028 2261 3a62 3a63 3a64  x", 0, ("a:b:c:d
-0000ce30: 222c 292c 2072 6576 6572 7365 3d54 7275  ",), reverse=Tru
-0000ce40: 6529 0a20 2020 2020 2020 2074 6573 745f  e).        test_
-0000ce50: 6d75 6c74 6970 6172 7469 7469 6f6e 2822  multipartition("
-0000ce60: 613a 623a 633a 6422 2c20 2278 222c 2031  a:b:c:d", "x", 1
-0000ce70: 2c20 2822 222c 2022 222c 2022 613a 623a  , ("", "", "a:b:
-0000ce80: 633a 6422 292c 2072 6576 6572 7365 3d54  c:d"), reverse=T
-0000ce90: 7275 6529 0a20 2020 2020 2020 2074 6573  rue).        tes
-0000cea0: 745f 6d75 6c74 6970 6172 7469 7469 6f6e  t_multipartition
-0000ceb0: 2822 613a 623a 633a 6422 2c20 2278 222c  ("a:b:c:d", "x",
-0000cec0: 2032 2c20 2822 222c 2022 222c 2022 222c   2, ("", "", "",
-0000ced0: 2022 222c 2022 613a 623a 633a 6422 292c   "", "a:b:c:d"),
-0000cee0: 2072 6576 6572 7365 3d54 7275 6529 0a20   reverse=True). 
-0000cef0: 2020 2020 2020 2074 6573 745f 6d75 6c74         test_mult
-0000cf00: 6970 6172 7469 7469 6f6e 2822 613a 623a  ipartition("a:b:
-0000cf10: 633a 6422 2c20 2278 222c 2033 2c20 2822  c:d", "x", 3, ("
-0000cf20: 222c 2022 222c 2022 222c 2022 222c 2022  ", "", "", "", "
-0000cf30: 222c 2022 222c 2022 613a 623a 633a 6422  ", "", "a:b:c:d"
-0000cf40: 292c 2072 6576 6572 7365 3d54 7275 6529  ), reverse=True)
-0000cf50: 0a0a 2020 2020 2020 2020 2320 7465 7374  ..        # test
-0000cf60: 206f 7665 726c 6170 7069 6e67 2073 6570   overlapping sep
-0000cf70: 6172 6174 6f72 2062 6568 6176 696f 720a  arator behavior.
-0000cf80: 2020 2020 2020 2020 7465 7374 5f6d 756c          test_mul
-0000cf90: 7469 7061 7274 6974 696f 6e28 2261 2078  tipartition("a x
-0000cfa0: 2078 2062 222c 2022 2078 2022 2c20 312c   x b", " x ", 1,
-0000cfb0: 2028 2261 222c 2022 2078 2022 2c20 2278   ("a", " x ", "x
-0000cfc0: 2062 2229 290a 2020 2020 2020 2020 7465   b")).        te
-0000cfd0: 7374 5f6d 756c 7469 7061 7274 6974 696f  st_multipartitio
-0000cfe0: 6e28 2261 2078 2078 2062 222c 2022 2078  n("a x x b", " x
-0000cff0: 2022 2c20 312c 2028 2261 2078 222c 2022   ", 1, ("a x", "
-0000d000: 2078 2022 2c20 2262 2229 2c20 7265 7665   x ", "b"), reve
-0000d010: 7273 653d 5472 7565 290a 0a20 2020 2020  rse=True)..     
-0000d020: 2020 2023 2074 6573 7420 6163 7475 616c     # test actual
-0000d030: 6c79 2075 7369 6e67 206d 756c 7469 706c  ly using multipl
-0000d040: 6520 7365 7061 7261 746f 7273 2c20 616e  e separators, an
-0000d050: 6420 6a75 7374 2066 6f72 2066 756e 2d2d  d just for fun--
-0000d060: 6f76 6572 6c61 7070 696e 6721 0a20 2020  overlapping!.   
-0000d070: 2020 2020 2074 6573 745f 6d75 6c74 6970       test_multip
-0000d080: 6172 7469 7469 6f6e 2822 6120 7820 7820  artition("a x x 
-0000d090: 6220 7920 7920 6322 2c20 2822 2078 2022  b y y c", (" x "
-0000d0a0: 2c20 2220 7920 2229 2c20 322c 2028 2261  , " y "), 2, ("a
-0000d0b0: 222c 2022 2078 2022 2c20 2278 2062 222c  ", " x ", "x b",
-0000d0c0: 2022 2079 2022 2c20 2279 2063 2229 290a   " y ", "y c")).
-0000d0d0: 2020 2020 2020 2020 7465 7374 5f6d 756c          test_mul
-0000d0e0: 7469 7061 7274 6974 696f 6e28 2261 2078  tipartition("a x
-0000d0f0: 2078 2062 2079 2079 2063 222c 2028 2220   x b y y c", (" 
-0000d100: 7820 222c 2022 2079 2022 292c 2032 2c20  x ", " y "), 2, 
-0000d110: 2822 6120 7822 2c20 2220 7820 222c 2022  ("a x", " x ", "
-0000d120: 6220 7922 2c20 2220 7920 222c 2022 6322  b y", " y ", "c"
-0000d130: 292c 2072 6576 6572 7365 3d54 7275 6529  ), reverse=True)
-0000d140: 0a0a 2020 2020 2020 2020 2320 7465 7374  ..        # test
-0000d150: 2067 7265 6564 790a 2020 2020 2020 2020   greedy.        
-0000d160: 7465 7374 5f6d 756c 7469 7061 7274 6974  test_multipartit
-0000d170: 696f 6e28 2256 5761 6263 5758 6162 5859  ion("VWabcWXabXY
-0000d180: 6263 595a 222c 2028 2761 272c 2027 6162  bcYZ", ('a', 'ab
-0000d190: 272c 2027 6162 6327 2c20 2762 272c 2027  ', 'abc', 'b', '
-0000d1a0: 6263 272c 2027 6327 292c 2033 2c20 2827  bc', 'c'), 3, ('
-0000d1b0: 5657 272c 2027 6162 6327 2c20 2757 5827  VW', 'abc', 'WX'
-0000d1c0: 2c20 2761 6227 2c20 2758 5927 2c20 2762  , 'ab', 'XY', 'b
-0000d1d0: 6327 2c20 2759 5a27 2929 0a20 2020 2020  c', 'YZ')).     
-0000d1e0: 2020 2074 6573 745f 6d75 6c74 6970 6172     test_multipar
-0000d1f0: 7469 7469 6f6e 2822 5657 6162 6357 5861  tition("VWabcWXa
-0000d200: 6258 5962 6359 5a22 2c20 2827 6127 2c20  bXYbcYZ", ('a', 
-0000d210: 2761 6227 2c20 2761 6263 272c 2027 6227  'ab', 'abc', 'b'
-0000d220: 2c20 2762 6327 2c20 2763 2729 2c20 332c  , 'bc', 'c'), 3,
-0000d230: 2028 2756 5727 2c20 2761 6263 272c 2027   ('VW', 'abc', '
-0000d240: 5758 272c 2027 6162 272c 2027 5859 272c  WX', 'ab', 'XY',
-0000d250: 2027 6263 272c 2027 595a 2729 2c20 7265   'bc', 'YZ'), re
-0000d260: 7665 7273 653d 5472 7565 290a 0a20 2020  verse=True)..   
-0000d270: 2064 6566 2074 6573 745f 7265 696d 706c   def test_reimpl
-0000d280: 656d 656e 7465 645f 7374 725f 7370 6c69  emented_str_spli
-0000d290: 7428 7365 6c66 293a 0a20 2020 2020 2020  t(self):.       
-0000d2a0: 2064 6566 205f 6d75 6c74 6973 706c 6974   def _multisplit
-0000d2b0: 5f74 6f5f 7370 6c69 7428 732c 2073 6570  _to_split(s, sep
-0000d2c0: 2c20 6d61 7873 706c 6974 2c20 7265 7665  , maxsplit, reve
-0000d2d0: 7273 6529 3a0a 2020 2020 2020 2020 2020  rse):.          
-0000d2e0: 2020 7365 7061 7261 7465 203d 2073 6570    separate = sep
-0000d2f0: 2021 3d20 4e6f 6e65 0a20 2020 2020 2020   != None.       
-0000d300: 2020 2020 2069 6620 7365 7061 7261 7465       if separate
-0000d310: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000d320: 2020 7374 7269 7020 3d20 4661 6c73 650a    strip = False.
-0000d330: 2020 2020 2020 2020 2020 2020 656c 7365              else
-0000d340: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000d350: 2020 7365 7020 3d20 6269 672e 6173 6369    sep = big.asci
-0000d360: 695f 7768 6974 6573 7061 6365 2069 6620  i_whitespace if 
-0000d370: 6973 696e 7374 616e 6365 2873 2c20 6279  isinstance(s, by
-0000d380: 7465 7329 2065 6c73 6520 6269 672e 7768  tes) else big.wh
-0000d390: 6974 6573 7061 6365 0a20 2020 2020 2020  itespace.       
-0000d3a0: 2020 2020 2020 2020 2073 7472 6970 203d           strip =
-0000d3b0: 2062 6967 2e50 524f 4752 4553 5349 5645   big.PROGRESSIVE
-0000d3c0: 0a20 2020 2020 2020 2020 2020 2072 6573  .            res
-0000d3d0: 756c 7420 3d20 6c69 7374 2862 6967 2e6d  ult = list(big.m
-0000d3e0: 756c 7469 7370 6c69 7428 732c 2073 6570  ultisplit(s, sep
-0000d3f0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0000d400: 2020 6d61 7873 706c 6974 3d6d 6178 7370    maxsplit=maxsp
-0000d410: 6c69 742c 2072 6576 6572 7365 3d72 6576  lit, reverse=rev
-0000d420: 6572 7365 2c0a 2020 2020 2020 2020 2020  erse,.          
-0000d430: 2020 2020 2020 7365 7061 7261 7465 3d73        separate=s
-0000d440: 6570 6172 6174 652c 2073 7472 6970 3d73  eparate, strip=s
-0000d450: 7472 6970 2929 0a20 2020 2020 2020 2020  trip)).         
-0000d460: 2020 2069 6620 6e6f 7420 7365 7061 7261     if not separa
-0000d470: 7465 3a0a 2020 2020 2020 2020 2020 2020  te:.            
-0000d480: 2020 2020 2320 2727 2e73 706c 6974 2829      # ''.split()
-0000d490: 203d 3d20 2720 2020 272e 7370 6c69 7428   == '   '.split(
-0000d4a0: 2920 3d3d 205b 5d0a 2020 2020 2020 2020  ) == [].        
-0000d4b0: 2020 2020 2020 2020 6966 2072 6573 756c          if resul
-0000d4c0: 7420 616e 6420 286e 6f74 2072 6573 756c  t and (not resul
-0000d4d0: 745b 2d31 5d29 3a0a 2020 2020 2020 2020  t[-1]):.        
-0000d4e0: 2020 2020 2020 2020 2020 2020 7265 7375              resu
-0000d4f0: 6c74 2e70 6f70 2829 0a20 2020 2020 2020  lt.pop().       
-0000d500: 2020 2020 2072 6574 7572 6e20 7265 7375       return resu
-0000d510: 6c74 0a0a 2020 2020 2020 2020 6465 6620  lt..        def 
-0000d520: 7374 725f 7370 6c69 7428 732c 2073 6570  str_split(s, sep
-0000d530: 3d4e 6f6e 652c 206d 6178 7370 6c69 743d  =None, maxsplit=
-0000d540: 2d31 293a 0a20 2020 2020 2020 2020 2020  -1):.           
-0000d550: 2072 6574 7572 6e20 5f6d 756c 7469 7370   return _multisp
-0000d560: 6c69 745f 746f 5f73 706c 6974 2873 2c20  lit_to_split(s, 
-0000d570: 7365 702c 206d 6178 7370 6c69 742c 2046  sep, maxsplit, F
-0000d580: 616c 7365 290a 0a20 2020 2020 2020 2064  alse)..        d
-0000d590: 6566 2073 7472 5f72 7370 6c69 7428 732c  ef str_rsplit(s,
-0000d5a0: 2073 6570 3d4e 6f6e 652c 206d 6178 7370   sep=None, maxsp
-0000d5b0: 6c69 743d 2d31 293a 0a20 2020 2020 2020  lit=-1):.       
-0000d5c0: 2020 2020 2072 6574 7572 6e20 5f6d 756c       return _mul
-0000d5d0: 7469 7370 6c69 745f 746f 5f73 706c 6974  tisplit_to_split
-0000d5e0: 2873 2c20 7365 702c 206d 6178 7370 6c69  (s, sep, maxspli
-0000d5f0: 742c 2054 7275 6529 0a0a 2020 2020 2020  t, True)..      
-0000d600: 2020 6465 6620 7465 7374 2873 2c20 7365    def test(s, se
-0000d610: 703d 4e6f 6e65 2c20 6d61 7873 706c 6974  p=None, maxsplit
-0000d620: 3d2d 3129 3a0a 2020 2020 2020 2020 2020  =-1):.          
-0000d630: 2020 2320 6175 746f 6d61 7469 6361 6c6c    # automaticall
-0000d640: 7920 7465 7374 2077 6974 6820 2873 7472  y test with (str
-0000d650: 2c20 6279 7465 7329 2078 2028 7365 703d  , bytes) x (sep=
-0000d660: 7365 702c 2073 6570 3d4e 6f6e 6529 0a20  sep, sep=None). 
-0000d670: 2020 2020 2020 2020 2020 2066 6f72 2061             for a
-0000d680: 735f 6279 7465 7320 696e 2028 4661 6c73  s_bytes in (Fals
-0000d690: 652c 2054 7275 6529 3a0a 2020 2020 2020  e, True):.      
-0000d6a0: 2020 2020 2020 2020 2020 6966 2061 735f            if as_
-0000d6b0: 6279 7465 733a 0a20 2020 2020 2020 2020  bytes:.         
-0000d6c0: 2020 2020 2020 2020 2020 2073 203d 2073             s = s
-0000d6d0: 2e65 6e63 6f64 6528 2761 7363 6969 2729  .encode('ascii')
-0000d6e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d6f0: 2020 2020 2069 6620 7365 7020 6973 206e       if sep is n
-0000d700: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
+0000c5b0: 2320 2020 2a20 6576 656e 206e 756d 6265  #   * even numbe
+0000c5c0: 7265 6420 6974 656d 7320 6172 6520 6e6f  red items are no
+0000c5d0: 6e73 6570 0a20 2020 2020 2020 2020 2020  nsep.           
+0000c5e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c5f0: 2020 2020 2023 2020 202a 206f 6464 206e       #   * odd n
+0000c600: 756d 6265 7265 6420 6974 656d 7320 6172  umbered items ar
+0000c610: 6520 7365 700a 2020 2020 2020 2020 2020  e sep.          
+0000c620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c630: 2020 2020 2020 6173 7365 7274 206c 656e        assert len
+0000c640: 2865 7870 6563 7465 6429 2025 2032 203d  (expected) % 2 =
+0000c650: 3d20 312c 2066 2265 7870 6563 7465 643d  = 1, f"expected=
+0000c660: 7b65 7870 6563 7465 647d 2064 6f65 736e  {expected} doesn
+0000c670: 2774 2068 6176 6520 616e 206f 6464 2023  't have an odd #
+0000c680: 206f 6620 656c 656d 656e 7473 2122 0a20   of elements!". 
+0000c690: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c6a0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+0000c6b0: 6f72 2069 2069 6e20 7261 6e67 6528 302c  or i in range(0,
+0000c6c0: 206c 656e 2865 7870 6563 7465 6429 2c20   len(expected), 
+0000c6d0: 3229 3a0a 2020 2020 2020 2020 2020 2020  2):.            
+0000c6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c6f0: 2020 2020 2020 2020 6173 7365 7274 2065          assert e
+0000c700: 7870 6563 7465 645b 695d 206e 6f74 2069  xpected[i] not i
+0000c710: 6e20 7365 7061 7261 746f 7273 5f73 6574  n separators_set
+0000c720: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c730: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c740: 2066 6f72 2069 2069 6e20 7261 6e67 6528   for i in range(
+0000c750: 312c 206c 656e 2865 7870 6563 7465 6429  1, len(expected)
+0000c760: 2c20 3229 3a0a 2020 2020 2020 2020 2020  , 2):.          
+0000c770: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c780: 2020 2020 2020 2020 2020 6173 7365 7274            assert
+0000c790: 206e 6f74 2062 6967 2e6d 756c 7469 7374   not big.multist
+0000c7a0: 7269 7028 6578 7065 6374 6564 5b69 5d2c  rip(expected[i],
+0000c7b0: 2073 6570 6172 6174 6f72 735f 7365 7429   separators_set)
+0000c7c0: 2c20 6622 6578 7065 6374 6564 5b7b 697d  , f"expected[{i}
+0000c7d0: 5d3d 7b65 7870 6563 7465 645b 695d 2172  ]={expected[i]!r
+0000c7e0: 7d20 6e6f 7420 696e 2073 6570 6172 6174  } not in separat
+0000c7f0: 6f72 735f 7365 743d 7b73 6570 6172 6174  ors_set={separat
+0000c800: 6f72 735f 7365 747d 2021 220a 0a20 2020  ors_set} !"..   
+0000c810: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c820: 2020 2020 2020 2020 2020 2020 2023 2068               # h
+0000c830: 6f77 206d 616e 7920 7370 6c69 7473 2063  ow many splits c
+0000c840: 616e 2077 6520 6861 7665 3f0a 2020 2020  an we have?.    
+0000c850: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c860: 2020 2020 2020 2020 2020 2020 2320 5465              # Te
+0000c870: 6368 6e69 6361 6c6c 7920 7468 6520 6d61  chnically the ma
+0000c880: 7869 6d75 6d20 6e75 6d62 6572 206f 6620  ximum number of 
+0000c890: 7370 6c69 7473 2070 6f73 7369 626c 650a  splits possible.
+0000c8a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c8b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c8c0: 2320 6973 0a20 2020 2020 2020 2020 2020  # is.           
+0000c8d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c8e0: 2020 2020 2023 2020 2020 286c 656e 2865       #    (len(e
+0000c8f0: 7870 6563 7465 6429 202f 2f20 3229 202d  xpected) // 2) -
+0000c900: 2031 0a20 2020 2020 2020 2020 2020 2020   1.             
+0000c910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c920: 2020 2023 2027 6120 6220 6320 6420 6527     # 'a b c d e'
+0000c930: 2077 6f75 6c64 2073 706c 6974 2062 7920   would split by 
+0000c940: 7768 6974 6573 7061 6365 2069 6e74 6f20  whitespace into 
+0000c950: 3920 656c 656d 656e 7473 2c0a 2020 2020  9 elements,.    
+0000c960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c970: 2020 2020 2020 2020 2020 2020 2320 6f6e              # on
+0000c980: 6c79 2075 7369 6e67 2066 6f75 7220 7370  ly using four sp
+0000c990: 6c69 7473 2e0a 2020 2020 2020 2020 2020  lits..          
+0000c9a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c9b0: 2020 2020 2020 2320 416e 7977 6179 2077        # Anyway w
+0000c9c0: 6520 7465 7374 2061 2063 6f75 706c 6520  e test a couple 
+0000c9d0: 7375 7065 726e 756d 6572 6172 7920 6d61  supernumerary ma
+0000c9e0: 7873 706c 6974 2076 616c 7565 732e 0a20  xsplit values.. 
+0000c9f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ca00: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+0000ca10: 6178 5f6d 6178 7370 6c69 7420 3d20 286c  ax_maxsplit = (l
+0000ca20: 656e 2865 7870 6563 7465 6429 202f 2f20  en(expected) // 
+0000ca30: 3229 202b 2031 0a0a 2020 2020 2020 2020  2) + 1..        
+0000ca40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ca50: 2020 2020 2020 2020 6578 7065 6374 6564          expected
+0000ca60: 5f6f 7269 6769 6e61 6c20 3d20 6578 7065  _original = expe
+0000ca70: 6374 6564 0a0a 2020 2020 2020 2020 2020  cted..          
+0000ca80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ca90: 2020 2020 2020 6966 2077 616e 745f 7072        if want_pr
+0000caa0: 696e 7473 3a20 2320 7072 6167 6d61 3a20  ints: # pragma: 
+0000cab0: 6e6f 2063 6f76 6572 0a20 2020 2020 2020  no cover.       
+0000cac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cad0: 2020 2020 2020 2020 2020 2020 2070 7269               pri
+0000cae0: 6e74 2866 2220 2020 2065 7870 6563 7465  nt(f"    expecte
+0000caf0: 645f 6f72 6967 696e 616c 3d7b 6578 7065  d_original={expe
+0000cb00: 6374 6564 5f6f 7269 6769 6e61 6c7d 2229  cted_original}")
+0000cb10: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+0000cb20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cb30: 2020 666f 7220 7265 7665 7273 6520 696e    for reverse in
+0000cb40: 2028 4661 6c73 652c 2054 7275 6529 3a0a   (False, True):.
+0000cb50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cb60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cb70: 2020 2020 666f 7220 6d61 7873 706c 6974      for maxsplit
+0000cb80: 2069 6e20 7261 6e67 6528 2d31 2c20 6d61   in range(-1, ma
+0000cb90: 785f 6d61 7873 706c 6974 293a 0a20 2020  x_maxsplit):.   
+0000cba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cbb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cbc0: 2020 2020 2065 7870 6563 7465 6420 3d20       expected = 
+0000cbd0: 6c69 7374 2865 7870 6563 7465 645f 6f72  list(expected_or
+0000cbe0: 6967 696e 616c 290a 2020 2020 2020 2020  iginal).        
+0000cbf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cc00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cc10: 6966 2077 616e 745f 7072 696e 7473 3a20  if want_prints: 
+0000cc20: 2320 7072 6167 6d61 3a20 6e6f 2063 6f76  # pragma: no cov
+0000cc30: 6572 0a20 2020 2020 2020 2020 2020 2020  er.             
+0000cc40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cc50: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+0000cc60: 7269 6e74 2866 225b 6c6f 6f70 2035 2c36  rint(f"[loop 5,6
+0000cc70: 5d20 7265 7665 7273 653d 7b72 6576 6572  ] reverse={rever
+0000cc80: 7365 7d20 6d61 7873 706c 6974 3d7b 6d61  se} maxsplit={ma
+0000cc90: 7873 706c 6974 7d20 2f2f 2065 7870 6563  xsplit} // expec
+0000cca0: 7465 643d 7b65 7870 6563 7465 647d 2229  ted={expected}")
+0000ccb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000ccc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ccd0: 2020 2020 2020 2020 2069 6620 6d61 7873           if maxs
+0000cce0: 706c 6974 203d 3d20 303a 0a20 2020 2020  plit == 0:.     
+0000ccf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cd00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cd10: 2020 2020 2020 206a 6f69 6e65 6420 3d20         joined = 
+0000cd20: 656d 7074 792e 6a6f 696e 2865 7870 6563  empty.join(expec
+0000cd30: 7465 6429 0a20 2020 2020 2020 2020 2020  ted).           
+0000cd40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cd50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cd60: 2065 7870 6563 7465 6420 3d20 5b6a 6f69   expected = [joi
+0000cd70: 6e65 645d 0a20 2020 2020 2020 2020 2020  ned].           
+0000cd80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cd90: 2020 2020 2020 2020 2020 2020 2065 6c69               eli
+0000cda0: 6620 6d61 7873 706c 6974 203e 2030 3a0a  f maxsplit > 0:.
+0000cdb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cdc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cdd0: 2020 2020 2020 2020 2020 2020 6966 206e              if n
+0000cde0: 6f74 2072 6576 6572 7365 3a0a 2020 2020  ot reverse:.    
+0000cdf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ce00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ce10: 2020 2020 2020 2020 2020 2020 2320 7765              # we
+0000ce20: 2772 6520 696e 2022 616c 7465 726e 6174  're in "alternat
+0000ce30: 696e 6722 206d 6f64 652c 0a20 2020 2020  ing" mode,.     
+0000ce40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ce50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ce60: 2020 2020 2020 2020 2020 2023 2073 6f20             # so 
+0000ce70: 6f64 642d 6e75 6d62 6572 6564 2069 6e64  odd-numbered ind
+0000ce80: 6578 6573 2061 7265 0a20 2020 2020 2020  exes are.       
+0000ce90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ceb0: 2020 2020 2020 2020 2023 2073 706c 6974           # split
+0000cec0: 730a 2020 2020 2020 2020 2020 2020 2020  s.              
+0000ced0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cef0: 2020 230a 2020 2020 2020 2020 2020 2020    #.            
+0000cf00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cf10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cf20: 2020 2020 2320 6c65 6e67 7468 2037 0a20      # length 7. 
+0000cf30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cf40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cf50: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000cf60: 2020 3020 2020 2031 2020 2020 3220 2020    0    1    2   
+0000cf70: 2033 2020 2020 3420 2020 2035 2020 2020   3    4    5    
+0000cf80: 3620 2020 696e 6465 780a 2020 2020 2020  6   index.      
+0000cf90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cfa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cfb0: 2020 2020 2020 2020 2020 2320 5b27 6127            # ['a'
+0000cfc0: 2c20 2720 272c 2027 6227 2c20 2720 272c  , ' ', 'b', ' ',
+0000cfd0: 2027 6327 2c20 2720 272c 2027 6427 5d0a   'c', ' ', 'd'].
+0000cfe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d000: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d010: 2320 2030 2020 2020 2020 2020 2031 2020  #  0         1  
+0000d020: 2020 2020 2020 2020 3220 2020 2020 2020          2       
+0000d030: 2033 2020 206d 6178 7370 6c69 740a 2020   3   maxsplit.  
+0000d040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d050: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d060: 2020 2020 2020 2020 2020 2020 2020 7374                st
+0000d070: 6172 7420 3d20 6d61 7873 706c 6974 202a  art = maxsplit *
+0000d080: 2032 0a20 2020 2020 2020 2020 2020 2020   2.             
+0000d090: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d0b0: 2020 2065 6e64 203d 206c 656e 2865 7870     end = len(exp
+0000d0c0: 6563 7465 6429 0a20 2020 2020 2020 2020  ected).         
+0000d0d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d0e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d0f0: 2020 2020 2020 2069 6620 7374 6172 7420         if start 
+0000d100: 3c20 656e 643a 0a20 2020 2020 2020 2020  < end:.         
+0000d110: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d120: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d130: 2020 2020 2020 2020 2020 2069 6620 7761             if wa
+0000d140: 6e74 5f70 7269 6e74 733a 2023 2070 7261  nt_prints: # pra
+0000d150: 676d 613a 206e 6f20 636f 7665 720a 2020  gma: no cover.  
+0000d160: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d190: 2020 2020 2020 7072 696e 7428 6622 2020        print(f"  
+0000d1a0: 2020 6e6f 7420 7265 7665 7273 653a 2065    not reverse: e
+0000d1b0: 7870 6563 7465 645b 7b73 7461 7274 7d3a  xpected[{start}:
+0000d1c0: 7b65 6e64 7d5d 203d 207b 6578 7065 6374  {end}] = {expect
+0000d1d0: 6564 5b73 7461 7274 3a65 6e64 5d7d 2229  ed[start:end]}")
+0000d1e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d1f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d210: 2020 2020 206a 6f69 6e65 6420 3d20 6e6f       joined = no
+0000d220: 6e5f 7365 705f 6d61 726b 6572 202b 2065  n_sep_marker + e
+0000d230: 6d70 7479 2e6a 6f69 6e28 6578 7065 6374  mpty.join(expect
+0000d240: 6564 5b73 7461 7274 3a65 6e64 5d29 0a20  ed[start:end]). 
+0000d250: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d260: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d270: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d280: 2020 2064 656c 2065 7870 6563 7465 645b     del expected[
+0000d290: 7374 6172 743a 656e 645d 0a20 2020 2020  start:end].     
+0000d2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d2b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d2c0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000d2d0: 6620 7761 6e74 5f70 7269 6e74 733a 2023  f want_prints: #
+0000d2e0: 2070 7261 676d 613a 206e 6f20 636f 7665   pragma: no cove
+0000d2f0: 720a 2020 2020 2020 2020 2020 2020 2020  r.              
+0000d300: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d310: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d320: 2020 2020 2020 2020 2020 7072 696e 7428            print(
+0000d330: 6622 2020 2020 6578 7065 6374 6564 3d7b  f"    expected={
+0000d340: 6578 7065 6374 6564 7d20 6a6f 696e 6564  expected} joined
+0000d350: 3d7b 6a6f 696e 6564 7d20 656d 7074 793d  ={joined} empty=
+0000d360: 7b65 6d70 7479 7d22 290a 2020 2020 2020  {empty}").      
+0000d370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d390: 2020 2020 2020 2020 2020 2020 2020 6578                ex
+0000d3a0: 7065 6374 6564 2e61 7070 656e 6428 6a6f  pected.append(jo
+0000d3b0: 696e 6564 290a 2020 2020 2020 2020 2020  ined).          
+0000d3c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d3d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d3e0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0000d3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d410: 2020 2020 2020 2020 2320 7265 7665 7273          # revers
+0000d420: 6520 616e 6420 6d61 7873 706c 6974 0a20  e and maxsplit. 
+0000d430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d450: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000d460: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d470: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d490: 2023 206c 656e 6774 6820 370a 2020 2020   # length 7.    
+0000d4a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d4c0: 2020 2020 2020 2020 2020 2020 2320 2030              #  0
+0000d4d0: 2020 2020 3120 2020 2032 2020 2020 3320      1    2    3 
+0000d4e0: 2020 2034 2020 2020 3520 2020 2036 2020     4    5    6  
+0000d4f0: 2069 6e64 6578 0a20 2020 2020 2020 2020   index.         
+0000d500: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d510: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d520: 2020 2020 2020 2023 205b 2761 272c 2027         # ['a', '
+0000d530: 2027 2c20 2762 272c 2027 2027 2c20 2763   ', 'b', ' ', 'c
+0000d540: 272c 2027 2027 2c20 2764 272c 2020 5d0a  ', ' ', 'd',  ].
+0000d550: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d560: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d580: 2320 2020 2020 2020 3320 2020 2020 2020  #       3       
+0000d590: 2020 3220 2020 2020 2020 2020 3120 2020    2         1   
+0000d5a0: 2020 2020 2020 3020 2020 6d61 7873 706c        0   maxspl
+0000d5b0: 6974 0a20 2020 2020 2020 2020 2020 2020  it.             
+0000d5c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d5d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d5e0: 2020 2073 7461 7274 203d 2030 0a20 2020     start = 0.   
+0000d5f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d600: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d610: 2020 2020 2020 2020 2020 2020 2065 6e64               end
+0000d620: 203d 206c 656e 2865 7870 6563 7465 6429   = len(expected)
+0000d630: 202d 2028 6d61 7873 706c 6974 202a 2032   - (maxsplit * 2
+0000d640: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000d650: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d670: 2020 6a6f 696e 6564 203d 206e 6f6e 5f73    joined = non_s
+0000d680: 6570 5f6d 6172 6b65 7220 2b20 656d 7074  ep_marker + empt
+0000d690: 792e 6a6f 696e 2865 7870 6563 7465 645b  y.join(expected[
+0000d6a0: 7374 6172 743a 656e 645d 290a 2020 2020  start:end]).    
+0000d6b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d6c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d6d0: 2020 2020 2020 2020 2020 2020 6966 2077              if w
+0000d6e0: 616e 745f 7072 696e 7473 3a20 2320 7072  ant_prints: # pr
+0000d6f0: 6167 6d61 3a20 6e6f 2063 6f76 6572 0a20  agma: no cover. 
+0000d700: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000d710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d720: 2073 6570 203d 2073 6570 2e65 6e63 6f64   sep = sep.encod
-0000d730: 6528 2761 7363 6969 2729 0a20 2020 2020  e('ascii').     
-0000d740: 2020 2020 2020 2020 2020 2066 6f72 2073             for s
-0000d750: 6570 5f6e 6f6e 6520 696e 2028 4661 6c73  ep_none in (Fals
-0000d760: 652c 2054 7275 6529 3a0a 2020 2020 2020  e, True):.      
-0000d770: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0000d780: 7032 203d 204e 6f6e 6520 6966 2073 6570  p2 = None if sep
-0000d790: 5f6e 6f6e 6520 656c 7365 2073 6570 0a20  _none else sep. 
+0000d720: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d730: 2020 2070 7269 6e74 2866 2220 2020 2072     print(f"    r
+0000d740: 6576 6572 7365 3a20 6578 7065 6374 6564  everse: expected
+0000d750: 5b7b 7374 6172 747d 3a7b 656e 647d 5d20  [{start}:{end}] 
+0000d760: 3d20 7b65 7870 6563 7465 645b 7374 6172  = {expected[star
+0000d770: 743a 656e 645d 7d20 202f 2f2f 206a 6f69  t:end]}  /// joi
+0000d780: 6e65 643d 7b6a 6f69 6e65 647d 2229 0a20  ned={joined}"). 
+0000d790: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000d7a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d7b0: 2020 2061 203d 2073 2e73 706c 6974 2873     a = s.split(s
-0000d7c0: 6570 322c 206d 6178 7370 6c69 7429 0a20  ep2, maxsplit). 
-0000d7d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d7e0: 2020 2062 203d 2073 7472 5f73 706c 6974     b = str_split
-0000d7f0: 2873 2c20 7365 7032 2c20 6d61 7873 706c  (s, sep2, maxspl
-0000d800: 6974 290a 2020 2020 2020 2020 2020 2020  it).            
-0000d810: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
-0000d820: 6572 7445 7175 616c 2861 2c20 622c 2066  ertEqual(a, b, f
-0000d830: 2272 6569 6d70 6c65 6d65 6e74 6564 2073  "reimplemented s
-0000d840: 7472 5f73 706c 6974 2066 6169 6c73 3a20  tr_split fails: 
-0000d850: 7b73 2172 7d2e 7370 6c69 7428 7b73 6570  {s!r}.split({sep
-0000d860: 3221 727d 2c20 7b6d 6178 7370 6c69 747d  2!r}, {maxsplit}
-0000d870: 2920 3d3d 207b 617d 2c20 7374 725f 7370  ) == {a}, str_sp
-0000d880: 6c69 7420 7665 7273 696f 6e20 6761 7665  lit version gave
-0000d890: 2075 7320 7b62 7d22 290a 0a20 2020 2020   us {b}")..     
-0000d8a0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-0000d8b0: 203d 2073 2e72 7370 6c69 7428 7365 7032   = s.rsplit(sep2
-0000d8c0: 2c20 6d61 7873 706c 6974 290a 2020 2020  , maxsplit).    
-0000d8d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d8e0: 6220 3d20 7374 725f 7273 706c 6974 2873  b = str_rsplit(s
-0000d8f0: 2c20 7365 7032 2c20 6d61 7873 706c 6974  , sep2, maxsplit
-0000d900: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0000d910: 2020 2020 2020 7365 6c66 2e61 7373 6572        self.asser
-0000d920: 7445 7175 616c 2861 2c20 622c 2066 2272  tEqual(a, b, f"r
-0000d930: 6569 6d70 6c65 6d65 6e74 6564 2073 7472  eimplemented str
-0000d940: 5f72 7370 6c69 7420 6661 696c 733a 207b  _rsplit fails: {
-0000d950: 7321 727d 2e72 7370 6c69 7428 7b73 6570  s!r}.rsplit({sep
-0000d960: 3221 727d 2c20 7b6d 6178 7370 6c69 747d  2!r}, {maxsplit}
-0000d970: 2920 3d3d 207b 617d 2c20 7374 725f 7370  ) == {a}, str_sp
-0000d980: 6c69 7420 7665 7273 696f 6e20 6761 7665  lit version gave
-0000d990: 2075 7320 7b62 7d22 290a 0a0a 2020 2020   us {b}")...    
-0000d9a0: 2020 2020 666f 7220 6d61 7873 706c 6974      for maxsplit
-0000d9b0: 2069 6e20 7261 6e67 6528 2d31 2c20 3130   in range(-1, 10
-0000d9c0: 293a 0a20 2020 2020 2020 2020 2020 2074  ):.            t
-0000d9d0: 6573 7428 2761 2062 2020 2063 2020 2020  est('a b   c    
-0000d9e0: 2020 2064 205c 745c 745c 6e20 6527 2c20     d \t\t\n e', 
-0000d9f0: 4e6f 6e65 2c20 6d61 7873 706c 6974 290a  None, maxsplit).
-0000da00: 2020 2020 2020 2020 2020 2020 7465 7374              test
-0000da10: 2827 2020 2061 2062 2063 2020 2027 2c20  ('   a b c   ', 
-0000da20: 2720 272c 206d 6178 7370 6c69 7429 0a0a  ' ', maxsplit)..
-0000da30: 2020 2020 2020 2020 666f 7220 6261 7365          for base
-0000da40: 5f73 2069 6e20 280a 2020 2020 2020 2020  _s in (.        
-0000da50: 2020 2020 2222 2c0a 2020 2020 2020 2020      "",.        
-0000da60: 2020 2020 2261 222c 0a20 2020 2020 2020      "a",.       
-0000da70: 2020 2020 2022 6120 6220 6322 2c0a 2020       "a b c",.  
-0000da80: 2020 2020 2020 2020 2020 2261 2062 2020            "a b  
-0000da90: 6320 6420 2020 6522 2c0a 2020 2020 2020  c d   e",.      
-0000daa0: 2020 2020 2020 293a 0a20 2020 2020 2020        ):.       
-0000dab0: 2020 2020 2066 6f72 206c 6561 6469 6e67       for leading
-0000dac0: 2069 6e20 7261 6e67 6528 3130 293a 0a20   in range(10):. 
-0000dad0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-0000dae0: 6f72 2074 7261 696c 696e 6720 696e 2072  or trailing in r
-0000daf0: 616e 6765 2831 3029 3a0a 2020 2020 2020  ange(10):.      
-0000db00: 2020 2020 2020 2020 2020 2020 2020 7320                s 
-0000db10: 3d20 2822 2022 202a 206c 6561 6469 6e67  = (" " * leading
-0000db20: 2920 2b20 6261 7365 5f73 202b 2028 2220  ) + base_s + (" 
-0000db30: 2220 2a20 7472 6169 6c69 6e67 290a 2020  " * trailing).  
-0000db40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000db50: 2020 735f 7769 7468 5f63 6f6d 6d61 7320    s_with_commas 
-0000db60: 3d20 732e 7265 706c 6163 6528 2720 272c  = s.replace(' ',
-0000db70: 2027 2c27 290a 2020 2020 2020 2020 2020   ',').          
-0000db80: 2020 2020 2020 2020 2020 666f 7220 6d61            for ma
-0000db90: 7873 706c 6974 2069 6e20 7261 6e67 6528  xsplit in range(
-0000dba0: 2d31 2c20 3829 3a0a 2020 2020 2020 2020  -1, 8):.        
+0000d7b0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+0000d7c0: 656c 2065 7870 6563 7465 645b 7374 6172  el expected[star
+0000d7d0: 743a 656e 645d 0a20 2020 2020 2020 2020  t:end].         
+0000d7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d7f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d800: 2020 2020 2020 2069 6620 7761 6e74 5f70         if want_p
+0000d810: 7269 6e74 733a 2023 2070 7261 676d 613a  rints: # pragma:
+0000d820: 206e 6f20 636f 7665 720a 2020 2020 2020   no cover.      
+0000d830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d840: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d850: 2020 2020 2020 2020 2020 2020 2020 7072                pr
+0000d860: 696e 7428 6622 2020 2020 6578 7065 6374  int(f"    expect
+0000d870: 6564 3d7b 6578 7065 6374 6564 7d20 6a6f  ed={expected} jo
+0000d880: 696e 6564 3d7b 6a6f 696e 6564 7d22 290a  ined={joined}").
+0000d890: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d8a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d8b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d8c0: 6578 7065 6374 6564 2e69 6e73 6572 7428  expected.insert(
+0000d8d0: 302c 206a 6f69 6e65 6429 0a20 2020 2020  0, joined).     
+0000d8e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d8f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d900: 2020 2065 7870 6563 7465 645f 6f72 6967     expected_orig
+0000d910: 696e 616c 3220 3d20 6578 7065 6374 6564  inal2 = expected
+0000d920: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d930: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d940: 2020 2020 2020 2020 2066 6f72 206b 6565           for kee
+0000d950: 7020 696e 2028 4661 6c73 652c 2054 7275  p in (False, Tru
+0000d960: 652c 2062 6967 2e41 4c54 4552 4e41 5449  e, big.ALTERNATI
+0000d970: 4e47 2c20 6269 672e 4153 5f50 4149 5253  NG, big.AS_PAIRS
+0000d980: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000d990: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d9a0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0000d9b0: 7870 6563 7465 6420 3d20 6c69 7374 2865  xpected = list(e
+0000d9c0: 7870 6563 7465 645f 6f72 6967 696e 616c  xpected_original
+0000d9d0: 3229 0a20 2020 2020 2020 2020 2020 2020  2).             
+0000d9e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d9f0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000da00: 6620 7761 6e74 5f70 7269 6e74 733a 2023  f want_prints: #
+0000da10: 2070 7261 676d 613a 206e 6f20 636f 7665   pragma: no cove
+0000da20: 720a 2020 2020 2020 2020 2020 2020 2020  r.              
+0000da30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000da40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000da50: 2020 7072 696e 7428 6622 5b6c 6f6f 7020    print(f"[loop 
+0000da60: 375d 206b 6565 703d 7b6b 6565 707d 202f  7] keep={keep} /
+0000da70: 2f20 6578 7065 6374 6564 3d7b 6578 7065  / expected={expe
+0000da80: 6374 6564 7d22 290a 2020 2020 2020 2020  cted}").        
+0000da90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000daa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dab0: 2020 2020 6966 206e 6f74 206b 6565 703a      if not keep:
+0000dac0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000dad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000daf0: 2065 7870 6563 7465 6420 3d20 5b73 2e72   expected = [s.r
+0000db00: 6570 6c61 6365 286e 6f6e 5f73 6570 5f6d  eplace(non_sep_m
+0000db10: 6172 6b65 722c 2065 6d70 7479 2920 666f  arker, empty) fo
+0000db20: 7220 692c 2073 2069 6e20 656e 756d 6572  r i, s in enumer
+0000db30: 6174 6528 6578 7065 6374 6564 2920 6966  ate(expected) if
+0000db40: 2069 2025 2032 203d 3d20 305d 0a20 2020   i % 2 == 0].   
+0000db50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000db60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000db70: 2020 2020 2020 2020 2065 6c69 6620 6b65           elif ke
+0000db80: 6570 203d 3d20 6269 672e 4153 5f50 4149  ep == big.AS_PAI
+0000db90: 5253 3a0a 2020 2020 2020 2020 2020 2020  RS:.            
+0000dba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000dbb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dbc0: 7465 7374 2873 2c20 4e6f 6e65 2c20 6d61  test(s, None, ma
-0000dbd0: 7873 706c 6974 290a 2020 2020 2020 2020  xsplit).        
+0000dbc0: 2020 2020 6e65 775f 6578 7065 6374 6564      new_expected
+0000dbd0: 203d 205b 5d0a 2020 2020 2020 2020 2020   = [].          
 0000dbe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dbf0: 7465 7374 2873 2c20 2220 222c 206d 6178  test(s, " ", max
-0000dc00: 7370 6c69 7429 0a20 2020 2020 2020 2020  split).         
-0000dc10: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-0000dc20: 6573 7428 735f 7769 7468 5f63 6f6d 6d61  est(s_with_comma
-0000dc30: 732c 2027 2c27 2c20 6d61 7873 706c 6974  s, ',', maxsplit
-0000dc40: 290a 0a20 2020 2020 2020 2073 656c 662e  )..        self.
-0000dc50: 6173 7365 7274 4571 7561 6c28 7374 725f  assertEqual(str_
-0000dc60: 7370 6c69 7428 2727 292c 205b 5d29 0a20  split(''), []). 
-0000dc70: 2020 2020 2020 2074 6573 7428 2727 290a         test('').
-0000dc80: 0a20 2020 2020 2020 2023 2074 6573 7420  .        # test 
-0000dc90: 6772 6565 6479 2062 6568 6176 696f 722e  greedy behavior.
-0000dca0: 0a20 2020 2020 2020 2023 2073 7472 2e73  .        # str.s
-0000dcb0: 706c 6974 2069 736e 2774 2067 7265 6564  plit isn't greed
-0000dcc0: 792c 2062 7574 206d 756c 7469 7370 6c69  y, but multispli
-0000dcd0: 7420 6973 2e0a 2020 2020 2020 2020 2320  t is..        # 
-0000dce0: 2877 656c 6c2c 2073 7472 2e73 706c 6974  (well, str.split
-0000dcf0: 202a 6d69 6768 742a 2062 653f 2074 6865   *might* be? the
-0000dd00: 7265 2773 206e 6f20 7761 7920 746f 2063  re's no way to c
-0000dd10: 616c 6c20 6974 0a20 2020 2020 2020 2023  all it.        #
-0000dd20: 2074 6861 7420 6465 6d6f 6e73 7472 6174   that demonstrat
-0000dd30: 6573 2077 6865 7468 6572 206f 7220 6e6f  es whether or no
-0000dd40: 7420 6974 2773 2067 7265 6564 792e 290a  t it's greedy.).
-0000dd50: 2020 2020 2020 2020 2320 616e 7977 6179          # anyway
-0000dd60: 2c20 656e 7375 7265 206d 756c 7469 7370  , ensure multisp
-0000dd70: 6c69 7427 7320 6772 6565 6479 2062 6568  lit's greedy beh
-0000dd80: 6176 696f 7220 646f 6573 6e27 740a 2020  avior doesn't.  
-0000dd90: 2020 2020 2020 2320 6d65 7373 2075 7020        # mess up 
-0000dda0: 6f75 7220 656d 756c 6174 696f 6e20 6f66  our emulation of
-0000ddb0: 2073 7472 2e73 706c 6974 2e0a 2020 2020   str.split..    
-0000ddc0: 2020 2020 7465 7374 2827 615c 7262 5c6e      test('a\rb\n
-0000ddd0: 635c 725c 6e64 2729 0a0a 2020 2020 2020  c\r\nd')..      
-0000dde0: 2020 7465 7374 2827 6120 6220 6320 272c    test('a b c ',
-0000ddf0: 2027 2027 290a 0a20 2020 2064 6566 2074   ' ')..    def t
-0000de00: 6573 745f 7265 696d 706c 656d 656e 7465  est_reimplemente
-0000de10: 645f 7374 725f 7370 6c69 746c 696e 6573  d_str_splitlines
-0000de20: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-0000de30: 6465 6620 7374 725f 7370 6c69 746c 696e  def str_splitlin
-0000de40: 6573 2873 2c20 6b65 6570 656e 6473 3d46  es(s, keepends=F
-0000de50: 616c 7365 293a 0a20 2020 2020 2020 2020  alse):.         
-0000de60: 2020 206e 6577 6c69 6e65 7320 3d20 6269     newlines = bi
-0000de70: 672e 6173 6369 695f 6e65 776c 696e 6573  g.ascii_newlines
-0000de80: 2069 6620 6973 696e 7374 616e 6365 2873   if isinstance(s
-0000de90: 2c20 6279 7465 7329 2065 6c73 6520 6269  , bytes) else bi
-0000dea0: 672e 6e65 776c 696e 6573 0a20 2020 2020  g.newlines.     
-0000deb0: 2020 2020 2020 206c 203d 206c 6973 7428         l = list(
-0000dec0: 6269 672e 6d75 6c74 6973 706c 6974 2873  big.multisplit(s
-0000ded0: 2c20 6e65 776c 696e 6573 2c0a 2020 2020  , newlines,.    
-0000dee0: 2020 2020 2020 2020 2020 2020 6b65 6570              keep
-0000def0: 3d6b 6565 7065 6e64 732c 2073 6570 6172  =keepends, separ
-0000df00: 6174 653d 5472 7565 2c20 7374 7269 703d  ate=True, strip=
-0000df10: 4661 6c73 6529 290a 2020 2020 2020 2020  False)).        
-0000df20: 2020 2020 6966 206c 2061 6e64 206e 6f74      if l and not
-0000df30: 206c 5b2d 315d 3a0a 2020 2020 2020 2020   l[-1]:.        
-0000df40: 2020 2020 2020 2020 2320 7965 732c 2022          # yes, "
-0000df50: 222e 7370 6c69 746c 696e 6573 2829 2072  ".splitlines() r
-0000df60: 6574 7572 6e73 2061 6e20 656d 7074 7920  eturns an empty 
-0000df70: 6c69 7374 0a20 2020 2020 2020 2020 2020  list.           
-0000df80: 2020 2020 206c 2e70 6f70 2829 0a20 2020       l.pop().   
-0000df90: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0000dfa0: 6c0a 0a20 2020 2020 2020 2064 6566 2074  l..        def t
-0000dfb0: 6573 7428 7329 3a0a 2020 2020 2020 2020  est(s):.        
-0000dfc0: 2020 2020 2320 6175 746f 6d61 7469 6361      # automatica
-0000dfd0: 6c6c 7920 7465 7374 2077 6974 6820 2873  lly test with (s
-0000dfe0: 7472 2c20 6279 7465 7329 2078 2028 6b65  tr, bytes) x (ke
-0000dff0: 6570 656e 6473 3d46 616c 7365 2c6b 6565  epends=False,kee
-0000e000: 7065 6e64 733d 5472 7565 2c29 0a20 2020  pends=True,).   
-0000e010: 2020 2020 2020 2020 2066 6f72 2061 735f           for as_
-0000e020: 6279 7465 7320 696e 2028 4661 6c73 652c  bytes in (False,
-0000e030: 2054 7275 6529 3a0a 2020 2020 2020 2020   True):.        
-0000e040: 2020 2020 2020 2020 6966 2061 735f 6279          if as_by
-0000e050: 7465 733a 0a20 2020 2020 2020 2020 2020  tes:.           
-0000e060: 2020 2020 2020 2020 2073 203d 2073 2e65           s = s.e
-0000e070: 6e63 6f64 6528 2761 7363 6969 2729 0a20  ncode('ascii'). 
-0000e080: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-0000e090: 6f72 206b 6565 7065 6e64 7320 696e 2028  or keepends in (
-0000e0a0: 4661 6c73 652c 2054 7275 6529 3a0a 2020  False, True):.  
-0000e0b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e0c0: 2020 6120 3d20 732e 7370 6c69 746c 696e    a = s.splitlin
-0000e0d0: 6573 286b 6565 7065 6e64 7329 0a20 2020  es(keepends).   
-0000e0e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e0f0: 2062 203d 2073 7472 5f73 706c 6974 6c69   b = str_splitli
-0000e100: 6e65 7328 732c 206b 6565 7065 6e64 7329  nes(s, keepends)
-0000e110: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e120: 2020 2020 2073 656c 662e 6173 7365 7274       self.assert
-0000e130: 4571 7561 6c28 612c 2062 2c20 6622 7265  Equal(a, b, f"re
-0000e140: 696d 706c 656d 656e 7465 6420 7374 725f  implemented str_
-0000e150: 7370 6c69 746c 696e 6573 2066 6169 6c73  splitlines fails
-0000e160: 3a20 7b73 2172 7d2e 7370 6c69 746c 696e  : {s!r}.splitlin
-0000e170: 6573 287b 6b65 6570 656e 6473 7d29 203d  es({keepends}) =
-0000e180: 3d20 7b61 7d2c 206d 756c 7469 7370 6c69  = {a}, multispli
-0000e190: 7420 6761 7665 2075 7320 7b62 7d22 290a  t gave us {b}").
-0000e1a0: 0a20 2020 2020 2020 2074 6573 7428 2727  .        test(''
-0000e1b0: 290a 2020 2020 2020 2020 7465 7374 2827  ).        test('
-0000e1c0: 4f6e 6520 6c69 6e65 2729 0a20 2020 2020  One line').     
-0000e1d0: 2020 2074 6573 7428 274f 6e65 206c 696e     test('One lin
-0000e1e0: 655c 6e27 290a 2020 2020 2020 2020 7465  e\n').        te
-0000e1f0: 7374 2827 5477 6f20 6c69 6e65 735c 6e54  st('Two lines\nT
-0000e200: 776f 206c 696e 6573 2729 0a20 2020 2020  wo lines').     
-0000e210: 2020 2074 6573 7428 2754 776f 206c 696e     test('Two lin
-0000e220: 6573 5c6e 5477 6f20 6c69 6e65 735c 6e27  es\nTwo lines\n'
-0000e230: 290a 2020 2020 2020 2020 7465 7374 2827  ).        test('
-0000e240: 5477 6f20 6c69 6e65 735c 6e54 776f 206c  Two lines\nTwo l
-0000e250: 696e 6573 5c6e 5c6e 5c6e 2729 0a0a 2020  ines\n\n\n')..  
-0000e260: 2020 6465 6620 7465 7374 5f72 6569 6d70    def test_reimp
-0000e270: 6c65 6d65 6e74 6564 5f73 7472 5f70 6172  lemented_str_par
-0000e280: 7469 7469 6f6e 2873 656c 6629 3a0a 2020  tition(self):.  
-0000e290: 2020 2020 2020 6465 6620 5f70 6172 7469        def _parti
-0000e2a0: 7469 6f6e 5f74 6f5f 6d75 6c74 6973 706c  tion_to_multispl
-0000e2b0: 6974 2873 2c20 7365 702c 2072 6576 6572  it(s, sep, rever
-0000e2c0: 7365 293a 0a20 2020 2020 2020 2020 2020  se):.           
-0000e2d0: 2069 6620 6e6f 7420 7365 703a 0a20 2020   if not sep:.   
-0000e2e0: 2020 2020 2020 2020 2020 2020 2072 6169               rai
-0000e2f0: 7365 2056 616c 7565 4572 726f 7228 2265  se ValueError("e
-0000e300: 6d70 7479 2073 6570 6172 6174 6f72 2229  mpty separator")
-0000e310: 0a20 2020 2020 2020 2020 2020 206c 203d  .            l =
-0000e320: 2074 7570 6c65 2862 6967 2e6d 756c 7469   tuple(big.multi
-0000e330: 7370 6c69 7428 732c 2028 7365 702c 292c  split(s, (sep,),
-0000e340: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e350: 206b 6565 703d 6269 672e 414c 5445 524e   keep=big.ALTERN
-0000e360: 4154 494e 472c 206d 6178 7370 6c69 743d  ATING, maxsplit=
-0000e370: 312c 2072 6576 6572 7365 3d72 6576 6572  1, reverse=rever
-0000e380: 7365 2c20 7365 7061 7261 7465 3d54 7275  se, separate=Tru
-0000e390: 6529 290a 2020 2020 2020 2020 2020 2020  e)).            
-0000e3a0: 6966 206c 656e 286c 2920 3d3d 2031 3a0a  if len(l) == 1:.
-0000e3b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e3c0: 656d 7074 7920 3d20 6227 2720 6966 2069  empty = b'' if i
-0000e3d0: 7369 6e73 7461 6e63 6528 732c 2062 7974  sinstance(s, byt
-0000e3e0: 6573 2920 656c 7365 2027 270a 2020 2020  es) else ''.    
-0000e3f0: 2020 2020 2020 2020 2020 2020 6966 2072              if r
-0000e400: 6576 6572 7365 3a0a 2020 2020 2020 2020  everse:.        
-0000e410: 2020 2020 2020 2020 2020 2020 6c20 3d20              l = 
-0000e420: 2865 6d70 7479 2c20 656d 7074 7929 202b  (empty, empty) +
-0000e430: 206c 0a20 2020 2020 2020 2020 2020 2020   l.             
-0000e440: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0000e450: 2020 2020 2020 2020 2020 2020 206c 203d               l =
-0000e460: 206c 202b 2028 656d 7074 792c 2065 6d70   l + (empty, emp
-0000e470: 7479 290a 2020 2020 2020 2020 2020 2020  ty).            
-0000e480: 7265 7475 726e 206c 0a0a 2020 2020 2020  return l..      
-0000e490: 2020 6465 6620 7374 725f 7061 7274 6974    def str_partit
-0000e4a0: 696f 6e28 732c 2073 6570 293a 0a20 2020  ion(s, sep):.   
-0000e4b0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0000e4c0: 5f70 6172 7469 7469 6f6e 5f74 6f5f 6d75  _partition_to_mu
-0000e4d0: 6c74 6973 706c 6974 2873 2c20 7365 702c  ltisplit(s, sep,
-0000e4e0: 2046 616c 7365 290a 0a20 2020 2020 2020   False)..       
-0000e4f0: 2064 6566 2073 7472 5f72 7061 7274 6974   def str_rpartit
-0000e500: 696f 6e28 732c 2073 6570 293a 0a20 2020  ion(s, sep):.   
-0000e510: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0000e520: 5f70 6172 7469 7469 6f6e 5f74 6f5f 6d75  _partition_to_mu
-0000e530: 6c74 6973 706c 6974 2873 2c20 7365 702c  ltisplit(s, sep,
-0000e540: 2054 7275 6529 0a0a 2020 2020 2020 2020   True)..        
-0000e550: 6465 6620 7465 7374 2873 2c20 7365 7029  def test(s, sep)
-0000e560: 3a0a 2020 2020 2020 2020 2020 2020 2320  :.            # 
-0000e570: 6175 746f 6d61 7469 6361 6c6c 7920 7465  automatically te
-0000e580: 7374 2077 6974 6820 2873 7472 2c20 6279  st with (str, by
-0000e590: 7465 7329 0a20 2020 2020 2020 2020 2020  tes).           
-0000e5a0: 2066 6f72 2061 735f 6279 7465 7320 696e   for as_bytes in
-0000e5b0: 2028 4661 6c73 652c 2054 7275 6529 3a0a   (False, True):.
-0000e5c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e5d0: 6966 2061 735f 6279 7465 733a 0a20 2020  if as_bytes:.   
+0000dbf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dc00: 2020 2020 2020 7761 6974 696e 6720 3d20        waiting = 
+0000dc10: 4e6f 6e65 0a20 2020 2020 2020 2020 2020  None.           
+0000dc20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dc30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dc40: 2020 2020 2064 6566 2061 7070 656e 6428       def append(
+0000dc50: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
+0000dc60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dc70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dc80: 2020 2020 2020 2020 6e6f 6e6c 6f63 616c          nonlocal
+0000dc90: 2077 6169 7469 6e67 0a20 2020 2020 2020   waiting.       
+0000dca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dcb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dcc0: 2020 2020 2020 2020 2020 2020 2073 203d               s =
+0000dcd0: 2073 2e72 6570 6c61 6365 286e 6f6e 5f73   s.replace(non_s
+0000dce0: 6570 5f6d 6172 6b65 722c 2065 6d70 7479  ep_marker, empty
+0000dcf0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000dd00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dd10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dd20: 2020 2020 2020 6966 2077 6169 7469 6e67        if waiting
+0000dd30: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+0000dd40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dd50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dd60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dd70: 2020 7761 6974 696e 6720 3d20 730a 2020    waiting = s.  
+0000dd80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dd90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dda0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ddb0: 2020 2020 2020 7265 7475 726e 0a20 2020        return.   
+0000ddc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ddd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dde0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ddf0: 206e 6577 5f65 7870 6563 7465 642e 6170   new_expected.ap
+0000de00: 7065 6e64 2828 7761 6974 696e 672c 2073  pend((waiting, s
+0000de10: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
+0000de20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000de30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000de40: 2020 2020 2020 2077 6169 7469 6e67 203d         waiting =
+0000de50: 204e 6f6e 650a 2020 2020 2020 2020 2020   None.          
+0000de60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000de70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000de80: 2020 2020 2020 666f 7220 7320 696e 2065        for s in e
+0000de90: 7870 6563 7465 643a 0a20 2020 2020 2020  xpected:.       
+0000dea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000deb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dec0: 2020 2020 2020 2020 2020 2020 2061 7070               app
+0000ded0: 656e 6428 7329 0a20 2020 2020 2020 2020  end(s).         
+0000dee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000def0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000df00: 2020 2020 2020 2023 206d 616e 7561 6c20         # manual 
+0000df10: 666c 7573 680a 2020 2020 2020 2020 2020  flush.          
+0000df20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000df30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000df40: 2020 2020 2020 6966 2077 6169 7469 6e67        if waiting
+0000df50: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
+0000df60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000df70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000df80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000df90: 2020 6170 7065 6e64 2865 6d70 7479 290a    append(empty).
+0000dfa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dfb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dfc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dfd0: 6578 7065 6374 6564 203d 206e 6577 5f65  expected = new_e
+0000dfe0: 7870 6563 7465 640a 2020 2020 2020 2020  xpected.        
+0000dff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e000: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e010: 2020 2020 656c 6966 206b 6565 7020 3d3d      elif keep ==
+0000e020: 2062 6967 2e41 4c54 4552 4e41 5449 4e47   big.ALTERNATING
+0000e030: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000e040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e050: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e060: 2020 2320 7374 7269 7020 6e6f 6e5f 7365    # strip non_se
+0000e070: 705f 6d61 726b 6572 2068 6163 6b0a 2020  p_marker hack.  
+0000e080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e090: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e0a0: 2020 2020 2020 2020 2020 2020 2020 6578                ex
+0000e0b0: 7065 6374 6564 203d 205b 732e 7265 706c  pected = [s.repl
+0000e0c0: 6163 6528 6e6f 6e5f 7365 705f 6d61 726b  ace(non_sep_mark
+0000e0d0: 6572 2c20 656d 7074 7929 2066 6f72 2073  er, empty) for s
+0000e0e0: 2069 6e20 6578 7065 6374 6564 5d0a 2020   in expected].  
+0000e0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e100: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e110: 2020 2020 2020 2020 2020 656c 6966 206b            elif k
+0000e120: 6565 703a 0a20 2020 2020 2020 2020 2020  eep:.           
+0000e130: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e140: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e150: 2020 2020 206e 6577 5f65 7870 6563 7465       new_expecte
+0000e160: 6420 3d20 5b5d 0a20 2020 2020 2020 2020  d = [].         
+0000e170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e190: 2020 2020 2020 2077 6169 7469 6e67 203d         waiting =
+0000e1a0: 204e 6f6e 650a 2020 2020 2020 2020 2020   None.          
+0000e1b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e1c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e1d0: 2020 2020 2020 6465 6620 6170 7065 6e64        def append
+0000e1e0: 2873 293a 0a20 2020 2020 2020 2020 2020  (s):.           
+0000e1f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e210: 2020 2020 2020 2020 206e 6f6e 6c6f 6361           nonloca
+0000e220: 6c20 7761 6974 696e 670a 2020 2020 2020  l waiting.      
+0000e230: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e240: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e250: 2020 2020 2020 2020 2020 2020 2020 6973                is
+0000e260: 5f73 6570 203d 2073 2069 6e20 7365 7061  _sep = s in sepa
+0000e270: 7261 746f 7273 5f73 6574 0a20 2020 2020  rators_set.     
+0000e280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e290: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e2a0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000e2b0: 203d 2073 2e72 6570 6c61 6365 286e 6f6e   = s.replace(non
+0000e2c0: 5f73 6570 5f6d 6172 6b65 722c 2065 6d70  _sep_marker, emp
+0000e2d0: 7479 290a 2020 2020 2020 2020 2020 2020  ty).            
+0000e2e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e2f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e300: 2020 2020 2020 2020 6966 2028 7761 6974          if (wait
+0000e310: 696e 6720 6973 204e 6f6e 6529 2061 6e64  ing is None) and
+0000e320: 2028 6e6f 7420 6973 5f73 6570 293a 0a20   (not is_sep):. 
+0000e330: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e350: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e360: 2020 2020 2020 2077 6169 7469 6e67 203d         waiting =
+0000e370: 2073 0a20 2020 2020 2020 2020 2020 2020   s.             
+0000e380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e390: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e3a0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0000e3b0: 6e0a 2020 2020 2020 2020 2020 2020 2020  n.              
+0000e3c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e3d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e3e0: 2020 2020 2020 6966 2077 6169 7469 6e67        if waiting
+0000e3f0: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
+0000e400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e420: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e430: 2020 2020 2020 7320 3d20 7761 6974 696e        s = waitin
+0000e440: 6720 2b20 730a 2020 2020 2020 2020 2020  g + s.          
+0000e450: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e460: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e470: 2020 2020 2020 2020 2020 6e65 775f 6578            new_ex
+0000e480: 7065 6374 6564 2e61 7070 656e 6428 7329  pected.append(s)
+0000e490: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e4a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e4c0: 2020 2020 2077 6169 7469 6e67 203d 204e       waiting = N
+0000e4d0: 6f6e 650a 2020 2020 2020 2020 2020 2020  one.            
+0000e4e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e500: 2020 2020 666f 7220 7320 696e 2065 7870      for s in exp
+0000e510: 6563 7465 643a 0a20 2020 2020 2020 2020  ected:.         
+0000e520: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e530: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e540: 2020 2020 2020 2020 2020 2061 7070 656e             appen
+0000e550: 6428 7329 0a20 2020 2020 2020 2020 2020  d(s).           
+0000e560: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e580: 2020 2020 2023 206d 616e 7561 6c20 666c       # manual fl
+0000e590: 7573 680a 2020 2020 2020 2020 2020 2020  ush.            
+0000e5a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e5b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e5c0: 2020 2020 6966 2077 6169 7469 6e67 2069      if waiting i
+0000e5d0: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
 0000e5e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e5f0: 2073 203d 2073 2e65 6e63 6f64 6528 2761   s = s.encode('a
-0000e600: 7363 6969 2729 0a20 2020 2020 2020 2020  scii').         
-0000e610: 2020 2020 2020 2020 2020 2069 6620 7365             if se
-0000e620: 7020 6973 206e 6f74 204e 6f6e 653a 0a20  p is not None:. 
+0000e5f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e600: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e610: 6e65 775f 6578 7065 6374 6564 2e61 7070  new_expected.app
+0000e620: 656e 6428 7761 6974 696e 6729 0a20 2020  end(waiting).   
 0000e630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e640: 2020 2020 2020 2073 6570 203d 2073 6570         sep = sep
-0000e650: 2e65 6e63 6f64 6528 2761 7363 6969 2729  .encode('ascii')
-0000e660: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000e670: 2020 6120 3d20 732e 7061 7274 6974 696f    a = s.partitio
-0000e680: 6e28 7365 7029 0a20 2020 2020 2020 2020  n(sep).         
-0000e690: 2020 2020 2020 2062 203d 2073 7472 5f70         b = str_p
-0000e6a0: 6172 7469 7469 6f6e 2873 2c20 7365 7029  artition(s, sep)
-0000e6b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e6c0: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
-0000e6d0: 6c28 612c 2062 2c20 6622 7265 696d 706c  l(a, b, f"reimpl
-0000e6e0: 656d 656e 7465 6420 7374 725f 7061 7274  emented str_part
-0000e6f0: 6974 696f 6e20 6661 696c 733a 207b 7321  ition fails: {s!
-0000e700: 727d 2e70 6172 7469 7469 6f6e 287b 7365  r}.partition({se
-0000e710: 7021 727d 2920 3d3d 207b 617d 2c20 6d75  p!r}) == {a}, mu
-0000e720: 6c74 6973 706c 6974 2067 6176 6520 7573  ltisplit gave us
-0000e730: 207b 627d 2229 0a0a 2020 2020 2020 2020   {b}")..        
-0000e740: 2020 2020 2020 2020 6120 3d20 732e 7270          a = s.rp
-0000e750: 6172 7469 7469 6f6e 2873 6570 290a 2020  artition(sep).  
-0000e760: 2020 2020 2020 2020 2020 2020 2020 6220                b 
-0000e770: 3d20 7374 725f 7270 6172 7469 7469 6f6e  = str_rpartition
-0000e780: 2873 2c20 7365 7029 0a20 2020 2020 2020  (s, sep).       
-0000e790: 2020 2020 2020 2020 2073 656c 662e 6173           self.as
-0000e7a0: 7365 7274 4571 7561 6c28 612c 2062 2c20  sertEqual(a, b, 
-0000e7b0: 6622 7265 696d 706c 656d 656e 7465 6420  f"reimplemented 
-0000e7c0: 7374 725f 7270 6172 7469 7469 6f6e 2066  str_rpartition f
-0000e7d0: 6169 6c73 3a20 7b73 2172 7d2e 7270 6172  ails: {s!r}.rpar
-0000e7e0: 7469 7469 6f6e 287b 7365 7021 727d 2920  tition({sep!r}) 
-0000e7f0: 3d3d 207b 617d 2c20 6d75 6c74 6973 706c  == {a}, multispl
-0000e800: 6974 2067 6176 6520 7573 207b 627d 2229  it gave us {b}")
-0000e810: 0a0a 2020 2020 2020 2020 7465 7374 2827  ..        test('
-0000e820: 272c 2027 2027 290a 2020 2020 2020 2020  ', ' ').        
-0000e830: 7465 7374 2827 2027 2c20 2720 2729 0a0a  test(' ', ' ')..
-0000e840: 2020 2020 2020 2020 7320 3d20 2220 2061          s = "  a
-0000e850: 2062 2062 2063 2064 2064 2065 2020 220a   b b c d d e  ".
-0000e860: 2020 2020 2020 2020 7465 7374 2873 2c20          test(s, 
-0000e870: 2220 2229 0a20 2020 2020 2020 2074 6573  " ").        tes
-0000e880: 7428 732c 2022 6220 2229 0a20 2020 2020  t(s, "b ").     
-0000e890: 2020 2074 6573 7428 732c 2022 2062 2022     test(s, " b "
-0000e8a0: 290a 2020 2020 2020 2020 7465 7374 2873  ).        test(s
-0000e8b0: 2c20 2220 6222 290a 2020 2020 2020 2020  , " b").        
-0000e8c0: 7465 7374 2873 2c20 2220 6320 2229 0a20  test(s, " c "). 
-0000e8d0: 2020 2020 2020 2074 6573 7428 732c 2022         test(s, "
-0000e8e0: 2064 2229 0a20 2020 2020 2020 2074 6573   d").        tes
-0000e8f0: 7428 732c 2022 2064 2022 290a 2020 2020  t(s, " d ").    
-0000e900: 2020 2020 7465 7374 2873 2c20 2264 2022      test(s, "d "
-0000e910: 290a 2020 2020 2020 2020 7465 7374 2873  ).        test(s
-0000e920: 2c20 2265 2229 0a20 2020 2020 2020 2074  , "e").        t
-0000e930: 6573 7428 732c 2022 686f 6e6b 2229 0a20  est(s, "honk"). 
-0000e940: 2020 2020 2020 2074 6573 7428 732c 2022         test(s, "
-0000e950: 7371 756f 6e6b 2229 0a0a 2020 2020 2020  squonk")..      
-0000e960: 2020 7769 7468 2073 656c 662e 6173 7365    with self.asse
-0000e970: 7274 5261 6973 6573 2856 616c 7565 4572  rtRaises(ValueEr
-0000e980: 726f 7229 3a0a 2020 2020 2020 2020 2020  ror):.          
-0000e990: 2020 2220 6120 6220 6320 222e 7061 7274    " a b c ".part
-0000e9a0: 6974 696f 6e28 2727 290a 2020 2020 2020  ition('').      
-0000e9b0: 2020 7769 7468 2073 656c 662e 6173 7365    with self.asse
-0000e9c0: 7274 5261 6973 6573 2856 616c 7565 4572  rtRaises(ValueEr
-0000e9d0: 726f 7229 3a0a 2020 2020 2020 2020 2020  ror):.          
-0000e9e0: 2020 7374 725f 7061 7274 6974 696f 6e28    str_partition(
-0000e9f0: 2220 6120 6220 6320 222c 2027 2729 0a0a  " a b c ", '')..
-0000ea00: 2020 2020 2020 2020 7769 7468 2073 656c          with sel
-0000ea10: 662e 6173 7365 7274 5261 6973 6573 2856  f.assertRaises(V
-0000ea20: 616c 7565 4572 726f 7229 3a0a 2020 2020  alueError):.    
-0000ea30: 2020 2020 2020 2020 2220 6120 6220 6320          " a b c 
-0000ea40: 222e 7270 6172 7469 7469 6f6e 2827 2729  ".rpartition('')
-0000ea50: 0a20 2020 2020 2020 2077 6974 6820 7365  .        with se
-0000ea60: 6c66 2e61 7373 6572 7452 6169 7365 7328  lf.assertRaises(
-0000ea70: 5661 6c75 6545 7272 6f72 293a 0a20 2020  ValueError):.   
-0000ea80: 2020 2020 2020 2020 2073 7472 5f72 7061           str_rpa
-0000ea90: 7274 6974 696f 6e28 2220 6120 6220 6320  rtition(" a b c 
-0000eaa0: 222c 2027 2729 0a0a 0a20 2020 2064 6566  ", '')...    def
-0000eab0: 2074 6573 745f 7772 6170 5f77 6f72 6473   test_wrap_words
-0000eac0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-0000ead0: 6465 6620 7465 7374 2877 6f72 6473 2c20  def test(words, 
-0000eae0: 6578 7065 6374 6564 2c20 6d61 7267 696e  expected, margin
-0000eaf0: 3d37 3929 3a0a 2020 2020 2020 2020 2020  =79):.          
-0000eb00: 2020 676f 7420 3d20 6269 672e 7772 6170    got = big.wrap
-0000eb10: 5f77 6f72 6473 2877 6f72 6473 2c20 6d61  _words(words, ma
-0000eb20: 7267 696e 290a 2020 2020 2020 2020 2020  rgin).          
-0000eb30: 2020 7365 6c66 2e61 7373 6572 7445 7175    self.assertEqu
-0000eb40: 616c 2867 6f74 2c20 6578 7065 6374 6564  al(got, expected
-0000eb50: 290a 0a20 2020 2020 2020 2074 6573 7428  )..        test(
-0000eb60: 0a20 2020 2020 2020 2020 2020 2022 6865  .            "he
-0000eb70: 6c6c 6f20 7468 6572 652e 2068 6f77 2061  llo there. how a
-0000eb80: 7265 2079 6f75 3f20 6920 616d 2066 696e  re you? i am fin
-0000eb90: 6521 2073 6f20 7468 6572 6527 7320 7468  e! so there's th
-0000eba0: 6174 2e22 2e73 706c 6974 2829 2c0a 2020  at.".split(),.  
-0000ebb0: 2020 2020 2020 2020 2020 2268 656c 6c6f            "hello
-0000ebc0: 2074 6865 7265 2e20 2068 6f77 2061 7265   there.  how are
-0000ebd0: 2079 6f75 3f20 2069 2061 6d20 6669 6e65   you?  i am fine
-0000ebe0: 2120 2073 6f20 7468 6572 6527 7320 7468  !  so there's th
-0000ebf0: 6174 2e22 290a 2020 2020 2020 2020 7465  at.").        te
-0000ec00: 7374 280a 2020 2020 2020 2020 2020 2020  st(.            
-0000ec10: 2268 656c 6c6f 2074 6865 7265 2e20 686f  "hello there. ho
-0000ec20: 7720 6172 6520 796f 753f 2069 2061 6d20  w are you? i am 
-0000ec30: 6669 6e65 2120 736f 2074 6865 7265 2773  fine! so there's
-0000ec40: 2074 6861 742e 222e 7370 6c69 7428 292c   that.".split(),
-0000ec50: 0a20 2020 2020 2020 2020 2020 2022 6865  .            "he
-0000ec60: 6c6c 6f20 7468 6572 652e 2020 686f 775c  llo there.  how\
-0000ec70: 6e61 7265 2079 6f75 3f20 2069 2061 6d20  nare you?  i am 
-0000ec80: 6669 6e65 215c 6e73 6f20 7468 6572 6527  fine!\nso there'
-0000ec90: 7320 7468 6174 2e22 2c0a 2020 2020 2020  s that.",.      
-0000eca0: 2020 2020 2020 3230 290a 2020 2020 2020        20).      
-0000ecb0: 2020 7465 7374 280a 2020 2020 2020 2020    test(.        
-0000ecc0: 2020 2020 5b22 7468 6573 6520 6172 6520      ["these are 
-0000ecd0: 616c 6c20 6c6f 6e67 206c 696e 6573 2074  all long lines t
-0000ece0: 6861 7420 6d75 7374 2062 6520 6279 2074  hat must be by t
-0000ecf0: 6865 6d73 656c 7665 732e 222c 0a20 2020  hemselves.",.   
-0000ed00: 2020 2020 2020 2020 2022 2020 206d 6f72           "   mor
-0000ed10: 6520 7374 7566 6620 676f 6573 2068 6572  e stuff goes her
-0000ed20: 6520 616e 6420 7374 7566 662e 222c 0a20  e and stuff.",. 
-0000ed30: 2020 2020 2020 2020 2020 2022 206b 6e6f             " kno
-0000ed40: 7720 7768 6174 2069 276d 2074 616c 6b69  w what i'm talki
-0000ed50: 6e27 2061 626f 7574 3f20 2079 6561 682c  n' about?  yeah,
-0000ed60: 2074 6861 7427 7320 7768 6174 2069 276d   that's what i'm
-0000ed70: 2074 616c 6b69 6e67 2061 626f 7574 2e22   talking about."
-0000ed80: 5d2c 0a20 2020 2020 2020 2020 2020 2022  ],.            "
-0000ed90: 7468 6573 6520 6172 6520 616c 6c20 6c6f  these are all lo
-0000eda0: 6e67 206c 696e 6573 2074 6861 7420 6d75  ng lines that mu
-0000edb0: 7374 2062 6520 6279 2074 6865 6d73 656c  st be by themsel
-0000edc0: 7665 732e 5c6e 2020 206d 6f72 6520 7374  ves.\n   more st
-0000edd0: 7566 6620 676f 6573 2068 6572 6520 616e  uff goes here an
-0000ede0: 6420 7374 7566 662e 5c6e 206b 6e6f 7720  d stuff.\n know 
-0000edf0: 7768 6174 2069 276d 2074 616c 6b69 6e27  what i'm talkin'
-0000ee00: 2061 626f 7574 3f20 2079 6561 682c 2074   about?  yeah, t
-0000ee10: 6861 7427 7320 7768 6174 2069 276d 2074  hat's what i'm t
-0000ee20: 616c 6b69 6e67 2061 626f 7574 2e22 2c0a  alking about.",.
-0000ee30: 2020 2020 2020 2020 2020 2020 3230 290a              20).
-0000ee40: 2020 2020 2020 2020 7465 7374 280a 2020          test(.  
-0000ee50: 2020 2020 2020 2020 2020 5b22 6122 2c20            ["a", 
-0000ee60: 2762 272c 2027 5c6e 5c6e 272c 2027 6327  'b', '\n\n', 'c'
-0000ee70: 2c20 2764 272c 2027 652e 275d 2c0a 2020  , 'd', 'e.'],.  
-0000ee80: 2020 2020 2020 2020 2020 2261 2062 5c6e            "a b\n
-0000ee90: 5c6e 6320 645c 6e65 2e22 2c0a 2020 2020  \nc d\ne.",.    
-0000eea0: 2020 2020 2020 2020 3429 0a0a 2020 2020          4)..    
-0000eeb0: 6465 6620 7465 7374 5f73 706c 6974 5f74  def test_split_t
-0000eec0: 6578 745f 7769 7468 5f63 6f64 6528 7365  ext_with_code(se
-0000eed0: 6c66 293a 0a20 2020 2020 2020 2064 6566  lf):.        def
-0000eee0: 2074 6573 7428 732c 2065 7870 6563 7465   test(s, expecte
-0000eef0: 642c 202a 2a6b 7761 7267 7329 3a0a 2020  d, **kwargs):.  
-0000ef00: 2020 2020 2020 2020 2020 676f 7420 3d20            got = 
-0000ef10: 6269 672e 7370 6c69 745f 7465 7874 5f77  big.split_text_w
-0000ef20: 6974 685f 636f 6465 2873 2c20 2a2a 6b77  ith_code(s, **kw
-0000ef30: 6172 6773 290a 2020 2020 2020 2020 2020  args).          
-0000ef40: 2020 6966 2030 3a0a 2020 2020 2020 2020    if 0:.        
-0000ef50: 2020 2020 2020 2020 7072 696e 7428 290a          print().
-0000ef60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ef70: 7072 696e 7428 2273 3a22 290a 2020 2020  print("s:").    
-0000ef80: 2020 2020 2020 2020 2020 2020 7072 696e              prin
-0000ef90: 7428 2220 2020 222c 2072 6570 7228 7329  t("   ", repr(s)
-0000efa0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0000efb0: 2020 7072 696e 7428 2267 6f74 3a22 290a    print("got:").
-0000efc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000efd0: 7072 696e 7428 2220 2020 222c 2072 6570  print("   ", rep
-0000efe0: 7228 676f 7429 290a 2020 2020 2020 2020  r(got)).        
-0000eff0: 2020 2020 2020 2020 7072 696e 7428 2265          print("e
-0000f000: 7870 6563 7465 643a 2229 0a20 2020 2020  xpected:").     
-0000f010: 2020 2020 2020 2020 2020 2070 7269 6e74             print
-0000f020: 2822 2020 2022 2c20 7265 7072 2865 7870  ("   ", repr(exp
-0000f030: 6563 7465 6429 290a 2020 2020 2020 2020  ected)).        
-0000f040: 2020 2020 2020 2020 7072 696e 7428 290a          print().
-0000f050: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0000f060: 2e61 7373 6572 7445 7175 616c 2865 7870  .assertEqual(exp
-0000f070: 6563 7465 642c 2067 6f74 290a 2020 2020  ected, got).    
-0000f080: 2020 2020 6465 6620 7874 6573 7428 2a61      def xtest(*a
-0000f090: 2c20 2a2a 6b77 293a 2070 6173 730a 0a20  , **kw): pass.. 
-0000f0a0: 2020 2020 2020 2074 6573 7428 0a20 2020         test(.   
-0000f0b0: 2020 2020 2020 2020 2022 6865 7920 7468           "hey th
-0000f0c0: 6572 6520 7061 7274 7920 7065 6f70 6c65  ere party people
-0000f0d0: 222c 0a20 2020 2020 2020 2020 2020 205b  ",.            [
-0000f0e0: 2768 6579 272c 2027 7468 6572 6527 2c20  'hey', 'there', 
-0000f0f0: 2770 6172 7479 272c 2027 7065 6f70 6c65  'party', 'people
-0000f100: 275d 2c0a 2020 2020 2020 2020 2020 2020  '],.            
-0000f110: 290a 2020 2020 2020 2020 7465 7374 280a  ).        test(.
-0000f120: 2020 2020 2020 2020 2020 2020 2268 6579              "hey
-0000f130: 2074 6865 7265 2070 6172 7479 2070 656f   there party peo
-0000f140: 706c 655c 6e5c 6e61 2073 6563 6f6e 6420  ple\n\na second 
-0000f150: 7061 7261 6772 6170 6821 5c6e 5c6e 616e  paragraph!\n\nan
-0000f160: 6420 6120 7468 6972 642e 222c 0a20 2020  d a third.",.   
-0000f170: 2020 2020 2020 2020 205b 2768 6579 272c           ['hey',
-0000f180: 2027 7468 6572 6527 2c20 2770 6172 7479   'there', 'party
-0000f190: 272c 2027 7065 6f70 6c65 272c 2027 5c6e  ', 'people', '\n
-0000f1a0: 5c6e 272c 2027 6127 2c20 2773 6563 6f6e  \n', 'a', 'secon
-0000f1b0: 6427 2c20 2770 6172 6167 7261 7068 2127  d', 'paragraph!'
-0000f1c0: 2c20 275c 6e5c 6e27 2c20 2761 6e64 272c  , '\n\n', 'and',
-0000f1d0: 2027 6127 2c20 2774 6869 7264 2e27 5d2c   'a', 'third.'],
-0000f1e0: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
-0000f1f0: 2020 2020 2020 2074 6573 7428 0a20 2020         test(.   
-0000f200: 2020 2020 2020 2020 2022 6865 7920 7468           "hey th
-0000f210: 6572 6520 7061 7274 7920 7065 6f70 6c65  ere party people
-0000f220: 5c6e 5c6e 6865 7265 2c20 7765 2068 6176  \n\nhere, we hav
-0000f230: 6520 6120 7365 636f 6e64 2070 6172 6167  e a second parag
-0000f240: 7261 7068 2e5c 6e77 6974 6820 616e 2069  raph.\nwith an i
-0000f250: 6e74 6572 6e61 6c20 6e65 776c 696e 652e  nternal newline.
-0000f260: 5c6e 5c6e 2020 2020 666f 7220 6920 696e  \n\n    for i in
-0000f270: 2063 6f64 653a 5c6e 2020 2020 2020 2020   code:\n        
-0000f280: 7072 696e 7428 6929 5c6e 5c6e 6d6f 7265  print(i)\n\nmore
-0000f290: 2074 6578 7420 6865 7265 3f20 7375 7265   text here? sure
-0000f2a0: 2073 6565 6d73 206c 696b 6520 6974 2e22   seems like it."
-0000f2b0: 2c0a 2020 2020 2020 2020 2020 2020 5b27  ,.            ['
-0000f2c0: 6865 7927 2c20 2774 6865 7265 272c 2027  hey', 'there', '
-0000f2d0: 7061 7274 7927 2c20 2770 656f 706c 6527  party', 'people'
-0000f2e0: 2c20 275c 6e5c 6e27 2c20 2768 6572 652c  , '\n\n', 'here,
-0000f2f0: 272c 2027 7765 272c 2027 6861 7665 272c  ', 'we', 'have',
-0000f300: 2027 6127 2c20 2773 6563 6f6e 6427 2c20   'a', 'second', 
-0000f310: 2770 6172 6167 7261 7068 2e27 2c20 2777  'paragraph.', 'w
-0000f320: 6974 6827 2c20 2761 6e27 2c20 2769 6e74  ith', 'an', 'int
-0000f330: 6572 6e61 6c27 2c20 276e 6577 6c69 6e65  ernal', 'newline
-0000f340: 2e27 2c20 275c 6e5c 6e27 2c20 2720 2020  .', '\n\n', '   
-0000f350: 2066 6f72 2069 2069 6e20 636f 6465 3a27   for i in code:'
-0000f360: 2c20 275c 6e27 2c20 2720 2020 2020 2020  , '\n', '       
-0000f370: 2070 7269 6e74 2869 2927 2c20 275c 6e5c   print(i)', '\n\
-0000f380: 6e27 2c20 276d 6f72 6527 2c20 2774 6578  n', 'more', 'tex
-0000f390: 7427 2c20 2768 6572 653f 272c 2027 7375  t', 'here?', 'su
-0000f3a0: 7265 272c 2027 7365 656d 7327 2c20 276c  re', 'seems', 'l
-0000f3b0: 696b 6527 2c20 2769 742e 275d 0a20 2020  ike', 'it.'].   
-0000f3c0: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
-0000f3d0: 2020 2074 6573 7428 0a20 2020 2020 2020     test(.       
-0000f3e0: 2020 2020 2022 7465 7874 2070 6172 6167       "text parag
-0000f3f0: 7261 7068 7320 7365 7061 7261 7465 6420  raphs separated 
-0000f400: 6279 2069 6e66 696e 6974 6520 6e65 776c  by infinite newl
-0000f410: 696e 6573 2067 6574 2063 6f6c 6c61 7073  ines get collaps
-0000f420: 6564 2074 6f20 6a75 7374 2074 776f 206e  ed to just two n
-0000f430: 6577 6c69 6e65 732e 5c6e 5c6e 5c6e 5c6e  ewlines.\n\n\n\n
-0000f440: 5c6e 7365 653f 206a 7573 7420 7477 6f2e  \nsee? just two.
-0000f450: 5c6e 5c6e 5c6e 5c6e 5c6e 5c6e 5c6e 5c6e  \n\n\n\n\n\n\n\n
-0000f460: 5c6e 7165 6421 222c 0a20 2020 2020 2020  \nqed!",.       
-0000f470: 2020 2020 205b 2774 6578 7427 2c20 2770       ['text', 'p
-0000f480: 6172 6167 7261 7068 7327 2c20 2773 6570  aragraphs', 'sep
-0000f490: 6172 6174 6564 272c 2027 6279 272c 2027  arated', 'by', '
-0000f4a0: 696e 6669 6e69 7465 272c 2027 6e65 776c  infinite', 'newl
-0000f4b0: 696e 6573 272c 2027 6765 7427 2c20 2763  ines', 'get', 'c
-0000f4c0: 6f6c 6c61 7073 6564 272c 2027 746f 272c  ollapsed', 'to',
-0000f4d0: 2027 6a75 7374 272c 2027 7477 6f27 2c20   'just', 'two', 
-0000f4e0: 276e 6577 6c69 6e65 732e 272c 2027 5c6e  'newlines.', '\n
-0000f4f0: 5c6e 272c 2027 7365 653f 272c 2027 6a75  \n', 'see?', 'ju
-0000f500: 7374 272c 2027 7477 6f2e 272c 2027 5c6e  st', 'two.', '\n
-0000f510: 5c6e 272c 2027 7165 6421 275d 0a20 2020  \n', 'qed!'].   
-0000f520: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
-0000f530: 2020 2074 6573 7428 0a20 2020 2020 2020     test(.       
-0000f540: 2020 2020 2022 6865 7265 2773 2073 6f6d       "here's som
-0000f550: 6520 636f 6465 2077 6974 6820 6120 7461  e code with a ta
-0000f560: 622e 5c6e 5c74 666f 7220 7820 696e 2072  b.\n\tfor x in r
-0000f570: 616e 6765 2833 293a 5c6e 5c74 5c74 7072  ange(3):\n\t\tpr
-0000f580: 696e 7428 7829 5c6e 7765 6c70 2120 7468  int(x)\nwelp! th
-0000f590: 6174 2773 2069 7420 666f 7220 7468 6520  at's it for the 
-0000f5a0: 636f 6465 2e22 2c0a 2020 2020 2020 2020  code.",.        
-0000f5b0: 2020 2020 5b22 6865 7265 2773 222c 2027      ["here's", '
-0000f5c0: 736f 6d65 272c 2027 636f 6465 272c 2027  some', 'code', '
-0000f5d0: 7769 7468 272c 2027 6127 2c20 2774 6162  with', 'a', 'tab
-0000f5e0: 2e27 2c20 275c 6e5c 6e27 2c20 2720 2020  .', '\n\n', '   
-0000f5f0: 2020 2020 2066 6f72 2078 2069 6e20 7261       for x in ra
-0000f600: 6e67 6528 3329 3a27 2c20 275c 6e27 2c20  nge(3):', '\n', 
-0000f610: 2720 2020 2020 2020 2020 2020 2020 2020  '               
-0000f620: 2070 7269 6e74 2878 2927 2c20 275c 6e5c   print(x)', '\n\
-0000f630: 6e27 2c20 2777 656c 7021 272c 2022 7468  n', 'welp!', "th
-0000f640: 6174 2773 222c 2027 6974 272c 2027 666f  at's", 'it', 'fo
-0000f650: 7227 2c20 2774 6865 272c 2027 636f 6465  r', 'the', 'code
-0000f660: 2e27 5d0a 2020 2020 2020 2020 2020 2020  .'].            
-0000f670: 290a 2020 2020 2020 2020 7465 7374 280a  ).        test(.
-0000f680: 2020 2020 2020 2020 2020 2020 2268 6572              "her
-0000f690: 6527 7320 736f 6d65 2063 6f64 6520 7769  e's some code wi
-0000f6a0: 7468 2061 2074 6162 2e5c 6e5c 7466 6f72  th a tab.\n\tfor
-0000f6b0: 2078 2069 6e20 7261 6e67 6528 3329 3a5c   x in range(3):\
-0000f6c0: 6e5c 745c 7470 7269 6e74 2878 295c 6e77  n\t\tprint(x)\nw
-0000f6d0: 656c 7021 2074 6861 7427 7320 6974 2066  elp! that's it f
-0000f6e0: 6f72 2074 6865 2063 6f64 652e 222c 0a20  or the code.",. 
-0000f6f0: 2020 2020 2020 2020 2020 205b 2268 6572             ["her
-0000f700: 6527 7322 2c20 2773 6f6d 6527 2c20 2763  e's", 'some', 'c
-0000f710: 6f64 6527 2c20 2777 6974 6827 2c20 2761  ode', 'with', 'a
-0000f720: 272c 2027 7461 622e 272c 2027 5c6e 5c6e  ', 'tab.', '\n\n
-0000f730: 272c 2027 5c74 666f 7220 7820 696e 2072  ', '\tfor x in r
-0000f740: 616e 6765 2833 293a 272c 2027 5c6e 272c  ange(3):', '\n',
-0000f750: 2027 5c74 5c74 7072 696e 7428 7829 272c   '\t\tprint(x)',
-0000f760: 2027 5c6e 5c6e 272c 2027 7765 6c70 2127   '\n\n', 'welp!'
-0000f770: 2c20 2274 6861 7427 7322 2c20 2769 7427  , "that's", 'it'
-0000f780: 2c20 2766 6f72 272c 2027 7468 6527 2c20  , 'for', 'the', 
-0000f790: 2763 6f64 652e 275d 2c0a 2020 2020 2020  'code.'],.      
-0000f7a0: 2020 2020 2020 636f 6e76 6572 745f 7461        convert_ta
-0000f7b0: 6273 5f74 6f5f 7370 6163 6573 3d46 616c  bs_to_spaces=Fal
-0000f7c0: 7365 290a 2020 2020 2020 2020 7465 7374  se).        test
-0000f7d0: 280a 2020 2020 2020 2020 2020 2020 2274  (.            "t
-0000f7e0: 6869 7320 6973 2074 6578 742c 2062 7574  his is text, but
-0000f7f0: 206e 6578 7420 6973 2061 2063 6f64 6520   next is a code 
-0000f800: 7061 7261 6772 6170 6820 7769 7468 2061  paragraph with a
-0000f810: 206c 6f74 206f 6620 696e 7465 726e 616c   lot of internal
-0000f820: 206e 6577 6c69 6e65 7320 616e 6420 7374   newlines and st
-0000f830: 7566 662e 5c6e 5c74 666f 7220 7820 696e  uff.\n\tfor x in
-0000f840: 2072 616e 6765 2833 293a 5c6e 5c6e 2020   range(3):\n\n  
-0000f850: 205c 6e5c 6e20 2020 205c 745c 6e5c 745c   \n\n    \t\n\t\
-0000f860: 7470 7269 6e74 2878 295c 6e5c 745c 745c  tprint(x)\n\t\t\
-0000f870: 6e5c 6e5c 745c 7470 7269 6e74 2878 2a78  n\n\t\tprint(x*x
-0000f880: 295c 6e77 656c 7021 2074 6861 7427 7320  )\nwelp! that's 
-0000f890: 6974 2066 6f72 2074 6865 2063 6f64 652e  it for the code.
-0000f8a0: 222c 0a20 2020 2020 2020 2020 2020 205b  ",.            [
-0000f8b0: 2774 6869 7327 2c20 2769 7327 2c20 2774  'this', 'is', 't
-0000f8c0: 6578 742c 272c 2027 6275 7427 2c20 276e  ext,', 'but', 'n
-0000f8d0: 6578 7427 2c20 2769 7327 2c20 2761 272c  ext', 'is', 'a',
-0000f8e0: 2027 636f 6465 272c 2027 7061 7261 6772   'code', 'paragr
-0000f8f0: 6170 6827 2c20 2777 6974 6827 2c20 2761  aph', 'with', 'a
-0000f900: 272c 2027 6c6f 7427 2c20 276f 6627 2c20  ', 'lot', 'of', 
-0000f910: 2769 6e74 6572 6e61 6c27 2c20 276e 6577  'internal', 'new
-0000f920: 6c69 6e65 7327 2c20 2761 6e64 272c 2027  lines', 'and', '
-0000f930: 7374 7566 662e 272c 2027 5c6e 5c6e 272c  stuff.', '\n\n',
-0000f940: 0a20 2020 2020 2020 2020 2020 2027 2020  .            '  
-0000f950: 2020 2020 2020 666f 7220 7820 696e 2072        for x in r
-0000f960: 616e 6765 2833 293a 272c 2027 5c6e 272c  ange(3):', '\n',
-0000f970: 2027 5c6e 272c 2027 5c6e 272c 2027 5c6e   '\n', '\n', '\n
-0000f980: 272c 2027 5c6e 272c 2027 2020 2020 2020  ', '\n', '      
-0000f990: 2020 2020 2020 2020 2020 7072 696e 7428            print(
-0000f9a0: 7829 272c 2027 5c6e 272c 2027 5c6e 272c  x)', '\n', '\n',
-0000f9b0: 2027 5c6e 272c 2027 2020 2020 2020 2020   '\n', '        
-0000f9c0: 2020 2020 2020 2020 7072 696e 7428 782a          print(x*
-0000f9d0: 7829 272c 2027 5c6e 5c6e 272c 2027 7765  x)', '\n\n', 'we
-0000f9e0: 6c70 2127 2c20 2274 6861 7427 7322 2c20  lp!', "that's", 
-0000f9f0: 2769 7427 2c20 2766 6f72 272c 2027 7468  'it', 'for', 'th
-0000fa00: 6527 2c20 2763 6f64 652e 275d 0a20 2020  e', 'code.'].   
-0000fa10: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
-0000fa20: 2020 2077 6974 6820 7365 6c66 2e61 7373     with self.ass
-0000fa30: 6572 7452 6169 7365 7328 5275 6e74 696d  ertRaises(Runtim
-0000fa40: 6545 7272 6f72 293a 0a20 2020 2020 2020  eError):.       
-0000fa50: 2020 2020 2062 6967 2e73 706c 6974 5f74       big.split_t
-0000fa60: 6578 745f 7769 7468 5f63 6f64 6528 2268  ext_with_code("h
-0000fa70: 6f77 6479 2e5c 6e5c 7677 6861 7427 7320  owdy.\n\vwhat's 
-0000fa80: 7468 6973 3f22 290a 2020 2020 2020 2020  this?").        
-0000fa90: 7769 7468 2073 656c 662e 6173 7365 7274  with self.assert
-0000faa0: 5261 6973 6573 2852 756e 7469 6d65 4572  Raises(RuntimeEr
-0000fab0: 726f 7229 3a0a 2020 2020 2020 2020 2020  ror):.          
-0000fac0: 2020 6269 672e 7370 6c69 745f 7465 7874    big.split_text
-0000fad0: 5f77 6974 685f 636f 6465 2822 686f 7764  _with_code("howd
-0000fae0: 792e 5c6e 2020 2020 666f 7220 6120 696e  y.\n    for a in
-0000faf0: 205c 7620 7261 6e67 6528 3330 293a 5c6e   \v range(30):\n
-0000fb00: 2020 2020 2020 2020 7072 696e 7428 6129          print(a)
-0000fb10: 2229 0a0a 2020 2020 6465 6620 7465 7374  ")..    def test
-0000fb20: 5f6d 6572 6765 5f63 6f6c 756d 6e73 2873  _merge_columns(s
-0000fb30: 656c 6629 3a0a 2020 2020 2020 2020 6465  elf):.        de
-0000fb40: 6620 7465 7374 2863 6f6c 756d 6e73 2c20  f test(columns, 
-0000fb50: 6578 7065 6374 6564 2c20 2a2a 6b77 6172  expected, **kwar
-0000fb60: 6773 293a 0a20 2020 2020 2020 2020 2020  gs):.           
-0000fb70: 2067 6f74 203d 2062 6967 2e6d 6572 6765   got = big.merge
-0000fb80: 5f63 6f6c 756d 6e73 282a 636f 6c75 6d6e  _columns(*column
-0000fb90: 732c 202a 2a6b 7761 7267 7329 0a20 2020  s, **kwargs).   
-0000fba0: 2020 2020 2020 2020 2069 6620 303a 0a20           if 0:. 
-0000fbb0: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-0000fbc0: 7269 6e74 2822 5f22 2a37 3029 0a20 2020  rint("_"*70).   
-0000fbd0: 2020 2020 2020 2020 2020 2020 2070 7269               pri
-0000fbe0: 6e74 2822 636f 6c75 6d6e 7322 290a 2020  nt("columns").  
-0000fbf0: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-0000fc00: 696e 7428 7265 7072 2863 6f6c 756d 6e73  int(repr(columns
-0000fc10: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
-0000fc20: 2020 2070 7269 6e74 2822 6578 7065 6374     print("expect
-0000fc30: 6564 3a22 290a 2020 2020 2020 2020 2020  ed:").          
-0000fc40: 2020 2020 2020 7072 696e 7428 290a 2020        print().  
-0000fc50: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-0000fc60: 696e 7428 7265 7072 2865 7870 6563 7465  int(repr(expecte
-0000fc70: 6429 290a 2020 2020 2020 2020 2020 2020  d)).            
-0000fc80: 2020 2020 7072 696e 7428 6578 7065 6374      print(expect
-0000fc90: 6564 290a 2020 2020 2020 2020 2020 2020  ed).            
-0000fca0: 2020 2020 7072 696e 7428 290a 2020 2020      print().    
-0000fcb0: 2020 2020 2020 2020 2020 2020 7072 696e              prin
-0000fcc0: 7428 2267 6f74 3a22 290a 2020 2020 2020  t("got:").      
-0000fcd0: 2020 2020 2020 2020 2020 7072 696e 7428            print(
-0000fce0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0000fcf0: 2020 7072 696e 7428 7265 7072 2867 6f74    print(repr(got
-0000fd00: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
-0000fd10: 2020 2070 7269 6e74 2867 6f74 290a 2020     print(got).  
-0000fd20: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-0000fd30: 696e 7428 290a 2020 2020 2020 2020 2020  int().          
-0000fd40: 2020 2020 2020 7072 696e 7428 290a 2020        print().  
-0000fd50: 2020 2020 2020 2020 2020 7365 6c66 2e61            self.a
-0000fd60: 7373 6572 7445 7175 616c 2867 6f74 2c20  ssertEqual(got, 
-0000fd70: 6578 7065 6374 6564 290a 0a20 2020 2020  expected)..     
-0000fd80: 2020 2077 6974 6820 7365 6c66 2e61 7373     with self.ass
-0000fd90: 6572 7452 6169 7365 7328 4f76 6572 666c  ertRaises(Overfl
-0000fda0: 6f77 4572 726f 7229 3a0a 2020 2020 2020  owError):.      
-0000fdb0: 2020 2020 2020 7465 7374 285b 2822 315c        test([("1\
-0000fdc0: 6e32 5c6e 3320 3420 3520 3620 3720 3822  n2\n3 4 5 6 7 8"
-0000fdd0: 2c20 342c 2034 292c 2028 2268 6f77 6479  , 4, 4), ("howdy
-0000fde0: 5c6e 6865 6c6c 6f5c 6e68 692c 2068 6f77  \nhello\nhi, how
-0000fdf0: 2061 7265 2079 6f75 3f5c 6e69 276d 2066   are you?\ni'm f
-0000fe00: 696e 652e 222c 2035 2c20 3136 292c 2028  ine.", 5, 16), (
-0000fe10: 2265 6e64 696e 675c 6e74 6578 7421 222e  "ending\ntext!".
-0000fe20: 7370 6c69 7428 225c 6e22 292c 2037 392c  split("\n"), 79,
-0000fe30: 2037 3929 5d2c 0a20 2020 2020 2020 2020   79)],.         
-0000fe40: 2020 2020 2020 2022 3120 2020 2068 6f77         "1    how
-0000fe50: 6479 2020 2020 2020 2020 2020 2020 656e  dy            en
-0000fe60: 6469 6e67 5c6e 3220 2020 2068 656c 6c6f  ding\n2    hello
-0000fe70: 2020 2020 2020 2020 2020 2020 7465 7874              text
-0000fe80: 215c 6e33 2020 2020 6869 2c20 686f 7720  !\n3    hi, how 
-0000fe90: 6172 6520 796f 753f 5c6e 2020 2020 2069  are you?\n     i
-0000fea0: 276d 2066 696e 652e 222c 0a20 2020 2020  'm fine.",.     
-0000feb0: 2020 2020 2020 2020 2020 206f 7665 7266             overf
-0000fec0: 6c6f 775f 7374 7261 7465 6779 3d62 6967  low_strategy=big
-0000fed0: 2e4f 7665 7266 6c6f 7753 7472 6174 6567  .OverflowStrateg
-0000fee0: 792e 5241 4953 4529 0a0a 2020 2020 2020  y.RAISE)..      
-0000fef0: 2020 7465 7374 285b 2822 315c 6e32 5c6e    test([("1\n2\n
-0000ff00: 3322 2c20 342c 2034 292c 2028 2268 6f77  3", 4, 4), ("how
-0000ff10: 6479 5c6e 6865 6c6c 6f5c 6e68 692c 2068  dy\nhello\nhi, h
-0000ff20: 6f77 2061 7265 2079 6f75 3f5c 6e69 276d  ow are you?\ni'm
-0000ff30: 2066 696e 652e 222c 2035 2c20 3136 292c   fine.", 5, 16),
-0000ff40: 2028 2265 6e64 696e 675c 6e74 6578 7421   ("ending\ntext!
-0000ff50: 222e 7370 6c69 7428 225c 6e22 292c 2037  ".split("\n"), 7
-0000ff60: 392c 2037 3929 5d2c 0a20 2020 2020 2020  9, 79)],.       
-0000ff70: 2020 2020 2022 3120 2020 2068 6f77 6479       "1    howdy
-0000ff80: 2020 2020 2020 2020 2020 2020 656e 6469              endi
-0000ff90: 6e67 5c6e 3220 2020 2068 656c 6c6f 2020  ng\n2    hello  
-0000ffa0: 2020 2020 2020 2020 2020 7465 7874 215c            text!\
-0000ffb0: 6e33 2020 2020 6869 2c20 686f 7720 6172  n3    hi, how ar
-0000ffc0: 6520 796f 753f 5c6e 2020 2020 2069 276d  e you?\n     i'm
-0000ffd0: 2066 696e 652e 222c 0a20 2020 2020 2020   fine.",.       
-0000ffe0: 2020 2020 206f 7665 7266 6c6f 775f 7374       overflow_st
-0000fff0: 7261 7465 6779 3d62 6967 2e4f 7665 7266  rategy=big.Overf
-00010000: 6c6f 7753 7472 6174 6567 792e 494e 5452  lowStrategy.INTR
-00010010: 5544 455f 414c 4c29 0a0a 2020 2020 2020  UDE_ALL)..      
-00010020: 2020 7465 7374 285b 2822 7375 7065 7220    test([("super 
-00010030: 6c6f 6e67 206c 696e 6573 2068 6572 655c  long lines here\
-00010040: 6e49 206d 6561 6e2c 2074 6865 7920 6a75  nI mean, they ju
-00010050: 7374 2067 6f20 6f6e 2061 6e64 206f 6e2e  st go on and on.
-00010060: 5c6e 2874 6578 7429 5c6e 7368 6f72 7420  \n(text)\nshort 
-00010070: 6e6f 775c 6e68 6f77 6576 6572 2e5c 6e74  now\nhowever.\nt
-00010080: 6861 6e6b 5c6e 7468 6520 6d61 6b65 7221  hank\nthe maker!
-00010090: 222c 2035 2c20 3135 292c 2028 2274 6869  ", 5, 15), ("thi
-000100a0: 7320 6973 2074 6865 2073 6563 6f6e 6420  s is the second 
-000100b0: 636f 6c75 6d6e 2e5c 6e64 6f65 7320 6974  column.\ndoes it
-000100c0: 2068 6176 6520 746f 2077 6169 743f 2020   have to wait?  
-000100d0: 6974 2073 686f 756c 642e 222c 2032 302c  it should.", 20,
-000100e0: 2036 3029 5d2c 0a20 2020 2020 2020 2020   60)],.         
-000100f0: 2020 2027 7375 7065 7220 6c6f 6e67 206c     'super long l
-00010100: 696e 6573 2068 6572 655c 6e49 206d 6561  ines here\nI mea
-00010110: 6e2c 2074 6865 7920 6a75 7374 2067 6f20  n, they just go 
-00010120: 6f6e 2061 6e64 206f 6e2e 5c6e 2874 6578  on and on.\n(tex
-00010130: 7429 5c6e 7368 6f72 7420 6e6f 775c 6e68  t)\nshort now\nh
-00010140: 6f77 6576 6572 2e20 2020 2020 2020 2074  owever.        t
-00010150: 6869 7320 6973 2074 6865 2073 6563 6f6e  his is the secon
-00010160: 6420 636f 6c75 6d6e 2e5c 6e74 6861 6e6b  d column.\nthank
-00010170: 2020 2020 2020 2020 2020 2064 6f65 7320             does 
-00010180: 6974 2068 6176 6520 746f 2077 6169 743f  it have to wait?
-00010190: 2020 6974 2073 686f 756c 642e 5c6e 7468    it should.\nth
-000101a0: 6520 6d61 6b65 7221 272c 0a20 2020 2020  e maker!',.     
-000101b0: 2020 2020 2020 206f 7665 7266 6c6f 775f         overflow_
-000101c0: 6166 7465 723d 322c 0a20 2020 2020 2020  after=2,.       
-000101d0: 2020 2020 206f 7665 7266 6c6f 775f 7374       overflow_st
-000101e0: 7261 7465 6779 3d62 6967 2e4f 7665 7266  rategy=big.Overf
-000101f0: 6c6f 7753 7472 6174 6567 792e 494e 5452  lowStrategy.INTR
-00010200: 5544 455f 414c 4c29 0a0a 2020 2020 2020  UDE_ALL)..      
-00010210: 2020 2320 6d65 7267 6520 6f76 6572 666c    # merge overfl
-00010220: 6f77 7320 6475 6520 746f 206f 7665 7266  ows due to overf
-00010230: 6c6f 775f 6265 666f 7265 2061 6e64 206f  low_before and o
-00010240: 7665 7266 6c6f 775f 6166 7465 7220 6265  verflow_after be
-00010250: 696e 6720 6c61 7267 650a 2020 2020 2020  ing large.      
-00010260: 2020 7465 7374 285b 0a20 2020 2020 2020    test([.       
-00010270: 2020 2020 2028 226f 7665 7266 6c6f 7720       ("overflow 
-00010280: 6c69 6e65 2031 5c6e 615c 6e62 5c6e 635c  line 1\na\nb\nc\
-00010290: 6e64 5c6e 6f76 6572 666c 6f77 206c 696e  nd\noverflow lin
-000102a0: 6520 325c 6e22 2c20 342c 2038 292c 0a20  e 2\n", 4, 8),. 
-000102b0: 2020 2020 2020 2020 2020 2028 2274 6869             ("thi
-000102c0: 7320 6973 2074 6865 2073 6563 6f6e 6420  s is the second 
-000102d0: 636f 6c75 6d6e 2e5c 6e64 6f65 7320 6974  column.\ndoes it
-000102e0: 2068 6176 6520 746f 2077 6169 743f 2020   have to wait?  
-000102f0: 6974 2073 686f 756c 642e 222c 2032 302c  it should.", 20,
-00010300: 2036 3029 2c0a 2020 2020 2020 2020 2020   60),.          
-00010310: 2020 5d2c 0a20 2020 2020 2020 2020 2020    ],.           
-00010320: 2027 6f76 6572 666c 6f77 206c 696e 6520   'overflow line 
-00010330: 315c 6e61 5c6e 625c 6e63 5c6e 645c 6e6f  1\na\nb\nc\nd\no
-00010340: 7665 7266 6c6f 7720 6c69 6e65 2032 5c6e  verflow line 2\n
-00010350: 2020 2020 2020 2020 2074 6869 7320 6973           this is
-00010360: 2074 6865 2073 6563 6f6e 6420 636f 6c75   the second colu
-00010370: 6d6e 2e5c 6e20 2020 2020 2020 2020 646f  mn.\n         do
-00010380: 6573 2069 7420 6861 7665 2074 6f20 7761  es it have to wa
-00010390: 6974 3f20 2069 7420 7368 6f75 6c64 2e27  it?  it should.'
-000103a0: 2c0a 2020 2020 2020 2020 2020 2020 6f76  ,.            ov
-000103b0: 6572 666c 6f77 5f62 6566 6f72 653d 322c  erflow_before=2,
-000103c0: 0a20 2020 2020 2020 2020 2020 206f 7665  .            ove
-000103d0: 7266 6c6f 775f 6166 7465 723d 332c 0a20  rflow_after=3,. 
-000103e0: 2020 2020 2020 2020 2020 206f 7665 7266             overf
-000103f0: 6c6f 775f 7374 7261 7465 6779 3d62 6967  low_strategy=big
-00010400: 2e4f 7665 7266 6c6f 7753 7472 6174 6567  .OverflowStrateg
-00010410: 792e 494e 5452 5544 455f 414c 4c29 0a0a  y.INTRUDE_ALL)..
-00010420: 2020 2020 2020 2020 7465 7374 285b 0a20          test([. 
-00010430: 2020 2020 2020 2020 2020 2028 226f 7665             ("ove
-00010440: 7266 6c6f 7720 6c69 6e65 2031 5c6e 615c  rflow line 1\na\
-00010450: 6e62 5c6e 635c 6e64 5c6e 655c 6e66 5c6e  nb\nc\nd\ne\nf\n
-00010460: 6f76 6572 666c 6f77 206c 696e 6520 325c  overflow line 2\
-00010470: 6e22 2c20 342c 2038 292c 0a20 2020 2020  n", 4, 8),.     
-00010480: 2020 2020 2020 2028 2274 6869 7320 6973         ("this is
-00010490: 2074 6865 2073 6563 6f6e 6420 636f 6c75   the second colu
-000104a0: 6d6e 2e5c 6e64 6f65 7320 6974 2068 6176  mn.\ndoes it hav
-000104b0: 6520 746f 2077 6169 743f 2020 6e6f 7420  e to wait?  not 
-000104c0: 7468 6973 2074 696d 652e 222c 2032 302c  this time.", 20,
-000104d0: 2036 3029 2c0a 2020 2020 2020 2020 2020   60),.          
-000104e0: 2020 5d2c 0a20 2020 2020 2020 2020 2020    ],.           
-000104f0: 2027 6f76 6572 666c 6f77 206c 696e 6520   'overflow line 
-00010500: 315c 6e61 2020 2020 2020 2020 7468 6973  1\na        this
-00010510: 2069 7320 7468 6520 7365 636f 6e64 2063   is the second c
-00010520: 6f6c 756d 6e2e 5c6e 6220 2020 2020 2020  olumn.\nb       
-00010530: 2064 6f65 7320 6974 2068 6176 6520 746f   does it have to
-00010540: 2077 6169 743f 2020 6e6f 7420 7468 6973   wait?  not this
-00010550: 2074 696d 652e 5c6e 635c 6e64 5c6e 655c   time.\nc\nd\ne\
-00010560: 6e66 5c6e 6f76 6572 666c 6f77 206c 696e  nf\noverflow lin
-00010570: 6520 3227 2c0a 2020 2020 2020 2020 2020  e 2',.          
-00010580: 2020 6f76 6572 666c 6f77 5f73 7472 6174    overflow_strat
-00010590: 6567 793d 6269 672e 4f76 6572 666c 6f77  egy=big.Overflow
-000105a0: 5374 7261 7465 6779 2e49 4e54 5255 4445  Strategy.INTRUDE
-000105b0: 5f41 4c4c 290a 2020 2020 2020 2020 2320  _ALL).        # 
-000105c0: 7465 7374 2070 6175 7365 2075 6e74 696c  test pause until
-000105d0: 2066 696e 616c 0a20 2020 2020 2020 2074   final.        t
-000105e0: 6573 7428 5b0a 2020 2020 2020 2020 2020  est([.          
-000105f0: 2020 2822 6f76 6572 666c 6f77 206c 696e    ("overflow lin
-00010600: 6520 315c 6e61 5c6e 625c 6e63 5c6e 645c  e 1\na\nb\nc\nd\
-00010610: 6e65 5c6e 665c 6e6f 7665 7266 6c6f 7720  ne\nf\noverflow 
-00010620: 6c69 6e65 2032 5c6e 222c 2034 2c20 3829  line 2\n", 4, 8)
-00010630: 2c0a 2020 2020 2020 2020 2020 2020 2822  ,.            ("
-00010640: 7468 6973 2069 7320 7468 6520 7365 636f  this is the seco
-00010650: 6e64 2063 6f6c 756d 6e2e 5c6e 646f 6573  nd column.\ndoes
-00010660: 2069 7420 6861 7665 2074 6f20 7761 6974   it have to wait
-00010670: 3f20 2069 7420 7368 6f75 6c64 2e22 2c20  ?  it should.", 
-00010680: 3230 2c20 3630 292c 0a20 2020 2020 2020  20, 60),.       
-00010690: 2020 2020 205d 2c0a 2020 2020 2020 2020       ],.        
-000106a0: 2020 2020 276f 7665 7266 6c6f 7720 6c69      'overflow li
-000106b0: 6e65 2031 5c6e 615c 6e62 5c6e 635c 6e64  ne 1\na\nb\nc\nd
-000106c0: 5c6e 655c 6e66 5c6e 6f76 6572 666c 6f77  \ne\nf\noverflow
-000106d0: 206c 696e 6520 325c 6e20 2020 2020 2020   line 2\n       
-000106e0: 2020 7468 6973 2069 7320 7468 6520 7365    this is the se
-000106f0: 636f 6e64 2063 6f6c 756d 6e2e 5c6e 2020  cond column.\n  
-00010700: 2020 2020 2020 2064 6f65 7320 6974 2068         does it h
-00010710: 6176 6520 746f 2077 6169 743f 2020 6974  ave to wait?  it
-00010720: 2073 686f 756c 642e 272c 0a20 2020 2020   should.',.     
-00010730: 2020 2020 2020 206f 7665 7266 6c6f 775f         overflow_
-00010740: 7374 7261 7465 6779 203d 2062 6967 2e4f  strategy = big.O
-00010750: 7665 7266 6c6f 7753 7472 6174 6567 792e  verflowStrategy.
-00010760: 4445 4c41 595f 414c 4c2c 0a20 2020 2020  DELAY_ALL,.     
-00010770: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
-00010780: 2020 7265 7375 6c74 7320 3d20 5b0a 2020    results = [.  
-00010790: 2020 2020 2020 2020 2020 2731 207c 2061            '1 | a
-000107a0: 6161 207c 2077 6861 7420 7c20 6161 615c  aa | what | aaa\
-000107b0: 6e32 207c 2062 6262 207c 2068 6f20 2020  n2 | bbb | ho   
-000107c0: 7c20 6262 625c 6e33 207c 2063 6363 207c  | bbb\n3 | ccc |
-000107d0: 2074 6f6f 2d6c 6f6e 675c 6e34 207c 2064   too-long\n4 | d
-000107e0: 6464 207c 2063 6f6c 756d 6e5c 6e35 207c  dd | column\n5 |
-000107f0: 2065 6565 207c 2068 6572 6520 7c20 6363   eee | here | cc
-00010800: 635c 6e36 207c 2066 6666 207c 206d 7920  c\n6 | fff | my 
-00010810: 2020 7c20 6464 645c 6e37 207c 2067 6767    | ddd\n7 | ggg
-00010820: 207c 206f 6820 2020 7c20 6565 655c 6e38   | oh   | eee\n8
-00010830: 207c 2068 6868 207c 206d 7920 2020 7c20   | hhh | my   | 
-00010840: 6666 665c 6e20 207c 2020 2020 207c 2077  fff\n  |     | w
-00010850: 6861 7420 7c20 6767 675c 6e20 207c 2020  hat | ggg\n  |  
-00010860: 2020 207c 2074 7765 6564 795c 6e20 207c     | tweedy\n  |
-00010870: 2020 2020 207c 2066 756e 2020 7c20 6868       | fun  | hh
-00010880: 6827 2c0a 2020 2020 2020 2020 2020 2020  h',.            
-00010890: 2731 207c 2061 6161 207c 2077 6861 7420  '1 | aaa | what 
-000108a0: 7c20 6161 615c 6e32 207c 2062 6262 207c  | aaa\n2 | bbb |
-000108b0: 2068 6f20 2020 7c20 6262 625c 6e33 207c   ho   | bbb\n3 |
-000108c0: 2063 6363 207c 2074 6f6f 2d6c 6f6e 675c   ccc | too-long\
-000108d0: 6e34 207c 2064 6464 207c 2063 6f6c 756d  n4 | ddd | colum
-000108e0: 6e5c 6e35 207c 2065 6565 207c 2068 6572  n\n5 | eee | her
-000108f0: 655c 6e36 207c 2066 6666 207c 206d 7920  e\n6 | fff | my 
-00010900: 2020 7c20 6363 635c 6e37 207c 2067 6767    | ccc\n7 | ggg
-00010910: 207c 206f 6820 2020 7c20 6464 645c 6e38   | oh   | ddd\n8
-00010920: 207c 2068 6868 207c 206d 7920 2020 7c20   | hhh | my   | 
-00010930: 6565 655c 6e20 207c 2020 2020 207c 2077  eee\n  |     | w
-00010940: 6861 7420 7c20 6666 665c 6e20 207c 2020  hat | fff\n  |  
-00010950: 2020 207c 2074 7765 6564 795c 6e20 207c     | tweedy\n  |
-00010960: 2020 2020 207c 2066 756e 5c6e 2020 7c20       | fun\n  | 
-00010970: 2020 2020 7c20 2020 2020 207c 2067 6767      |      | ggg
-00010980: 5c6e 2020 7c20 2020 2020 7c20 2020 2020  \n  |     |     
-00010990: 207c 2068 6868 272c 0a20 2020 2020 2020   | hhh',.       
-000109a0: 2020 2020 2027 3120 7c20 6161 6120 7c20       '1 | aaa | 
-000109b0: 7768 6174 207c 2061 6161 5c6e 3220 7c20  what | aaa\n2 | 
-000109c0: 6262 6220 7c20 686f 5c6e 3320 7c20 6363  bbb | ho\n3 | cc
-000109d0: 6320 7c20 746f 6f2d 6c6f 6e67 5c6e 3420  c | too-long\n4 
-000109e0: 7c20 6464 6420 7c20 636f 6c75 6d6e 5c6e  | ddd | column\n
-000109f0: 3520 7c20 6565 6520 7c20 6865 7265 207c  5 | eee | here |
-00010a00: 2062 6262 5c6e 3620 7c20 6666 6620 7c20   bbb\n6 | fff | 
-00010a10: 6d79 2020 207c 2063 6363 5c6e 3720 7c20  my   | ccc\n7 | 
-00010a20: 6767 6720 7c20 6f68 2020 207c 2064 6464  ggg | oh   | ddd
-00010a30: 5c6e 3820 7c20 6868 6820 7c20 6d79 2020  \n8 | hhh | my  
-00010a40: 207c 2065 6565 5c6e 2020 7c20 2020 2020   | eee\n  |     
-00010a50: 7c20 7768 6174 5c6e 2020 7c20 2020 2020  | what\n  |     
-00010a60: 7c20 7477 6565 6479 5c6e 2020 7c20 2020  | tweedy\n  |   
-00010a70: 2020 7c20 6675 6e20 207c 2066 6666 5c6e    | fun  | fff\n
-00010a80: 2020 7c20 2020 2020 7c20 2020 2020 207c    |     |      |
-00010a90: 2067 6767 5c6e 2020 7c20 2020 2020 7c20   ggg\n  |     | 
-00010aa0: 2020 2020 207c 2068 6868 272c 0a20 2020       | hhh',.   
-00010ab0: 2020 2020 2020 2020 2027 3120 7c20 6161           '1 | aa
-00010ac0: 6120 7c20 7768 6174 207c 2061 6161 5c6e  a | what | aaa\n
-00010ad0: 3220 7c20 6262 6220 7c20 686f 5c6e 3320  2 | bbb | ho\n3 
-00010ae0: 7c20 6363 6320 7c20 746f 6f2d 6c6f 6e67  | ccc | too-long
-00010af0: 5c6e 3420 7c20 6464 6420 7c20 636f 6c75  \n4 | ddd | colu
-00010b00: 6d6e 5c6e 3520 7c20 6565 6520 7c20 6865  mn\n5 | eee | he
-00010b10: 7265 5c6e 3620 7c20 6666 6620 7c20 6d79  re\n6 | fff | my
-00010b20: 2020 207c 2062 6262 5c6e 3720 7c20 6767     | bbb\n7 | gg
-00010b30: 6720 7c20 6f68 2020 207c 2063 6363 5c6e  g | oh   | ccc\n
-00010b40: 3820 7c20 6868 6820 7c20 6d79 2020 207c  8 | hhh | my   |
-00010b50: 2064 6464 5c6e 2020 7c20 2020 2020 7c20   ddd\n  |     | 
-00010b60: 7768 6174 5c6e 2020 7c20 2020 2020 7c20  what\n  |     | 
-00010b70: 7477 6565 6479 5c6e 2020 7c20 2020 2020  tweedy\n  |     
-00010b80: 7c20 6675 6e5c 6e20 207c 2020 2020 207c  | fun\n  |     |
-00010b90: 2020 2020 2020 7c20 6565 655c 6e20 207c        | eee\n  |
-00010ba0: 2020 2020 207c 2020 2020 2020 7c20 6666       |      | ff
-00010bb0: 665c 6e20 207c 2020 2020 207c 2020 2020  f\n  |     |    
-00010bc0: 2020 7c20 6767 675c 6e20 207c 2020 2020    | ggg\n  |    
-00010bd0: 207c 2020 2020 2020 7c20 6868 6827 2c0a   |      | hhh',.
-00010be0: 2020 2020 2020 2020 2020 2020 5d0a 0a20              ].. 
-00010bf0: 2020 2020 2020 2072 6573 756c 7473 5f69         results_i
-00010c00: 7465 7261 746f 7220 3d20 6974 6572 2872  terator = iter(r
-00010c10: 6573 756c 7473 290a 2020 2020 2020 2020  esults).        
-00010c20: 666f 7220 6f76 6572 666c 6f77 5f62 6566  for overflow_bef
-00010c30: 6f72 6520 696e 2072 616e 6765 2832 293a  ore in range(2):
-00010c40: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
-00010c50: 206f 7665 7266 6c6f 775f 6166 7465 7220   overflow_after 
-00010c60: 696e 2072 616e 6765 2832 293a 0a20 2020  in range(2):.   
-00010c70: 2020 2020 2020 2020 2020 2020 2074 6573               tes
-00010c80: 7428 280a 2020 2020 2020 2020 2020 2020  t((.            
-00010c90: 2020 2020 2020 2020 2822 315c 6e32 5c6e          ("1\n2\n
-00010ca0: 335c 6e34 5c6e 355c 6e36 5c6e 375c 6e38  3\n4\n5\n6\n7\n8
-00010cb0: 222c 2031 2c20 3129 2c0a 2020 2020 2020  ", 1, 1),.      
-00010cc0: 2020 2020 2020 2020 2020 2020 2020 2822                ("
-00010cd0: 6161 615c 6e62 6262 5c6e 6363 635c 6e64  aaa\nbbb\nccc\nd
-00010ce0: 6464 5c6e 6565 655c 6e66 6666 5c6e 6767  dd\neee\nfff\ngg
-00010cf0: 675c 6e68 6868 222c 2033 2c20 3329 2c0a  g\nhhh", 3, 3),.
-00010d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010d10: 2020 2020 2822 7768 6174 5c6e 686f 5c6e      ("what\nho\n
-00010d20: 746f 6f2d 6c6f 6e67 5c6e 636f 6c75 6d6e  too-long\ncolumn
-00010d30: 5c6e 6865 7265 5c6e 6d79 5c6e 6f68 5c6e  \nhere\nmy\noh\n
-00010d40: 6d79 5c6e 7768 6174 5c6e 7477 6565 6479  my\nwhat\ntweedy
-00010d50: 5c6e 6675 6e5c 6e22 2c20 322c 2034 292c  \nfun\n", 2, 4),
-00010d60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00010d70: 2020 2020 2028 2261 6161 5c6e 6262 625c       ("aaa\nbbb\
-00010d80: 6e63 6363 5c6e 6464 645c 6e65 6565 5c6e  nccc\nddd\neee\n
-00010d90: 6666 665c 6e67 6767 5c6e 6868 6822 2c20  fff\nggg\nhhh", 
-00010da0: 332c 2033 292c 0a20 2020 2020 2020 2020  3, 3),.         
-00010db0: 2020 2020 2020 2020 2020 2029 2c0a 2020             ),.  
-00010dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010dd0: 2020 6e65 7874 2872 6573 756c 7473 5f69    next(results_i
-00010de0: 7465 7261 746f 7229 2c0a 2020 2020 2020  terator),.      
-00010df0: 2020 2020 2020 2020 2020 2020 2020 636f                co
-00010e00: 6c75 6d6e 5f73 6570 6172 6174 6f72 3d22  lumn_separator="
-00010e10: 207c 2022 2c0a 2020 2020 2020 2020 2020   | ",.          
-00010e20: 2020 2020 2020 2020 2020 6f76 6572 666c            overfl
-00010e30: 6f77 5f62 6566 6f72 653d 6f76 6572 666c  ow_before=overfl
-00010e40: 6f77 5f62 6566 6f72 652c 0a20 2020 2020  ow_before,.     
-00010e50: 2020 2020 2020 2020 2020 2020 2020 206f                 o
-00010e60: 7665 7266 6c6f 775f 6166 7465 723d 6f76  verflow_after=ov
-00010e70: 6572 666c 6f77 5f61 6674 6572 2c0a 2020  erflow_after,.  
-00010e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010e90: 2020 6f76 6572 666c 6f77 5f73 7472 6174    overflow_strat
-00010ea0: 6567 793d 6269 672e 4f76 6572 666c 6f77  egy=big.Overflow
-00010eb0: 5374 7261 7465 6779 2e49 4e54 5255 4445  Strategy.INTRUDE
-00010ec0: 5f41 4c4c 290a 0a20 2020 2020 2020 2074  _ALL)..        t
-00010ed0: 6573 7428 280a 2020 2020 2020 2020 2020  est((.          
-00010ee0: 2020 2822 315c 6e32 5c6e 335c 6e34 5c6e    ("1\n2\n3\n4\n
-00010ef0: 355c 6e36 5c6e 375c 6e38 222c 2031 2c20  5\n6\n7\n8", 1, 
-00010f00: 3129 2c0a 2020 2020 2020 2020 2020 2020  1),.            
-00010f10: 2822 6161 615c 6e62 6262 5c6e 6363 635c  ("aaa\nbbb\nccc\
-00010f20: 6e64 6464 5c6e 6565 655c 6e66 6666 5c6e  nddd\neee\nfff\n
-00010f30: 6767 675c 6e68 6868 222c 2033 2c20 3329  ggg\nhhh", 3, 3)
-00010f40: 2c0a 2020 2020 2020 2020 2020 2020 2822  ,.            ("
-00010f50: 7768 6174 5c6e 686f 5c6e 746f 6f2d 6c6f  what\nho\ntoo-lo
-00010f60: 6e67 5c6e 636f 6c75 6d6e 5c6e 6865 7265  ng\ncolumn\nhere
-00010f70: 5c6e 6d79 5c6e 6f68 5c6e 6d79 5c6e 7768  \nmy\noh\nmy\nwh
-00010f80: 6174 5c6e 7477 6565 6479 5c6e 6675 6e5c  at\ntweedy\nfun\
-00010f90: 6e22 2c20 322c 2034 292c 0a20 2020 2020  n", 2, 4),.     
-00010fa0: 2020 2020 2020 2028 2261 6161 5c6e 6262         ("aaa\nbb
-00010fb0: 625c 6e63 6363 5c6e 6464 645c 6e65 6565  b\nccc\nddd\neee
-00010fc0: 5c6e 6666 665c 6e67 6767 5c6e 6868 6822  \nfff\nggg\nhhh"
-00010fd0: 2c20 332c 2033 292c 0a20 2020 2020 2020  , 3, 3),.       
-00010fe0: 2020 2020 2029 2c0a 2020 2020 2020 2020       ),.        
-00010ff0: 2020 2020 2731 207c 2061 6161 207c 2077      '1 | aaa | w
-00011000: 6861 745c 6e32 207c 2062 6262 207c 2068  hat\n2 | bbb | h
-00011010: 6f5c 6e33 207c 2063 6363 207c 2074 6f6f  o\n3 | ccc | too
-00011020: 2d6c 6f6e 675c 6e34 207c 2064 6464 207c  -long\n4 | ddd |
-00011030: 2063 6f6c 756d 6e5c 6e35 207c 2065 6565   column\n5 | eee
-00011040: 207c 2068 6572 655c 6e36 207c 2066 6666   | here\n6 | fff
-00011050: 207c 206d 795c 6e37 207c 2067 6767 207c   | my\n7 | ggg |
-00011060: 206f 685c 6e38 207c 2068 6868 207c 206d   oh\n8 | hhh | m
-00011070: 795c 6e20 207c 2020 2020 207c 2077 6861  y\n  |     | wha
-00011080: 745c 6e20 207c 2020 2020 207c 2074 7765  t\n  |     | twe
-00011090: 6564 795c 6e20 207c 2020 2020 207c 2066  edy\n  |     | f
-000110a0: 756e 5c6e 2020 7c20 2020 2020 7c20 2020  un\n  |     |   
-000110b0: 2020 207c 2061 6161 5c6e 2020 7c20 2020     | aaa\n  |   
-000110c0: 2020 7c20 2020 2020 207c 2062 6262 5c6e    |      | bbb\n
-000110d0: 2020 7c20 2020 2020 7c20 2020 2020 207c    |     |      |
-000110e0: 2063 6363 5c6e 2020 7c20 2020 2020 7c20   ccc\n  |     | 
-000110f0: 2020 2020 207c 2064 6464 5c6e 2020 7c20       | ddd\n  | 
-00011100: 2020 2020 7c20 2020 2020 207c 2065 6565      |      | eee
-00011110: 5c6e 2020 7c20 2020 2020 7c20 2020 2020  \n  |     |     
-00011120: 207c 2066 6666 5c6e 2020 7c20 2020 2020   | fff\n  |     
-00011130: 7c20 2020 2020 207c 2067 6767 5c6e 2020  |      | ggg\n  
-00011140: 7c20 2020 2020 7c20 2020 2020 207c 2068  |     |      | h
-00011150: 6868 272c 0a20 2020 2020 2020 2020 2020  hh',.           
-00011160: 2063 6f6c 756d 6e5f 7365 7061 7261 746f   column_separato
-00011170: 723d 2220 7c20 222c 0a20 2020 2020 2020  r=" | ",.       
-00011180: 2020 2020 206f 7665 7266 6c6f 775f 7374       overflow_st
-00011190: 7261 7465 6779 3d62 6967 2e4f 7665 7266  rategy=big.Overf
-000111a0: 6c6f 7753 7472 6174 6567 792e 4445 4c41  lowStrategy.DELA
-000111b0: 595f 414c 4c2c 0a20 2020 2020 2020 2020  Y_ALL,.         
-000111c0: 2020 206f 7665 7266 6c6f 775f 6265 666f     overflow_befo
-000111d0: 7265 3d30 2c0a 2020 2020 2020 2020 2020  re=0,.          
-000111e0: 2020 6f76 6572 666c 6f77 5f61 6674 6572    overflow_after
-000111f0: 3d31 2c0a 2020 2020 2020 2020 2020 2020  =1,.            
-00011200: 290a 0a0a 0a20 2020 2064 6566 2074 6573  )....    def tes
-00011210: 745f 7465 7874 5f70 6970 656c 696e 6528  t_text_pipeline(
-00011220: 7365 6c66 293a 0a20 2020 2020 2020 2064  self):.        d
-00011230: 6566 2074 6573 7428 636f 6c75 6d6e 732c  ef test(columns,
-00011240: 2065 7870 6563 7465 6429 3a0a 2020 2020   expected):.    
-00011250: 2020 2020 2020 2020 7370 6c69 7473 203d          splits =
-00011260: 205b 2862 6967 2e73 706c 6974 5f74 6578   [(big.split_tex
-00011270: 745f 7769 7468 5f63 6f64 6528 636f 6c75  t_with_code(colu
-00011280: 6d6e 292c 206d 696e 2c20 6d61 7829 2066  mn), min, max) f
-00011290: 6f72 2063 6f6c 756d 6e2c 206d 696e 2c20  or column, min, 
-000112a0: 6d61 7820 696e 2063 6f6c 756d 6e73 5d0a  max in columns].
-000112b0: 2020 2020 2020 2020 2020 2020 7772 6170              wrap
-000112c0: 7065 6420 3d20 5b28 6269 672e 7772 6170  ped = [(big.wrap
-000112d0: 5f77 6f72 6473 2873 706c 6974 2c20 6d61  _words(split, ma
-000112e0: 7267 696e 3d6d 6178 292c 206d 696e 2c20  rgin=max), min, 
-000112f0: 6d61 7829 2066 6f72 2073 706c 6974 2c20  max) for split, 
-00011300: 6d69 6e2c 206d 6178 2069 6e20 7370 6c69  min, max in spli
-00011310: 7473 5d0a 2020 2020 2020 2020 2020 2020  ts].            
-00011320: 676f 7420 3d20 6269 672e 6d65 7267 655f  got = big.merge_
-00011330: 636f 6c75 6d6e 7328 2a77 7261 7070 6564  columns(*wrapped
-00011340: 2c20 6f76 6572 666c 6f77 5f73 7472 6174  , overflow_strat
-00011350: 6567 793d 6269 672e 4f76 6572 666c 6f77  egy=big.Overflow
-00011360: 5374 7261 7465 6779 2e49 4e54 5255 4445  Strategy.INTRUDE
-00011370: 5f41 4c4c 290a 2020 2020 2020 2020 2020  _ALL).          
-00011380: 2020 6966 2030 3a0a 2020 2020 2020 2020    if 0:.        
-00011390: 2020 2020 2020 2020 7072 696e 7428 225f          print("_
-000113a0: 222a 3730 290a 2020 2020 2020 2020 2020  "*70).          
-000113b0: 2020 2020 2020 7072 696e 7428 2263 6f6c        print("col
-000113c0: 756d 6e73 2229 0a20 2020 2020 2020 2020  umns").         
-000113d0: 2020 2020 2020 2070 7269 6e74 2872 6570         print(rep
-000113e0: 7228 636f 6c75 6d6e 7329 290a 2020 2020  r(columns)).    
-000113f0: 2020 2020 2020 2020 2020 2020 7072 696e              prin
-00011400: 7428 2265 7870 6563 7465 643a 2229 0a20  t("expected:"). 
-00011410: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-00011420: 7269 6e74 2829 0a20 2020 2020 2020 2020  rint().         
-00011430: 2020 2020 2020 2070 7269 6e74 2865 7870         print(exp
-00011440: 6563 7465 6429 0a20 2020 2020 2020 2020  ected).         
-00011450: 2020 2020 2020 2070 7269 6e74 2829 0a20         print(). 
-00011460: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-00011470: 7269 6e74 2822 676f 743a 2229 0a20 2020  rint("got:").   
-00011480: 2020 2020 2020 2020 2020 2020 2070 7269               pri
-00011490: 6e74 2829 0a20 2020 2020 2020 2020 2020  nt().           
-000114a0: 2020 2020 2070 7269 6e74 2867 6f74 290a       print(got).
-000114b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000114c0: 7072 696e 7428 290a 2020 2020 2020 2020  print().        
-000114d0: 2020 2020 2020 2020 7072 696e 7428 290a          print().
-000114e0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-000114f0: 2e61 7373 6572 7445 7175 616c 2867 6f74  .assertEqual(got
-00011500: 2c20 6578 7065 6374 6564 290a 0a20 2020  , expected)..   
-00011510: 2020 2020 2074 6573 7428 0a20 2020 2020       test(.     
-00011520: 2020 2020 2020 2028 0a20 2020 2020 2020         (.       
-00011530: 2020 2020 2020 2020 2028 0a20 2020 2020           (.     
-00011540: 2020 2020 2020 2020 2020 2022 2d76 7c2d             "-v|-
-00011550: 2d76 6572 626f 7365 222c 0a20 2020 2020  -verbose",.     
-00011560: 2020 2020 2020 2020 2020 2031 392c 0a20             19,. 
-00011570: 2020 2020 2020 2020 2020 2020 2020 2031                 1
-00011580: 392c 0a20 2020 2020 2020 2020 2020 2020  9,.             
-00011590: 2020 2029 2c0a 2020 2020 2020 2020 2020     ),.          
-000115a0: 2020 2020 2020 280a 2020 2020 2020 2020        (.        
-000115b0: 2020 2020 2020 2020 2243 6175 7365 7320          "Causes 
-000115c0: 7468 6520 7072 6f67 7261 6d20 746f 2070  the program to p
-000115d0: 726f 6475 6365 206d 6f72 6520 6f75 7470  roduce more outp
-000115e0: 7574 2e20 2053 7065 6369 6679 696e 6720  ut.  Specifying 
-000115f0: 6974 206d 756c 7469 706c 6520 7469 6d65  it multiple time
-00011600: 7320 7261 6973 6573 2074 6865 2076 6f6c  s raises the vol
-00011610: 756d 6520 6f66 206f 7574 7075 742e 222c  ume of output.",
-00011620: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00011630: 2030 2c0a 2020 2020 2020 2020 2020 2020   0,.            
-00011640: 2020 2020 3630 2c0a 2020 2020 2020 2020      60,.        
-00011650: 2020 2020 2020 2020 292c 0a20 2020 2020          ),.     
-00011660: 2020 2020 2020 2029 2c0a 2020 2020 2020         ),.      
-00011670: 2020 2020 2020 272d 767c 2d2d 7665 7262        '-v|--verb
-00011680: 6f73 6520 2020 2020 2020 2043 6175 7365  ose        Cause
-00011690: 7320 7468 6520 7072 6f67 7261 6d20 746f  s the program to
-000116a0: 2070 726f 6475 6365 206d 6f72 6520 6f75   produce more ou
-000116b0: 7470 7574 2e20 2053 7065 6369 6679 696e  tput.  Specifyin
-000116c0: 6720 6974 5c6e 2020 2020 2020 2020 2020  g it\n          
-000116d0: 2020 2020 2020 2020 2020 6d75 6c74 6970            multip
-000116e0: 6c65 2074 696d 6573 2072 6169 7365 7320  le times raises 
-000116f0: 7468 6520 766f 6c75 6d65 206f 6620 6f75  the volume of ou
-00011700: 7470 7574 2e27 0a20 2020 2020 2020 2029  tput.'.        )
-00011710: 0a0a 2020 2020 2020 2020 7465 7374 280a  ..        test(.
-00011720: 2020 2020 2020 2020 2020 2020 280a 2020              (.  
-00011730: 2020 2020 2020 2020 2020 2020 2020 280a                (.
-00011740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011750: 222d 767c 2d2d 7665 7262 6f73 6522 2c0a  "-v|--verbose",.
-00011760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011770: 392c 0a20 2020 2020 2020 2020 2020 2020  9,.             
-00011780: 2020 2039 2c0a 2020 2020 2020 2020 2020     9,.          
-00011790: 2020 2020 2020 292c 0a20 2020 2020 2020        ),.       
-000117a0: 2020 2020 2020 2020 2028 0a20 2020 2020           (.     
-000117b0: 2020 2020 2020 2020 2020 2022 4361 7573             "Caus
-000117c0: 6573 2074 6865 2070 726f 6772 616d 2074  es the program t
-000117d0: 6f20 7072 6f64 7563 6520 6d6f 7265 206f  o produce more o
-000117e0: 7574 7075 742e 2020 5370 6563 6966 7969  utput.  Specifyi
-000117f0: 6e67 2069 7420 6d75 6c74 6970 6c65 2074  ng it multiple t
-00011800: 696d 6573 2072 6169 7365 7320 7468 6520  imes raises the 
-00011810: 766f 6c75 6d65 206f 6620 6f75 7470 7574  volume of output
-00011820: 2e22 2c0a 2020 2020 2020 2020 2020 2020  .",.            
-00011830: 2020 2020 302c 0a20 2020 2020 2020 2020      0,.         
-00011840: 2020 2020 2020 2036 302c 0a20 2020 2020         60,.     
-00011850: 2020 2020 2020 2020 2020 2029 2c0a 2020             ),.  
-00011860: 2020 2020 2020 2020 2020 292c 0a20 2020            ),.   
-00011870: 2020 2020 2020 2020 2027 2d76 7c2d 2d76           '-v|--v
-00011880: 6572 626f 7365 5c6e 2020 2020 2020 2020  erbose\n        
-00011890: 2020 4361 7573 6573 2074 6865 2070 726f    Causes the pro
-000118a0: 6772 616d 2074 6f20 7072 6f64 7563 6520  gram to produce 
-000118b0: 6d6f 7265 206f 7574 7075 742e 2020 5370  more output.  Sp
-000118c0: 6563 6966 7969 6e67 2069 745c 6e20 2020  ecifying it\n   
-000118d0: 2020 2020 2020 206d 756c 7469 706c 6520         multiple 
-000118e0: 7469 6d65 7320 7261 6973 6573 2074 6865  times raises the
-000118f0: 2076 6f6c 756d 6520 6f66 206f 7574 7075   volume of outpu
-00011900: 742e 270a 2020 2020 2020 2020 290a 0a20  t.'.        ).. 
-00011910: 2020 2020 2020 2023 2061 6e20 656d 7074         # an empt
-00011920: 7920 636f 6c75 6d6e 206a 7573 7420 6164  y column just ad
-00011930: 6473 2073 7061 6365 2e20 2073 6f2c 2074  ds space.  so, t
-00011940: 6f20 696e 6465 6e74 2065 7665 7279 7468  o indent everyth
-00011950: 696e 672c 2061 6464 2061 6e20 656d 7074  ing, add an empt
-00011960: 7920 696e 6974 6961 6c20 636f 6c75 6d6e  y initial column
-00011970: 2e0a 2020 2020 2020 2020 2320 6e6f 7465  ..        # note
-00011980: 2074 6861 7420 6974 276c 6c20 6265 206d   that it'll be m
-00011990: 696e 5f77 6964 7468 2077 6964 6520 616e  in_width wide an
-000119a0: 6420 2a74 6865 6e2a 2079 6f75 276c 6c20  d *then* you'll 
-000119b0: 6765 7420 7468 6520 636f 6c75 6d6e 5f73  get the column_s
-000119c0: 6570 6172 6174 6f72 2e0a 2020 2020 2020  eparator..      
-000119d0: 2020 7465 7374 280a 2020 2020 2020 2020    test(.        
-000119e0: 2020 2020 280a 2020 2020 2020 2020 2020      (.          
-000119f0: 2020 2020 2020 280a 2020 2020 2020 2020        (.        
-00011a00: 2020 2020 2020 2020 2222 2c0a 2020 2020          "",.    
-00011a10: 2020 2020 2020 2020 2020 2020 332c 0a20              3,. 
-00011a20: 2020 2020 2020 2020 2020 2020 2020 2033                 3
-00011a30: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00011a40: 2020 292c 0a20 2020 2020 2020 2020 2020    ),.           
-00011a50: 2020 2020 2028 0a20 2020 2020 2020 2020       (.         
-00011a60: 2020 2020 2020 2022 2d76 7c2d 2d76 6572         "-v|--ver
-00011a70: 626f 7365 222c 0a20 2020 2020 2020 2020  bose",.         
-00011a80: 2020 2020 2020 2031 392c 0a20 2020 2020         19,.     
-00011a90: 2020 2020 2020 2020 2020 2031 392c 0a20             19,. 
-00011aa0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-00011ab0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00011ac0: 2020 280a 2020 2020 2020 2020 2020 2020    (.            
-00011ad0: 2020 2020 2243 6175 7365 7320 7468 6520      "Causes the 
-00011ae0: 7072 6f67 7261 6d20 746f 2070 726f 6475  program to produ
-00011af0: 6365 206d 6f72 6520 6f75 7470 7574 2e20  ce more output. 
-00011b00: 2053 7065 6369 6679 696e 6720 6974 206d   Specifying it m
-00011b10: 756c 7469 706c 6520 7469 6d65 7320 7261  ultiple times ra
-00011b20: 6973 6573 2074 6865 2076 6f6c 756d 6520  ises the volume 
-00011b30: 6f66 206f 7574 7075 742e 222c 0a20 2020  of output.",.   
-00011b40: 2020 2020 2020 2020 2020 2020 2030 2c0a               0,.
-00011b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011b60: 3630 2c0a 2020 2020 2020 2020 2020 2020  60,.            
-00011b70: 2020 2020 292c 0a20 2020 2020 2020 2020      ),.         
-00011b80: 2020 2029 2c0a 2020 2020 2020 2020 2020     ),.          
-00011b90: 2020 2720 2020 202d 767c 2d2d 7665 7262    '    -v|--verb
-00011ba0: 6f73 6520 2020 2020 2020 2043 6175 7365  ose        Cause
-00011bb0: 7320 7468 6520 7072 6f67 7261 6d20 746f  s the program to
-00011bc0: 2070 726f 6475 6365 206d 6f72 6520 6f75   produce more ou
-00011bd0: 7470 7574 2e20 2053 7065 6369 6679 696e  tput.  Specifyin
-00011be0: 6720 6974 5c6e 2020 2020 2020 2020 2020  g it\n          
-00011bf0: 2020 2020 2020 2020 2020 2020 2020 6d75                mu
-00011c00: 6c74 6970 6c65 2074 696d 6573 2072 6169  ltiple times rai
-00011c10: 7365 7320 7468 6520 766f 6c75 6d65 206f  ses the volume o
-00011c20: 6620 6f75 7470 7574 2e27 0a20 2020 2020  f output.'.     
-00011c30: 2020 2029 0a0a 2020 2020 6465 6620 7465     )..    def te
-00011c40: 7374 5f67 656e 746c 795f 7469 746c 6528  st_gently_title(
-00011c50: 7365 6c66 293a 0a20 2020 2020 2020 2064  self):.        d
-00011c60: 6566 2074 6573 7428 732c 2065 7870 6563  ef test(s, expec
-00011c70: 7465 642c 2074 6573 745f 6173 6369 693d  ted, test_ascii=
-00011c80: 5472 7565 2c20 6170 6f73 7472 6f70 6865  True, apostrophe
-00011c90: 733d 4e6f 6e65 2c20 646f 7562 6c65 5f71  s=None, double_q
-00011ca0: 756f 7465 733d 4e6f 6e65 293a 0a20 2020  uotes=None):.   
-00011cb0: 2020 2020 2020 2020 2072 6573 756c 7420           result 
-00011cc0: 3d20 6269 672e 6765 6e74 6c79 5f74 6974  = big.gently_tit
-00011cd0: 6c65 2873 2c20 6170 6f73 7472 6f70 6865  le(s, apostrophe
-00011ce0: 733d 6170 6f73 7472 6f70 6865 732c 2064  s=apostrophes, d
-00011cf0: 6f75 626c 655f 7175 6f74 6573 3d64 6f75  ouble_quotes=dou
-00011d00: 626c 655f 7175 6f74 6573 290a 2020 2020  ble_quotes).    
-00011d10: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
-00011d20: 6572 7445 7175 616c 2872 6573 756c 742c  ertEqual(result,
-00011d30: 2065 7870 6563 7465 6429 0a20 2020 2020   expected).     
-00011d40: 2020 2020 2020 2069 6620 7465 7374 5f61         if test_a
-00011d50: 7363 6969 3a0a 2020 2020 2020 2020 2020  scii:.          
-00011d60: 2020 2020 2020 6966 2061 706f 7374 726f        if apostro
-00011d70: 7068 6573 3a0a 2020 2020 2020 2020 2020  phes:.          
-00011d80: 2020 2020 2020 2020 2020 6170 6f73 7472            apostr
-00011d90: 6f70 6865 7320 3d20 6170 6f73 7472 6f70  ophes = apostrop
-00011da0: 6865 732e 656e 636f 6465 2827 6173 6369  hes.encode('asci
-00011db0: 6927 290a 2020 2020 2020 2020 2020 2020  i').            
-00011dc0: 2020 2020 6966 2064 6f75 626c 655f 7175      if double_qu
-00011dd0: 6f74 6573 3a0a 2020 2020 2020 2020 2020  otes:.          
-00011de0: 2020 2020 2020 2020 2020 646f 7562 6c65            double
-00011df0: 5f71 756f 7465 7320 3d20 646f 7562 6c65  _quotes = double
-00011e00: 5f71 756f 7465 732e 656e 636f 6465 2827  _quotes.encode('
-00011e10: 6173 6369 6927 290a 2020 2020 2020 2020  ascii').        
-00011e20: 2020 2020 2020 2020 7265 7375 6c74 203d          result =
-00011e30: 2062 6967 2e67 656e 746c 795f 7469 746c   big.gently_titl
-00011e40: 6528 732e 656e 636f 6465 2827 6173 6369  e(s.encode('asci
-00011e50: 6927 292c 2061 706f 7374 726f 7068 6573  i'), apostrophes
-00011e60: 3d61 706f 7374 726f 7068 6573 2c20 646f  =apostrophes, do
-00011e70: 7562 6c65 5f71 756f 7465 733d 646f 7562  uble_quotes=doub
-00011e80: 6c65 5f71 756f 7465 7329 0a20 2020 2020  le_quotes).     
-00011e90: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00011ea0: 6173 7365 7274 4571 7561 6c28 7265 7375  assertEqual(resu
-00011eb0: 6c74 2c20 6578 7065 6374 6564 2e65 6e63  lt, expected.enc
-00011ec0: 6f64 6528 2761 7363 6969 2729 290a 0a20  ode('ascii')).. 
-00011ed0: 2020 2020 2020 2074 6573 7428 2222 2c20         test("", 
-00011ee0: 2222 290a 2020 2020 2020 2020 7465 7374  "").        test
-00011ef0: 2822 6162 6364 6520 6667 6822 2c20 2241  ("abcde fgh", "A
-00011f00: 6263 6465 2046 6768 2229 0a20 2020 2020  bcde Fgh").     
-00011f10: 2020 2074 6573 7428 2270 6574 6572 206f     test("peter o
-00011f20: 2774 6f6f 6c65 222c 2022 5065 7465 7220  'toole", "Peter 
-00011f30: 4f27 546f 6f6c 6522 290a 2020 2020 2020  O'Toole").      
-00011f40: 2020 7465 7374 2822 6c6f 7264 2064 2761    test("lord d'a
-00011f50: 7263 7922 2c20 224c 6f72 6420 4427 4172  rcy", "Lord D'Ar
-00011f60: 6379 2229 0a20 2020 2020 2020 2074 6573  cy").        tes
-00011f70: 7428 226d 756c 7469 706c 6520 2020 7370  t("multiple   sp
-00011f80: 6163 6573 222c 2022 4d75 6c74 6970 6c65  aces", "Multiple
-00011f90: 2020 2053 7061 6365 7322 290a 2020 2020     Spaces").    
-00011fa0: 2020 2020 7465 7374 2822 2774 7761 7320      test("'twas 
-00011fb0: 7468 6520 6e69 6768 7420 6265 666f 7265  the night before
-00011fc0: 2063 6872 6973 746d 6173 222c 2022 2754   christmas", "'T
-00011fd0: 7761 7320 5468 6520 4e69 6768 7420 4265  was The Night Be
-00011fe0: 666f 7265 2043 6872 6973 746d 6173 2229  fore Christmas")
-00011ff0: 0a20 2020 2020 2020 2074 6573 7428 2264  .        test("d
-00012000: 6f6e 2774 2073 6c65 6570 206f 6e20 7468  on't sleep on th
-00012010: 6520 7375 6277 6179 222c 2022 446f 6e27  e subway", "Don'
-00012020: 7420 536c 6565 7020 4f6e 2054 6865 2053  t Sleep On The S
-00012030: 7562 7761 7922 290a 2020 2020 2020 2020  ubway").        
-00012040: 7465 7374 2822 6576 6572 7962 6f64 7927  test("everybody'
-00012050: 7320 7468 696e 6b69 6e67 2074 6865 7920  s thinking they 
-00012060: 636f 756c 646e 2774 2776 6520 6861 6420  couldn't've had 
-00012070: 6120 762d 3822 2c20 2245 7665 7279 626f  a v-8", "Everybo
-00012080: 6479 2773 2054 6869 6e6b 696e 6720 5468  dy's Thinking Th
-00012090: 6579 2043 6f75 6c64 6e27 7427 7665 2048  ey Couldn't've H
-000120a0: 6164 2041 2056 2d38 2229 0a20 2020 2020  ad A V-8").     
-000120b0: 2020 2074 6573 7428 2264 6f6e 2774 2063     test("don't c
-000120c0: 6f6d 6520 686f 6d65 2069 6620 796f 7520  ome home if you 
-000120d0: 646f 6e27 7420 6765 7420 3173 7422 2c20  don't get 1st", 
-000120e0: 2244 6f6e 2774 2043 6f6d 6520 486f 6d65  "Don't Come Home
-000120f0: 2049 6620 596f 7520 446f 6e27 7420 4765   If You Don't Ge
-00012100: 7420 3173 7422 290a 2020 2020 2020 2020  t 1st").        
-00012110: 7465 7374 2822 2222 6920 7361 6964 2022  test("""i said "
-00012120: 6e6f 2c20 6920 6469 646e 2774 222c 2079  no, i didn't", y
-00012130: 6f75 2069 6469 6f74 2222 222c 2022 2222  ou idiot""", """
-00012140: 4920 5361 6964 2022 4e6f 2c20 4920 4469  I Said "No, I Di
-00012150: 646e 2774 222c 2059 6f75 2049 6469 6f74  dn't", You Idiot
-00012160: 2222 2229 0a20 2020 2020 2020 2074 6573  """).        tes
-00012170: 7428 276d 756c 7469 706c 6520 c2ab 22e2  t('multiple ..".
-00012180: 809c 7175 6f74 6520 6d61 726b 73e2 809d  ..quote marks...
-00012190: 22c2 bb27 2c20 274d 756c 7469 706c 6520  "..', 'Multiple 
-000121a0: c2ab 22e2 809c 5175 6f74 6520 4d61 726b  .."...Quote Mark
-000121b0: 73e2 809d 22c2 bb27 2c20 7465 7374 5f61  s..."..', test_a
-000121c0: 7363 6969 3d46 616c 7365 290a 2020 2020  scii=False).    
-000121d0: 2020 2020 7465 7374 2827 6d79 2068 6561      test('my hea
-000121e0: 6420 6973 206d 7920 6f6e 6c79 2068 6f75  d is my only hou
-000121f0: 7365 2028 7768 656e 2069 7420 7261 696e  se (when it rain
-00012200: 7329 272c 2027 4d79 2048 6561 6420 4973  s)', 'My Head Is
-00012210: 204d 7920 4f6e 6c79 2048 6f75 7365 2028   My Only House (
-00012220: 5768 656e 2049 7420 5261 696e 7329 2729  When It Rains)')
-00012230: 0a0a 2020 2020 2020 2020 7465 7374 2822  ..        test("
-00012240: 2222 6920 7361 6964 205a 646f 6e58 7420  ""i said ZdonXt 
-00012250: 746f 7563 6820 7468 6174 2c20 6f58 636f  touch that, oXco
-00012260: 6e6e 656c 6c21 5a2c 2079 6f75 2032 6e64  nnell!Z, you 2nd
-00012270: 2072 6174 6520 6964 696f 7421 2222 222c   rate idiot!""",
-00012280: 2022 2222 4920 5361 6964 205a 446f 6e58   """I Said ZDonX
-00012290: 7420 546f 7563 6820 5468 6174 2c20 4f58  t Touch That, OX
-000122a0: 436f 6e6e 656c 6c21 5a2c 2059 6f75 2032  Connell!Z, You 2
-000122b0: 6e64 2052 6174 6520 4964 696f 7421 2222  nd Rate Idiot!""
-000122c0: 222c 2061 706f 7374 726f 7068 6573 3d27  ", apostrophes='
-000122d0: 5827 2c20 646f 7562 6c65 5f71 756f 7465  X', double_quote
-000122e0: 733d 275a 2729 0a0a 2020 2020 6465 6620  s='Z')..    def 
-000122f0: 7465 7374 5f6e 6f72 6d61 6c69 7a65 5f77  test_normalize_w
-00012300: 6869 7465 7370 6163 6528 7365 6c66 293a  hitespace(self):
-00012310: 0a20 2020 2020 2020 2064 6566 2074 6573  .        def tes
-00012320: 7428 732c 2065 7870 6563 7465 642c 202a  t(s, expected, *
-00012330: 2c20 7365 7061 7261 746f 7273 3d4e 6f6e  , separators=Non
-00012340: 652c 2072 6570 6c61 6365 6d65 6e74 3d22  e, replacement="
-00012350: 2022 293a 0a20 2020 2020 2020 2020 2020   "):.           
-00012360: 2072 6573 756c 7420 3d20 6269 672e 6e6f   result = big.no
-00012370: 726d 616c 697a 655f 7768 6974 6573 7061  rmalize_whitespa
-00012380: 6365 2873 2c20 7365 7061 7261 746f 7273  ce(s, separators
-00012390: 3d73 6570 6172 6174 6f72 732c 2072 6570  =separators, rep
-000123a0: 6c61 6365 6d65 6e74 3d72 6570 6c61 6365  lacement=replace
-000123b0: 6d65 6e74 290a 2020 2020 2020 2020 2020  ment).          
-000123c0: 2020 7365 6c66 2e61 7373 6572 7445 7175    self.assertEqu
-000123d0: 616c 2872 6573 756c 742c 2065 7870 6563  al(result, expec
-000123e0: 7465 6429 0a0a 2020 2020 2020 2020 2020  ted)..          
-000123f0: 2020 7320 3d20 732e 656e 636f 6465 2827    s = s.encode('
-00012400: 6173 6369 6927 290a 2020 2020 2020 2020  ascii').        
-00012410: 2020 2020 6578 7065 6374 6564 203d 2065      expected = e
-00012420: 7870 6563 7465 642e 656e 636f 6465 2827  xpected.encode('
-00012430: 6173 6369 6927 290a 2020 2020 2020 2020  ascii').        
-00012440: 2020 2020 6966 2073 6570 6172 6174 6f72      if separator
-00012450: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
-00012460: 2020 2073 6570 6172 6174 6f72 7320 3d20     separators = 
-00012470: 5b73 2e65 6e63 6f64 6528 2761 7363 6969  [s.encode('ascii
-00012480: 2729 2066 6f72 2073 2069 6e20 7365 7061  ') for s in sepa
-00012490: 7261 746f 7273 5d0a 2020 2020 2020 2020  rators].        
-000124a0: 2020 2020 6966 2072 6570 6c61 6365 6d65      if replaceme
-000124b0: 6e74 3a0a 2020 2020 2020 2020 2020 2020  nt:.            
-000124c0: 2020 2020 7265 706c 6163 656d 656e 7420      replacement 
-000124d0: 3d20 7265 706c 6163 656d 656e 742e 656e  = replacement.en
-000124e0: 636f 6465 2827 6173 6369 6927 290a 0a20  code('ascii').. 
-000124f0: 2020 2020 2020 2020 2020 2072 6573 756c             resul
-00012500: 7420 3d20 6269 672e 6e6f 726d 616c 697a  t = big.normaliz
-00012510: 655f 7768 6974 6573 7061 6365 2873 2c20  e_whitespace(s, 
-00012520: 7365 7061 7261 746f 7273 3d73 6570 6172  separators=separ
-00012530: 6174 6f72 732c 2072 6570 6c61 6365 6d65  ators, replaceme
-00012540: 6e74 3d72 6570 6c61 6365 6d65 6e74 290a  nt=replacement).
-00012550: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00012560: 2e61 7373 6572 7445 7175 616c 2872 6573  .assertEqual(res
-00012570: 756c 742c 2065 7870 6563 7465 6429 0a0a  ult, expected)..
-00012580: 2020 2020 2020 2020 7465 7374 2822 2020          test("  
-00012590: 2061 2020 2020 6220 2020 2063 222c 2022   a    b    c", "
-000125a0: 2061 2062 2063 2229 0a0a 2020 2020 2020   a b c")..      
-000125b0: 2020 7465 7374 2822 6420 2020 2020 6520    test("d     e 
-000125c0: 205c 745c 6e20 2066 2022 2c20 2264 2065   \t\n  f ", "d e
-000125d0: 2066 2022 290a 2020 2020 2020 2020 7465   f ").        te
-000125e0: 7374 2822 6768 6922 2c20 2267 6869 222c  st("ghi", "ghi",
-000125f0: 2072 6570 6c61 6365 6d65 6e74 3d4e 6f6e   replacement=Non
-00012600: 6529 0a20 2020 2020 2020 2074 6573 7428  e).        test(
-00012610: 2220 2020 6a20 2020 2020 6b6c 2020 206d  "   j     kl   m
-00012620: 6e6f 7020 2020 2022 2c20 2220 6a20 6b6c  nop    ", " j kl
-00012630: 206d 6e6f 7020 2229 0a20 2020 2020 2020   mnop ").       
-00012640: 2074 6573 7428 2222 2c20 2222 290a 2020   test("", "").  
-00012650: 2020 2020 2020 7465 7374 2822 2020 205c        test("   \
-00012660: 6e5c 6e5c 7420 5c74 2020 2020 2022 2c20  n\n\t \t     ", 
-00012670: 2220 2229 0a0a 2020 2020 2020 2020 7465  " ")..        te
-00012680: 7374 2822 2020 206a 2020 2020 206b 6c20  st("   j     kl 
-00012690: 2020 6d6e 6f70 2020 2020 222c 2022 586a    mnop    ", "Xj
-000126a0: 586b 6c58 6d6e 6f70 5822 2c20 7265 706c  XklXmnopX", repl
-000126b0: 6163 656d 656e 743d 2258 2229 0a20 2020  acement="X").   
-000126c0: 2020 2020 2074 6573 7428 2220 2020 6a20       test("   j 
-000126d0: 2020 2020 6b6c 2020 206d 6e6f 7020 2020      kl   mnop   
-000126e0: 2022 2c20 2251 516a 5151 6b6c 5151 6d6e   ", "QQjQQklQQmn
-000126f0: 6f70 5151 222c 2072 6570 6c61 6365 6d65  opQQ", replaceme
-00012700: 6e74 3d22 5151 2229 0a0a 2020 2020 2020  nt="QQ")..      
-00012710: 2020 7465 7374 2822 6162 6344 4546 6162    test("abcDEFab
-00012720: 6163 6162 4748 4961 6161 222c 2022 2b44  acabGHIaaa", "+D
-00012730: 4546 2b47 4849 2b22 2c20 7365 7061 7261  EF+GHI+", separa
-00012740: 746f 7273 3d28 2261 222c 2022 6222 2c20  tors=("a", "b", 
-00012750: 2263 2229 2c20 7265 706c 6163 656d 656e  "c"), replacemen
-00012760: 743d 222b 2229 0a0a 2020 2020 2020 2020  t="+")..        
-00012770: 7769 7468 2073 656c 662e 6173 7365 7274  with self.assert
-00012780: 5261 6973 6573 2856 616c 7565 4572 726f  Raises(ValueErro
-00012790: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
-000127a0: 6269 672e 6d75 6c74 6970 6172 7469 7469  big.multipartiti
-000127b0: 6f6e 2822 6162 6322 2c20 2262 222c 202d  on("abc", "b", -
-000127c0: 3129 0a0a 2020 2020 6465 6620 7465 7374  1)..    def test
-000127d0: 5f73 706c 6974 5f71 756f 7465 645f 7374  _split_quoted_st
-000127e0: 7269 6e67 7328 7365 6c66 293a 0a20 2020  rings(self):.   
-000127f0: 2020 2020 2064 6566 2074 6573 7428 732c       def test(s,
-00012800: 2065 7870 6563 7465 642c 202a 2a6b 7761   expected, **kwa
-00012810: 7267 7329 3a0a 2020 2020 2020 2020 2020  rgs):.          
-00012820: 2020 676f 7420 3d20 6c69 7374 2862 6967    got = list(big
-00012830: 2e73 706c 6974 5f71 756f 7465 645f 7374  .split_quoted_st
-00012840: 7269 6e67 7328 732c 202a 2a6b 7761 7267  rings(s, **kwarg
-00012850: 7329 290a 2020 2020 2020 2020 2020 2020  s)).            
-00012860: 7365 6c66 2e61 7373 6572 7445 7175 616c  self.assertEqual
-00012870: 2867 6f74 2c20 6578 7065 6374 6564 290a  (got, expected).
-00012880: 0a20 2020 2020 2020 2020 2020 2067 6f74  .            got
-00012890: 203d 206c 6973 7428 6269 672e 7370 6c69   = list(big.spli
-000128a0: 745f 7175 6f74 6564 5f73 7472 696e 6773  t_quoted_strings
-000128b0: 2873 2e65 6e63 6f64 6528 2761 7363 6969  (s.encode('ascii
-000128c0: 2729 2c20 2a2a 6b77 6172 6773 2929 0a20  '), **kwargs)). 
-000128d0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-000128e0: 6173 7365 7274 4571 7561 6c28 676f 742c  assertEqual(got,
-000128f0: 205b 2862 2c20 732e 656e 636f 6465 2827   [(b, s.encode('
-00012900: 6173 6369 6927 2929 2066 6f72 2062 2c20  ascii')) for b, 
-00012910: 7320 696e 2065 7870 6563 7465 645d 290a  s in expected]).
-00012920: 0a20 2020 2020 2020 2074 6573 7428 2222  .        test(""
-00012930: 2268 6579 2074 6865 7265 2022 7468 6973  "hey there "this
-00012940: 2069 7320 7175 6f74 6564 2220 616e 2065   is quoted" an e
-00012950: 6d70 7479 2071 756f 7465 3a20 2727 2074  mpty quote: '' t
-00012960: 6869 7320 6973 206e 6f74 2071 756f 7465  his is not quote
-00012970: 6420 2774 6869 7320 6973 206d 6f72 6520  d 'this is more 
-00012980: 7175 6f74 6564 2720 2268 6572 6527 7320  quoted' "here's 
-00012990: 7175 6f74 696e 6720 6120 7175 6f74 6520  quoting a quote 
-000129a0: 6d61 726b 3a20 5c5c 2220 776f 7721 2220  mark: \\" wow!" 
-000129b0: 7468 6973 2069 7320 776f 726b 696e 6721  this is working!
-000129c0: 2222 222c 0a20 2020 2020 2020 2020 2020  """,.           
-000129d0: 205b 0a20 2020 2020 2020 2020 2020 2020   [.             
-000129e0: 2020 2028 4661 6c73 652c 2027 6865 7920     (False, 'hey 
-000129f0: 7468 6572 6520 2729 2c0a 2020 2020 2020  there '),.      
-00012a00: 2020 2020 2020 2020 2020 2854 7275 652c            (True,
-00012a10: 2027 2274 6869 7320 6973 2071 756f 7465   '"this is quote
-00012a20: 6422 2729 2c0a 2020 2020 2020 2020 2020  d"'),.          
-00012a30: 2020 2020 2020 2846 616c 7365 2c20 2720        (False, ' 
-00012a40: 616e 2065 6d70 7479 2071 756f 7465 3a20  an empty quote: 
-00012a50: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
-00012a60: 2020 2020 2854 7275 652c 2022 2727 2229      (True, "''")
-00012a70: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00012a80: 2020 2846 616c 7365 2c20 2720 7468 6973    (False, ' this
-00012a90: 2069 7320 6e6f 7420 7175 6f74 6564 2027   is not quoted '
-00012aa0: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
-00012ab0: 2020 2028 5472 7565 2c20 2227 7468 6973     (True, "'this
-00012ac0: 2069 7320 6d6f 7265 2071 756f 7465 6427   is more quoted'
-00012ad0: 2229 2c0a 2020 2020 2020 2020 2020 2020  "),.            
-00012ae0: 2020 2020 2846 616c 7365 2c20 2720 2729      (False, ' ')
-00012af0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00012b00: 2020 2854 7275 652c 2027 2268 6572 655c    (True, '"here\
-00012b10: 2773 2071 756f 7469 6e67 2061 2071 756f  's quoting a quo
-00012b20: 7465 206d 6172 6b3a 205c 5c22 2077 6f77  te mark: \\" wow
-00012b30: 2122 2729 2c0a 2020 2020 2020 2020 2020  !"'),.          
-00012b40: 2020 2020 2020 2846 616c 7365 2c20 2720        (False, ' 
-00012b50: 7468 6973 2069 7320 776f 726b 696e 6721  this is working!
-00012b60: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
-00012b70: 5d29 0a0a 2020 2020 2020 2020 7465 7374  ])..        test
-00012b80: 2827 2727 6865 7265 2069 7320 7472 6970  ('''here is trip
-00012b90: 6c65 2071 756f 7465 643a 2022 2222 6920  le quoted: """i 
-00012ba0: 616d 2074 7269 706c 6520 7175 6f74 6564  am triple quoted
-00012bb0: 2e22 2222 2077 6f77 2120 2061 6761 696e  .""" wow!  again
-00012bc0: 3a20 2222 2274 7269 706c 6520 7175 6f74  : """triple quot
-00012bd0: 6564 2068 6572 652e 2022 7175 6f74 6573  ed here. "quotes
-00012be0: 2069 6e20 7175 6f74 6573 2220 656d 7074   in quotes" empt
-00012bf0: 793a 2022 2220 646f 6e65 2e22 2222 2070  y: "" done.""" p
-00012c00: 6865 7721 2727 272c 0a20 2020 2020 2020  hew!''',.       
-00012c10: 2020 2020 205b 0a20 2020 2020 2020 2020       [.         
-00012c20: 2020 2020 2020 2028 4661 6c73 652c 2027         (False, '
-00012c30: 6865 7265 2069 7320 7472 6970 6c65 2071  here is triple q
-00012c40: 756f 7465 643a 2027 292c 0a20 2020 2020  uoted: '),.     
-00012c50: 2020 2020 2020 2020 2020 2028 5472 7565             (True
-00012c60: 2c20 2722 2222 6920 616d 2074 7269 706c  , '"""i am tripl
-00012c70: 6520 7175 6f74 6564 2e22 2222 2729 2c0a  e quoted."""'),.
-00012c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012c90: 2846 616c 7365 2c20 2720 776f 7721 2020  (False, ' wow!  
-00012ca0: 6167 6169 6e3a 2027 292c 0a20 2020 2020  again: '),.     
-00012cb0: 2020 2020 2020 2020 2020 2028 5472 7565             (True
-00012cc0: 2c20 2722 2222 7472 6970 6c65 2071 756f  , '"""triple quo
-00012cd0: 7465 6420 6865 7265 2e20 2271 756f 7465  ted here. "quote
-00012ce0: 7320 696e 2071 756f 7465 7322 2065 6d70  s in quotes" emp
-00012cf0: 7479 3a20 2222 2064 6f6e 652e 2222 2227  ty: "" done."""'
-00012d00: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
-00012d10: 2020 2028 4661 6c73 652c 2027 2070 6865     (False, ' phe
-00012d20: 7721 2729 2c0a 2020 2020 2020 2020 2020  w!'),.          
-00012d30: 2020 5d29 0a0a 2020 2020 2020 2020 7465    ])..        te
-00012d40: 7374 2827 2727 7465 7374 2074 7572 6e69  st('''test turni
-00012d50: 6e67 206f 6666 2071 756f 7465 6420 7374  ng off quoted st
-00012d60: 7269 6e67 732e 2020 2222 2268 6f77 6479  rings.  """howdy
-00012d70: 2064 6f6f 646c 6573 2222 2220 6974 206b   doodles""" it k
-00012d80: 696e 6461 2077 6f72 6b73 2061 6e79 7761  inda works anywa
-00012d90: 7921 2727 272c 0a20 2020 2020 2020 2020  y!''',.         
-00012da0: 2020 205b 0a20 2020 2020 2020 2020 2020     [.           
-00012db0: 2020 2020 2028 4661 6c73 652c 2027 7465       (False, 'te
-00012dc0: 7374 2074 7572 6e69 6e67 206f 6666 2071  st turning off q
-00012dd0: 756f 7465 6420 7374 7269 6e67 732e 2020  uoted strings.  
-00012de0: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
-00012df0: 2020 2020 2854 7275 652c 2027 2222 2729      (True, '""')
-00012e00: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00012e10: 2020 2854 7275 652c 2027 2268 6f77 6479    (True, '"howdy
-00012e20: 2064 6f6f 646c 6573 2227 292c 0a20 2020   doodles"'),.   
-00012e30: 2020 2020 2020 2020 2020 2020 2028 5472               (Tr
-00012e40: 7565 2c20 2722 2227 292c 0a20 2020 2020  ue, '""'),.     
-00012e50: 2020 2020 2020 2020 2020 2028 4661 6c73             (Fals
-00012e60: 652c 2027 2069 7420 6b69 6e64 6120 776f  e, ' it kinda wo
-00012e70: 726b 7320 616e 7977 6179 2127 292c 0a20  rks anyway!'),. 
-00012e80: 2020 2020 2020 2020 2020 205d 2c0a 2020             ],.  
-00012e90: 2020 2020 2020 2020 2020 7472 6970 6c65            triple
-00012ea0: 5f71 756f 7465 733d 4661 6c73 6529 0a0a  _quotes=False)..
-00012eb0: 0a20 2020 2064 6566 2074 6573 745f 6c69  .    def test_li
-00012ec0: 6e65 7328 7365 6c66 293a 0a20 2020 2020  nes(self):.     
-00012ed0: 2020 2064 6566 2074 6573 7428 692c 2065     def test(i, e
-00012ee0: 7870 6563 7465 6429 3a0a 2020 2020 2020  xpected):.      
-00012ef0: 2020 2020 2020 676f 7420 3d20 6c69 7374        got = list
-00012f00: 2869 290a 2020 2020 2020 2020 2020 2020  (i).            
-00012f10: 7365 6c66 2e61 7373 6572 7445 7175 616c  self.assertEqual
-00012f20: 2867 6f74 2c20 6578 7065 6374 6564 290a  (got, expected).
-00012f30: 0a20 2020 2020 2020 204c 4920 3d20 6269  .        LI = bi
-00012f40: 672e 4c69 6e65 496e 666f 0a0a 2020 2020  g.LineInfo..    
-00012f50: 2020 2020 6465 6620 4c28 6c69 6e65 2c20      def L(line, 
-00012f60: 6c69 6e65 5f6e 756d 6265 722c 2063 6f6c  line_number, col
-00012f70: 756d 6e5f 6e75 6d62 6572 3d31 2c20 2a2a  umn_number=1, **
-00012f80: 6b77 6172 6773 293a 0a20 2020 2020 2020  kwargs):.       
-00012f90: 2020 2020 2069 6e66 6f20 3d20 6269 672e       info = big.
-00012fa0: 4c69 6e65 496e 666f 286c 696e 652c 206c  LineInfo(line, l
-00012fb0: 696e 655f 6e75 6d62 6572 2c20 636f 6c75  ine_number, colu
-00012fc0: 6d6e 5f6e 756d 6265 722c 202a 2a6b 7761  mn_number, **kwa
-00012fd0: 7267 7329 0a20 2020 2020 2020 2020 2020  rgs).           
-00012fe0: 2072 6574 7572 6e20 2869 6e66 6f2c 206c   return (info, l
-00012ff0: 696e 6529 0a0a 2020 2020 2020 2020 7465  ine)..        te
-00013000: 7374 2862 6967 2e6c 696e 6573 2822 615c  st(big.lines("a\
-00013010: 6e62 5c6e 635c 6e64 5c6e 655c 6e22 292c  nb\nc\nd\ne\n"),
-00013020: 0a20 2020 2020 2020 2020 2020 205b 0a20  .            [. 
-00013030: 2020 2020 2020 2020 2020 2028 4c49 2827             (LI('
-00013040: 6127 2c20 312c 2031 292c 2027 6127 292c  a', 1, 1), 'a'),
-00013050: 0a20 2020 2020 2020 2020 2020 2028 4c49  .            (LI
-00013060: 2827 6227 2c20 322c 2031 292c 2027 6227  ('b', 2, 1), 'b'
-00013070: 292c 0a20 2020 2020 2020 2020 2020 2028  ),.            (
-00013080: 4c49 2827 6327 2c20 332c 2031 292c 2027  LI('c', 3, 1), '
-00013090: 6327 292c 0a20 2020 2020 2020 2020 2020  c'),.           
-000130a0: 2028 4c49 2827 6427 2c20 342c 2031 292c   (LI('d', 4, 1),
-000130b0: 2027 6427 292c 0a20 2020 2020 2020 2020   'd'),.         
-000130c0: 2020 2028 4c49 2827 6527 2c20 352c 2031     (LI('e', 5, 1
-000130d0: 292c 2027 6527 292c 0a20 2020 2020 2020  ), 'e'),.       
-000130e0: 2020 2020 2028 4c49 2827 272c 2020 362c       (LI('',  6,
-000130f0: 2031 292c 2027 2729 2c0a 2020 2020 2020   1), ''),.      
-00013100: 2020 2020 2020 5d29 0a0a 2020 2020 2020        ])..      
-00013110: 2020 6c69 6e65 7320 3d20 5b27 6669 7273    lines = ['firs
-00013120: 7420 6c69 6e65 272c 2027 5c74 7365 636f  t line', '\tseco
-00013130: 6e64 206c 696e 6527 2c20 2774 6869 7264  nd line', 'third
-00013140: 206c 696e 6527 5d0a 2020 2020 2020 2020   line'].        
-00013150: 7465 7374 2862 6967 2e6c 696e 6573 5f73  test(big.lines_s
-00013160: 7472 6970 2862 6967 2e6c 696e 6573 286c  trip(big.lines(l
-00013170: 696e 6573 2929 2c0a 2020 2020 2020 2020  ines)),.        
-00013180: 2020 2020 5b0a 2020 2020 2020 2020 2020      [.          
-00013190: 2020 284c 4928 2766 6972 7374 206c 696e    (LI('first lin
-000131a0: 6527 2c20 312c 2031 292c 2027 6669 7273  e', 1, 1), 'firs
-000131b0: 7420 6c69 6e65 2729 2c0a 2020 2020 2020  t line'),.      
-000131c0: 2020 2020 2020 284c 4928 275c 7473 6563        (LI('\tsec
-000131d0: 6f6e 6420 6c69 6e65 272c 2032 2c20 392c  ond line', 2, 9,
-000131e0: 206c 6561 6469 6e67 3d27 5c74 2729 2c20   leading='\t'), 
-000131f0: 2773 6563 6f6e 6420 6c69 6e65 2729 2c0a  'second line'),.
-00013200: 2020 2020 2020 2020 2020 2020 284c 4928              (LI(
-00013210: 2774 6869 7264 206c 696e 6527 2c20 332c  'third line', 3,
-00013220: 2031 292c 2027 7468 6972 6420 6c69 6e65   1), 'third line
-00013230: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
-00013240: 5d29 0a0a 2020 2020 2020 2020 7465 7374  ])..        test
-00013250: 2862 6967 2e6c 696e 6573 5f66 696c 7465  (big.lines_filte
-00013260: 725f 636f 6d6d 656e 745f 6c69 6e65 7328  r_comment_lines(
-00013270: 6269 672e 6c69 6e65 7328 2222 220a 2020  big.lines(""".  
-00013280: 2020 2320 636f 6d6d 656e 740a 2020 2020    # comment.    
-00013290: 6120 3d20 620a 2020 2020 2f2f 2061 6e6f  a = b.    // ano
-000132a0: 7468 6572 2063 6f6d 6d65 6e74 0a20 2020  ther comment.   
-000132b0: 2063 203d 2064 0a20 2020 202f 206e 6f74   c = d.    / not
-000132c0: 2061 2063 6f6d 6d65 6e74 0a20 2020 202f   a comment.    /
-000132d0: 2f2f 2069 7320 6120 636f 6d6d 656e 7421  // is a comment!
-000132e0: 0a20 2020 2023 2320 616e 6f74 6865 7220  .    ## another 
-000132f0: 636f 6d6d 656e 7421 0a20 2020 2023 2120  comment!.    #! 
-00013300: 6120 7468 6972 6420 636f 6d6d 656e 7421  a third comment!
-00013310: 0a22 2222 2e6c 7374 7269 7028 275c 6e27  .""".lstrip('\n'
-00013320: 2929 2c20 2827 2327 2c20 272f 2f27 2929  )), ('#', '//'))
-00013330: 2c0a 2020 2020 2020 2020 2020 2020 5b0a  ,.            [.
-00013340: 2020 2020 2020 2020 2020 2020 284c 4928              (LI(
-00013350: 2720 2020 2061 203d 2062 272c 2020 2020  '    a = b',    
-00013360: 2020 2020 2020 2032 2c20 3129 2c20 2720         2, 1), ' 
-00013370: 2020 2061 203d 2062 2729 2c0a 2020 2020     a = b'),.    
-00013380: 2020 2020 2020 2020 284c 4928 2720 2020          (LI('   
-00013390: 2063 203d 2064 272c 2020 2020 2020 2020   c = d',        
-000133a0: 2020 2034 2c20 3129 2c20 2720 2020 2063     4, 1), '    c
-000133b0: 203d 2064 2729 2c0a 2020 2020 2020 2020   = d'),.        
-000133c0: 2020 2020 284c 4928 2720 2020 202f 206e      (LI('    / n
-000133d0: 6f74 2061 2063 6f6d 6d65 6e74 272c 2035  ot a comment', 5
-000133e0: 2c20 3129 2c20 2720 2020 202f 206e 6f74  , 1), '    / not
-000133f0: 2061 2063 6f6d 6d65 6e74 2729 2c0a 2020   a comment'),.  
-00013400: 2020 2020 2020 2020 2020 284c 4928 2727            (LI(''
-00013410: 2c20 2020 2020 2020 2020 2020 2020 2020  ,               
-00013420: 2020 2020 2039 2c20 3129 2c20 2727 292c       9, 1), ''),
-00013430: 0a20 2020 2020 2020 2020 2020 205d 290a  .            ]).
-00013440: 0a20 2020 2020 2020 2074 6573 7428 6269  .        test(bi
-00013450: 672e 6c69 6e65 735f 6669 6c74 6572 5f63  g.lines_filter_c
-00013460: 6f6d 6d65 6e74 5f6c 696e 6573 2862 6967  omment_lines(big
-00013470: 2e6c 696e 6573 2862 2261 5c6e 2320 6967  .lines(b"a\n# ig
-00013480: 6e6f 7265 645c 6e20 6322 292c 2062 2723  nored\n c"), b'#
-00013490: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
-000134a0: 5b0a 2020 2020 2020 2020 2020 2020 4c28  [.            L(
-000134b0: 6227 6127 2c20 3129 2c0a 2020 2020 2020  b'a', 1),.      
-000134c0: 2020 2020 2020 4c28 6227 2063 272c 2033        L(b' c', 3
-000134d0: 292c 0a20 2020 2020 2020 2020 2020 205d  ),.            ]
-000134e0: 0a20 2020 2020 2020 2020 2020 2029 0a0a  .            )..
-000134f0: 2020 2020 2020 2020 7465 7374 2862 6967          test(big
-00013500: 2e6c 696e 6573 5f63 6f6e 7461 696e 696e  .lines_containin
-00013510: 6728 6269 672e 6c69 6e65 7328 2222 220a  g(big.lines(""".
-00013520: 6865 6c6c 6f20 796f 6c6b 730a 7768 6174  hello yolks.what
-00013530: 2064 6f20 796f 7520 6861 7665 2074 6f20   do you have to 
-00013540: 7361 792c 2063 6861 6d70 3f0a 6920 6c69  say, champ?.i li
-00013550: 6b65 2065 6767 732e 0a74 6865 7920 646f  ke eggs..they do
-00013560: 6e27 7420 6861 7665 2074 6f20 6265 2066  n't have to be f
-00013570: 616e 6379 2e0a 7369 6d70 6c65 2073 6372  ancy..simple scr
-00013580: 616d 626c 6564 2065 6767 7320 6172 6520  ambled eggs are 
-00013590: 6a75 7374 2066 696e 652e 0a6e 6567 6761  just fine..negga
-000135a0: 746f 7279 210a 7768 6f6f 7073 2c20 4920  tory!.whoops, I 
-000135b0: 6d65 616e 742c 206e 6567 6174 6f72 792e  meant, negatory.
-000135c0: 0a22 2222 5b31 3a5d 292c 2022 6567 6722  ."""[1:]), "egg"
-000135d0: 292c 0a20 2020 2020 2020 2020 2020 205b  ),.            [
-000135e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000135f0: 2028 4c49 2827 6920 6c69 6b65 2065 6767   (LI('i like egg
-00013600: 732e 272c 2033 2c20 3129 2c20 2769 206c  s.', 3, 1), 'i l
-00013610: 696b 6520 6567 6773 2e27 292c 0a20 2020  ike eggs.'),.   
-00013620: 2020 2020 2020 2020 2020 2020 2028 4c49               (LI
-00013630: 2827 7369 6d70 6c65 2073 6372 616d 626c  ('simple scrambl
-00013640: 6564 2065 6767 7320 6172 6520 6a75 7374  ed eggs are just
-00013650: 2066 696e 652e 272c 2035 2c20 3129 2c20   fine.', 5, 1), 
-00013660: 2773 696d 706c 6520 7363 7261 6d62 6c65  'simple scramble
-00013670: 6420 6567 6773 2061 7265 206a 7573 7420  d eggs are just 
-00013680: 6669 6e65 2e27 292c 0a20 2020 2020 2020  fine.'),.       
-00013690: 2020 2020 2020 2020 2028 4c49 2827 6e65           (LI('ne
-000136a0: 6767 6174 6f72 7921 272c 2036 2c20 3129  ggatory!', 6, 1)
-000136b0: 2c20 276e 6567 6761 746f 7279 2127 292c  , 'neggatory!'),
-000136c0: 0a20 2020 2020 2020 2020 2020 205d 0a20  .            ]. 
-000136d0: 2020 2020 2020 2020 2020 2029 0a0a 2020             )..  
-000136e0: 2020 2020 2020 7465 7374 2862 6967 2e6c        test(big.l
-000136f0: 696e 6573 5f63 6f6e 7461 696e 696e 6728  ines_containing(
-00013700: 6269 672e 6c69 6e65 7328 2222 220a 6865  big.lines(""".he
-00013710: 6c6c 6f20 796f 6c6b 730a 7768 6174 2064  llo yolks.what d
-00013720: 6f20 796f 7520 6861 7665 2074 6f20 7361  o you have to sa
-00013730: 792c 2063 6861 6d70 3f0a 6920 6c69 6b65  y, champ?.i like
-00013740: 2065 6767 732e 0a74 6865 7920 646f 6e27   eggs..they don'
-00013750: 7420 6861 7665 2074 6f20 6265 2066 616e  t have to be fan
-00013760: 6379 2e0a 7369 6d70 6c65 2073 6372 616d  cy..simple scram
-00013770: 626c 6564 2065 6767 7320 6172 6520 6a75  bled eggs are ju
-00013780: 7374 2066 696e 652e 0a6e 6567 6761 746f  st fine..neggato
-00013790: 7279 210a 7768 6f6f 7073 2c20 4920 6d65  ry!.whoops, I me
-000137a0: 616e 742c 206e 6567 6174 6f72 792e 0a22  ant, negatory.."
-000137b0: 2222 5b31 3a5d 292c 2022 6567 6722 2c20  ""[1:]), "egg", 
-000137c0: 696e 7665 7274 3d54 7275 6529 2c0a 2020  invert=True),.  
-000137d0: 2020 2020 2020 2020 2020 5b0a 2020 2020            [.    
-000137e0: 2020 2020 2020 2020 2020 2020 284c 4928              (LI(
-000137f0: 2768 656c 6c6f 2079 6f6c 6b73 272c 2031  'hello yolks', 1
-00013800: 2c20 3129 2c20 2768 656c 6c6f 2079 6f6c  , 1), 'hello yol
-00013810: 6b73 2729 2c0a 2020 2020 2020 2020 2020  ks'),.          
-00013820: 2020 2020 2020 284c 4928 2777 6861 7420        (LI('what 
-00013830: 646f 2079 6f75 2068 6176 6520 746f 2073  do you have to s
-00013840: 6179 2c20 6368 616d 703f 272c 2032 2c20  ay, champ?', 2, 
-00013850: 3129 2c20 2777 6861 7420 646f 2079 6f75  1), 'what do you
-00013860: 2068 6176 6520 746f 2073 6179 2c20 6368   have to say, ch
-00013870: 616d 703f 2729 2c0a 2020 2020 2020 2020  amp?'),.        
-00013880: 2020 2020 2020 2020 284c 4928 2274 6865          (LI("the
-00013890: 7920 646f 6e27 7420 6861 7665 2074 6f20  y don't have to 
-000138a0: 6265 2066 616e 6379 2e22 2c20 342c 2031  be fancy.", 4, 1
-000138b0: 292c 2022 7468 6579 2064 6f6e 2774 2068  ), "they don't h
-000138c0: 6176 6520 746f 2062 6520 6661 6e63 792e  ave to be fancy.
-000138d0: 2229 2c0a 2020 2020 2020 2020 2020 2020  "),.            
-000138e0: 2020 2020 284c 4928 2777 686f 6f70 732c      (LI('whoops,
-000138f0: 2049 206d 6561 6e74 2c20 6e65 6761 746f   I meant, negato
-00013900: 7279 2e27 2c20 372c 2031 292c 2027 7768  ry.', 7, 1), 'wh
-00013910: 6f6f 7073 2c20 4920 6d65 616e 742c 206e  oops, I meant, n
-00013920: 6567 6174 6f72 792e 2729 2c0a 2020 2020  egatory.'),.    
-00013930: 2020 2020 2020 2020 2020 2020 284c 4928              (LI(
-00013940: 2727 2c20 382c 2031 292c 2027 2729 2c0a  '', 8, 1), ''),.
-00013950: 2020 2020 2020 2020 2020 2020 5d0a 2020              ].  
-00013960: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
-00013970: 2020 2020 2074 6573 7428 6269 672e 6c69       test(big.li
-00013980: 6e65 735f 6772 6570 2862 6967 2e6c 696e  nes_grep(big.lin
-00013990: 6573 2822 2222 0a68 656c 6c6f 2079 6f6c  es(""".hello yol
-000139a0: 6b73 0a77 6861 7420 646f 2079 6f75 2068  ks.what do you h
-000139b0: 6176 6520 746f 2073 6179 2c20 6368 616d  ave to say, cham
-000139c0: 703f 0a69 206c 696b 6520 6567 6773 2e0a  p?.i like eggs..
-000139d0: 7468 6579 2064 6f6e 2774 2068 6176 6520  they don't have 
-000139e0: 746f 2062 6520 6661 6e63 792e 0a73 696d  to be fancy..sim
-000139f0: 706c 6520 7363 7261 6d62 6c65 6420 6567  ple scrambled eg
-00013a00: 6773 2061 7265 206a 7573 7420 6669 6e65  gs are just fine
-00013a10: 2e0a 6e65 6767 6174 6f72 7921 0a77 686f  ..neggatory!.who
-00013a20: 6f70 732c 2049 206d 6561 6e74 2c20 6e65  ops, I meant, ne
-00013a30: 6761 746f 7279 2e0a 2222 225b 313a 5d29  gatory.."""[1:])
-00013a40: 2c20 2265 672b 2229 2c0a 2020 2020 2020  , "eg+"),.      
-00013a50: 2020 2020 2020 5b0a 2020 2020 2020 2020        [.        
-00013a60: 2020 2020 2020 2020 284c 4928 2769 206c          (LI('i l
-00013a70: 696b 6520 6567 6773 2e27 2c20 332c 2031  ike eggs.', 3, 1
-00013a80: 292c 2027 6920 6c69 6b65 2065 6767 732e  ), 'i like eggs.
-00013a90: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
-00013aa0: 2020 2020 284c 4928 2773 696d 706c 6520      (LI('simple 
-00013ab0: 7363 7261 6d62 6c65 6420 6567 6773 2061  scrambled eggs a
-00013ac0: 7265 206a 7573 7420 6669 6e65 2e27 2c20  re just fine.', 
-00013ad0: 352c 2031 292c 2027 7369 6d70 6c65 2073  5, 1), 'simple s
-00013ae0: 6372 616d 626c 6564 2065 6767 7320 6172  crambled eggs ar
-00013af0: 6520 6a75 7374 2066 696e 652e 2729 2c0a  e just fine.'),.
-00013b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013b10: 284c 4928 276e 6567 6761 746f 7279 2127  (LI('neggatory!'
-00013b20: 2c20 362c 2031 292c 2027 6e65 6767 6174  , 6, 1), 'neggat
-00013b30: 6f72 7921 2729 2c0a 2020 2020 2020 2020  ory!'),.        
-00013b40: 2020 2020 2020 2020 284c 4928 2777 686f          (LI('who
-00013b50: 6f70 732c 2049 206d 6561 6e74 2c20 6e65  ops, I meant, ne
-00013b60: 6761 746f 7279 2e27 2c20 372c 2031 292c  gatory.', 7, 1),
-00013b70: 2027 7768 6f6f 7073 2c20 4920 6d65 616e   'whoops, I mean
-00013b80: 742c 206e 6567 6174 6f72 792e 2729 2c0a  t, negatory.'),.
-00013b90: 2020 2020 2020 2020 2020 2020 5d0a 2020              ].  
-00013ba0: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
-00013bb0: 2020 2020 2074 6573 7428 6269 672e 6c69       test(big.li
-00013bc0: 6e65 735f 6772 6570 2862 6967 2e6c 696e  nes_grep(big.lin
-00013bd0: 6573 2822 2222 0a68 656c 6c6f 2079 6f6c  es(""".hello yol
-00013be0: 6b73 0a77 6861 7420 646f 2079 6f75 2068  ks.what do you h
-00013bf0: 6176 6520 746f 2073 6179 2c20 6368 616d  ave to say, cham
-00013c00: 703f 0a69 206c 696b 6520 6567 6773 2e0a  p?.i like eggs..
-00013c10: 7468 6579 2064 6f6e 2774 2068 6176 6520  they don't have 
-00013c20: 746f 2062 6520 6661 6e63 792e 0a73 696d  to be fancy..sim
-00013c30: 706c 6520 7363 7261 6d62 6c65 6420 6567  ple scrambled eg
-00013c40: 6773 2061 7265 206a 7573 7420 6669 6e65  gs are just fine
-00013c50: 2e0a 6e65 6767 6174 6f72 7921 0a77 686f  ..neggatory!.who
-00013c60: 6f70 732c 2049 206d 6561 6e74 2c20 6e65  ops, I meant, ne
-00013c70: 6761 746f 7279 2e0a 2222 225b 313a 5d29  gatory.."""[1:])
-00013c80: 2c20 2265 672b 222c 2069 6e76 6572 743d  , "eg+", invert=
-00013c90: 5472 7565 292c 0a20 2020 2020 2020 2020  True),.         
-00013ca0: 2020 205b 0a20 2020 2020 2020 2020 2020     [.           
-00013cb0: 2020 2020 2028 4c49 2827 6865 6c6c 6f20       (LI('hello 
-00013cc0: 796f 6c6b 7327 2c20 312c 2031 292c 2027  yolks', 1, 1), '
-00013cd0: 6865 6c6c 6f20 796f 6c6b 7327 292c 0a20  hello yolks'),. 
-00013ce0: 2020 2020 2020 2020 2020 2020 2020 2028                 (
-00013cf0: 4c49 2827 7768 6174 2064 6f20 796f 7520  LI('what do you 
-00013d00: 6861 7665 2074 6f20 7361 792c 2063 6861  have to say, cha
-00013d10: 6d70 3f27 2c20 322c 2031 292c 2027 7768  mp?', 2, 1), 'wh
-00013d20: 6174 2064 6f20 796f 7520 6861 7665 2074  at do you have t
-00013d30: 6f20 7361 792c 2063 6861 6d70 3f27 292c  o say, champ?'),
-00013d40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00013d50: 2028 4c49 2822 7468 6579 2064 6f6e 2774   (LI("they don't
-00013d60: 2068 6176 6520 746f 2062 6520 6661 6e63   have to be fanc
-00013d70: 792e 222c 2034 2c20 3129 2c20 2274 6865  y.", 4, 1), "the
-00013d80: 7920 646f 6e27 7420 6861 7665 2074 6f20  y don't have to 
-00013d90: 6265 2066 616e 6379 2e22 292c 0a20 2020  be fancy."),.   
-00013da0: 2020 2020 2020 2020 2020 2020 2028 4c49               (LI
-00013db0: 2827 272c 2038 2c20 3129 2c20 2727 292c  ('', 8, 1), ''),
-00013dc0: 0a20 2020 2020 2020 2020 2020 205d 0a20  .            ]. 
-00013dd0: 2020 2020 2020 2020 2020 2029 0a0a 2020             )..  
-00013de0: 2020 2020 2020 7465 7374 2862 6967 2e6c        test(big.l
-00013df0: 696e 6573 5f73 6f72 7428 6269 672e 6c69  ines_sort(big.li
-00013e00: 6e65 7328 2222 220a 636f 726d 6f72 616e  nes(""".cormoran
-00013e10: 740a 6669 7265 666f 780a 616c 6c69 6761  t.firefox.alliga
-00013e20: 746f 720a 6469 706c 6f64 6f63 7573 0a65  tor.diplodocus.e
-00013e30: 6c65 7068 616e 740a 6769 7261 6666 650a  lephant.giraffe.
-00013e40: 6261 7272 6163 7564 610a 6875 6d6d 696e  barracuda.hummin
-00013e50: 6762 6972 640a 2222 225b 313a 2d31 5d29  gbird."""[1:-1])
-00013e60: 292c 0a20 2020 2020 2020 2020 2020 205b  ),.            [
-00013e70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00013e80: 204c 2827 616c 6c69 6761 746f 7227 2c20   L('alligator', 
-00013e90: 3329 2c0a 2020 2020 2020 2020 2020 2020  3),.            
-00013ea0: 2020 2020 4c28 2762 6172 7261 6375 6461      L('barracuda
-00013eb0: 272c 2037 292c 0a20 2020 2020 2020 2020  ', 7),.         
-00013ec0: 2020 2020 2020 204c 2827 636f 726d 6f72         L('cormor
-00013ed0: 616e 7427 2c20 3129 2c0a 2020 2020 2020  ant', 1),.      
-00013ee0: 2020 2020 2020 2020 2020 4c28 2764 6970            L('dip
-00013ef0: 6c6f 646f 6375 7327 2c20 3429 2c0a 2020  lodocus', 4),.  
-00013f00: 2020 2020 2020 2020 2020 2020 2020 4c28                L(
-00013f10: 2765 6c65 7068 616e 7427 2c20 3529 2c0a  'elephant', 5),.
+0000e640: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e650: 2020 2020 2020 2020 2020 2020 2065 7870               exp
+0000e660: 6563 7465 6420 3d20 6e65 775f 6578 7065  ected = new_expe
+0000e670: 6374 6564 0a20 2020 2020 2020 2020 2020  cted.           
+0000e680: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e690: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e6a0: 2020 2020 2069 6620 7761 6e74 5f70 7269       if want_pri
+0000e6b0: 6e74 733a 2023 2070 7261 676d 613a 206e  nts: # pragma: n
+0000e6c0: 6f20 636f 7665 720a 2020 2020 2020 2020  o cover.        
+0000e6d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e6f0: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+0000e700: 7428 6622 2020 2020 6e6f 7720 6578 7065  t(f"    now expe
+0000e710: 6374 6564 3d7b 6578 7065 6374 6564 7d22  cted={expected}"
+0000e720: 290a 0a20 2020 2020 2020 2020 2020 2020  )..             
+0000e730: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e740: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+0000e750: 6573 756c 7420 3d20 6c69 7374 2862 6967  esult = list(big
+0000e760: 2e6d 756c 7469 7370 6c69 7428 696e 7075  .multisplit(inpu
+0000e770: 745f 7374 7269 6e67 2c20 7365 7061 7261  t_string, separa
+0000e780: 746f 7273 2c0a 2020 2020 2020 2020 2020  tors,.          
+0000e790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e7a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e7b0: 2020 2020 2020 6b65 6570 3d6b 6565 702c        keep=keep,
+0000e7c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e7d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e7f0: 206d 6178 7370 6c69 743d 6d61 7873 706c   maxsplit=maxspl
+0000e800: 6974 2c0a 2020 2020 2020 2020 2020 2020  it,.            
+0000e810: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e830: 2020 2020 7265 7665 7273 653d 7265 7665      reverse=reve
+0000e840: 7273 652c 0a20 2020 2020 2020 2020 2020  rse,.           
+0000e850: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e870: 2020 2020 2073 6570 6172 6174 653d 7365       separate=se
+0000e880: 7061 7261 7465 2c0a 2020 2020 2020 2020  parate,.        
+0000e890: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e8a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e8b0: 2020 2020 2020 2020 7374 7269 703d 7374          strip=st
+0000e8c0: 7269 702c 0a20 2020 2020 2020 2020 2020  rip,.           
+0000e8d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e8e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e8f0: 2020 2020 2029 290a 2020 2020 2020 2020       )).        
+0000e900: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e920: 2020 2020 6966 2077 616e 745f 7072 696e      if want_prin
+0000e930: 7473 3a20 2320 7072 6167 6d61 3a20 6e6f  ts: # pragma: no
+0000e940: 2063 6f76 6572 0a20 2020 2020 2020 2020   cover.         
+0000e950: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e970: 2020 2020 2020 2070 7269 6e74 2866 2261         print(f"a
+0000e980: 735f 6279 7465 733d 7b61 735f 6279 7465  s_bytes={as_byte
+0000e990: 737d 2075 7365 5f6c 6561 6469 6e67 3d7b  s} use_leading={
+0000e9a0: 7573 655f 6c65 6164 696e 677d 2075 7365  use_leading} use
+0000e9b0: 5f74 7261 696c 696e 673d 7b75 7365 5f74  _trailing={use_t
+0000e9c0: 7261 696c 696e 677d 2229 0a20 2020 2020  railing}").     
+0000e9d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e9e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e9f0: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+0000ea00: 2866 226d 756c 7469 7370 6c69 7428 7b69  (f"multisplit({i
+0000ea10: 6e70 7574 5f73 7472 696e 6721 727d 2c20  nput_string!r}, 
+0000ea20: 7365 7061 7261 746f 7273 3d7b 7072 696e  separators={prin
+0000ea30: 7461 626c 655f 7365 7061 7261 746f 7273  table_separators
+0000ea40: 2873 6570 6172 6174 6f72 7329 7d2c 206b  (separators)}, k
+0000ea50: 6565 703d 7b6b 6565 707d 2c20 7365 7061  eep={keep}, sepa
+0000ea60: 7261 7465 3d7b 7365 7061 7261 7465 7d2c  rate={separate},
+0000ea70: 2073 7472 6970 3d7b 7374 7269 707d 2c20   strip={strip}, 
+0000ea80: 7265 7665 7273 653d 7b72 6576 6572 7365  reverse={reverse
+0000ea90: 7d2c 206d 6178 7370 6c69 743d 7b6d 6178  }, maxsplit={max
+0000eaa0: 7370 6c69 747d 2922 290a 2020 2020 2020  split})").      
+0000eab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ead0: 2020 2020 2020 2020 2020 7072 696e 7428            print(
+0000eae0: 6622 2020 7265 7375 6c74 3d7b 7265 7375  f"  result={resu
+0000eaf0: 6c74 7d22 290a 2020 2020 2020 2020 2020  lt}").          
+0000eb00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eb10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eb20: 2020 2020 2020 7072 696e 7428 6622 6578        print(f"ex
+0000eb30: 7065 6374 6564 3d7b 6578 7065 6374 6564  pected={expected
+0000eb40: 7d22 290a 2020 2020 2020 2020 2020 2020  }").            
+0000eb50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eb60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eb70: 2020 2020 7072 696e 7428 225f 5f5f 5f5f      print("_____
+0000eb80: 5f5f 5f22 290a 2020 2020 2020 2020 2020  ___").          
+0000eb90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ebb0: 2020 2020 2020 7072 696e 7428 290a 2020        print().  
+0000ebc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ebd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ebe0: 2020 2020 2020 2020 2020 7365 6c66 2e61            self.a
+0000ebf0: 7373 6572 7445 7175 616c 2872 6573 756c  ssertEqual(resul
+0000ec00: 742c 2065 7870 6563 7465 642c 2066 2261  t, expected, f"a
+0000ec10: 735f 6279 7465 733d 7b61 735f 6279 7465  s_bytes={as_byte
+0000ec20: 737d 2075 7365 5f6c 6561 6469 6e67 3d7b  s} use_leading={
+0000ec30: 7573 655f 6c65 6164 696e 677d 2075 7365  use_leading} use
+0000ec40: 5f74 7261 696c 696e 673d 7b75 7365 5f74  _trailing={use_t
+0000ec50: 7261 696c 696e 677d 206d 756c 7469 7370  railing} multisp
+0000ec60: 6c69 7428 696e 7075 745f 7374 7269 6e67  lit(input_string
+0000ec70: 3d7b 696e 7075 745f 7374 7269 6e67 7d2c  ={input_string},
+0000ec80: 2073 6570 6172 6174 6f72 733d 7b70 7269   separators={pri
+0000ec90: 6e74 6162 6c65 5f73 6570 6172 6174 6f72  ntable_separator
+0000eca0: 7328 7365 7061 7261 746f 7273 297d 2c20  s(separators)}, 
+0000ecb0: 6b65 6570 3d7b 6b65 6570 7d2c 2073 6570  keep={keep}, sep
+0000ecc0: 6172 6174 653d 7b73 6570 6172 6174 657d  arate={separate}
+0000ecd0: 2c20 7374 7269 703d 7b73 7472 6970 7d2c  , strip={strip},
+0000ece0: 2072 6576 6572 7365 3d7b 7265 7665 7273   reverse={revers
+0000ecf0: 657d 2c20 6d61 7873 706c 6974 3d7b 6d61  e}, maxsplit={ma
+0000ed00: 7873 706c 6974 7d29 2229 0a0a 0a20 2020  xsplit})")...   
+0000ed10: 2020 2020 2074 6573 745f 7374 7269 6e67       test_string
+0000ed20: 203d 205b 0a20 2020 2020 2020 2020 2020   = [.           
+0000ed30: 2027 2027 2c0a 2020 2020 2020 2020 2020   ' ',.          
+0000ed40: 2020 2761 272c 0a20 2020 2020 2020 2020    'a',.         
+0000ed50: 2020 2027 2027 2c0a 2020 2020 2020 2020     ' ',.        
+0000ed60: 2020 2020 2762 272c 0a20 2020 2020 2020      'b',.       
+0000ed70: 2020 2020 2027 2027 2c0a 2020 2020 2020       ' ',.      
+0000ed80: 2020 2020 2020 2763 272c 0a20 2020 2020        'c',.     
+0000ed90: 2020 2020 2020 2027 2027 2c0a 2020 2020         ' ',.    
+0000eda0: 2020 2020 2020 2020 5d0a 0a20 2020 2020          ]..     
+0000edb0: 2020 206d 756c 7469 7370 6c69 745f 7465     multisplit_te
+0000edc0: 7374 6572 280a 2020 2020 2020 2020 2020  ster(.          
+0000edd0: 2020 2a74 6573 745f 7374 7269 6e67 2c0a    *test_string,.
+0000ede0: 2020 2020 2020 2020 2020 2020 2827 2027              (' '
+0000edf0: 2c29 2c0a 2020 2020 2020 2020 2020 2020  ,),.            
+0000ee00: 290a 0a20 2020 2020 2020 206d 756c 7469  )..        multi
+0000ee10: 7370 6c69 745f 7465 7374 6572 280a 2020  split_tester(.  
+0000ee20: 2020 2020 2020 2020 2020 2a74 6573 745f            *test_
+0000ee30: 7374 7269 6e67 2c0a 2020 2020 2020 2020  string,.        
+0000ee40: 2020 2020 4e6f 6e65 2c0a 2020 2020 2020      None,.      
+0000ee50: 2020 2020 2020 290a 0a0a 2020 2020 2020        )...      
+0000ee60: 2020 6d75 6c74 6973 706c 6974 5f74 6573    multisplit_tes
+0000ee70: 7465 7228 0a20 2020 2020 2020 2020 2020  ter(.           
+0000ee80: 2027 2027 2c0a 2020 2020 2020 2020 2020   ' ',.          
+0000ee90: 2020 275c 7427 2c0a 2020 2020 2020 2020    '\t',.        
+0000eea0: 2020 2020 2720 272c 0a20 2020 2020 2020      ' ',.       
+0000eeb0: 2020 2020 2027 5c6e 272c 0a20 2020 2020       '\n',.     
+0000eec0: 2020 2020 2020 2027 2027 2c0a 0a20 2020         ' ',..   
+0000eed0: 2020 2020 2020 2020 2027 6127 2c0a 0a20           'a',.. 
+0000eee0: 2020 2020 2020 2020 2020 2027 2027 2c0a             ' ',.
+0000eef0: 2020 2020 2020 2020 2020 2020 275c 7427              '\t'
+0000ef00: 2c0a 2020 2020 2020 2020 2020 2020 2720  ,.            ' 
+0000ef10: 272c 0a20 2020 2020 2020 2020 2020 2027  ',.            '
+0000ef20: 5c6e 272c 0a0a 2020 2020 2020 2020 2020  \n',..          
+0000ef30: 2020 2762 272c 0a0a 2020 2020 2020 2020    'b',..        
+0000ef40: 2020 2020 275c 7427 2c0a 2020 2020 2020      '\t',.      
+0000ef50: 2020 2020 2020 2720 272c 0a20 2020 2020        ' ',.     
+0000ef60: 2020 2020 2020 2027 5c6e 272c 0a0a 2020         '\n',..  
+0000ef70: 2020 2020 2020 2020 2020 2763 272c 0a0a            'c',..
+0000ef80: 2020 2020 2020 2020 2020 2020 2720 272c              ' ',
+0000ef90: 0a20 2020 2020 2020 2020 2020 2027 2027  .            ' '
+0000efa0: 2c0a 2020 2020 2020 2020 2020 2020 275c  ,.            '\
+0000efb0: 6e27 2c0a 0a20 2020 2020 2020 2020 2020  n',..           
+0000efc0: 2062 6967 2e77 6869 7465 7370 6163 652c   big.whitespace,
+0000efd0: 0a20 2020 2020 2020 2020 2020 2029 0a0a  .            )..
+0000efe0: 0a20 2020 2020 2020 206d 756c 7469 7370  .        multisp
+0000eff0: 6c69 745f 7465 7374 6572 280a 2020 2020  lit_tester(.    
+0000f000: 2020 2020 2020 2020 2778 272c 0a20 2020          'x',.   
+0000f010: 2020 2020 2020 2020 2027 7927 2c0a 2020           'y',.  
+0000f020: 2020 2020 2020 2020 2020 2778 272c 0a20            'x',. 
+0000f030: 2020 2020 2020 2020 2020 2027 7927 2c0a             'y',.
+0000f040: 0a20 2020 2020 2020 2020 2020 2027 6127  .            'a'
+0000f050: 2c0a 0a20 2020 2020 2020 2020 2020 2027  ,..            '
+0000f060: 7827 2c0a 2020 2020 2020 2020 2020 2020  x',.            
+0000f070: 2779 272c 0a20 2020 2020 2020 2020 2020  'y',.           
+0000f080: 2027 7827 2c0a 2020 2020 2020 2020 2020   'x',.          
+0000f090: 2020 2779 272c 0a20 2020 2020 2020 2020    'y',.         
+0000f0a0: 2020 2027 7827 2c0a 0a20 2020 2020 2020     'x',..       
+0000f0b0: 2020 2020 2027 6227 2c0a 0a20 2020 2020       'b',..     
+0000f0c0: 2020 2020 2020 2027 7927 2c0a 0a20 2020         'y',..   
+0000f0d0: 2020 2020 2020 2020 2027 6327 2c0a 0a20           'c',.. 
+0000f0e0: 2020 2020 2020 2020 2020 2027 7827 2c0a             'x',.
+0000f0f0: 2020 2020 2020 2020 2020 2020 2779 272c              'y',
+0000f100: 0a20 2020 2020 2020 2020 2020 2027 7827  .            'x'
+0000f110: 2c0a 2020 2020 2020 2020 2020 2020 2779  ,.            'y
+0000f120: 272c 0a20 2020 2020 2020 2020 2020 2027  ',.            '
+0000f130: 7827 2c0a 2020 2020 2020 2020 2020 2020  x',.            
+0000f140: 2779 272c 0a0a 2020 2020 2020 2020 2020  'y',..          
+0000f150: 2020 2764 272c 0a0a 2020 2020 2020 2020    'd',..        
+0000f160: 2020 2020 2779 272c 0a20 2020 2020 2020      'y',.       
+0000f170: 2020 2020 2027 7827 2c0a 0a20 2020 2020       'x',..     
+0000f180: 2020 2020 2020 2027 6527 2c0a 0a20 2020         'e',..   
+0000f190: 2020 2020 2020 2020 2027 7927 2c0a 2020           'y',.  
+0000f1a0: 2020 2020 2020 2020 2020 2779 272c 0a20            'y',. 
+0000f1b0: 2020 2020 2020 2020 2020 2027 7927 2c0a             'y',.
+0000f1c0: 2020 2020 2020 2020 2020 2020 2779 272c              'y',
+0000f1d0: 0a0a 2020 2020 2020 2020 2020 2020 2766  ..            'f
+0000f1e0: 272c 0a0a 2020 2020 2020 2020 2020 2020  ',..            
+0000f1f0: 2778 272c 0a20 2020 2020 2020 2020 2020  'x',.           
+0000f200: 2027 7827 2c0a 2020 2020 2020 2020 2020   'x',.          
+0000f210: 2020 2778 272c 0a20 2020 2020 2020 2020    'x',.         
+0000f220: 2020 2027 7827 2c0a 2020 2020 2020 2020     'x',.        
+0000f230: 2020 2020 2778 272c 0a20 2020 2020 2020      'x',.       
+0000f240: 2020 2020 2027 7827 2c0a 0a20 2020 2020       'x',..     
+0000f250: 2020 2020 2020 2028 2778 272c 2027 7927         ('x', 'y'
+0000f260: 292c 0a20 2020 2020 2020 2020 2020 2029  ),.            )
+0000f270: 0a0a 2020 2020 6465 6620 7465 7374 5f6d  ..    def test_m
+0000f280: 756c 7469 7061 7274 6974 696f 6e28 7365  ultipartition(se
+0000f290: 6c66 293a 0a20 2020 2020 2020 2064 6566  lf):.        def
+0000f2a0: 2074 6573 745f 6d75 6c74 6970 6172 7469   test_multiparti
+0000f2b0: 7469 6f6e 2873 2c20 7365 7061 7261 746f  tion(s, separato
+0000f2c0: 722c 2063 6f75 6e74 2c20 6578 7065 6374  r, count, expect
+0000f2d0: 6564 2c20 2a2c 2072 6576 6572 7365 3d46  ed, *, reverse=F
+0000f2e0: 616c 7365 293a 0a20 2020 2020 2020 2020  alse):.         
+0000f2f0: 2020 2066 6f72 205f 2069 6e20 7261 6e67     for _ in rang
+0000f300: 6528 3229 3a0a 2020 2020 2020 2020 2020  e(2):.          
+0000f310: 2020 2020 2020 6966 205f 203d 3d20 313a        if _ == 1:
+0000f320: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000f330: 2020 2020 2023 2065 6e63 6f64 6521 0a20       # encode!. 
+0000f340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f350: 2020 2073 203d 2073 2e65 6e63 6f64 6528     s = s.encode(
+0000f360: 2761 7363 6969 2729 0a20 2020 2020 2020  'ascii').       
+0000f370: 2020 2020 2020 2020 2020 2020 2023 2069               # i
+0000f380: 6620 7365 7061 7261 746f 7220 3d3d 2062  f separator == b
+0000f390: 6967 2e77 6869 7465 7370 6163 653a 0a20  ig.whitespace:. 
+0000f3a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f3b0: 2020 2023 2020 2020 2073 6570 6172 6174     #     separat
+0000f3c0: 6f72 203d 2062 6967 2e61 7363 6969 5f77  or = big.ascii_w
+0000f3d0: 6869 7465 7370 6163 650a 2020 2020 2020  hitespace.      
+0000f3e0: 2020 2020 2020 2020 2020 2020 2020 6966                if
+0000f3f0: 2069 7369 6e73 7461 6e63 6528 7365 7061   isinstance(sepa
+0000f400: 7261 746f 722c 2073 7472 293a 0a20 2020  rator, str):.   
+0000f410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f420: 2020 2020 2073 6570 6172 6174 6f72 203d       separator =
+0000f430: 2073 6570 6172 6174 6f72 2e65 6e63 6f64   separator.encod
+0000f440: 6528 2761 7363 6969 2729 0a20 2020 2020  e('ascii').     
+0000f450: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0000f460: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000f470: 2020 2020 2020 2020 2020 2020 2073 6570               sep
+0000f480: 6172 6174 6f72 203d 2062 6967 2e74 6578  arator = big.tex
+0000f490: 742e 5f63 6865 6170 5f65 6e63 6f64 655f  t._cheap_encode_
+0000f4a0: 6974 6572 6162 6c65 5f6f 665f 7374 7269  iterable_of_stri
+0000f4b0: 6e67 7328 7365 7061 7261 746f 7229 0a20  ngs(separator). 
+0000f4c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f4d0: 2020 2065 7870 6563 7465 6420 3d20 6269     expected = bi
+0000f4e0: 672e 7465 7874 2e5f 6368 6561 705f 656e  g.text._cheap_en
+0000f4f0: 636f 6465 5f69 7465 7261 626c 655f 6f66  code_iterable_of
+0000f500: 5f73 7472 696e 6773 2865 7870 6563 7465  _strings(expecte
+0000f510: 6429 0a0a 2020 2020 2020 2020 2020 2020  d)..            
+0000f520: 2020 2020 2320 7072 696e 7428 290a 2020      # print().  
+0000f530: 2020 2020 2020 2020 2020 2020 2020 6966                if
+0000f540: 2069 7369 6e73 7461 6e63 6528 7365 7061   isinstance(sepa
+0000f550: 7261 746f 722c 2028 7374 722c 2062 7974  rator, (str, byt
+0000f560: 6573 2929 3a0a 2020 2020 2020 2020 2020  es)):.          
+0000f570: 2020 2020 2020 2020 2020 7365 7061 7261            separa
+0000f580: 746f 7273 203d 2028 7365 7061 7261 746f  tors = (separato
+0000f590: 722c 290a 2020 2020 2020 2020 2020 2020  r,).            
+0000f5a0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000f5b0: 2020 2020 2020 2020 2020 2020 2020 7365                se
+0000f5c0: 7061 7261 746f 7273 203d 2073 6570 6172  parators = separ
+0000f5d0: 6174 6f72 0a0a 2020 2020 2020 2020 2020  ator..          
+0000f5e0: 2020 2020 2020 676f 7420 3d20 6269 672e        got = big.
+0000f5f0: 6d75 6c74 6970 6172 7469 7469 6f6e 2873  multipartition(s
+0000f600: 2c20 7365 7061 7261 746f 7273 2c20 636f  , separators, co
+0000f610: 756e 742c 2072 6576 6572 7365 3d72 6576  unt, reverse=rev
+0000f620: 6572 7365 290a 2020 2020 2020 2020 2020  erse).          
+0000f630: 2020 2020 2020 2320 7072 696e 7428 6622        # print(f"
+0000f640: 2020 2020 7b67 6f74 2172 7d22 290a 2020      {got!r}").  
+0000f650: 2020 2020 2020 2020 2020 2020 2020 7365                se
+0000f660: 6c66 2e61 7373 6572 7445 7175 616c 2865  lf.assertEqual(e
+0000f670: 7870 6563 7465 642c 2067 6f74 290a 0a20  xpected, got).. 
+0000f680: 2020 2020 2020 2020 2020 2020 2020 2067                 g
+0000f690: 6f74 3220 3d20 6269 672e 6d75 6c74 6972  ot2 = big.multir
+0000f6a0: 7061 7274 6974 696f 6e28 732c 2073 6570  partition(s, sep
+0000f6b0: 6172 6174 6f72 732c 2063 6f75 6e74 2c20  arators, count, 
+0000f6c0: 7265 7665 7273 653d 6e6f 7420 7265 7665  reverse=not reve
+0000f6d0: 7273 6529 0a20 2020 2020 2020 2020 2020  rse).           
+0000f6e0: 2020 2020 2023 2070 7269 6e74 2866 2220       # print(f" 
+0000f6f0: 2020 207b 676f 7432 2172 7d22 290a 2020     {got2!r}").  
+0000f700: 2020 2020 2020 2020 2020 2020 2020 7365                se
+0000f710: 6c66 2e61 7373 6572 7445 7175 616c 2865  lf.assertEqual(e
+0000f720: 7870 6563 7465 642c 2067 6f74 3229 0a0a  xpected, got2)..
+0000f730: 2020 2020 2020 2020 7465 7374 5f6d 756c          test_mul
+0000f740: 7469 7061 7274 6974 696f 6e28 2261 3a62  tipartition("a:b
+0000f750: 3a63 3a64 222c 2022 3a22 2c20 302c 2028  :c:d", ":", 0, (
+0000f760: 2261 3a62 3a63 3a64 222c 2929 0a20 2020  "a:b:c:d",)).   
+0000f770: 2020 2020 2074 6573 745f 6d75 6c74 6970       test_multip
+0000f780: 6172 7469 7469 6f6e 2822 613a 623a 633a  artition("a:b:c:
+0000f790: 6422 2c20 223a 222c 2031 2c20 2822 6122  d", ":", 1, ("a"
+0000f7a0: 2c20 223a 222c 2022 623a 633a 6422 2929  , ":", "b:c:d"))
+0000f7b0: 0a20 2020 2020 2020 2074 6573 745f 6d75  .        test_mu
+0000f7c0: 6c74 6970 6172 7469 7469 6f6e 2822 613a  ltipartition("a:
+0000f7d0: 623a 633a 6422 2c20 223a 222c 2032 2c20  b:c:d", ":", 2, 
+0000f7e0: 2822 6122 2c20 223a 222c 2022 6222 2c20  ("a", ":", "b", 
+0000f7f0: 223a 222c 2022 633a 6422 2929 0a20 2020  ":", "c:d")).   
+0000f800: 2020 2020 2074 6573 745f 6d75 6c74 6970       test_multip
+0000f810: 6172 7469 7469 6f6e 2822 613a 623a 633a  artition("a:b:c:
+0000f820: 6422 2c20 223a 222c 2033 2c20 2822 6122  d", ":", 3, ("a"
+0000f830: 2c20 223a 222c 2022 6222 2c20 223a 222c  , ":", "b", ":",
+0000f840: 2022 6322 2c20 223a 222c 2022 6422 2929   "c", ":", "d"))
+0000f850: 0a20 2020 2020 2020 2074 6573 745f 6d75  .        test_mu
+0000f860: 6c74 6970 6172 7469 7469 6f6e 2822 613a  ltipartition("a:
+0000f870: 623a 633a 6422 2c20 223a 222c 2034 2c20  b:c:d", ":", 4, 
+0000f880: 2822 6122 2c20 223a 222c 2022 6222 2c20  ("a", ":", "b", 
+0000f890: 223a 222c 2022 6322 2c20 223a 222c 2022  ":", "c", ":", "
+0000f8a0: 6422 2c20 2727 2c20 2727 2929 0a20 2020  d", '', '')).   
+0000f8b0: 2020 2020 2074 6573 745f 6d75 6c74 6970       test_multip
+0000f8c0: 6172 7469 7469 6f6e 2822 613a 623a 633a  artition("a:b:c:
+0000f8d0: 6422 2c20 223a 222c 2035 2c20 2822 6122  d", ":", 5, ("a"
+0000f8e0: 2c20 223a 222c 2022 6222 2c20 223a 222c  , ":", "b", ":",
+0000f8f0: 2022 6322 2c20 223a 222c 2022 6422 2c20   "c", ":", "d", 
+0000f900: 2727 2c20 2727 2c20 2727 2c20 2727 2929  '', '', '', ''))
+0000f910: 0a0a 2020 2020 2020 2020 7465 7374 5f6d  ..        test_m
+0000f920: 756c 7469 7061 7274 6974 696f 6e28 2261  ultipartition("a
+0000f930: 3a62 3a63 3a64 222c 2022 3a22 2c20 302c  :b:c:d", ":", 0,
+0000f940: 2028 2261 3a62 3a63 3a64 222c 292c 2072   ("a:b:c:d",), r
+0000f950: 6576 6572 7365 3d54 7275 6529 0a20 2020  everse=True).   
+0000f960: 2020 2020 2074 6573 745f 6d75 6c74 6970       test_multip
+0000f970: 6172 7469 7469 6f6e 2822 613a 623a 633a  artition("a:b:c:
+0000f980: 6422 2c20 223a 222c 2031 2c20 2822 613a  d", ":", 1, ("a:
+0000f990: 623a 6322 2c20 273a 2720 2c22 6422 292c  b:c", ':' ,"d"),
+0000f9a0: 2072 6576 6572 7365 3d54 7275 6529 0a20   reverse=True). 
+0000f9b0: 2020 2020 2020 2074 6573 745f 6d75 6c74         test_mult
+0000f9c0: 6970 6172 7469 7469 6f6e 2822 613a 623a  ipartition("a:b:
+0000f9d0: 633a 6422 2c20 223a 222c 2032 2c20 2822  c:d", ":", 2, ("
+0000f9e0: 613a 6222 2c20 223a 222c 2022 6322 2c20  a:b", ":", "c", 
+0000f9f0: 273a 2720 2c22 6422 292c 2072 6576 6572  ':' ,"d"), rever
+0000fa00: 7365 3d54 7275 6529 0a20 2020 2020 2020  se=True).       
+0000fa10: 2074 6573 745f 6d75 6c74 6970 6172 7469   test_multiparti
+0000fa20: 7469 6f6e 2822 613a 623a 633a 6422 2c20  tion("a:b:c:d", 
+0000fa30: 223a 222c 2033 2c20 2822 6122 2c20 223a  ":", 3, ("a", ":
+0000fa40: 222c 2022 6222 2c20 223a 222c 2022 6322  ", "b", ":", "c"
+0000fa50: 2c20 273a 2720 2c22 6422 292c 2072 6576  , ':' ,"d"), rev
+0000fa60: 6572 7365 3d54 7275 6529 0a20 2020 2020  erse=True).     
+0000fa70: 2020 2074 6573 745f 6d75 6c74 6970 6172     test_multipar
+0000fa80: 7469 7469 6f6e 2822 613a 623a 633a 6422  tition("a:b:c:d"
+0000fa90: 2c20 223a 222c 2034 2c20 2822 222c 2022  , ":", 4, ("", "
+0000faa0: 222c 2022 6122 2c20 223a 222c 2022 6222  ", "a", ":", "b"
+0000fab0: 2c20 223a 222c 2022 6322 2c20 273a 2720  , ":", "c", ':' 
+0000fac0: 2c22 6422 292c 2072 6576 6572 7365 3d54  ,"d"), reverse=T
+0000fad0: 7275 6529 0a20 2020 2020 2020 2074 6573  rue).        tes
+0000fae0: 745f 6d75 6c74 6970 6172 7469 7469 6f6e  t_multipartition
+0000faf0: 2822 613a 623a 633a 6422 2c20 223a 222c  ("a:b:c:d", ":",
+0000fb00: 2035 2c20 2822 222c 2022 222c 2022 222c   5, ("", "", "",
+0000fb10: 2022 222c 2022 6122 2c20 223a 222c 2022   "", "a", ":", "
+0000fb20: 6222 2c20 223a 222c 2022 6322 2c20 273a  b", ":", "c", ':
+0000fb30: 2720 2c22 6422 292c 2072 6576 6572 7365  ' ,"d"), reverse
+0000fb40: 3d54 7275 6529 0a0a 2020 2020 2020 2020  =True)..        
+0000fb50: 7465 7374 5f6d 756c 7469 7061 7274 6974  test_multipartit
+0000fb60: 696f 6e28 2261 3a62 3a63 3a64 222c 2022  ion("a:b:c:d", "
+0000fb70: 7822 2c20 312c 2028 2261 3a62 3a63 3a64  x", 1, ("a:b:c:d
+0000fb80: 222c 2022 222c 2022 2229 290a 2020 2020  ", "", "")).    
+0000fb90: 2020 2020 7465 7374 5f6d 756c 7469 7061      test_multipa
+0000fba0: 7274 6974 696f 6e28 2261 3a62 3a63 3a64  rtition("a:b:c:d
+0000fbb0: 222c 2022 7822 2c20 302c 2028 2261 3a62  ", "x", 0, ("a:b
+0000fbc0: 3a63 3a64 222c 2929 0a20 2020 2020 2020  :c:d",)).       
+0000fbd0: 2074 6573 745f 6d75 6c74 6970 6172 7469   test_multiparti
+0000fbe0: 7469 6f6e 2822 613a 623a 633a 6422 2c20  tion("a:b:c:d", 
+0000fbf0: 2278 222c 2032 2c20 2822 613a 623a 633a  "x", 2, ("a:b:c:
+0000fc00: 6422 2c20 2222 2c20 2222 2c20 2222 2c20  d", "", "", "", 
+0000fc10: 2222 2929 0a20 2020 2020 2020 2074 6573  "")).        tes
+0000fc20: 745f 6d75 6c74 6970 6172 7469 7469 6f6e  t_multipartition
+0000fc30: 2822 613a 623a 633a 6422 2c20 2278 222c  ("a:b:c:d", "x",
+0000fc40: 2033 2c20 2822 613a 623a 633a 6422 2c20   3, ("a:b:c:d", 
+0000fc50: 2222 2c20 2222 2c20 2222 2c20 2222 2c20  "", "", "", "", 
+0000fc60: 2222 2c20 2222 2929 0a0a 2020 2020 2020  "", ""))..      
+0000fc70: 2020 7465 7374 5f6d 756c 7469 7061 7274    test_multipart
+0000fc80: 6974 696f 6e28 2261 3a62 3a63 3a64 222c  ition("a:b:c:d",
+0000fc90: 2022 7822 2c20 302c 2028 2261 3a62 3a63   "x", 0, ("a:b:c
+0000fca0: 3a64 222c 292c 2072 6576 6572 7365 3d54  :d",), reverse=T
+0000fcb0: 7275 6529 0a20 2020 2020 2020 2074 6573  rue).        tes
+0000fcc0: 745f 6d75 6c74 6970 6172 7469 7469 6f6e  t_multipartition
+0000fcd0: 2822 613a 623a 633a 6422 2c20 2278 222c  ("a:b:c:d", "x",
+0000fce0: 2031 2c20 2822 222c 2022 222c 2022 613a   1, ("", "", "a:
+0000fcf0: 623a 633a 6422 292c 2072 6576 6572 7365  b:c:d"), reverse
+0000fd00: 3d54 7275 6529 0a20 2020 2020 2020 2074  =True).        t
+0000fd10: 6573 745f 6d75 6c74 6970 6172 7469 7469  est_multipartiti
+0000fd20: 6f6e 2822 613a 623a 633a 6422 2c20 2278  on("a:b:c:d", "x
+0000fd30: 222c 2032 2c20 2822 222c 2022 222c 2022  ", 2, ("", "", "
+0000fd40: 222c 2022 222c 2022 613a 623a 633a 6422  ", "", "a:b:c:d"
+0000fd50: 292c 2072 6576 6572 7365 3d54 7275 6529  ), reverse=True)
+0000fd60: 0a20 2020 2020 2020 2074 6573 745f 6d75  .        test_mu
+0000fd70: 6c74 6970 6172 7469 7469 6f6e 2822 613a  ltipartition("a:
+0000fd80: 623a 633a 6422 2c20 2278 222c 2033 2c20  b:c:d", "x", 3, 
+0000fd90: 2822 222c 2022 222c 2022 222c 2022 222c  ("", "", "", "",
+0000fda0: 2022 222c 2022 222c 2022 613a 623a 633a   "", "", "a:b:c:
+0000fdb0: 6422 292c 2072 6576 6572 7365 3d54 7275  d"), reverse=Tru
+0000fdc0: 6529 0a0a 2020 2020 2020 2020 2320 7465  e)..        # te
+0000fdd0: 7374 206f 7665 726c 6170 7069 6e67 2073  st overlapping s
+0000fde0: 6570 6172 6174 6f72 2062 6568 6176 696f  eparator behavio
+0000fdf0: 720a 2020 2020 2020 2020 7465 7374 5f6d  r.        test_m
+0000fe00: 756c 7469 7061 7274 6974 696f 6e28 2261  ultipartition("a
+0000fe10: 2078 2078 2062 222c 2022 2078 2022 2c20   x x b", " x ", 
+0000fe20: 312c 2028 2261 222c 2022 2078 2022 2c20  1, ("a", " x ", 
+0000fe30: 2278 2062 2229 290a 2020 2020 2020 2020  "x b")).        
+0000fe40: 7465 7374 5f6d 756c 7469 7061 7274 6974  test_multipartit
+0000fe50: 696f 6e28 2261 2078 2078 2062 222c 2022  ion("a x x b", "
+0000fe60: 2078 2022 2c20 312c 2028 2261 2078 222c   x ", 1, ("a x",
+0000fe70: 2022 2078 2022 2c20 2262 2229 2c20 7265   " x ", "b"), re
+0000fe80: 7665 7273 653d 5472 7565 290a 0a20 2020  verse=True)..   
+0000fe90: 2020 2020 2023 2074 6573 7420 6163 7475       # test actu
+0000fea0: 616c 6c79 2075 7369 6e67 206d 756c 7469  ally using multi
+0000feb0: 706c 6520 7365 7061 7261 746f 7273 2c20  ple separators, 
+0000fec0: 616e 6420 6a75 7374 2066 6f72 2066 756e  and just for fun
+0000fed0: 2d2d 6f76 6572 6c61 7070 696e 6721 0a20  --overlapping!. 
+0000fee0: 2020 2020 2020 2074 6573 745f 6d75 6c74         test_mult
+0000fef0: 6970 6172 7469 7469 6f6e 2822 6120 7820  ipartition("a x 
+0000ff00: 7820 6220 7920 7920 6322 2c20 2822 2078  x b y y c", (" x
+0000ff10: 2022 2c20 2220 7920 2229 2c20 322c 2028   ", " y "), 2, (
+0000ff20: 2261 222c 2022 2078 2022 2c20 2278 2062  "a", " x ", "x b
+0000ff30: 222c 2022 2079 2022 2c20 2279 2063 2229  ", " y ", "y c")
+0000ff40: 290a 2020 2020 2020 2020 7465 7374 5f6d  ).        test_m
+0000ff50: 756c 7469 7061 7274 6974 696f 6e28 2261  ultipartition("a
+0000ff60: 2078 2078 2062 2079 2079 2063 222c 2028   x x b y y c", (
+0000ff70: 2220 7820 222c 2022 2079 2022 292c 2032  " x ", " y "), 2
+0000ff80: 2c20 2822 6120 7822 2c20 2220 7820 222c  , ("a x", " x ",
+0000ff90: 2022 6220 7922 2c20 2220 7920 222c 2022   "b y", " y ", "
+0000ffa0: 6322 292c 2072 6576 6572 7365 3d54 7275  c"), reverse=Tru
+0000ffb0: 6529 0a0a 2020 2020 2020 2020 2320 7465  e)..        # te
+0000ffc0: 7374 2067 7265 6564 790a 2020 2020 2020  st greedy.      
+0000ffd0: 2020 7465 7374 5f6d 756c 7469 7061 7274    test_multipart
+0000ffe0: 6974 696f 6e28 2256 5761 6263 5758 6162  ition("VWabcWXab
+0000fff0: 5859 6263 595a 222c 2028 2761 272c 2027  XYbcYZ", ('a', '
+00010000: 6162 272c 2027 6162 6327 2c20 2762 272c  ab', 'abc', 'b',
+00010010: 2027 6263 272c 2027 6327 292c 2033 2c20   'bc', 'c'), 3, 
+00010020: 2827 5657 272c 2027 6162 6327 2c20 2757  ('VW', 'abc', 'W
+00010030: 5827 2c20 2761 6227 2c20 2758 5927 2c20  X', 'ab', 'XY', 
+00010040: 2762 6327 2c20 2759 5a27 2929 0a20 2020  'bc', 'YZ')).   
+00010050: 2020 2020 2074 6573 745f 6d75 6c74 6970       test_multip
+00010060: 6172 7469 7469 6f6e 2822 5657 6162 6357  artition("VWabcW
+00010070: 5861 6258 5962 6359 5a22 2c20 2827 6127  XabXYbcYZ", ('a'
+00010080: 2c20 2761 6227 2c20 2761 6263 272c 2027  , 'ab', 'abc', '
+00010090: 6227 2c20 2762 6327 2c20 2763 2729 2c20  b', 'bc', 'c'), 
+000100a0: 332c 2028 2756 5727 2c20 2761 6263 272c  3, ('VW', 'abc',
+000100b0: 2027 5758 272c 2027 6162 272c 2027 5859   'WX', 'ab', 'XY
+000100c0: 272c 2027 6263 272c 2027 595a 2729 2c20  ', 'bc', 'YZ'), 
+000100d0: 7265 7665 7273 653d 5472 7565 290a 0a20  reverse=True).. 
+000100e0: 2020 2020 2020 2023 2049 2064 6f6e 2774         # I don't
+000100f0: 2062 6f74 6865 7220 746f 2074 6573 7420   bother to test 
+00010100: 7468 6520 7374 7220 2f20 7375 6263 6c61  the str / subcla
+00010110: 7373 206f 6620 7374 7220 2f20 6574 6320  ss of str / etc 
+00010120: 7374 7566 660a 2020 2020 2020 2020 2320  stuff.        # 
+00010130: 7769 7468 206d 756c 7469 7061 7274 6974  with multipartit
+00010140: 696f 6e2c 2062 6563 6175 7365 2069 7420  ion, because it 
+00010150: 6c69 7465 7261 6c6c 7920 7573 6573 206d  literally uses m
+00010160: 756c 7469 7370 6c69 740a 2020 2020 2020  ultisplit.      
+00010170: 2020 2320 746f 2064 6f20 7468 6520 7370    # to do the sp
+00010180: 6c69 7474 696e 672e 2020 736f 206d 756c  litting.  so mul
+00010190: 7469 7370 6c69 7420 6861 6e64 6c65 7320  tisplit handles 
+000101a0: 6974 2e0a 0a20 2020 2020 2020 2077 6974  it...        wit
+000101b0: 6820 7365 6c66 2e61 7373 6572 7452 6169  h self.assertRai
+000101c0: 7365 7328 5661 6c75 6545 7272 6f72 293a  ses(ValueError):
+000101d0: 0a20 2020 2020 2020 2020 2020 2062 6967  .            big
+000101e0: 2e6d 756c 7469 7061 7274 6974 696f 6e28  .multipartition(
+000101f0: 2261 2078 2078 2062 2079 2079 2063 222c  "a x x b y y c",
+00010200: 2028 2220 7820 222c 2022 2079 2022 292c   (" x ", " y "),
+00010210: 202d 3129 0a0a 2020 2020 6465 6620 7465   -1)..    def te
+00010220: 7374 5f72 6569 6d70 6c65 6d65 6e74 6564  st_reimplemented
+00010230: 5f73 7472 5f73 706c 6974 2873 656c 6629  _str_split(self)
+00010240: 3a0a 2020 2020 2020 2020 6465 6620 5f6d  :.        def _m
+00010250: 756c 7469 7370 6c69 745f 746f 5f73 706c  ultisplit_to_spl
+00010260: 6974 2873 2c20 7365 702c 206d 6178 7370  it(s, sep, maxsp
+00010270: 6c69 742c 2072 6576 6572 7365 293a 0a20  lit, reverse):. 
+00010280: 2020 2020 2020 2020 2020 2073 6570 6172             separ
+00010290: 6174 6520 3d20 7365 7020 213d 204e 6f6e  ate = sep != Non
+000102a0: 650a 2020 2020 2020 2020 2020 2020 6966  e.            if
+000102b0: 2073 6570 6172 6174 653a 0a20 2020 2020   separate:.     
+000102c0: 2020 2020 2020 2020 2020 2073 7472 6970             strip
+000102d0: 203d 2046 616c 7365 0a20 2020 2020 2020   = False.       
+000102e0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+000102f0: 2020 2020 2020 2020 2020 2073 6570 203d             sep =
+00010300: 2062 6967 2e61 7363 6969 5f77 6869 7465   big.ascii_white
+00010310: 7370 6163 6520 6966 2069 7369 6e73 7461  space if isinsta
+00010320: 6e63 6528 732c 2062 7974 6573 2920 656c  nce(s, bytes) el
+00010330: 7365 2062 6967 2e77 6869 7465 7370 6163  se big.whitespac
+00010340: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+00010350: 2020 7374 7269 7020 3d20 6269 672e 5052    strip = big.PR
+00010360: 4f47 5245 5353 4956 450a 2020 2020 2020  OGRESSIVE.      
+00010370: 2020 2020 2020 7265 7375 6c74 203d 206c        result = l
+00010380: 6973 7428 6269 672e 6d75 6c74 6973 706c  ist(big.multispl
+00010390: 6974 2873 2c20 7365 702c 0a20 2020 2020  it(s, sep,.     
+000103a0: 2020 2020 2020 2020 2020 206d 6178 7370             maxsp
+000103b0: 6c69 743d 6d61 7873 706c 6974 2c20 7265  lit=maxsplit, re
+000103c0: 7665 7273 653d 7265 7665 7273 652c 0a20  verse=reverse,. 
+000103d0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+000103e0: 6570 6172 6174 653d 7365 7061 7261 7465  eparate=separate
+000103f0: 2c20 7374 7269 703d 7374 7269 7029 290a  , strip=strip)).
+00010400: 2020 2020 2020 2020 2020 2020 6966 206e              if n
+00010410: 6f74 2073 6570 6172 6174 653a 0a20 2020  ot separate:.   
+00010420: 2020 2020 2020 2020 2020 2020 2023 2027               # '
+00010430: 272e 7370 6c69 7428 2920 3d3d 2027 2020  '.split() == '  
+00010440: 2027 2e73 706c 6974 2829 203d 3d20 5b5d   '.split() == []
+00010450: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010460: 2069 6620 7265 7375 6c74 2061 6e64 2028   if result and (
+00010470: 6e6f 7420 7265 7375 6c74 5b2d 315d 293a  not result[-1]):
+00010480: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010490: 2020 2020 2072 6573 756c 742e 706f 7028       result.pop(
+000104a0: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+000104b0: 7475 726e 2072 6573 756c 740a 0a20 2020  turn result..   
+000104c0: 2020 2020 2064 6566 2073 7472 5f73 706c       def str_spl
+000104d0: 6974 2873 2c20 7365 703d 4e6f 6e65 2c20  it(s, sep=None, 
+000104e0: 6d61 7873 706c 6974 3d2d 3129 3a0a 2020  maxsplit=-1):.  
+000104f0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00010500: 205f 6d75 6c74 6973 706c 6974 5f74 6f5f   _multisplit_to_
+00010510: 7370 6c69 7428 732c 2073 6570 2c20 6d61  split(s, sep, ma
+00010520: 7873 706c 6974 2c20 4661 6c73 6529 0a0a  xsplit, False)..
+00010530: 2020 2020 2020 2020 6465 6620 7374 725f          def str_
+00010540: 7273 706c 6974 2873 2c20 7365 703d 4e6f  rsplit(s, sep=No
+00010550: 6e65 2c20 6d61 7873 706c 6974 3d2d 3129  ne, maxsplit=-1)
+00010560: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00010570: 7475 726e 205f 6d75 6c74 6973 706c 6974  turn _multisplit
+00010580: 5f74 6f5f 7370 6c69 7428 732c 2073 6570  _to_split(s, sep
+00010590: 2c20 6d61 7873 706c 6974 2c20 5472 7565  , maxsplit, True
+000105a0: 290a 0a20 2020 2020 2020 2064 6566 2074  )..        def t
+000105b0: 6573 7428 732c 2073 6570 3d4e 6f6e 652c  est(s, sep=None,
+000105c0: 206d 6178 7370 6c69 743d 2d31 293a 0a20   maxsplit=-1):. 
+000105d0: 2020 2020 2020 2020 2020 2023 2061 7574             # aut
+000105e0: 6f6d 6174 6963 616c 6c79 2074 6573 7420  omatically test 
+000105f0: 7769 7468 2028 7374 722c 2062 7974 6573  with (str, bytes
+00010600: 2920 7820 2873 6570 3d73 6570 2c20 7365  ) x (sep=sep, se
+00010610: 703d 4e6f 6e65 290a 2020 2020 2020 2020  p=None).        
+00010620: 2020 2020 666f 7220 6173 5f62 7974 6573      for as_bytes
+00010630: 2069 6e20 2846 616c 7365 2c20 5472 7565   in (False, True
+00010640: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+00010650: 2020 2069 6620 6173 5f62 7974 6573 3a0a     if as_bytes:.
+00010660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010670: 2020 2020 7320 3d20 732e 656e 636f 6465      s = s.encode
+00010680: 2827 6173 6369 6927 290a 2020 2020 2020  ('ascii').      
+00010690: 2020 2020 2020 2020 2020 2020 2020 6966                if
+000106a0: 2073 6570 2069 7320 6e6f 7420 4e6f 6e65   sep is not None
+000106b0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000106c0: 2020 2020 2020 2020 2020 7365 7020 3d20            sep = 
+000106d0: 7365 702e 656e 636f 6465 2827 6173 6369  sep.encode('asci
+000106e0: 6927 290a 2020 2020 2020 2020 2020 2020  i').            
+000106f0: 2020 2020 666f 7220 7365 705f 6e6f 6e65      for sep_none
+00010700: 2069 6e20 2846 616c 7365 2c20 5472 7565   in (False, True
+00010710: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+00010720: 2020 2020 2020 2073 6570 3220 3d20 4e6f         sep2 = No
+00010730: 6e65 2069 6620 7365 705f 6e6f 6e65 2065  ne if sep_none e
+00010740: 6c73 6520 7365 700a 2020 2020 2020 2020  lse sep.        
+00010750: 2020 2020 2020 2020 2020 2020 6120 3d20              a = 
+00010760: 732e 7370 6c69 7428 7365 7032 2c20 6d61  s.split(sep2, ma
+00010770: 7873 706c 6974 290a 2020 2020 2020 2020  xsplit).        
+00010780: 2020 2020 2020 2020 2020 2020 6220 3d20              b = 
+00010790: 7374 725f 7370 6c69 7428 732c 2073 6570  str_split(s, sep
+000107a0: 322c 206d 6178 7370 6c69 7429 0a20 2020  2, maxsplit).   
+000107b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000107c0: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
+000107d0: 6c28 612c 2062 2c20 6622 7265 696d 706c  l(a, b, f"reimpl
+000107e0: 656d 656e 7465 6420 7374 725f 7370 6c69  emented str_spli
+000107f0: 7420 6661 696c 733a 207b 7321 727d 2e73  t fails: {s!r}.s
+00010800: 706c 6974 287b 7365 7032 2172 7d2c 207b  plit({sep2!r}, {
+00010810: 6d61 7873 706c 6974 7d29 203d 3d20 7b61  maxsplit}) == {a
+00010820: 7d2c 2073 7472 5f73 706c 6974 2076 6572  }, str_split ver
+00010830: 7369 6f6e 2067 6176 6520 7573 207b 627d  sion gave us {b}
+00010840: 2229 0a0a 2020 2020 2020 2020 2020 2020  ")..            
+00010850: 2020 2020 2020 2020 6120 3d20 732e 7273          a = s.rs
+00010860: 706c 6974 2873 6570 322c 206d 6178 7370  plit(sep2, maxsp
+00010870: 6c69 7429 0a20 2020 2020 2020 2020 2020  lit).           
+00010880: 2020 2020 2020 2020 2062 203d 2073 7472           b = str
+00010890: 5f72 7370 6c69 7428 732c 2073 6570 322c  _rsplit(s, sep2,
+000108a0: 206d 6178 7370 6c69 7429 0a20 2020 2020   maxsplit).     
+000108b0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+000108c0: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
+000108d0: 612c 2062 2c20 6622 7265 696d 706c 656d  a, b, f"reimplem
+000108e0: 656e 7465 6420 7374 725f 7273 706c 6974  ented str_rsplit
+000108f0: 2066 6169 6c73 3a20 7b73 2172 7d2e 7273   fails: {s!r}.rs
+00010900: 706c 6974 287b 7365 7032 2172 7d2c 207b  plit({sep2!r}, {
+00010910: 6d61 7873 706c 6974 7d29 203d 3d20 7b61  maxsplit}) == {a
+00010920: 7d2c 2073 7472 5f73 706c 6974 2076 6572  }, str_split ver
+00010930: 7369 6f6e 2067 6176 6520 7573 207b 627d  sion gave us {b}
+00010940: 2229 0a0a 0a20 2020 2020 2020 2066 6f72  ")...        for
+00010950: 206d 6178 7370 6c69 7420 696e 2072 616e   maxsplit in ran
+00010960: 6765 282d 312c 2031 3029 3a0a 2020 2020  ge(-1, 10):.    
+00010970: 2020 2020 2020 2020 7465 7374 2827 6120          test('a 
+00010980: 6220 2020 6320 2020 2020 2020 6420 5c74  b   c       d \t
+00010990: 5c74 5c6e 2065 272c 204e 6f6e 652c 206d  \t\n e', None, m
+000109a0: 6178 7370 6c69 7429 0a20 2020 2020 2020  axsplit).       
+000109b0: 2020 2020 2074 6573 7428 2720 2020 6120       test('   a 
+000109c0: 6220 6320 2020 272c 2027 2027 2c20 6d61  b c   ', ' ', ma
+000109d0: 7873 706c 6974 290a 0a20 2020 2020 2020  xsplit)..       
+000109e0: 2066 6f72 2062 6173 655f 7320 696e 2028   for base_s in (
+000109f0: 0a20 2020 2020 2020 2020 2020 2022 222c  .            "",
+00010a00: 0a20 2020 2020 2020 2020 2020 2022 6122  .            "a"
+00010a10: 2c0a 2020 2020 2020 2020 2020 2020 2261  ,.            "a
+00010a20: 2062 2063 222c 0a20 2020 2020 2020 2020   b c",.         
+00010a30: 2020 2022 6120 6220 2063 2064 2020 2065     "a b  c d   e
+00010a40: 222c 0a20 2020 2020 2020 2020 2020 2029  ",.            )
+00010a50: 3a0a 2020 2020 2020 2020 2020 2020 666f  :.            fo
+00010a60: 7220 6c65 6164 696e 6720 696e 2072 616e  r leading in ran
+00010a70: 6765 2831 3029 3a0a 2020 2020 2020 2020  ge(10):.        
+00010a80: 2020 2020 2020 2020 666f 7220 7472 6169          for trai
+00010a90: 6c69 6e67 2069 6e20 7261 6e67 6528 3130  ling in range(10
+00010aa0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+00010ab0: 2020 2020 2020 2073 203d 2028 2220 2220         s = (" " 
+00010ac0: 2a20 6c65 6164 696e 6729 202b 2062 6173  * leading) + bas
+00010ad0: 655f 7320 2b20 2822 2022 202a 2074 7261  e_s + (" " * tra
+00010ae0: 696c 696e 6729 0a20 2020 2020 2020 2020  iling).         
+00010af0: 2020 2020 2020 2020 2020 2073 5f77 6974             s_wit
+00010b00: 685f 636f 6d6d 6173 203d 2073 2e72 6570  h_commas = s.rep
+00010b10: 6c61 6365 2827 2027 2c20 272c 2729 0a20  lace(' ', ','). 
+00010b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010b30: 2020 2066 6f72 206d 6178 7370 6c69 7420     for maxsplit 
+00010b40: 696e 2072 616e 6765 282d 312c 2038 293a  in range(-1, 8):
+00010b50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010b60: 2020 2020 2020 2020 2074 6573 7428 732c           test(s,
+00010b70: 204e 6f6e 652c 206d 6178 7370 6c69 7429   None, maxsplit)
+00010b80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010b90: 2020 2020 2020 2020 2074 6573 7428 732c           test(s,
+00010ba0: 2022 2022 2c20 6d61 7873 706c 6974 290a   " ", maxsplit).
+00010bb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010bc0: 2020 2020 2020 2020 7465 7374 2873 5f77          test(s_w
+00010bd0: 6974 685f 636f 6d6d 6173 2c20 272c 272c  ith_commas, ',',
+00010be0: 206d 6178 7370 6c69 7429 0a0a 2020 2020   maxsplit)..    
+00010bf0: 2020 2020 7365 6c66 2e61 7373 6572 7445      self.assertE
+00010c00: 7175 616c 2873 7472 5f73 706c 6974 2827  qual(str_split('
+00010c10: 2729 2c20 5b5d 290a 2020 2020 2020 2020  '), []).        
+00010c20: 7465 7374 2827 2729 0a0a 2020 2020 2020  test('')..      
+00010c30: 2020 2320 7465 7374 2067 7265 6564 7920    # test greedy 
+00010c40: 6265 6861 7669 6f72 2e0a 2020 2020 2020  behavior..      
+00010c50: 2020 2320 7374 722e 7370 6c69 7420 6973    # str.split is
+00010c60: 6e27 7420 6772 6565 6479 2c20 6275 7420  n't greedy, but 
+00010c70: 6d75 6c74 6973 706c 6974 2069 732e 0a20  multisplit is.. 
+00010c80: 2020 2020 2020 2023 2028 7765 6c6c 2c20         # (well, 
+00010c90: 7374 722e 7370 6c69 7420 2a6d 6967 6874  str.split *might
+00010ca0: 2a20 6265 3f20 7468 6572 6527 7320 6e6f  * be? there's no
+00010cb0: 2077 6179 2074 6f20 6361 6c6c 2069 740a   way to call it.
+00010cc0: 2020 2020 2020 2020 2320 7468 6174 2064          # that d
+00010cd0: 656d 6f6e 7374 7261 7465 7320 7768 6574  emonstrates whet
+00010ce0: 6865 7220 6f72 206e 6f74 2069 7427 7320  her or not it's 
+00010cf0: 6772 6565 6479 2e29 0a20 2020 2020 2020  greedy.).       
+00010d00: 2023 2061 6e79 7761 792c 2065 6e73 7572   # anyway, ensur
+00010d10: 6520 6d75 6c74 6973 706c 6974 2773 2067  e multisplit's g
+00010d20: 7265 6564 7920 6265 6861 7669 6f72 2064  reedy behavior d
+00010d30: 6f65 736e 2774 0a20 2020 2020 2020 2023  oesn't.        #
+00010d40: 206d 6573 7320 7570 206f 7572 2065 6d75   mess up our emu
+00010d50: 6c61 7469 6f6e 206f 6620 7374 722e 7370  lation of str.sp
+00010d60: 6c69 742e 0a20 2020 2020 2020 2074 6573  lit..        tes
+00010d70: 7428 2761 5c72 625c 6e63 5c72 5c6e 6427  t('a\rb\nc\r\nd'
+00010d80: 290a 0a20 2020 2020 2020 2074 6573 7428  )..        test(
+00010d90: 2761 2062 2063 2027 2c20 2720 2729 0a0a  'a b c ', ' ')..
+00010da0: 2020 2020 6465 6620 7465 7374 5f72 6569      def test_rei
+00010db0: 6d70 6c65 6d65 6e74 6564 5f73 7472 5f73  mplemented_str_s
+00010dc0: 706c 6974 6c69 6e65 7328 7365 6c66 293a  plitlines(self):
+00010dd0: 0a20 2020 2020 2020 2064 6566 2073 7472  .        def str
+00010de0: 5f73 706c 6974 6c69 6e65 7328 732c 206b  _splitlines(s, k
+00010df0: 6565 7065 6e64 733d 4661 6c73 6529 3a0a  eepends=False):.
+00010e00: 2020 2020 2020 2020 2020 2020 6e65 776c              newl
+00010e10: 696e 6573 203d 2062 6967 2e61 7363 6969  ines = big.ascii
+00010e20: 5f6e 6577 6c69 6e65 7320 6966 2069 7369  _newlines if isi
+00010e30: 6e73 7461 6e63 6528 732c 2062 7974 6573  nstance(s, bytes
+00010e40: 2920 656c 7365 2062 6967 2e6e 6577 6c69  ) else big.newli
+00010e50: 6e65 730a 2020 2020 2020 2020 2020 2020  nes.            
+00010e60: 6c20 3d20 6c69 7374 2862 6967 2e6d 756c  l = list(big.mul
+00010e70: 7469 7370 6c69 7428 732c 206e 6577 6c69  tisplit(s, newli
+00010e80: 6e65 732c 0a20 2020 2020 2020 2020 2020  nes,.           
+00010e90: 2020 2020 206b 6565 703d 6b65 6570 656e       keep=keepen
+00010ea0: 6473 2c20 7365 7061 7261 7465 3d54 7275  ds, separate=Tru
+00010eb0: 652c 2073 7472 6970 3d46 616c 7365 2929  e, strip=False))
+00010ec0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00010ed0: 6c20 616e 6420 6e6f 7420 6c5b 2d31 5d3a  l and not l[-1]:
+00010ee0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010ef0: 2023 2079 6573 2c20 2222 2e73 706c 6974   # yes, "".split
+00010f00: 6c69 6e65 7328 2920 7265 7475 726e 7320  lines() returns 
+00010f10: 616e 2065 6d70 7479 206c 6973 740a 2020  an empty list.  
+00010f20: 2020 2020 2020 2020 2020 2020 2020 6c2e                l.
+00010f30: 706f 7028 290a 2020 2020 2020 2020 2020  pop().          
+00010f40: 2020 7265 7475 726e 206c 0a0a 2020 2020    return l..    
+00010f50: 2020 2020 6465 6620 7465 7374 2873 293a      def test(s):
+00010f60: 0a20 2020 2020 2020 2020 2020 2023 2061  .            # a
+00010f70: 7574 6f6d 6174 6963 616c 6c79 2074 6573  utomatically tes
+00010f80: 7420 7769 7468 2028 7374 722c 2062 7974  t with (str, byt
+00010f90: 6573 2920 7820 286b 6565 7065 6e64 733d  es) x (keepends=
+00010fa0: 4661 6c73 652c 6b65 6570 656e 6473 3d54  False,keepends=T
+00010fb0: 7275 652c 290a 2020 2020 2020 2020 2020  rue,).          
+00010fc0: 2020 666f 7220 6173 5f62 7974 6573 2069    for as_bytes i
+00010fd0: 6e20 2846 616c 7365 2c20 5472 7565 293a  n (False, True):
+00010fe0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010ff0: 2069 6620 6173 5f62 7974 6573 3a0a 2020   if as_bytes:.  
+00011000: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011010: 2020 7320 3d20 732e 656e 636f 6465 2827    s = s.encode('
+00011020: 6173 6369 6927 290a 2020 2020 2020 2020  ascii').        
+00011030: 2020 2020 2020 2020 666f 7220 6b65 6570          for keep
+00011040: 656e 6473 2069 6e20 2846 616c 7365 2c20  ends in (False, 
+00011050: 5472 7565 293a 0a20 2020 2020 2020 2020  True):.         
+00011060: 2020 2020 2020 2020 2020 2061 203d 2073             a = s
+00011070: 2e73 706c 6974 6c69 6e65 7328 6b65 6570  .splitlines(keep
+00011080: 656e 6473 290a 2020 2020 2020 2020 2020  ends).          
+00011090: 2020 2020 2020 2020 2020 6220 3d20 7374            b = st
+000110a0: 725f 7370 6c69 746c 696e 6573 2873 2c20  r_splitlines(s, 
+000110b0: 6b65 6570 656e 6473 290a 2020 2020 2020  keepends).      
+000110c0: 2020 2020 2020 2020 2020 2020 2020 7365                se
+000110d0: 6c66 2e61 7373 6572 7445 7175 616c 2861  lf.assertEqual(a
+000110e0: 2c20 622c 2066 2272 6569 6d70 6c65 6d65  , b, f"reimpleme
+000110f0: 6e74 6564 2073 7472 5f73 706c 6974 6c69  nted str_splitli
+00011100: 6e65 7320 6661 696c 733a 207b 7321 727d  nes fails: {s!r}
+00011110: 2e73 706c 6974 6c69 6e65 7328 7b6b 6565  .splitlines({kee
+00011120: 7065 6e64 737d 2920 3d3d 207b 617d 2c20  pends}) == {a}, 
+00011130: 6d75 6c74 6973 706c 6974 2067 6176 6520  multisplit gave 
+00011140: 7573 207b 627d 2229 0a0a 2020 2020 2020  us {b}")..      
+00011150: 2020 7465 7374 2827 2729 0a20 2020 2020    test('').     
+00011160: 2020 2074 6573 7428 274f 6e65 206c 696e     test('One lin
+00011170: 6527 290a 2020 2020 2020 2020 7465 7374  e').        test
+00011180: 2827 4f6e 6520 6c69 6e65 5c6e 2729 0a20  ('One line\n'). 
+00011190: 2020 2020 2020 2074 6573 7428 2754 776f         test('Two
+000111a0: 206c 696e 6573 5c6e 5477 6f20 6c69 6e65   lines\nTwo line
+000111b0: 7327 290a 2020 2020 2020 2020 7465 7374  s').        test
+000111c0: 2827 5477 6f20 6c69 6e65 735c 6e54 776f  ('Two lines\nTwo
+000111d0: 206c 696e 6573 5c6e 2729 0a20 2020 2020   lines\n').     
+000111e0: 2020 2074 6573 7428 2754 776f 206c 696e     test('Two lin
+000111f0: 6573 5c6e 5477 6f20 6c69 6e65 735c 6e5c  es\nTwo lines\n\
+00011200: 6e5c 6e27 290a 0a20 2020 2064 6566 2074  n\n')..    def t
+00011210: 6573 745f 7265 696d 706c 656d 656e 7465  est_reimplemente
+00011220: 645f 7374 725f 7061 7274 6974 696f 6e28  d_str_partition(
+00011230: 7365 6c66 293a 0a20 2020 2020 2020 2064  self):.        d
+00011240: 6566 205f 7061 7274 6974 696f 6e5f 746f  ef _partition_to
+00011250: 5f6d 756c 7469 7370 6c69 7428 732c 2073  _multisplit(s, s
+00011260: 6570 2c20 7265 7665 7273 6529 3a0a 2020  ep, reverse):.  
+00011270: 2020 2020 2020 2020 2020 6966 206e 6f74            if not
+00011280: 2073 6570 3a0a 2020 2020 2020 2020 2020   sep:.          
+00011290: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
+000112a0: 6545 7272 6f72 2822 656d 7074 7920 7365  eError("empty se
+000112b0: 7061 7261 746f 7222 290a 2020 2020 2020  parator").      
+000112c0: 2020 2020 2020 6c20 3d20 7475 706c 6528        l = tuple(
+000112d0: 6269 672e 6d75 6c74 6973 706c 6974 2873  big.multisplit(s
+000112e0: 2c20 2873 6570 2c29 2c0a 2020 2020 2020  , (sep,),.      
+000112f0: 2020 2020 2020 2020 2020 6b65 6570 3d62            keep=b
+00011300: 6967 2e41 4c54 4552 4e41 5449 4e47 2c20  ig.ALTERNATING, 
+00011310: 6d61 7873 706c 6974 3d31 2c20 7265 7665  maxsplit=1, reve
+00011320: 7273 653d 7265 7665 7273 652c 2073 6570  rse=reverse, sep
+00011330: 6172 6174 653d 5472 7565 2929 0a20 2020  arate=True)).   
+00011340: 2020 2020 2020 2020 2069 6620 6c65 6e28           if len(
+00011350: 6c29 203d 3d20 313a 0a20 2020 2020 2020  l) == 1:.       
+00011360: 2020 2020 2020 2020 2065 6d70 7479 203d           empty =
+00011370: 2062 2727 2069 6620 6973 696e 7374 616e   b'' if isinstan
+00011380: 6365 2873 2c20 6279 7465 7329 2065 6c73  ce(s, bytes) els
+00011390: 6520 2727 0a20 2020 2020 2020 2020 2020  e ''.           
+000113a0: 2020 2020 2069 6620 7265 7665 7273 653a       if reverse:
+000113b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000113c0: 2020 2020 206c 203d 2028 656d 7074 792c       l = (empty,
+000113d0: 2065 6d70 7479 2920 2b20 6c0a 2020 2020   empty) + l.    
+000113e0: 2020 2020 2020 2020 2020 2020 656c 7365              else
+000113f0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00011400: 2020 2020 2020 6c20 3d20 6c20 2b20 2865        l = l + (e
+00011410: 6d70 7479 2c20 656d 7074 7929 0a20 2020  mpty, empty).   
+00011420: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00011430: 6c0a 0a20 2020 2020 2020 2064 6566 2073  l..        def s
+00011440: 7472 5f70 6172 7469 7469 6f6e 2873 2c20  tr_partition(s, 
+00011450: 7365 7029 3a0a 2020 2020 2020 2020 2020  sep):.          
+00011460: 2020 7265 7475 726e 205f 7061 7274 6974    return _partit
+00011470: 696f 6e5f 746f 5f6d 756c 7469 7370 6c69  ion_to_multispli
+00011480: 7428 732c 2073 6570 2c20 4661 6c73 6529  t(s, sep, False)
+00011490: 0a0a 2020 2020 2020 2020 6465 6620 7374  ..        def st
+000114a0: 725f 7270 6172 7469 7469 6f6e 2873 2c20  r_rpartition(s, 
+000114b0: 7365 7029 3a0a 2020 2020 2020 2020 2020  sep):.          
+000114c0: 2020 7265 7475 726e 205f 7061 7274 6974    return _partit
+000114d0: 696f 6e5f 746f 5f6d 756c 7469 7370 6c69  ion_to_multispli
+000114e0: 7428 732c 2073 6570 2c20 5472 7565 290a  t(s, sep, True).
+000114f0: 0a20 2020 2020 2020 2064 6566 2074 6573  .        def tes
+00011500: 7428 732c 2073 6570 293a 0a20 2020 2020  t(s, sep):.     
+00011510: 2020 2020 2020 2023 2061 7574 6f6d 6174         # automat
+00011520: 6963 616c 6c79 2074 6573 7420 7769 7468  ically test with
+00011530: 2028 7374 722c 2062 7974 6573 290a 2020   (str, bytes).  
+00011540: 2020 2020 2020 2020 2020 666f 7220 6173            for as
+00011550: 5f62 7974 6573 2069 6e20 2846 616c 7365  _bytes in (False
+00011560: 2c20 5472 7565 293a 0a20 2020 2020 2020  , True):.       
+00011570: 2020 2020 2020 2020 2069 6620 6173 5f62           if as_b
+00011580: 7974 6573 3a0a 2020 2020 2020 2020 2020  ytes:.          
+00011590: 2020 2020 2020 2020 2020 7320 3d20 732e            s = s.
+000115a0: 656e 636f 6465 2827 6173 6369 6927 290a  encode('ascii').
+000115b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000115c0: 2020 2020 6966 2073 6570 2069 7320 6e6f      if sep is no
+000115d0: 7420 4e6f 6e65 3a0a 2020 2020 2020 2020  t None:.        
+000115e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000115f0: 7365 7020 3d20 7365 702e 656e 636f 6465  sep = sep.encode
+00011600: 2827 6173 6369 6927 290a 0a20 2020 2020  ('ascii')..     
+00011610: 2020 2020 2020 2020 2020 2061 203d 2073             a = s
+00011620: 2e70 6172 7469 7469 6f6e 2873 6570 290a  .partition(sep).
+00011630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011640: 6220 3d20 7374 725f 7061 7274 6974 696f  b = str_partitio
+00011650: 6e28 732c 2073 6570 290a 2020 2020 2020  n(s, sep).      
+00011660: 2020 2020 2020 2020 2020 7365 6c66 2e61            self.a
+00011670: 7373 6572 7445 7175 616c 2861 2c20 622c  ssertEqual(a, b,
+00011680: 2066 2272 6569 6d70 6c65 6d65 6e74 6564   f"reimplemented
+00011690: 2073 7472 5f70 6172 7469 7469 6f6e 2066   str_partition f
+000116a0: 6169 6c73 3a20 7b73 2172 7d2e 7061 7274  ails: {s!r}.part
+000116b0: 6974 696f 6e28 7b73 6570 2172 7d29 203d  ition({sep!r}) =
+000116c0: 3d20 7b61 7d2c 206d 756c 7469 7370 6c69  = {a}, multispli
+000116d0: 7420 6761 7665 2075 7320 7b62 7d22 290a  t gave us {b}").
+000116e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000116f0: 2061 203d 2073 2e72 7061 7274 6974 696f   a = s.rpartitio
+00011700: 6e28 7365 7029 0a20 2020 2020 2020 2020  n(sep).         
+00011710: 2020 2020 2020 2062 203d 2073 7472 5f72         b = str_r
+00011720: 7061 7274 6974 696f 6e28 732c 2073 6570  partition(s, sep
+00011730: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00011740: 2020 7365 6c66 2e61 7373 6572 7445 7175    self.assertEqu
+00011750: 616c 2861 2c20 622c 2066 2272 6569 6d70  al(a, b, f"reimp
+00011760: 6c65 6d65 6e74 6564 2073 7472 5f72 7061  lemented str_rpa
+00011770: 7274 6974 696f 6e20 6661 696c 733a 207b  rtition fails: {
+00011780: 7321 727d 2e72 7061 7274 6974 696f 6e28  s!r}.rpartition(
+00011790: 7b73 6570 2172 7d29 203d 3d20 7b61 7d2c  {sep!r}) == {a},
+000117a0: 206d 756c 7469 7370 6c69 7420 6761 7665   multisplit gave
+000117b0: 2075 7320 7b62 7d22 290a 0a20 2020 2020   us {b}")..     
+000117c0: 2020 2074 6573 7428 2727 2c20 2720 2729     test('', ' ')
+000117d0: 0a20 2020 2020 2020 2074 6573 7428 2720  .        test(' 
+000117e0: 272c 2027 2027 290a 0a20 2020 2020 2020  ', ' ')..       
+000117f0: 2073 203d 2022 2020 6120 6220 6220 6320   s = "  a b b c 
+00011800: 6420 6420 6520 2022 0a20 2020 2020 2020  d d e  ".       
+00011810: 2074 6573 7428 732c 2022 2022 290a 2020   test(s, " ").  
+00011820: 2020 2020 2020 7465 7374 2873 2c20 2262        test(s, "b
+00011830: 2022 290a 2020 2020 2020 2020 7465 7374   ").        test
+00011840: 2873 2c20 2220 6220 2229 0a20 2020 2020  (s, " b ").     
+00011850: 2020 2074 6573 7428 732c 2022 2062 2229     test(s, " b")
+00011860: 0a20 2020 2020 2020 2074 6573 7428 732c  .        test(s,
+00011870: 2022 2063 2022 290a 2020 2020 2020 2020   " c ").        
+00011880: 7465 7374 2873 2c20 2220 6422 290a 2020  test(s, " d").  
+00011890: 2020 2020 2020 7465 7374 2873 2c20 2220        test(s, " 
+000118a0: 6420 2229 0a20 2020 2020 2020 2074 6573  d ").        tes
+000118b0: 7428 732c 2022 6420 2229 0a20 2020 2020  t(s, "d ").     
+000118c0: 2020 2074 6573 7428 732c 2022 6522 290a     test(s, "e").
+000118d0: 2020 2020 2020 2020 7465 7374 2873 2c20          test(s, 
+000118e0: 2268 6f6e 6b22 290a 2020 2020 2020 2020  "honk").        
+000118f0: 7465 7374 2873 2c20 2273 7175 6f6e 6b22  test(s, "squonk"
+00011900: 290a 0a20 2020 2020 2020 2077 6974 6820  )..        with 
+00011910: 7365 6c66 2e61 7373 6572 7452 6169 7365  self.assertRaise
+00011920: 7328 5661 6c75 6545 7272 6f72 293a 0a20  s(ValueError):. 
+00011930: 2020 2020 2020 2020 2020 2022 2061 2062             " a b
+00011940: 2063 2022 2e70 6172 7469 7469 6f6e 2827   c ".partition('
+00011950: 2729 0a20 2020 2020 2020 2077 6974 6820  ').        with 
+00011960: 7365 6c66 2e61 7373 6572 7452 6169 7365  self.assertRaise
+00011970: 7328 5661 6c75 6545 7272 6f72 293a 0a20  s(ValueError):. 
+00011980: 2020 2020 2020 2020 2020 2073 7472 5f70             str_p
+00011990: 6172 7469 7469 6f6e 2822 2061 2062 2063  artition(" a b c
+000119a0: 2022 2c20 2727 290a 0a20 2020 2020 2020   ", '')..       
+000119b0: 2077 6974 6820 7365 6c66 2e61 7373 6572   with self.asser
+000119c0: 7452 6169 7365 7328 5661 6c75 6545 7272  tRaises(ValueErr
+000119d0: 6f72 293a 0a20 2020 2020 2020 2020 2020  or):.           
+000119e0: 2022 2061 2062 2063 2022 2e72 7061 7274   " a b c ".rpart
+000119f0: 6974 696f 6e28 2727 290a 2020 2020 2020  ition('').      
+00011a00: 2020 7769 7468 2073 656c 662e 6173 7365    with self.asse
+00011a10: 7274 5261 6973 6573 2856 616c 7565 4572  rtRaises(ValueEr
+00011a20: 726f 7229 3a0a 2020 2020 2020 2020 2020  ror):.          
+00011a30: 2020 7374 725f 7270 6172 7469 7469 6f6e    str_rpartition
+00011a40: 2822 2061 2062 2063 2022 2c20 2727 290a  (" a b c ", '').
+00011a50: 0a0a 2020 2020 6465 6620 7465 7374 5f77  ..    def test_w
+00011a60: 7261 705f 776f 7264 7328 7365 6c66 293a  rap_words(self):
+00011a70: 0a20 2020 2020 2020 2064 6566 2074 6573  .        def tes
+00011a80: 7428 776f 7264 732c 2065 7870 6563 7465  t(words, expecte
+00011a90: 642c 206d 6172 6769 6e3d 3739 293a 0a20  d, margin=79):. 
+00011aa0: 2020 2020 2020 2020 2020 2067 6f74 203d             got =
+00011ab0: 2062 6967 2e77 7261 705f 776f 7264 7328   big.wrap_words(
+00011ac0: 776f 7264 732c 206d 6172 6769 6e29 0a20  words, margin). 
+00011ad0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00011ae0: 6173 7365 7274 4571 7561 6c28 676f 742c  assertEqual(got,
+00011af0: 2065 7870 6563 7465 6429 0a20 2020 2020   expected).     
+00011b00: 2020 2020 2020 2067 6f74 203d 2062 6967         got = big
+00011b10: 2e77 7261 705f 776f 7264 7328 746f 5f62  .wrap_words(to_b
+00011b20: 7974 6573 2877 6f72 6473 292c 206d 6172  ytes(words), mar
+00011b30: 6769 6e29 0a20 2020 2020 2020 2020 2020  gin).           
+00011b40: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
+00011b50: 6c28 676f 742c 2074 6f5f 6279 7465 7328  l(got, to_bytes(
+00011b60: 6578 7065 6374 6564 2929 0a0a 2020 2020  expected))..    
+00011b70: 2020 2020 7465 7374 280a 2020 2020 2020      test(.      
+00011b80: 2020 2020 2020 2268 656c 6c6f 2074 6865        "hello the
+00011b90: 7265 2e20 686f 7720 6172 6520 796f 753f  re. how are you?
+00011ba0: 2069 2061 6d20 6669 6e65 2120 736f 2074   i am fine! so t
+00011bb0: 6865 7265 2773 2074 6861 742e 222e 7370  here's that.".sp
+00011bc0: 6c69 7428 292c 0a20 2020 2020 2020 2020  lit(),.         
+00011bd0: 2020 2022 6865 6c6c 6f20 7468 6572 652e     "hello there.
+00011be0: 2020 686f 7720 6172 6520 796f 753f 2020    how are you?  
+00011bf0: 6920 616d 2066 696e 6521 2020 736f 2074  i am fine!  so t
+00011c00: 6865 7265 2773 2074 6861 742e 2229 0a20  here's that."). 
+00011c10: 2020 2020 2020 2074 6573 7428 0a20 2020         test(.   
+00011c20: 2020 2020 2020 2020 2022 6865 6c6c 6f20           "hello 
+00011c30: 7468 6572 652e 2068 6f77 2061 7265 2079  there. how are y
+00011c40: 6f75 3f20 6920 616d 2066 696e 6521 2073  ou? i am fine! s
+00011c50: 6f20 7468 6572 6527 7320 7468 6174 2e22  o there's that."
+00011c60: 2e73 706c 6974 2829 2c0a 2020 2020 2020  .split(),.      
+00011c70: 2020 2020 2020 2268 656c 6c6f 2074 6865        "hello the
+00011c80: 7265 2e20 2068 6f77 5c6e 6172 6520 796f  re.  how\nare yo
+00011c90: 753f 2020 6920 616d 2066 696e 6521 5c6e  u?  i am fine!\n
+00011ca0: 736f 2074 6865 7265 2773 2074 6861 742e  so there's that.
+00011cb0: 222c 0a20 2020 2020 2020 2020 2020 2032  ",.            2
+00011cc0: 3029 0a20 2020 2020 2020 2074 6573 7428  0).        test(
+00011cd0: 0a20 2020 2020 2020 2020 2020 205b 2274  .            ["t
+00011ce0: 6865 7365 2061 7265 2061 6c6c 206c 6f6e  hese are all lon
+00011cf0: 6720 6c69 6e65 7320 7468 6174 206d 7573  g lines that mus
+00011d00: 7420 6265 2062 7920 7468 656d 7365 6c76  t be by themselv
+00011d10: 6573 2e22 2c0a 2020 2020 2020 2020 2020  es.",.          
+00011d20: 2020 2220 2020 6d6f 7265 2073 7475 6666    "   more stuff
+00011d30: 2067 6f65 7320 6865 7265 2061 6e64 2073   goes here and s
+00011d40: 7475 6666 2e22 2c0a 2020 2020 2020 2020  tuff.",.        
+00011d50: 2020 2020 2220 6b6e 6f77 2077 6861 7420      " know what 
+00011d60: 6927 6d20 7461 6c6b 696e 2720 6162 6f75  i'm talkin' abou
+00011d70: 743f 2020 7965 6168 2c20 7468 6174 2773  t?  yeah, that's
+00011d80: 2077 6861 7420 6927 6d20 7461 6c6b 696e   what i'm talkin
+00011d90: 6720 6162 6f75 742e 225d 2c0a 2020 2020  g about."],.    
+00011da0: 2020 2020 2020 2020 2274 6865 7365 2061          "these a
+00011db0: 7265 2061 6c6c 206c 6f6e 6720 6c69 6e65  re all long line
+00011dc0: 7320 7468 6174 206d 7573 7420 6265 2062  s that must be b
+00011dd0: 7920 7468 656d 7365 6c76 6573 2e5c 6e20  y themselves.\n 
+00011de0: 2020 6d6f 7265 2073 7475 6666 2067 6f65    more stuff goe
+00011df0: 7320 6865 7265 2061 6e64 2073 7475 6666  s here and stuff
+00011e00: 2e5c 6e20 6b6e 6f77 2077 6861 7420 6927  .\n know what i'
+00011e10: 6d20 7461 6c6b 696e 2720 6162 6f75 743f  m talkin' about?
+00011e20: 2020 7965 6168 2c20 7468 6174 2773 2077    yeah, that's w
+00011e30: 6861 7420 6927 6d20 7461 6c6b 696e 6720  hat i'm talking 
+00011e40: 6162 6f75 742e 222c 0a20 2020 2020 2020  about.",.       
+00011e50: 2020 2020 2032 3029 0a20 2020 2020 2020       20).       
+00011e60: 2074 6573 7428 0a20 2020 2020 2020 2020   test(.         
+00011e70: 2020 205b 2261 222c 2027 6227 2c20 275c     ["a", 'b', '\
+00011e80: 6e5c 6e27 2c20 2763 272c 2027 6427 2c20  n\n', 'c', 'd', 
+00011e90: 2765 2e27 5d2c 0a20 2020 2020 2020 2020  'e.'],.         
+00011ea0: 2020 2022 6120 625c 6e5c 6e63 2064 5c6e     "a b\n\nc d\n
+00011eb0: 652e 222c 0a20 2020 2020 2020 2020 2020  e.",.           
+00011ec0: 2034 290a 0a20 2020 2020 2020 2077 6974   4)..        wit
+00011ed0: 6820 7365 6c66 2e61 7373 6572 7452 6169  h self.assertRai
+00011ee0: 7365 7328 5661 6c75 6545 7272 6f72 293a  ses(ValueError):
+00011ef0: 0a20 2020 2020 2020 2020 2020 2062 6967  .            big
+00011f00: 2e77 7261 705f 776f 7264 7328 5b5d 290a  .wrap_words([]).
+00011f10: 0a20 2020 2064 6566 2074 6573 745f 7370  .    def test_sp
+00011f20: 6c69 745f 7465 7874 5f77 6974 685f 636f  lit_text_with_co
+00011f30: 6465 2873 656c 6629 3a0a 2020 2020 2020  de(self):.      
+00011f40: 2020 6465 6620 7465 7374 2873 2c20 6578    def test(s, ex
+00011f50: 7065 6374 6564 2c20 2a2a 6b77 6172 6773  pected, **kwargs
+00011f60: 293a 0a20 2020 2020 2020 2020 2020 2067  ):.            g
+00011f70: 6f74 203d 2062 6967 2e73 706c 6974 5f74  ot = big.split_t
+00011f80: 6578 745f 7769 7468 5f63 6f64 6528 732c  ext_with_code(s,
+00011f90: 202a 2a6b 7761 7267 7329 0a20 2020 2020   **kwargs).     
+00011fa0: 2020 2020 2020 2069 6620 303a 0a20 2020         if 0:.   
+00011fb0: 2020 2020 2020 2020 2020 2020 2070 7269               pri
+00011fc0: 6e74 2829 0a20 2020 2020 2020 2020 2020  nt().           
+00011fd0: 2020 2020 2070 7269 6e74 2822 733a 2229       print("s:")
+00011fe0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00011ff0: 2070 7269 6e74 2822 2020 2022 2c20 7265   print("   ", re
+00012000: 7072 2873 2929 0a20 2020 2020 2020 2020  pr(s)).         
+00012010: 2020 2020 2020 2070 7269 6e74 2822 676f         print("go
+00012020: 743a 2229 0a20 2020 2020 2020 2020 2020  t:").           
+00012030: 2020 2020 2070 7269 6e74 2822 2020 2022       print("   "
+00012040: 2c20 7265 7072 2867 6f74 2929 0a20 2020  , repr(got)).   
+00012050: 2020 2020 2020 2020 2020 2020 2070 7269               pri
+00012060: 6e74 2822 6578 7065 6374 6564 3a22 290a  nt("expected:").
+00012070: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012080: 7072 696e 7428 2220 2020 222c 2072 6570  print("   ", rep
+00012090: 7228 6578 7065 6374 6564 2929 0a20 2020  r(expected)).   
+000120a0: 2020 2020 2020 2020 2020 2020 2070 7269               pri
+000120b0: 6e74 2829 0a20 2020 2020 2020 2020 2020  nt().           
+000120c0: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
+000120d0: 6c28 6578 7065 6374 6564 2c20 676f 7429  l(expected, got)
+000120e0: 0a20 2020 2020 2020 2020 2020 2067 6f74  .            got
+000120f0: 203d 2062 6967 2e73 706c 6974 5f74 6578   = big.split_tex
+00012100: 745f 7769 7468 5f63 6f64 6528 746f 5f62  t_with_code(to_b
+00012110: 7974 6573 2873 292c 202a 2a6b 7761 7267  ytes(s), **kwarg
+00012120: 7329 0a20 2020 2020 2020 2020 2020 2073  s).            s
+00012130: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
+00012140: 746f 5f62 7974 6573 2865 7870 6563 7465  to_bytes(expecte
+00012150: 6429 2c20 676f 7429 0a0a 2020 2020 2020  d), got)..      
+00012160: 2020 6465 6620 7874 6573 7428 2a61 2c20    def xtest(*a, 
+00012170: 2a2a 6b77 293a 2070 6173 730a 0a20 2020  **kw): pass..   
+00012180: 2020 2020 2074 6573 7428 0a20 2020 2020       test(.     
+00012190: 2020 2020 2020 2022 6865 7920 7468 6572         "hey ther
+000121a0: 6520 7061 7274 7920 7065 6f70 6c65 222c  e party people",
+000121b0: 0a20 2020 2020 2020 2020 2020 205b 2768  .            ['h
+000121c0: 6579 272c 2027 7468 6572 6527 2c20 2770  ey', 'there', 'p
+000121d0: 6172 7479 272c 2027 7065 6f70 6c65 275d  arty', 'people']
+000121e0: 2c0a 2020 2020 2020 2020 2020 2020 290a  ,.            ).
+000121f0: 2020 2020 2020 2020 7465 7374 280a 2020          test(.  
+00012200: 2020 2020 2020 2020 2020 2268 6579 2074            "hey t
+00012210: 6865 7265 2070 6172 7479 2070 656f 706c  here party peopl
+00012220: 655c 6e5c 6e61 2073 6563 6f6e 6420 7061  e\n\na second pa
+00012230: 7261 6772 6170 6821 5c6e 5c6e 616e 6420  ragraph!\n\nand 
+00012240: 6120 7468 6972 642e 222c 0a20 2020 2020  a third.",.     
+00012250: 2020 2020 2020 205b 2768 6579 272c 2027         ['hey', '
+00012260: 7468 6572 6527 2c20 2770 6172 7479 272c  there', 'party',
+00012270: 2027 7065 6f70 6c65 272c 2027 5c6e 5c6e   'people', '\n\n
+00012280: 272c 2027 6127 2c20 2773 6563 6f6e 6427  ', 'a', 'second'
+00012290: 2c20 2770 6172 6167 7261 7068 2127 2c20  , 'paragraph!', 
+000122a0: 275c 6e5c 6e27 2c20 2761 6e64 272c 2027  '\n\n', 'and', '
+000122b0: 6127 2c20 2774 6869 7264 2e27 5d2c 0a20  a', 'third.'],. 
+000122c0: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+000122d0: 2020 2020 2074 6573 7428 0a20 2020 2020       test(.     
+000122e0: 2020 2020 2020 2022 6865 7920 7468 6572         "hey ther
+000122f0: 6520 7061 7274 7920 7065 6f70 6c65 5c6e  e party people\n
+00012300: 5c6e 6865 7265 2c20 7765 2068 6176 6520  \nhere, we have 
+00012310: 6120 7365 636f 6e64 2070 6172 6167 7261  a second paragra
+00012320: 7068 2e5c 6e77 6974 6820 616e 2069 6e74  ph.\nwith an int
+00012330: 6572 6e61 6c20 6e65 776c 696e 652e 5c6e  ernal newline.\n
+00012340: 5c6e 2020 2020 666f 7220 6920 696e 2063  \n    for i in c
+00012350: 6f64 653a 5c6e 2020 2020 2020 2020 7072  ode:\n        pr
+00012360: 696e 7428 6929 5c6e 5c6e 6d6f 7265 2074  int(i)\n\nmore t
+00012370: 6578 7420 6865 7265 3f20 7375 7265 2073  ext here? sure s
+00012380: 6565 6d73 206c 696b 6520 6974 2e22 2c0a  eems like it.",.
+00012390: 2020 2020 2020 2020 2020 2020 5b27 6865              ['he
+000123a0: 7927 2c20 2774 6865 7265 272c 2027 7061  y', 'there', 'pa
+000123b0: 7274 7927 2c20 2770 656f 706c 6527 2c20  rty', 'people', 
+000123c0: 275c 6e5c 6e27 2c20 2768 6572 652c 272c  '\n\n', 'here,',
+000123d0: 2027 7765 272c 2027 6861 7665 272c 2027   'we', 'have', '
+000123e0: 6127 2c20 2773 6563 6f6e 6427 2c20 2770  a', 'second', 'p
+000123f0: 6172 6167 7261 7068 2e27 2c20 2777 6974  aragraph.', 'wit
+00012400: 6827 2c20 2761 6e27 2c20 2769 6e74 6572  h', 'an', 'inter
+00012410: 6e61 6c27 2c20 276e 6577 6c69 6e65 2e27  nal', 'newline.'
+00012420: 2c20 275c 6e5c 6e27 2c20 2720 2020 2066  , '\n\n', '    f
+00012430: 6f72 2069 2069 6e20 636f 6465 3a27 2c20  or i in code:', 
+00012440: 275c 6e27 2c20 2720 2020 2020 2020 2070  '\n', '        p
+00012450: 7269 6e74 2869 2927 2c20 275c 6e5c 6e27  rint(i)', '\n\n'
+00012460: 2c20 276d 6f72 6527 2c20 2774 6578 7427  , 'more', 'text'
+00012470: 2c20 2768 6572 653f 272c 2027 7375 7265  , 'here?', 'sure
+00012480: 272c 2027 7365 656d 7327 2c20 276c 696b  ', 'seems', 'lik
+00012490: 6527 2c20 2769 742e 275d 0a20 2020 2020  e', 'it.'].     
+000124a0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+000124b0: 2074 6573 7428 0a20 2020 2020 2020 2020   test(.         
+000124c0: 2020 2022 7465 7874 2070 6172 6167 7261     "text paragra
+000124d0: 7068 7320 7365 7061 7261 7465 6420 6279  phs separated by
+000124e0: 2069 6e66 696e 6974 6520 6e65 776c 696e   infinite newlin
+000124f0: 6573 2067 6574 2063 6f6c 6c61 7073 6564  es get collapsed
+00012500: 2074 6f20 6a75 7374 2074 776f 206e 6577   to just two new
+00012510: 6c69 6e65 732e 5c6e 5c6e 5c6e 5c6e 5c6e  lines.\n\n\n\n\n
+00012520: 7365 653f 206a 7573 7420 7477 6f2e 5c6e  see? just two.\n
+00012530: 5c6e 5c6e 5c6e 5c6e 5c6e 5c6e 5c6e 5c6e  \n\n\n\n\n\n\n\n
+00012540: 7165 6421 222c 0a20 2020 2020 2020 2020  qed!",.         
+00012550: 2020 205b 2774 6578 7427 2c20 2770 6172     ['text', 'par
+00012560: 6167 7261 7068 7327 2c20 2773 6570 6172  agraphs', 'separ
+00012570: 6174 6564 272c 2027 6279 272c 2027 696e  ated', 'by', 'in
+00012580: 6669 6e69 7465 272c 2027 6e65 776c 696e  finite', 'newlin
+00012590: 6573 272c 2027 6765 7427 2c20 2763 6f6c  es', 'get', 'col
+000125a0: 6c61 7073 6564 272c 2027 746f 272c 2027  lapsed', 'to', '
+000125b0: 6a75 7374 272c 2027 7477 6f27 2c20 276e  just', 'two', 'n
+000125c0: 6577 6c69 6e65 732e 272c 2027 5c6e 5c6e  ewlines.', '\n\n
+000125d0: 272c 2027 7365 653f 272c 2027 6a75 7374  ', 'see?', 'just
+000125e0: 272c 2027 7477 6f2e 272c 2027 5c6e 5c6e  ', 'two.', '\n\n
+000125f0: 272c 2027 7165 6421 275d 0a20 2020 2020  ', 'qed!'].     
+00012600: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00012610: 2074 6573 7428 0a20 2020 2020 2020 2020   test(.         
+00012620: 2020 2022 6865 7265 2773 2073 6f6d 6520     "here's some 
+00012630: 636f 6465 2077 6974 6820 6120 7461 622e  code with a tab.
+00012640: 5c6e 5c74 666f 7220 7820 696e 2072 616e  \n\tfor x in ran
+00012650: 6765 2833 293a 5c6e 5c74 5c74 7072 696e  ge(3):\n\t\tprin
+00012660: 7428 7829 5c6e 7765 6c70 2120 7468 6174  t(x)\nwelp! that
+00012670: 2773 2069 7420 666f 7220 7468 6520 636f  's it for the co
+00012680: 6465 2e22 2c0a 2020 2020 2020 2020 2020  de.",.          
+00012690: 2020 5b22 6865 7265 2773 222c 2027 736f    ["here's", 'so
+000126a0: 6d65 272c 2027 636f 6465 272c 2027 7769  me', 'code', 'wi
+000126b0: 7468 272c 2027 6127 2c20 2774 6162 2e27  th', 'a', 'tab.'
+000126c0: 2c20 275c 6e5c 6e27 2c20 2720 2020 2020  , '\n\n', '     
+000126d0: 2020 2066 6f72 2078 2069 6e20 7261 6e67     for x in rang
+000126e0: 6528 3329 3a27 2c20 275c 6e27 2c20 2720  e(3):', '\n', ' 
+000126f0: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+00012700: 7269 6e74 2878 2927 2c20 275c 6e5c 6e27  rint(x)', '\n\n'
+00012710: 2c20 2777 656c 7021 272c 2022 7468 6174  , 'welp!', "that
+00012720: 2773 222c 2027 6974 272c 2027 666f 7227  's", 'it', 'for'
+00012730: 2c20 2774 6865 272c 2027 636f 6465 2e27  , 'the', 'code.'
+00012740: 5d0a 2020 2020 2020 2020 2020 2020 290a  ].            ).
+00012750: 2020 2020 2020 2020 7465 7374 280a 2020          test(.  
+00012760: 2020 2020 2020 2020 2020 2268 6572 6527            "here'
+00012770: 7320 736f 6d65 2063 6f64 6520 7769 7468  s some code with
+00012780: 2061 2074 6162 2e5c 6e5c 7466 6f72 2078   a tab.\n\tfor x
+00012790: 2069 6e20 7261 6e67 6528 3329 3a5c 6e5c   in range(3):\n\
+000127a0: 745c 7470 7269 6e74 2878 295c 6e77 656c  t\tprint(x)\nwel
+000127b0: 7021 2074 6861 7427 7320 6974 2066 6f72  p! that's it for
+000127c0: 2074 6865 2063 6f64 652e 222c 0a20 2020   the code.",.   
+000127d0: 2020 2020 2020 2020 205b 2268 6572 6527           ["here'
+000127e0: 7322 2c20 2773 6f6d 6527 2c20 2763 6f64  s", 'some', 'cod
+000127f0: 6527 2c20 2777 6974 6827 2c20 2761 272c  e', 'with', 'a',
+00012800: 2027 7461 622e 272c 2027 5c6e 5c6e 272c   'tab.', '\n\n',
+00012810: 2027 5c74 666f 7220 7820 696e 2072 616e   '\tfor x in ran
+00012820: 6765 2833 293a 272c 2027 5c6e 272c 2027  ge(3):', '\n', '
+00012830: 5c74 5c74 7072 696e 7428 7829 272c 2027  \t\tprint(x)', '
+00012840: 5c6e 5c6e 272c 2027 7765 6c70 2127 2c20  \n\n', 'welp!', 
+00012850: 2274 6861 7427 7322 2c20 2769 7427 2c20  "that's", 'it', 
+00012860: 2766 6f72 272c 2027 7468 6527 2c20 2763  'for', 'the', 'c
+00012870: 6f64 652e 275d 2c0a 2020 2020 2020 2020  ode.'],.        
+00012880: 2020 2020 636f 6e76 6572 745f 7461 6273      convert_tabs
+00012890: 5f74 6f5f 7370 6163 6573 3d46 616c 7365  _to_spaces=False
+000128a0: 290a 2020 2020 2020 2020 7465 7374 280a  ).        test(.
+000128b0: 2020 2020 2020 2020 2020 2020 2274 6869              "thi
+000128c0: 7320 6973 2074 6578 742c 2062 7574 206e  s is text, but n
+000128d0: 6578 7420 6973 2061 2063 6f64 6520 7061  ext is a code pa
+000128e0: 7261 6772 6170 6820 7769 7468 2061 206c  ragraph with a l
+000128f0: 6f74 206f 6620 696e 7465 726e 616c 206e  ot of internal n
+00012900: 6577 6c69 6e65 7320 616e 6420 7374 7566  ewlines and stuf
+00012910: 662e 5c6e 5c74 666f 7220 7820 696e 2072  f.\n\tfor x in r
+00012920: 616e 6765 2833 293a 5c6e 5c6e 2020 205c  ange(3):\n\n   \
+00012930: 6e5c 6e20 2020 205c 745c 6e5c 745c 7470  n\n    \t\n\t\tp
+00012940: 7269 6e74 2878 295c 6e5c 745c 745c 6e5c  rint(x)\n\t\t\n\
+00012950: 6e5c 745c 7470 7269 6e74 2878 2a78 295c  n\t\tprint(x*x)\
+00012960: 6e77 656c 7021 2074 6861 7427 7320 6974  nwelp! that's it
+00012970: 2066 6f72 2074 6865 2063 6f64 652e 222c   for the code.",
+00012980: 0a20 2020 2020 2020 2020 2020 205b 2774  .            ['t
+00012990: 6869 7327 2c20 2769 7327 2c20 2774 6578  his', 'is', 'tex
+000129a0: 742c 272c 2027 6275 7427 2c20 276e 6578  t,', 'but', 'nex
+000129b0: 7427 2c20 2769 7327 2c20 2761 272c 2027  t', 'is', 'a', '
+000129c0: 636f 6465 272c 2027 7061 7261 6772 6170  code', 'paragrap
+000129d0: 6827 2c20 2777 6974 6827 2c20 2761 272c  h', 'with', 'a',
+000129e0: 2027 6c6f 7427 2c20 276f 6627 2c20 2769   'lot', 'of', 'i
+000129f0: 6e74 6572 6e61 6c27 2c20 276e 6577 6c69  nternal', 'newli
+00012a00: 6e65 7327 2c20 2761 6e64 272c 2027 7374  nes', 'and', 'st
+00012a10: 7566 662e 272c 2027 5c6e 5c6e 272c 0a20  uff.', '\n\n',. 
+00012a20: 2020 2020 2020 2020 2020 2027 2020 2020             '    
+00012a30: 2020 2020 666f 7220 7820 696e 2072 616e      for x in ran
+00012a40: 6765 2833 293a 272c 2027 5c6e 272c 2027  ge(3):', '\n', '
+00012a50: 5c6e 272c 2027 5c6e 272c 2027 5c6e 272c  \n', '\n', '\n',
+00012a60: 2027 5c6e 272c 2027 2020 2020 2020 2020   '\n', '        
+00012a70: 2020 2020 2020 2020 7072 696e 7428 7829          print(x)
+00012a80: 272c 2027 5c6e 272c 2027 5c6e 272c 2027  ', '\n', '\n', '
+00012a90: 5c6e 272c 2027 2020 2020 2020 2020 2020  \n', '          
+00012aa0: 2020 2020 2020 7072 696e 7428 782a 7829        print(x*x)
+00012ab0: 272c 2027 5c6e 5c6e 272c 2027 7765 6c70  ', '\n\n', 'welp
+00012ac0: 2127 2c20 2274 6861 7427 7322 2c20 2769  !', "that's", 'i
+00012ad0: 7427 2c20 2766 6f72 272c 2027 7468 6527  t', 'for', 'the'
+00012ae0: 2c20 2763 6f64 652e 275d 0a20 2020 2020  , 'code.'].     
+00012af0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00012b00: 2077 6974 6820 7365 6c66 2e61 7373 6572   with self.asser
+00012b10: 7452 6169 7365 7328 5275 6e74 696d 6545  tRaises(RuntimeE
+00012b20: 7272 6f72 293a 0a20 2020 2020 2020 2020  rror):.         
+00012b30: 2020 2062 6967 2e73 706c 6974 5f74 6578     big.split_tex
+00012b40: 745f 7769 7468 5f63 6f64 6528 2268 6f77  t_with_code("how
+00012b50: 6479 2e5c 6e5c 7677 6861 7427 7320 7468  dy.\n\vwhat's th
+00012b60: 6973 3f22 290a 2020 2020 2020 2020 7769  is?").        wi
+00012b70: 7468 2073 656c 662e 6173 7365 7274 5261  th self.assertRa
+00012b80: 6973 6573 2852 756e 7469 6d65 4572 726f  ises(RuntimeErro
+00012b90: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
+00012ba0: 6269 672e 7370 6c69 745f 7465 7874 5f77  big.split_text_w
+00012bb0: 6974 685f 636f 6465 2822 686f 7764 792e  ith_code("howdy.
+00012bc0: 5c6e 2020 2020 666f 7220 6120 696e 205c  \n    for a in \
+00012bd0: 7620 7261 6e67 6528 3330 293a 5c6e 2020  v range(30):\n  
+00012be0: 2020 2020 2020 7072 696e 7428 6129 2229        print(a)")
+00012bf0: 0a0a 2020 2020 6465 6620 7465 7374 5f6d  ..    def test_m
+00012c00: 6572 6765 5f63 6f6c 756d 6e73 2873 656c  erge_columns(sel
+00012c10: 6629 3a0a 2020 2020 2020 2020 6465 6620  f):.        def 
+00012c20: 7465 7374 2863 6f6c 756d 6e73 2c20 6578  test(columns, ex
+00012c30: 7065 6374 6564 2c20 2a2a 6b77 6172 6773  pected, **kwargs
+00012c40: 293a 0a20 2020 2020 2020 2020 2020 2067  ):.            g
+00012c50: 6f74 203d 2062 6967 2e6d 6572 6765 5f63  ot = big.merge_c
+00012c60: 6f6c 756d 6e73 282a 636f 6c75 6d6e 732c  olumns(*columns,
+00012c70: 202a 2a6b 7761 7267 7329 0a20 2020 2020   **kwargs).     
+00012c80: 2020 2020 2020 2069 6620 303a 0a20 2020         if 0:.   
+00012c90: 2020 2020 2020 2020 2020 2020 2070 7269               pri
+00012ca0: 6e74 2822 5f22 2a37 3029 0a20 2020 2020  nt("_"*70).     
+00012cb0: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+00012cc0: 2822 636f 6c75 6d6e 7322 290a 2020 2020  ("columns").    
+00012cd0: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+00012ce0: 7428 7265 7072 2863 6f6c 756d 6e73 2929  t(repr(columns))
+00012cf0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00012d00: 2070 7269 6e74 2822 6578 7065 6374 6564   print("expected
+00012d10: 3a22 290a 2020 2020 2020 2020 2020 2020  :").            
+00012d20: 2020 2020 7072 696e 7428 290a 2020 2020      print().    
+00012d30: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+00012d40: 7428 7265 7072 2865 7870 6563 7465 6429  t(repr(expected)
+00012d50: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00012d60: 2020 7072 696e 7428 6578 7065 6374 6564    print(expected
+00012d70: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00012d80: 2020 7072 696e 7428 290a 2020 2020 2020    print().      
+00012d90: 2020 2020 2020 2020 2020 7072 696e 7428            print(
+00012da0: 2267 6f74 3a22 290a 2020 2020 2020 2020  "got:").        
+00012db0: 2020 2020 2020 2020 7072 696e 7428 290a          print().
+00012dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012dd0: 7072 696e 7428 7265 7072 2867 6f74 2929  print(repr(got))
+00012de0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00012df0: 2070 7269 6e74 2867 6f74 290a 2020 2020   print(got).    
+00012e00: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+00012e10: 7428 290a 2020 2020 2020 2020 2020 2020  t().            
+00012e20: 2020 2020 7072 696e 7428 290a 2020 2020      print().    
+00012e30: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
+00012e40: 6572 7445 7175 616c 2867 6f74 2c20 6578  ertEqual(got, ex
+00012e50: 7065 6374 6564 290a 2020 2020 2020 2020  pected).        
+00012e60: 2020 2020 6279 7465 735f 636f 6c75 6d6e      bytes_column
+00012e70: 7320 3d20 5b28 746f 5f62 7974 6573 2863  s = [(to_bytes(c
+00012e80: 5b30 5d29 2c20 635b 315d 2c20 635b 325d  [0]), c[1], c[2]
+00012e90: 2920 666f 7220 6320 696e 2063 6f6c 756d  ) for c in colum
+00012ea0: 6e73 5d0a 2020 2020 2020 2020 2020 2020  ns].            
+00012eb0: 6966 2027 636f 6c75 6d6e 5f73 6570 6172  if 'column_separ
+00012ec0: 6174 6f72 2720 696e 206b 7761 7267 733a  ator' in kwargs:
+00012ed0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00012ee0: 206b 7761 7267 735b 2763 6f6c 756d 6e5f   kwargs['column_
+00012ef0: 7365 7061 7261 746f 7227 5d20 3d20 746f  separator'] = to
+00012f00: 5f62 7974 6573 286b 7761 7267 735b 2763  _bytes(kwargs['c
+00012f10: 6f6c 756d 6e5f 7365 7061 7261 746f 7227  olumn_separator'
+00012f20: 5d29 0a20 2020 2020 2020 2020 2020 2067  ]).            g
+00012f30: 6f74 203d 2062 6967 2e6d 6572 6765 5f63  ot = big.merge_c
+00012f40: 6f6c 756d 6e73 282a 6279 7465 735f 636f  olumns(*bytes_co
+00012f50: 6c75 6d6e 732c 202a 2a6b 7761 7267 7329  lumns, **kwargs)
+00012f60: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00012f70: 662e 6173 7365 7274 4571 7561 6c28 676f  f.assertEqual(go
+00012f80: 742c 2074 6f5f 6279 7465 7328 6578 7065  t, to_bytes(expe
+00012f90: 6374 6564 2929 0a0a 2020 2020 2020 2020  cted))..        
+00012fa0: 7769 7468 2073 656c 662e 6173 7365 7274  with self.assert
+00012fb0: 5261 6973 6573 284f 7665 7266 6c6f 7745  Raises(OverflowE
+00012fc0: 7272 6f72 293a 0a20 2020 2020 2020 2020  rror):.         
+00012fd0: 2020 2074 6573 7428 5b28 2231 5c6e 325c     test([("1\n2\
+00012fe0: 6e33 2034 2035 2036 2037 2038 222c 2034  n3 4 5 6 7 8", 4
+00012ff0: 2c20 3429 2c20 2822 686f 7764 795c 6e68  , 4), ("howdy\nh
+00013000: 656c 6c6f 5c6e 6869 2c20 686f 7720 6172  ello\nhi, how ar
+00013010: 6520 796f 753f 5c6e 6927 6d20 6669 6e65  e you?\ni'm fine
+00013020: 2e22 2c20 352c 2031 3629 2c20 2822 656e  .", 5, 16), ("en
+00013030: 6469 6e67 5c6e 7465 7874 2122 2e73 706c  ding\ntext!".spl
+00013040: 6974 2822 5c6e 2229 2c20 3739 2c20 3739  it("\n"), 79, 79
+00013050: 295d 2c0a 2020 2020 2020 2020 2020 2020  )],.            
+00013060: 2020 2020 2231 2020 2020 686f 7764 7920      "1    howdy 
+00013070: 2020 2020 2020 2020 2020 2065 6e64 696e             endin
+00013080: 675c 6e32 2020 2020 6865 6c6c 6f20 2020  g\n2    hello   
+00013090: 2020 2020 2020 2020 2074 6578 7421 5c6e           text!\n
+000130a0: 3320 2020 2068 692c 2068 6f77 2061 7265  3    hi, how are
+000130b0: 2079 6f75 3f5c 6e20 2020 2020 6927 6d20   you?\n     i'm 
+000130c0: 6669 6e65 2e22 2c0a 2020 2020 2020 2020  fine.",.        
+000130d0: 2020 2020 2020 2020 6f76 6572 666c 6f77          overflow
+000130e0: 5f73 7472 6174 6567 793d 6269 672e 4f76  _strategy=big.Ov
+000130f0: 6572 666c 6f77 5374 7261 7465 6779 2e52  erflowStrategy.R
+00013100: 4149 5345 290a 0a20 2020 2020 2020 2074  AISE)..        t
+00013110: 6573 7428 5b28 2231 5c6e 325c 6e33 222c  est([("1\n2\n3",
+00013120: 2034 2c20 3429 2c20 2822 686f 7764 795c   4, 4), ("howdy\
+00013130: 6e68 656c 6c6f 5c6e 6869 2c20 686f 7720  nhello\nhi, how 
+00013140: 6172 6520 796f 753f 5c6e 6927 6d20 6669  are you?\ni'm fi
+00013150: 6e65 2e22 2c20 352c 2031 3629 2c20 2822  ne.", 5, 16), ("
+00013160: 656e 6469 6e67 5c6e 7465 7874 2122 2e73  ending\ntext!".s
+00013170: 706c 6974 2822 5c6e 2229 2c20 3739 2c20  plit("\n"), 79, 
+00013180: 3739 295d 2c0a 2020 2020 2020 2020 2020  79)],.          
+00013190: 2020 2231 2020 2020 686f 7764 7920 2020    "1    howdy   
+000131a0: 2020 2020 2020 2020 2065 6e64 696e 675c           ending\
+000131b0: 6e32 2020 2020 6865 6c6c 6f20 2020 2020  n2    hello     
+000131c0: 2020 2020 2020 2074 6578 7421 5c6e 3320         text!\n3 
+000131d0: 2020 2068 692c 2068 6f77 2061 7265 2079     hi, how are y
+000131e0: 6f75 3f5c 6e20 2020 2020 6927 6d20 6669  ou?\n     i'm fi
+000131f0: 6e65 2e22 2c0a 2020 2020 2020 2020 2020  ne.",.          
+00013200: 2020 6f76 6572 666c 6f77 5f73 7472 6174    overflow_strat
+00013210: 6567 793d 6269 672e 4f76 6572 666c 6f77  egy=big.Overflow
+00013220: 5374 7261 7465 6779 2e49 4e54 5255 4445  Strategy.INTRUDE
+00013230: 5f41 4c4c 290a 0a20 2020 2020 2020 2074  _ALL)..        t
+00013240: 6573 7428 5b28 2273 7570 6572 206c 6f6e  est([("super lon
+00013250: 6720 6c69 6e65 7320 6865 7265 5c6e 4920  g lines here\nI 
+00013260: 6d65 616e 2c20 7468 6579 206a 7573 7420  mean, they just 
+00013270: 676f 206f 6e20 616e 6420 6f6e 2e5c 6e28  go on and on.\n(
+00013280: 7465 7874 295c 6e73 686f 7274 206e 6f77  text)\nshort now
+00013290: 5c6e 686f 7765 7665 722e 5c6e 7468 616e  \nhowever.\nthan
+000132a0: 6b5c 6e74 6865 206d 616b 6572 2122 2c20  k\nthe maker!", 
+000132b0: 352c 2031 3529 2c20 2822 7468 6973 2069  5, 15), ("this i
+000132c0: 7320 7468 6520 7365 636f 6e64 2063 6f6c  s the second col
+000132d0: 756d 6e2e 5c6e 646f 6573 2069 7420 6861  umn.\ndoes it ha
+000132e0: 7665 2074 6f20 7761 6974 3f20 2069 7420  ve to wait?  it 
+000132f0: 7368 6f75 6c64 2e22 2c20 3230 2c20 3630  should.", 20, 60
+00013300: 295d 2c0a 2020 2020 2020 2020 2020 2020  )],.            
+00013310: 2773 7570 6572 206c 6f6e 6720 6c69 6e65  'super long line
+00013320: 7320 6865 7265 5c6e 4920 6d65 616e 2c20  s here\nI mean, 
+00013330: 7468 6579 206a 7573 7420 676f 206f 6e20  they just go on 
+00013340: 616e 6420 6f6e 2e5c 6e28 7465 7874 295c  and on.\n(text)\
+00013350: 6e73 686f 7274 206e 6f77 5c6e 686f 7765  nshort now\nhowe
+00013360: 7665 722e 2020 2020 2020 2020 7468 6973  ver.        this
+00013370: 2069 7320 7468 6520 7365 636f 6e64 2063   is the second c
+00013380: 6f6c 756d 6e2e 5c6e 7468 616e 6b20 2020  olumn.\nthank   
+00013390: 2020 2020 2020 2020 646f 6573 2069 7420          does it 
+000133a0: 6861 7665 2074 6f20 7761 6974 3f20 2069  have to wait?  i
+000133b0: 7420 7368 6f75 6c64 2e5c 6e74 6865 206d  t should.\nthe m
+000133c0: 616b 6572 2127 2c0a 2020 2020 2020 2020  aker!',.        
+000133d0: 2020 2020 6f76 6572 666c 6f77 5f61 6674      overflow_aft
+000133e0: 6572 3d32 2c0a 2020 2020 2020 2020 2020  er=2,.          
+000133f0: 2020 6f76 6572 666c 6f77 5f73 7472 6174    overflow_strat
+00013400: 6567 793d 6269 672e 4f76 6572 666c 6f77  egy=big.Overflow
+00013410: 5374 7261 7465 6779 2e49 4e54 5255 4445  Strategy.INTRUDE
+00013420: 5f41 4c4c 290a 0a20 2020 2020 2020 2023  _ALL)..        #
+00013430: 206d 6572 6765 206f 7665 7266 6c6f 7773   merge overflows
+00013440: 2064 7565 2074 6f20 6f76 6572 666c 6f77   due to overflow
+00013450: 5f62 6566 6f72 6520 616e 6420 6f76 6572  _before and over
+00013460: 666c 6f77 5f61 6674 6572 2062 6569 6e67  flow_after being
+00013470: 206c 6172 6765 0a20 2020 2020 2020 2074   large.        t
+00013480: 6573 7428 5b0a 2020 2020 2020 2020 2020  est([.          
+00013490: 2020 2822 6f76 6572 666c 6f77 206c 696e    ("overflow lin
+000134a0: 6520 315c 6e61 5c6e 625c 6e63 5c6e 645c  e 1\na\nb\nc\nd\
+000134b0: 6e6f 7665 7266 6c6f 7720 6c69 6e65 2032  noverflow line 2
+000134c0: 5c6e 222c 2034 2c20 3829 2c0a 2020 2020  \n", 4, 8),.    
+000134d0: 2020 2020 2020 2020 2822 7468 6973 2069          ("this i
+000134e0: 7320 7468 6520 7365 636f 6e64 2063 6f6c  s the second col
+000134f0: 756d 6e2e 5c6e 646f 6573 2069 7420 6861  umn.\ndoes it ha
+00013500: 7665 2074 6f20 7761 6974 3f20 2069 7420  ve to wait?  it 
+00013510: 7368 6f75 6c64 2e22 2c20 3230 2c20 3630  should.", 20, 60
+00013520: 292c 0a20 2020 2020 2020 2020 2020 205d  ),.            ]
+00013530: 2c0a 2020 2020 2020 2020 2020 2020 276f  ,.            'o
+00013540: 7665 7266 6c6f 7720 6c69 6e65 2031 5c6e  verflow line 1\n
+00013550: 615c 6e62 5c6e 635c 6e64 5c6e 6f76 6572  a\nb\nc\nd\nover
+00013560: 666c 6f77 206c 696e 6520 325c 6e20 2020  flow line 2\n   
+00013570: 2020 2020 2020 7468 6973 2069 7320 7468        this is th
+00013580: 6520 7365 636f 6e64 2063 6f6c 756d 6e2e  e second column.
+00013590: 5c6e 2020 2020 2020 2020 2064 6f65 7320  \n         does 
+000135a0: 6974 2068 6176 6520 746f 2077 6169 743f  it have to wait?
+000135b0: 2020 6974 2073 686f 756c 642e 272c 0a20    it should.',. 
+000135c0: 2020 2020 2020 2020 2020 206f 7665 7266             overf
+000135d0: 6c6f 775f 6265 666f 7265 3d32 2c0a 2020  low_before=2,.  
+000135e0: 2020 2020 2020 2020 2020 6f76 6572 666c            overfl
+000135f0: 6f77 5f61 6674 6572 3d33 2c0a 2020 2020  ow_after=3,.    
+00013600: 2020 2020 2020 2020 6f76 6572 666c 6f77          overflow
+00013610: 5f73 7472 6174 6567 793d 6269 672e 4f76  _strategy=big.Ov
+00013620: 6572 666c 6f77 5374 7261 7465 6779 2e49  erflowStrategy.I
+00013630: 4e54 5255 4445 5f41 4c4c 290a 0a20 2020  NTRUDE_ALL)..   
+00013640: 2020 2020 2074 6573 7428 5b0a 2020 2020       test([.    
+00013650: 2020 2020 2020 2020 2822 6f76 6572 666c          ("overfl
+00013660: 6f77 206c 696e 6520 315c 6e61 5c6e 625c  ow line 1\na\nb\
+00013670: 6e63 5c6e 645c 6e65 5c6e 665c 6e6f 7665  nc\nd\ne\nf\nove
+00013680: 7266 6c6f 7720 6c69 6e65 2032 5c6e 222c  rflow line 2\n",
+00013690: 2034 2c20 3829 2c0a 2020 2020 2020 2020   4, 8),.        
+000136a0: 2020 2020 2822 7468 6973 2069 7320 7468      ("this is th
+000136b0: 6520 7365 636f 6e64 2063 6f6c 756d 6e2e  e second column.
+000136c0: 5c6e 646f 6573 2069 7420 6861 7665 2074  \ndoes it have t
+000136d0: 6f20 7761 6974 3f20 206e 6f74 2074 6869  o wait?  not thi
+000136e0: 7320 7469 6d65 2e22 2c20 3230 2c20 3630  s time.", 20, 60
+000136f0: 292c 0a20 2020 2020 2020 2020 2020 205d  ),.            ]
+00013700: 2c0a 2020 2020 2020 2020 2020 2020 276f  ,.            'o
+00013710: 7665 7266 6c6f 7720 6c69 6e65 2031 5c6e  verflow line 1\n
+00013720: 6120 2020 2020 2020 2074 6869 7320 6973  a        this is
+00013730: 2074 6865 2073 6563 6f6e 6420 636f 6c75   the second colu
+00013740: 6d6e 2e5c 6e62 2020 2020 2020 2020 646f  mn.\nb        do
+00013750: 6573 2069 7420 6861 7665 2074 6f20 7761  es it have to wa
+00013760: 6974 3f20 206e 6f74 2074 6869 7320 7469  it?  not this ti
+00013770: 6d65 2e5c 6e63 5c6e 645c 6e65 5c6e 665c  me.\nc\nd\ne\nf\
+00013780: 6e6f 7665 7266 6c6f 7720 6c69 6e65 2032  noverflow line 2
+00013790: 272c 0a20 2020 2020 2020 2020 2020 206f  ',.            o
+000137a0: 7665 7266 6c6f 775f 7374 7261 7465 6779  verflow_strategy
+000137b0: 3d62 6967 2e4f 7665 7266 6c6f 7753 7472  =big.OverflowStr
+000137c0: 6174 6567 792e 494e 5452 5544 455f 414c  ategy.INTRUDE_AL
+000137d0: 4c29 0a20 2020 2020 2020 2023 2074 6573  L).        # tes
+000137e0: 7420 7061 7573 6520 756e 7469 6c20 6669  t pause until fi
+000137f0: 6e61 6c0a 2020 2020 2020 2020 7465 7374  nal.        test
+00013800: 285b 0a20 2020 2020 2020 2020 2020 2028  ([.            (
+00013810: 226f 7665 7266 6c6f 7720 6c69 6e65 2031  "overflow line 1
+00013820: 5c6e 615c 6e62 5c6e 635c 6e64 5c6e 655c  \na\nb\nc\nd\ne\
+00013830: 6e66 5c6e 6f76 6572 666c 6f77 206c 696e  nf\noverflow lin
+00013840: 6520 325c 6e22 2c20 342c 2038 292c 0a20  e 2\n", 4, 8),. 
+00013850: 2020 2020 2020 2020 2020 2028 2274 6869             ("thi
+00013860: 7320 6973 2074 6865 2073 6563 6f6e 6420  s is the second 
+00013870: 636f 6c75 6d6e 2e5c 6e64 6f65 7320 6974  column.\ndoes it
+00013880: 2068 6176 6520 746f 2077 6169 743f 2020   have to wait?  
+00013890: 6974 2073 686f 756c 642e 222c 2032 302c  it should.", 20,
+000138a0: 2036 3029 2c0a 2020 2020 2020 2020 2020   60),.          
+000138b0: 2020 5d2c 0a20 2020 2020 2020 2020 2020    ],.           
+000138c0: 2027 6f76 6572 666c 6f77 206c 696e 6520   'overflow line 
+000138d0: 315c 6e61 5c6e 625c 6e63 5c6e 645c 6e65  1\na\nb\nc\nd\ne
+000138e0: 5c6e 665c 6e6f 7665 7266 6c6f 7720 6c69  \nf\noverflow li
+000138f0: 6e65 2032 5c6e 2020 2020 2020 2020 2074  ne 2\n         t
+00013900: 6869 7320 6973 2074 6865 2073 6563 6f6e  his is the secon
+00013910: 6420 636f 6c75 6d6e 2e5c 6e20 2020 2020  d column.\n     
+00013920: 2020 2020 646f 6573 2069 7420 6861 7665      does it have
+00013930: 2074 6f20 7761 6974 3f20 2069 7420 7368   to wait?  it sh
+00013940: 6f75 6c64 2e27 2c0a 2020 2020 2020 2020  ould.',.        
+00013950: 2020 2020 6f76 6572 666c 6f77 5f73 7472      overflow_str
+00013960: 6174 6567 7920 3d20 6269 672e 4f76 6572  ategy = big.Over
+00013970: 666c 6f77 5374 7261 7465 6779 2e44 454c  flowStrategy.DEL
+00013980: 4159 5f41 4c4c 2c0a 2020 2020 2020 2020  AY_ALL,.        
+00013990: 2020 2020 290a 0a20 2020 2020 2020 2072      )..        r
+000139a0: 6573 756c 7473 203d 205b 0a20 2020 2020  esults = [.     
+000139b0: 2020 2020 2020 2027 3120 7c20 6161 6120         '1 | aaa 
+000139c0: 7c20 7768 6174 207c 2061 6161 5c6e 3220  | what | aaa\n2 
+000139d0: 7c20 6262 6220 7c20 686f 2020 207c 2062  | bbb | ho   | b
+000139e0: 6262 5c6e 3320 7c20 6363 6320 7c20 746f  bb\n3 | ccc | to
+000139f0: 6f2d 6c6f 6e67 5c6e 3420 7c20 6464 6420  o-long\n4 | ddd 
+00013a00: 7c20 636f 6c75 6d6e 5c6e 3520 7c20 6565  | column\n5 | ee
+00013a10: 6520 7c20 6865 7265 207c 2063 6363 5c6e  e | here | ccc\n
+00013a20: 3620 7c20 6666 6620 7c20 6d79 2020 207c  6 | fff | my   |
+00013a30: 2064 6464 5c6e 3720 7c20 6767 6720 7c20   ddd\n7 | ggg | 
+00013a40: 6f68 2020 207c 2065 6565 5c6e 3820 7c20  oh   | eee\n8 | 
+00013a50: 6868 6820 7c20 6d79 2020 207c 2066 6666  hhh | my   | fff
+00013a60: 5c6e 2020 7c20 2020 2020 7c20 7768 6174  \n  |     | what
+00013a70: 207c 2067 6767 5c6e 2020 7c20 2020 2020   | ggg\n  |     
+00013a80: 7c20 7477 6565 6479 5c6e 2020 7c20 2020  | tweedy\n  |   
+00013a90: 2020 7c20 6675 6e20 207c 2068 6868 272c    | fun  | hhh',
+00013aa0: 0a20 2020 2020 2020 2020 2020 2027 3120  .            '1 
+00013ab0: 7c20 6161 6120 7c20 7768 6174 207c 2061  | aaa | what | a
+00013ac0: 6161 5c6e 3220 7c20 6262 6220 7c20 686f  aa\n2 | bbb | ho
+00013ad0: 2020 207c 2062 6262 5c6e 3320 7c20 6363     | bbb\n3 | cc
+00013ae0: 6320 7c20 746f 6f2d 6c6f 6e67 5c6e 3420  c | too-long\n4 
+00013af0: 7c20 6464 6420 7c20 636f 6c75 6d6e 5c6e  | ddd | column\n
+00013b00: 3520 7c20 6565 6520 7c20 6865 7265 5c6e  5 | eee | here\n
+00013b10: 3620 7c20 6666 6620 7c20 6d79 2020 207c  6 | fff | my   |
+00013b20: 2063 6363 5c6e 3720 7c20 6767 6720 7c20   ccc\n7 | ggg | 
+00013b30: 6f68 2020 207c 2064 6464 5c6e 3820 7c20  oh   | ddd\n8 | 
+00013b40: 6868 6820 7c20 6d79 2020 207c 2065 6565  hhh | my   | eee
+00013b50: 5c6e 2020 7c20 2020 2020 7c20 7768 6174  \n  |     | what
+00013b60: 207c 2066 6666 5c6e 2020 7c20 2020 2020   | fff\n  |     
+00013b70: 7c20 7477 6565 6479 5c6e 2020 7c20 2020  | tweedy\n  |   
+00013b80: 2020 7c20 6675 6e5c 6e20 207c 2020 2020    | fun\n  |    
+00013b90: 207c 2020 2020 2020 7c20 6767 675c 6e20   |      | ggg\n 
+00013ba0: 207c 2020 2020 207c 2020 2020 2020 7c20   |     |      | 
+00013bb0: 6868 6827 2c0a 2020 2020 2020 2020 2020  hhh',.          
+00013bc0: 2020 2731 207c 2061 6161 207c 2077 6861    '1 | aaa | wha
+00013bd0: 7420 7c20 6161 615c 6e32 207c 2062 6262  t | aaa\n2 | bbb
+00013be0: 207c 2068 6f5c 6e33 207c 2063 6363 207c   | ho\n3 | ccc |
+00013bf0: 2074 6f6f 2d6c 6f6e 675c 6e34 207c 2064   too-long\n4 | d
+00013c00: 6464 207c 2063 6f6c 756d 6e5c 6e35 207c  dd | column\n5 |
+00013c10: 2065 6565 207c 2068 6572 6520 7c20 6262   eee | here | bb
+00013c20: 625c 6e36 207c 2066 6666 207c 206d 7920  b\n6 | fff | my 
+00013c30: 2020 7c20 6363 635c 6e37 207c 2067 6767    | ccc\n7 | ggg
+00013c40: 207c 206f 6820 2020 7c20 6464 645c 6e38   | oh   | ddd\n8
+00013c50: 207c 2068 6868 207c 206d 7920 2020 7c20   | hhh | my   | 
+00013c60: 6565 655c 6e20 207c 2020 2020 207c 2077  eee\n  |     | w
+00013c70: 6861 745c 6e20 207c 2020 2020 207c 2074  hat\n  |     | t
+00013c80: 7765 6564 795c 6e20 207c 2020 2020 207c  weedy\n  |     |
+00013c90: 2066 756e 2020 7c20 6666 665c 6e20 207c   fun  | fff\n  |
+00013ca0: 2020 2020 207c 2020 2020 2020 7c20 6767       |      | gg
+00013cb0: 675c 6e20 207c 2020 2020 207c 2020 2020  g\n  |     |    
+00013cc0: 2020 7c20 6868 6827 2c0a 2020 2020 2020    | hhh',.      
+00013cd0: 2020 2020 2020 2731 207c 2061 6161 207c        '1 | aaa |
+00013ce0: 2077 6861 7420 7c20 6161 615c 6e32 207c   what | aaa\n2 |
+00013cf0: 2062 6262 207c 2068 6f5c 6e33 207c 2063   bbb | ho\n3 | c
+00013d00: 6363 207c 2074 6f6f 2d6c 6f6e 675c 6e34  cc | too-long\n4
+00013d10: 207c 2064 6464 207c 2063 6f6c 756d 6e5c   | ddd | column\
+00013d20: 6e35 207c 2065 6565 207c 2068 6572 655c  n5 | eee | here\
+00013d30: 6e36 207c 2066 6666 207c 206d 7920 2020  n6 | fff | my   
+00013d40: 7c20 6262 625c 6e37 207c 2067 6767 207c  | bbb\n7 | ggg |
+00013d50: 206f 6820 2020 7c20 6363 635c 6e38 207c   oh   | ccc\n8 |
+00013d60: 2068 6868 207c 206d 7920 2020 7c20 6464   hhh | my   | dd
+00013d70: 645c 6e20 207c 2020 2020 207c 2077 6861  d\n  |     | wha
+00013d80: 745c 6e20 207c 2020 2020 207c 2074 7765  t\n  |     | twe
+00013d90: 6564 795c 6e20 207c 2020 2020 207c 2066  edy\n  |     | f
+00013da0: 756e 5c6e 2020 7c20 2020 2020 7c20 2020  un\n  |     |   
+00013db0: 2020 207c 2065 6565 5c6e 2020 7c20 2020     | eee\n  |   
+00013dc0: 2020 7c20 2020 2020 207c 2066 6666 5c6e    |      | fff\n
+00013dd0: 2020 7c20 2020 2020 7c20 2020 2020 207c    |     |      |
+00013de0: 2067 6767 5c6e 2020 7c20 2020 2020 7c20   ggg\n  |     | 
+00013df0: 2020 2020 207c 2068 6868 272c 0a20 2020       | hhh',.   
+00013e00: 2020 2020 2020 2020 205d 0a0a 2020 2020           ]..    
+00013e10: 2020 2020 7265 7375 6c74 735f 6974 6572      results_iter
+00013e20: 6174 6f72 203d 2069 7465 7228 7265 7375  ator = iter(resu
+00013e30: 6c74 7329 0a20 2020 2020 2020 2066 6f72  lts).        for
+00013e40: 206f 7665 7266 6c6f 775f 6265 666f 7265   overflow_before
+00013e50: 2069 6e20 7261 6e67 6528 3229 3a0a 2020   in range(2):.  
+00013e60: 2020 2020 2020 2020 2020 666f 7220 6f76            for ov
+00013e70: 6572 666c 6f77 5f61 6674 6572 2069 6e20  erflow_after in 
+00013e80: 7261 6e67 6528 3229 3a0a 2020 2020 2020  range(2):.      
+00013e90: 2020 2020 2020 2020 2020 7465 7374 2828            test((
+00013ea0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00013eb0: 2020 2020 2028 2231 5c6e 325c 6e33 5c6e       ("1\n2\n3\n
+00013ec0: 345c 6e35 5c6e 365c 6e37 5c6e 3822 2c20  4\n5\n6\n7\n8", 
+00013ed0: 312c 2031 292c 0a20 2020 2020 2020 2020  1, 1),.         
+00013ee0: 2020 2020 2020 2020 2020 2028 2261 6161             ("aaa
+00013ef0: 5c6e 6262 625c 6e63 6363 5c6e 6464 645c  \nbbb\nccc\nddd\
+00013f00: 6e65 6565 5c6e 6666 665c 6e67 6767 5c6e  neee\nfff\nggg\n
+00013f10: 6868 6822 2c20 332c 2033 292c 0a20 2020  hhh", 3, 3),.   
 00013f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013f30: 4c28 2766 6972 6566 6f78 272c 2032 292c  L('firefox', 2),
-00013f40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00013f50: 204c 2827 6769 7261 6666 6527 2c20 3629   L('giraffe', 6)
-00013f60: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00013f70: 2020 4c28 2768 756d 6d69 6e67 6269 7264    L('hummingbird
-00013f80: 272c 2038 292c 0a20 2020 2020 2020 2020  ', 8),.         
-00013f90: 2020 205d 0a20 2020 2020 2020 2020 2020     ].           
-00013fa0: 2029 0a0a 2020 2020 2020 2020 7465 7374   )..        test
-00013fb0: 2862 6967 2e6c 696e 6573 5f73 6f72 7428  (big.lines_sort(
-00013fc0: 6269 672e 6c69 6e65 7328 2222 220a 636f  big.lines(""".co
-00013fd0: 726d 6f72 616e 740a 6669 7265 666f 780a  rmorant.firefox.
-00013fe0: 616c 6c69 6761 746f 720a 6469 706c 6f64  alligator.diplod
-00013ff0: 6f63 7573 0a65 6c65 7068 616e 740a 6769  ocus.elephant.gi
-00014000: 7261 6666 650a 6261 7272 6163 7564 610a  raffe.barracuda.
-00014010: 6875 6d6d 696e 6762 6972 640a 2222 225b  hummingbird."""[
-00014020: 313a 2d31 5d29 2c20 7265 7665 7273 653d  1:-1]), reverse=
-00014030: 5472 7565 292c 0a20 2020 2020 2020 2020  True),.         
-00014040: 2020 205b 0a20 2020 2020 2020 2020 2020     [.           
-00014050: 2020 2020 204c 2827 6875 6d6d 696e 6762       L('hummingb
-00014060: 6972 6427 2c20 3829 2c0a 2020 2020 2020  ird', 8),.      
-00014070: 2020 2020 2020 2020 2020 4c28 2767 6972            L('gir
-00014080: 6166 6665 272c 2036 292c 0a20 2020 2020  affe', 6),.     
-00014090: 2020 2020 2020 2020 2020 204c 2827 6669             L('fi
-000140a0: 7265 666f 7827 2c20 3229 2c0a 2020 2020  refox', 2),.    
-000140b0: 2020 2020 2020 2020 2020 2020 4c28 2765              L('e
-000140c0: 6c65 7068 616e 7427 2c20 3529 2c0a 2020  lephant', 5),.  
-000140d0: 2020 2020 2020 2020 2020 2020 2020 4c28                L(
-000140e0: 2764 6970 6c6f 646f 6375 7327 2c20 3429  'diplodocus', 4)
-000140f0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00014100: 2020 4c28 2763 6f72 6d6f 7261 6e74 272c    L('cormorant',
-00014110: 2031 292c 0a20 2020 2020 2020 2020 2020   1),.           
-00014120: 2020 2020 204c 2827 6261 7272 6163 7564       L('barracud
-00014130: 6127 2c20 3729 2c0a 2020 2020 2020 2020  a', 7),.        
-00014140: 2020 2020 2020 2020 4c28 2761 6c6c 6967          L('allig
-00014150: 6174 6f72 272c 2033 292c 0a20 2020 2020  ator', 3),.     
-00014160: 2020 2020 2020 205d 0a20 2020 2020 2020         ].       
-00014170: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
-00014180: 7465 7374 2862 6967 2e6c 696e 6573 5f72  test(big.lines_r
-00014190: 7374 7269 7028 6269 672e 6c69 6e65 7328  strip(big.lines(
-000141a0: 0a22 2020 2020 6120 3d20 6220 205c 6e22  ."    a = b  \n"
-000141b0: 0a22 2020 2020 6320 3d20 6420 2020 2020  ."    c = d     
-000141c0: 5c6e 220a 2929 2c0a 2020 2020 2020 2020  \n".)),.        
-000141d0: 2020 2020 5b0a 2020 2020 2020 2020 2020      [.          
-000141e0: 2020 284c 4928 2720 2020 2061 203d 2062    (LI('    a = b
-000141f0: 2020 272c 2020 2020 312c 2031 292c 2027    ',    1, 1), '
-00014200: 2020 2020 6120 3d20 6227 292c 0a20 2020      a = b'),.   
-00014210: 2020 2020 2020 2020 2028 4c49 2827 2020           (LI('  
-00014220: 2020 6320 3d20 6420 2020 2020 272c 2032    c = d     ', 2
-00014230: 2c20 3129 2c20 2720 2020 2063 203d 2064  , 1), '    c = d
-00014240: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
-00014250: 284c 4928 2727 2c20 2020 2020 2020 2020  (LI('',         
-00014260: 2020 2020 2020 332c 2031 292c 2027 2729        3, 1), '')
-00014270: 2c0a 2020 2020 2020 2020 2020 2020 5d29  ,.            ])
-00014280: 0a0a 2020 2020 2020 2020 7465 7374 2862  ..        test(b
-00014290: 6967 2e6c 696e 6573 5f73 7472 6970 2862  ig.lines_strip(b
-000142a0: 6967 2e6c 696e 6573 280a 2220 2020 2061  ig.lines(."    a
-000142b0: 203d 2062 2020 5c6e 220a 2220 2020 2063   = b  \n"."    c
-000142c0: 203d 2064 2020 2020 205c 6e22 0a29 292c   = d     \n".)),
-000142d0: 0a20 2020 2020 2020 2020 2020 205b 0a20  .            [. 
-000142e0: 2020 2020 2020 2020 2020 2028 4c49 2827             (LI('
-000142f0: 2020 2020 6120 3d20 6220 2027 2c20 2020      a = b  ',   
-00014300: 2031 2c20 352c 206c 6561 6469 6e67 3d27   1, 5, leading='
-00014310: 2020 2020 2729 2c20 2761 203d 2062 2729      '), 'a = b')
-00014320: 2c0a 2020 2020 2020 2020 2020 2020 284c  ,.            (L
-00014330: 4928 2720 2020 2063 203d 2064 2020 2020  I('    c = d    
-00014340: 2027 2c20 322c 2035 2c20 6c65 6164 696e   ', 2, 5, leadin
-00014350: 673d 2720 2020 2027 292c 2027 6320 3d20  g='    '), 'c = 
-00014360: 6427 292c 0a20 2020 2020 2020 2020 2020  d'),.           
-00014370: 2028 4c49 2827 272c 2020 2020 2020 2020   (LI('',        
-00014380: 2020 2020 2020 2033 2c20 3129 2c20 2727         3, 1), ''
-00014390: 292c 0a20 2020 2020 2020 2020 2020 205d  ),.            ]
-000143a0: 290a 0a20 2020 2020 2020 2074 6573 7428  )..        test(
-000143b0: 6269 672e 6c69 6e65 735f 6669 6c74 6572  big.lines_filter
-000143c0: 5f65 6d70 7479 5f6c 696e 6573 2862 6967  _empty_lines(big
-000143d0: 2e6c 696e 6573 2822 2222 0a0a 2020 2020  .lines("""..    
-000143e0: 6120 3d20 620a 0a0a 2020 2020 6320 3d20  a = b...    c = 
-000143f0: 640a 0a22 2222 5b31 3a5d 2929 2c0a 2020  d.."""[1:])),.  
-00014400: 2020 2020 2020 2020 2020 5b0a 2020 2020            [.    
-00014410: 2020 2020 2020 2020 284c 4928 2720 2020          (LI('   
-00014420: 2061 203d 2062 272c 2032 2c20 3129 2c20   a = b', 2, 1), 
-00014430: 2720 2020 2061 203d 2062 2729 2c0a 2020  '    a = b'),.  
-00014440: 2020 2020 2020 2020 2020 284c 4928 2720            (LI(' 
-00014450: 2020 2063 203d 2064 272c 2035 2c20 3129     c = d', 5, 1)
-00014460: 2c20 2720 2020 2063 203d 2064 2729 2c0a  , '    c = d'),.
-00014470: 2020 2020 2020 2020 2020 2020 5d29 0a0a              ])..
-00014480: 2020 2020 2020 2020 7465 7374 2862 6967          test(big
-00014490: 2e6c 696e 6573 5f63 6f6e 7665 7274 5f74  .lines_convert_t
-000144a0: 6162 735f 746f 5f73 7061 6365 7328 6269  abs_to_spaces(bi
-000144b0: 672e 6c69 6e65 7328 0a20 2020 2020 2020  g.lines(.       
-000144c0: 2020 2020 2022 5c74 6669 7273 7420 6c69       "\tfirst li
-000144d0: 6e65 5c6e 220a 2020 2020 2020 2020 2020  ne\n".          
-000144e0: 2020 225c 745c 7473 6563 6f6e 6420 6c69    "\t\tsecond li
-000144f0: 6e65 5c6e 220a 2020 2020 2020 2020 2020  ne\n".          
-00014500: 2020 2220 205c 7474 6869 7264 206c 696e    "  \tthird lin
-00014510: 655c 6e22 2c0a 2020 2020 2020 2020 2020  e\n",.          
-00014520: 2020 7461 625f 7769 6474 683d 3829 292c    tab_width=8)),
-00014530: 0a20 2020 2020 2020 2020 2020 205b 0a20  .            [. 
-00014540: 2020 2020 2020 2020 2020 2020 2020 2028                 (
-00014550: 4c49 2822 5c74 6669 7273 7420 6c69 6e65  LI("\tfirst line
-00014560: 222c 2031 2c20 3129 2c20 2220 2020 2020  ", 1, 1), "     
-00014570: 2020 2066 6972 7374 206c 696e 6522 292c     first line"),
-00014580: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00014590: 2028 4c49 2822 5c74 5c74 7365 636f 6e64   (LI("\t\tsecond
-000145a0: 206c 696e 6522 2c20 322c 2031 292c 2022   line", 2, 1), "
-000145b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000145c0: 7365 636f 6e64 206c 696e 6522 292c 0a20  second line"),. 
-000145d0: 2020 2020 2020 2020 2020 2020 2020 2028                 (
-000145e0: 4c49 2822 2020 5c74 7468 6972 6420 6c69  LI("  \tthird li
-000145f0: 6e65 222c 2033 2c20 3129 2c20 2220 2020  ne", 3, 1), "   
-00014600: 2020 2020 2074 6869 7264 206c 696e 6522       third line"
-00014610: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
-00014620: 2020 2028 4c49 2822 222c 2034 2c20 3129     (LI("", 4, 1)
-00014630: 2c20 2222 292c 0a20 2020 2020 2020 2020  , ""),.         
-00014640: 2020 205d 290a 0a20 2020 2020 2020 2074     ])..        t
-00014650: 6573 7428 6269 672e 6c69 6e65 735f 7374  est(big.lines_st
-00014660: 7269 705f 636f 6d6d 656e 7473 2862 6967  rip_comments(big
-00014670: 2e6c 696e 6573 2822 2222 0a66 6f72 2078  .lines(""".for x
-00014680: 2069 6e20 7261 6e67 6528 3529 3a20 2320   in range(5): # 
-00014690: 7468 6973 2069 7320 6120 636f 6d6d 656e  this is a commen
-000146a0: 740a 2020 2020 7072 696e 7428 2223 2074  t.    print("# t
-000146b0: 6869 7320 6973 2071 756f 7465 6422 2c20  his is quoted", 
-000146c0: 7829 0a20 2020 2070 7269 6e74 2822 2229  x).    print("")
-000146d0: 2023 2074 6869 7320 2263 6f6d 6d65 6e74   # this "comment
-000146e0: 2220 6973 2075 7365 6c65 7373 0a20 2020  " is useless.   
-000146f0: 2070 7269 6e74 286e 6f5f 636f 6d6d 656e   print(no_commen
-00014700: 7473 5f6f 725f 7175 6f74 6573 5f6f 6e5f  ts_or_quotes_on_
-00014710: 7468 6973 5f6c 696e 6529 0a22 2222 5b31  this_line)."""[1
-00014720: 3a5d 292c 2028 2223 222c 2022 2f2f 2229  :]), ("#", "//")
-00014730: 292c 0a20 2020 2020 2020 2020 2020 205b  ),.            [
-00014740: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00014750: 2028 4c49 286c 696e 653d 2766 6f72 2078   (LI(line='for x
-00014760: 2069 6e20 7261 6e67 6528 3529 3a20 2320   in range(5): # 
-00014770: 7468 6973 2069 7320 6120 636f 6d6d 656e  this is a commen
-00014780: 7427 2c20 6c69 6e65 5f6e 756d 6265 723d  t', line_number=
-00014790: 312c 2063 6f6c 756d 6e5f 6e75 6d62 6572  1, column_number
-000147a0: 3d31 2c20 636f 6d6d 656e 743d 2723 2074  =1, comment='# t
-000147b0: 6869 7320 6973 2061 2063 6f6d 6d65 6e74  his is a comment
-000147c0: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
-000147d0: 2020 2020 2020 2020 2766 6f72 2078 2069          'for x i
-000147e0: 6e20 7261 6e67 6528 3529 3a27 292c 0a20  n range(5):'),. 
-000147f0: 2020 2020 2020 2020 2020 2020 2020 2028                 (
-00014800: 4c49 286c 696e 653d 2720 2020 2070 7269  LI(line='    pri
-00014810: 6e74 2822 2320 7468 6973 2069 7320 7175  nt("# this is qu
-00014820: 6f74 6564 222c 2078 2927 2c20 6c69 6e65  oted", x)', line
-00014830: 5f6e 756d 6265 723d 322c 2063 6f6c 756d  _number=2, colum
-00014840: 6e5f 6e75 6d62 6572 3d31 2c20 636f 6d6d  n_number=1, comm
-00014850: 656e 743d 2727 292c 0a20 2020 2020 2020  ent=''),.       
-00014860: 2020 2020 2020 2020 2020 2020 2027 2020               '  
-00014870: 2020 7072 696e 7428 2223 2074 6869 7320    print("# this 
-00014880: 6973 2071 756f 7465 6422 2c20 7829 2729  is quoted", x)')
-00014890: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-000148a0: 2020 284c 4928 6c69 6e65 3d27 2020 2020    (LI(line='    
-000148b0: 7072 696e 7428 2222 2920 2320 7468 6973  print("") # this
-000148c0: 2022 636f 6d6d 656e 7422 2069 7320 7573   "comment" is us
-000148d0: 656c 6573 7327 2c20 6c69 6e65 5f6e 756d  eless', line_num
-000148e0: 6265 723d 332c 2063 6f6c 756d 6e5f 6e75  ber=3, column_nu
-000148f0: 6d62 6572 3d31 2c20 636f 6d6d 656e 743d  mber=1, comment=
-00014900: 2723 2074 6869 7320 2263 6f6d 6d65 6e74  '# this "comment
-00014910: 2220 6973 2075 7365 6c65 7373 2729 2c0a  " is useless'),.
-00014920: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014930: 2020 2020 2720 2020 2070 7269 6e74 2822      '    print("
-00014940: 2229 2729 2c0a 2020 2020 2020 2020 2020  ")'),.          
-00014950: 2020 2020 2020 284c 4928 6c69 6e65 3d27        (LI(line='
-00014960: 2020 2020 7072 696e 7428 6e6f 5f63 6f6d      print(no_com
-00014970: 6d65 6e74 735f 6f72 5f71 756f 7465 735f  ments_or_quotes_
-00014980: 6f6e 5f74 6869 735f 6c69 6e65 2927 2c20  on_this_line)', 
-00014990: 6c69 6e65 5f6e 756d 6265 723d 342c 2063  line_number=4, c
-000149a0: 6f6c 756d 6e5f 6e75 6d62 6572 3d31 2c20  olumn_number=1, 
-000149b0: 636f 6d6d 656e 743d 2727 292c 0a20 2020  comment=''),.   
-000149c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000149d0: 2027 2020 2020 7072 696e 7428 6e6f 5f63   '    print(no_c
-000149e0: 6f6d 6d65 6e74 735f 6f72 5f71 756f 7465  omments_or_quote
-000149f0: 735f 6f6e 5f74 6869 735f 6c69 6e65 2927  s_on_this_line)'
-00014a00: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
-00014a10: 2020 2028 4c49 286c 696e 653d 2727 2c20     (LI(line='', 
-00014a20: 6c69 6e65 5f6e 756d 6265 723d 352c 2063  line_number=5, c
-00014a30: 6f6c 756d 6e5f 6e75 6d62 6572 3d31 2c20  olumn_number=1, 
-00014a40: 636f 6d6d 656e 743d 2727 292c 0a20 2020  comment=''),.   
-00014a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014a60: 2027 2729 0a20 2020 2020 2020 2020 2020   '').           
-00014a70: 205d 290a 0a20 2020 2020 2020 2074 6573   ])..        tes
-00014a80: 7428 6269 672e 6c69 6e65 735f 7374 7269  t(big.lines_stri
-00014a90: 705f 636f 6d6d 656e 7473 2862 6967 2e6c  p_comments(big.l
-00014aa0: 696e 6573 2822 2222 0a66 6f72 2078 2069  ines(""".for x i
-00014ab0: 6e20 7261 6e67 6528 3529 3a20 2320 7468  n range(5): # th
-00014ac0: 6973 2069 7320 6120 636f 6d6d 656e 740a  is is a comment.
-00014ad0: 2020 2020 7072 696e 7428 2223 2074 6869      print("# thi
-00014ae0: 7320 6973 2071 756f 7465 6422 2c20 7829  s is quoted", x)
-00014af0: 0a20 2020 2070 7269 6e74 2822 2229 2023  .    print("") #
-00014b00: 2074 6869 7320 2263 6f6d 6d65 6e74 2220   this "comment" 
-00014b10: 6973 2075 7365 6c65 7373 0a20 2020 2070  is useless.    p
-00014b20: 7269 6e74 286e 6f5f 636f 6d6d 656e 7473  rint(no_comments
-00014b30: 5f6f 725f 7175 6f74 6573 5f6f 6e5f 7468  _or_quotes_on_th
-00014b40: 6973 5f6c 696e 6529 0a22 2222 5b31 3a5d  is_line)."""[1:]
-00014b50: 292c 2028 2223 222c 2022 2f2f 2229 2c20  ), ("#", "//"), 
-00014b60: 7175 6f74 6573 3d4e 6f6e 6529 2c0a 2020  quotes=None),.  
-00014b70: 2020 2020 2020 2020 2020 5b0a 2020 2020            [.    
-00014b80: 2020 2020 2020 2020 2020 2020 284c 4928              (LI(
-00014b90: 6c69 6e65 3d27 666f 7220 7820 696e 2072  line='for x in r
-00014ba0: 616e 6765 2835 293a 2023 2074 6869 7320  ange(5): # this 
-00014bb0: 6973 2061 2063 6f6d 6d65 6e74 272c 206c  is a comment', l
-00014bc0: 696e 655f 6e75 6d62 6572 3d31 2c20 636f  ine_number=1, co
-00014bd0: 6c75 6d6e 5f6e 756d 6265 723d 312c 2063  lumn_number=1, c
-00014be0: 6f6d 6d65 6e74 3d27 2320 7468 6973 2069  omment='# this i
-00014bf0: 7320 6120 636f 6d6d 656e 7427 292c 0a20  s a comment'),. 
-00014c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014c10: 2027 666f 7220 7820 696e 2072 616e 6765   'for x in range
-00014c20: 2835 293a 2729 2c0a 2020 2020 2020 2020  (5):'),.        
-00014c30: 2020 2020 2020 2020 284c 4928 6c69 6e65          (LI(line
-00014c40: 3d27 2020 2020 7072 696e 7428 2223 2074  ='    print("# t
-00014c50: 6869 7320 6973 2071 756f 7465 6422 2c20  his is quoted", 
-00014c60: 7829 272c 206c 696e 655f 6e75 6d62 6572  x)', line_number
-00014c70: 3d32 2c20 636f 6c75 6d6e 5f6e 756d 6265  =2, column_numbe
-00014c80: 723d 312c 2063 6f6d 6d65 6e74 3d27 2320  r=1, comment='# 
-00014c90: 7468 6973 2069 7320 7175 6f74 6564 222c  this is quoted",
-00014ca0: 2078 2927 292c 0a20 2020 2020 2020 2020   x)'),.         
-00014cb0: 2020 2020 2020 2020 2020 2027 2020 2020             '    
-00014cc0: 7072 696e 7428 2227 292c 0a20 2020 2020  print("'),.     
-00014cd0: 2020 2020 2020 2020 2020 2028 4c49 286c             (LI(l
-00014ce0: 696e 653d 2720 2020 2070 7269 6e74 2822  ine='    print("
-00014cf0: 2229 2023 2074 6869 7320 2263 6f6d 6d65  ") # this "comme
-00014d00: 6e74 2220 6973 2075 7365 6c65 7373 272c  nt" is useless',
-00014d10: 206c 696e 655f 6e75 6d62 6572 3d33 2c20   line_number=3, 
-00014d20: 636f 6c75 6d6e 5f6e 756d 6265 723d 312c  column_number=1,
-00014d30: 2063 6f6d 6d65 6e74 3d27 2320 7468 6973   comment='# this
-00014d40: 2022 636f 6d6d 656e 7422 2069 7320 7573   "comment" is us
-00014d50: 656c 6573 7327 292c 0a20 2020 2020 2020  eless'),.       
-00014d60: 2020 2020 2020 2020 2020 2020 2027 2020               '  
-00014d70: 2020 7072 696e 7428 2222 2927 292c 0a20    print("")'),. 
-00014d80: 2020 2020 2020 2020 2020 2020 2020 2028                 (
-00014d90: 4c49 286c 696e 653d 2720 2020 2070 7269  LI(line='    pri
-00014da0: 6e74 286e 6f5f 636f 6d6d 656e 7473 5f6f  nt(no_comments_o
-00014db0: 725f 7175 6f74 6573 5f6f 6e5f 7468 6973  r_quotes_on_this
-00014dc0: 5f6c 696e 6529 272c 206c 696e 655f 6e75  _line)', line_nu
-00014dd0: 6d62 6572 3d34 2c20 636f 6c75 6d6e 5f6e  mber=4, column_n
-00014de0: 756d 6265 723d 312c 2063 6f6d 6d65 6e74  umber=1, comment
-00014df0: 3d27 2729 2c0a 2020 2020 2020 2020 2020  =''),.          
-00014e00: 2020 2020 2020 2020 2020 2720 2020 2070            '    p
-00014e10: 7269 6e74 286e 6f5f 636f 6d6d 656e 7473  rint(no_comments
-00014e20: 5f6f 725f 7175 6f74 6573 5f6f 6e5f 7468  _or_quotes_on_th
-00014e30: 6973 5f6c 696e 6529 2729 2c0a 2020 2020  is_line)'),.    
-00014e40: 2020 2020 2020 2020 2020 2020 284c 4928              (LI(
-00014e50: 6c69 6e65 3d27 272c 206c 696e 655f 6e75  line='', line_nu
-00014e60: 6d62 6572 3d35 2c20 636f 6c75 6d6e 5f6e  mber=5, column_n
-00014e70: 756d 6265 723d 312c 2063 6f6d 6d65 6e74  umber=1, comment
-00014e80: 3d27 2729 2c0a 2020 2020 2020 2020 2020  =''),.          
-00014e90: 2020 2020 2020 2020 2020 2727 292c 0a20            ''),. 
-00014ea0: 2020 2020 2020 2020 2020 205d 290a 0a20             ]).. 
-00014eb0: 2020 2020 2020 2077 6974 6820 7365 6c66         with self
-00014ec0: 2e61 7373 6572 7452 6169 7365 7328 5661  .assertRaises(Va
-00014ed0: 6c75 6545 7272 6f72 293a 0a20 2020 2020  lueError):.     
-00014ee0: 2020 2020 2020 2074 6573 7428 6269 672e         test(big.
-00014ef0: 6c69 6e65 735f 7374 7269 705f 636f 6d6d  lines_strip_comm
-00014f00: 656e 7473 2862 6967 2e6c 696e 6573 2822  ents(big.lines("
-00014f10: 615c 6e62 5c6e 2229 2c20 4e6f 6e65 292c  a\nb\n"), None),
-00014f20: 205b 5d29 0a0a 2020 2020 2020 2020 7465   [])..        te
-00014f30: 7374 2862 6967 2e6c 696e 6573 5f73 7472  st(big.lines_str
-00014f40: 6970 5f63 6f6d 6d65 6e74 7328 6269 672e  ip_comments(big.
-00014f50: 6c69 6e65 7328 6222 615c 6e62 2320 6967  lines(b"a\nb# ig
-00014f60: 6e6f 7265 645c 6e20 6322 292c 2062 2723  nored\n c"), b'#
-00014f70: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
-00014f80: 5b0a 2020 2020 2020 2020 2020 2020 4c28  [.            L(
-00014f90: 6227 6127 2c20 312c 2063 6f6d 6d65 6e74  b'a', 1, comment
-00014fa0: 3d62 2727 292c 0a20 2020 2020 2020 2020  =b''),.         
-00014fb0: 2020 2028 4c49 2862 2762 2320 6967 6e6f     (LI(b'b# igno
-00014fc0: 7265 6427 2c20 322c 2031 2c20 636f 6d6d  red', 2, 1, comm
-00014fd0: 656e 743d 6227 2320 6967 6e6f 7265 6427  ent=b'# ignored'
-00014fe0: 292c 2062 2762 2729 2c0a 2020 2020 2020  ), b'b'),.      
-00014ff0: 2020 2020 2020 4c28 6227 2063 272c 2033        L(b' c', 3
-00015000: 2c20 636f 6d6d 656e 743d 6227 2729 2c0a  , comment=b''),.
-00015010: 2020 2020 2020 2020 2020 2020 5d0a 2020              ].  
-00015020: 2020 2020 2020 2020 2020 290a 0a0a 2020            )...  
-00015030: 2020 2020 2020 7465 7374 2862 6967 2e6c        test(big.l
-00015040: 696e 6573 5f66 696c 7465 725f 656d 7074  ines_filter_empt
-00015050: 795f 6c69 6e65 7328 6269 672e 6c69 6e65  y_lines(big.line
-00015060: 735f 6669 6c74 6572 5f63 6f6d 6d65 6e74  s_filter_comment
-00015070: 5f6c 696e 6573 2862 6967 2e6c 696e 6573  _lines(big.lines
-00015080: 5f73 7472 6970 2862 6967 2e6c 696e 6573  _strip(big.lines
-00015090: 280a 2220 2020 5c6e 2220 2b0a 2220 2020  (."   \n" +."   
-000150a0: 2061 203d 2062 205c 6e22 202b 0a22 2020   a = b \n" +."  
-000150b0: 205c 6e22 202b 0a22 2020 2020 2320 636f   \n" +."    # co
-000150c0: 6d6d 656e 7420 6c69 6e65 205c 6e22 202b  mment line \n" +
-000150d0: 0a22 2020 2020 5c6e 2220 2b0a 2220 2020  ."    \n" +."   
-000150e0: 205c 6e22 202b 0a22 2020 2020 6320 3d20   \n" +."    c = 
-000150f0: 6420 205c 6e22 202b 0a22 2020 2020 205c  d  \n" +."     \
-00015100: 6e22 2929 2c20 2723 2729 292c 0a20 2020  n")), '#')),.   
-00015110: 2020 2020 2020 2020 205b 0a20 2020 2020           [.     
-00015120: 2020 2020 2020 2028 4c49 2827 2020 2020         (LI('    
-00015130: 6120 3d20 6220 272c 2020 322c 2035 2c20  a = b ',  2, 5, 
-00015140: 6c65 6164 696e 673d 2720 2020 2027 292c  leading='    '),
-00015150: 2027 6120 3d20 6227 292c 0a20 2020 2020   'a = b'),.     
-00015160: 2020 2020 2020 2028 4c49 2827 2020 2020         (LI('    
-00015170: 6320 3d20 6420 2027 2c20 372c 2035 2c20  c = d  ', 7, 5, 
-00015180: 6c65 6164 696e 673d 2720 2020 2027 292c  leading='    '),
-00015190: 2027 6320 3d20 6427 292c 0a20 2020 2020   'c = d'),.     
-000151a0: 2020 2020 2020 205d 290a 0a0a 2020 2020         ])...    
-000151b0: 6465 6620 7465 7374 5f6c 696e 6573 5f73  def test_lines_s
-000151c0: 7472 6970 5f69 6e64 656e 7428 7365 6c66  trip_indent(self
-000151d0: 293a 0a20 2020 2020 2020 2064 6566 2074  ):.        def t
-000151e0: 6573 7428 6c69 6e65 732c 2065 7870 6563  est(lines, expec
-000151f0: 7465 642c 202a 2c20 7461 625f 7769 6474  ted, *, tab_widt
-00015200: 683d 3829 3a0a 2020 2020 2020 2020 2020  h=8):.          
-00015210: 2020 676f 7420 3d20 6c69 7374 2862 6967    got = list(big
-00015220: 2e6c 696e 6573 5f73 7472 6970 5f69 6e64  .lines_strip_ind
-00015230: 656e 7428 6269 672e 6c69 6e65 7328 6c69  ent(big.lines(li
-00015240: 6e65 732c 2074 6162 5f77 6964 7468 3d74  nes, tab_width=t
-00015250: 6162 5f77 6964 7468 2929 290a 2020 2020  ab_width))).    
-00015260: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
-00015270: 6572 7445 7175 616c 2867 6f74 2c20 6578  ertEqual(got, ex
-00015280: 7065 6374 6564 290a 0a0a 2020 2020 2020  pected)...      
-00015290: 2020 4c69 6e65 496e 666f 203d 2062 6967    LineInfo = big
-000152a0: 2e74 6578 742e 4c69 6e65 496e 666f 0a0a  .text.LineInfo..
-000152b0: 2020 2020 2020 2020 6c69 6e65 7320 3d20          lines = 
-000152c0: 2222 220a 6c65 6674 206d 6172 6769 6e0a  """.left margin.
-000152d0: 6966 2033 3a0a 2020 2020 7465 7874 0a65  if 3:.    text.e
-000152e0: 6c73 653a 0a20 2020 2069 6620 313a 0a20  lse:.    if 1:. 
-000152f0: 2020 2020 2020 2020 206f 7468 6572 2074           other t
-00015300: 6578 740a 2020 2020 2020 2020 2020 6f74  ext.          ot
-00015310: 6865 7220 7465 7874 0a20 2020 206d 6f72  her text.    mor
-00015320: 6520 7465 7874 0a20 2020 2020 2064 6966  e text.      dif
-00015330: 6665 7265 6e74 2069 6e64 656e 740a 2020  ferent indent.  
-00015340: 2020 6f75 7464 656e 740a 6f75 7464 656e    outdent.outden
-00015350: 740a 2020 6e65 7720 696e 6465 6e74 0a6f  t.  new indent.o
-00015360: 7574 6465 6e74 0a22 2222 0a0a 2020 2020  utdent."""..    
-00015370: 2020 2020 6578 7065 6374 6564 203d 205b      expected = [
-00015380: 0a20 2020 2020 2020 2020 2020 2028 4c69  .            (Li
-00015390: 6e65 496e 666f 286c 696e 653d 2727 2c20  neInfo(line='', 
-000153a0: 6c69 6e65 5f6e 756d 6265 723d 312c 2063  line_number=1, c
-000153b0: 6f6c 756d 6e5f 6e75 6d62 6572 3d31 2c20  olumn_number=1, 
-000153c0: 696e 6465 6e74 3d30 2c20 6c65 6164 696e  indent=0, leadin
-000153d0: 673d 2727 292c 0a20 2020 2020 2020 2020  g=''),.         
-000153e0: 2020 2020 2020 2027 2729 2c0a 2020 2020         ''),.    
-000153f0: 2020 2020 2020 2020 284c 696e 6549 6e66          (LineInf
-00015400: 6f28 6c69 6e65 3d27 6c65 6674 206d 6172  o(line='left mar
-00015410: 6769 6e27 2c20 6c69 6e65 5f6e 756d 6265  gin', line_numbe
-00015420: 723d 322c 2063 6f6c 756d 6e5f 6e75 6d62  r=2, column_numb
-00015430: 6572 3d31 2c20 696e 6465 6e74 3d30 2c20  er=1, indent=0, 
-00015440: 6c65 6164 696e 673d 2727 292c 0a20 2020  leading=''),.   
-00015450: 2020 2020 2020 2020 2020 2020 2027 6c65               'le
-00015460: 6674 206d 6172 6769 6e27 292c 0a20 2020  ft margin'),.   
-00015470: 2020 2020 2020 2020 2028 4c69 6e65 496e           (LineIn
-00015480: 666f 286c 696e 653d 2769 6620 333a 272c  fo(line='if 3:',
-00015490: 206c 696e 655f 6e75 6d62 6572 3d33 2c20   line_number=3, 
-000154a0: 636f 6c75 6d6e 5f6e 756d 6265 723d 312c  column_number=1,
-000154b0: 2069 6e64 656e 743d 302c 206c 6561 6469   indent=0, leadi
-000154c0: 6e67 3d27 2729 2c0a 2020 2020 2020 2020  ng=''),.        
-000154d0: 2020 2020 2020 2020 2769 6620 333a 2729          'if 3:')
-000154e0: 2c0a 2020 2020 2020 2020 2020 2020 284c  ,.            (L
-000154f0: 696e 6549 6e66 6f28 6c69 6e65 3d27 2020  ineInfo(line='  
-00015500: 2020 7465 7874 272c 206c 696e 655f 6e75    text', line_nu
-00015510: 6d62 6572 3d34 2c20 636f 6c75 6d6e 5f6e  mber=4, column_n
-00015520: 756d 6265 723d 352c 2069 6e64 656e 743d  umber=5, indent=
-00015530: 312c 206c 6561 6469 6e67 3d27 2020 2020  1, leading='    
-00015540: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
-00015550: 2020 2020 2774 6578 7427 292c 0a20 2020      'text'),.   
-00015560: 2020 2020 2020 2020 2028 4c69 6e65 496e           (LineIn
-00015570: 666f 286c 696e 653d 2765 6c73 653a 272c  fo(line='else:',
-00015580: 206c 696e 655f 6e75 6d62 6572 3d35 2c20   line_number=5, 
-00015590: 636f 6c75 6d6e 5f6e 756d 6265 723d 312c  column_number=1,
-000155a0: 2069 6e64 656e 743d 302c 206c 6561 6469   indent=0, leadi
-000155b0: 6e67 3d27 2729 2c0a 2020 2020 2020 2020  ng=''),.        
-000155c0: 2020 2020 2020 2020 2765 6c73 653a 2729          'else:')
-000155d0: 2c0a 2020 2020 2020 2020 2020 2020 284c  ,.            (L
-000155e0: 696e 6549 6e66 6f28 6c69 6e65 3d27 2020  ineInfo(line='  
-000155f0: 2020 6966 2031 3a27 2c20 6c69 6e65 5f6e    if 1:', line_n
-00015600: 756d 6265 723d 362c 2063 6f6c 756d 6e5f  umber=6, column_
-00015610: 6e75 6d62 6572 3d35 2c20 696e 6465 6e74  number=5, indent
-00015620: 3d31 2c20 6c65 6164 696e 673d 2720 2020  =1, leading='   
-00015630: 2027 292c 0a20 2020 2020 2020 2020 2020   '),.           
-00015640: 2020 2020 2027 6966 2031 3a27 292c 0a20       'if 1:'),. 
-00015650: 2020 2020 2020 2020 2020 2028 4c69 6e65             (Line
-00015660: 496e 666f 286c 696e 653d 2720 2020 2020  Info(line='     
-00015670: 2020 2020 206f 7468 6572 2074 6578 7427       other text'
-00015680: 2c20 6c69 6e65 5f6e 756d 6265 723d 372c  , line_number=7,
-00015690: 2063 6f6c 756d 6e5f 6e75 6d62 6572 3d31   column_number=1
-000156a0: 312c 2069 6e64 656e 743d 322c 206c 6561  1, indent=2, lea
-000156b0: 6469 6e67 3d27 2020 2020 2020 2020 2020  ding='          
-000156c0: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
-000156d0: 2020 2020 276f 7468 6572 2074 6578 7427      'other text'
-000156e0: 292c 0a20 2020 2020 2020 2020 2020 2028  ),.            (
-000156f0: 4c69 6e65 496e 666f 286c 696e 653d 2720  LineInfo(line=' 
-00015700: 2020 2020 2020 2020 206f 7468 6572 2074           other t
-00015710: 6578 7427 2c20 6c69 6e65 5f6e 756d 6265  ext', line_numbe
-00015720: 723d 382c 2063 6f6c 756d 6e5f 6e75 6d62  r=8, column_numb
-00015730: 6572 3d31 312c 2069 6e64 656e 743d 322c  er=11, indent=2,
-00015740: 206c 6561 6469 6e67 3d27 2020 2020 2020   leading='      
-00015750: 2020 2020 2729 2c0a 2020 2020 2020 2020      '),.        
-00015760: 2020 2020 2020 2020 276f 7468 6572 2074          'other t
-00015770: 6578 7427 292c 0a20 2020 2020 2020 2020  ext'),.         
-00015780: 2020 2028 4c69 6e65 496e 666f 286c 696e     (LineInfo(lin
-00015790: 653d 2720 2020 206d 6f72 6520 7465 7874  e='    more text
-000157a0: 272c 206c 696e 655f 6e75 6d62 6572 3d39  ', line_number=9
-000157b0: 2c20 636f 6c75 6d6e 5f6e 756d 6265 723d  , column_number=
-000157c0: 352c 2069 6e64 656e 743d 312c 206c 6561  5, indent=1, lea
-000157d0: 6469 6e67 3d27 2020 2020 2729 2c0a 2020  ding='    '),.  
-000157e0: 2020 2020 2020 2020 2020 2020 2020 276d                'm
-000157f0: 6f72 6520 7465 7874 2729 2c0a 2020 2020  ore text'),.    
-00015800: 2020 2020 2020 2020 284c 696e 6549 6e66          (LineInf
-00015810: 6f28 6c69 6e65 3d27 2020 2020 2020 6469  o(line='      di
-00015820: 6666 6572 656e 7420 696e 6465 6e74 272c  fferent indent',
-00015830: 206c 696e 655f 6e75 6d62 6572 3d31 302c   line_number=10,
-00015840: 2063 6f6c 756d 6e5f 6e75 6d62 6572 3d37   column_number=7
-00015850: 2c20 696e 6465 6e74 3d32 2c20 6c65 6164  , indent=2, lead
-00015860: 696e 673d 2720 2020 2020 2027 292c 0a20  ing='      '),. 
-00015870: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-00015880: 6469 6666 6572 656e 7420 696e 6465 6e74  different indent
-00015890: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
-000158a0: 284c 696e 6549 6e66 6f28 6c69 6e65 3d27  (LineInfo(line='
-000158b0: 2020 2020 6f75 7464 656e 7427 2c20 6c69      outdent', li
-000158c0: 6e65 5f6e 756d 6265 723d 3131 2c20 636f  ne_number=11, co
-000158d0: 6c75 6d6e 5f6e 756d 6265 723d 352c 2069  lumn_number=5, i
-000158e0: 6e64 656e 743d 312c 206c 6561 6469 6e67  ndent=1, leading
-000158f0: 3d27 2020 2020 2729 2c0a 2020 2020 2020  ='    '),.      
-00015900: 2020 2020 2020 2020 2020 276f 7574 6465            'outde
-00015910: 6e74 2729 2c0a 2020 2020 2020 2020 2020  nt'),.          
-00015920: 2020 284c 696e 6549 6e66 6f28 6c69 6e65    (LineInfo(line
-00015930: 3d27 6f75 7464 656e 7427 2c20 6c69 6e65  ='outdent', line
-00015940: 5f6e 756d 6265 723d 3132 2c20 636f 6c75  _number=12, colu
-00015950: 6d6e 5f6e 756d 6265 723d 312c 2069 6e64  mn_number=1, ind
-00015960: 656e 743d 302c 206c 6561 6469 6e67 3d27  ent=0, leading='
-00015970: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
-00015980: 2020 2020 276f 7574 6465 6e74 2729 2c0a      'outdent'),.
-00015990: 2020 2020 2020 2020 2020 2020 284c 696e              (Lin
-000159a0: 6549 6e66 6f28 6c69 6e65 3d27 2020 6e65  eInfo(line='  ne
-000159b0: 7720 696e 6465 6e74 272c 206c 696e 655f  w indent', line_
-000159c0: 6e75 6d62 6572 3d31 332c 2063 6f6c 756d  number=13, colum
-000159d0: 6e5f 6e75 6d62 6572 3d33 2c20 696e 6465  n_number=3, inde
-000159e0: 6e74 3d31 2c20 6c65 6164 696e 673d 2720  nt=1, leading=' 
-000159f0: 2027 292c 0a20 2020 2020 2020 2020 2020   '),.           
-00015a00: 2020 2020 2027 6e65 7720 696e 6465 6e74       'new indent
-00015a10: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
-00015a20: 284c 696e 6549 6e66 6f28 6c69 6e65 3d27  (LineInfo(line='
-00015a30: 6f75 7464 656e 7427 2c20 6c69 6e65 5f6e  outdent', line_n
-00015a40: 756d 6265 723d 3134 2c20 636f 6c75 6d6e  umber=14, column
-00015a50: 5f6e 756d 6265 723d 312c 2069 6e64 656e  _number=1, inden
-00015a60: 743d 302c 206c 6561 6469 6e67 3d27 2729  t=0, leading='')
-00015a70: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00015a80: 2020 276f 7574 6465 6e74 2729 2c0a 2020    'outdent'),.  
-00015a90: 2020 2020 2020 2020 2020 284c 696e 6549            (LineI
-00015aa0: 6e66 6f28 6c69 6e65 3d27 272c 206c 696e  nfo(line='', lin
-00015ab0: 655f 6e75 6d62 6572 3d31 352c 2063 6f6c  e_number=15, col
-00015ac0: 756d 6e5f 6e75 6d62 6572 3d31 2c20 696e  umn_number=1, in
-00015ad0: 6465 6e74 3d30 2c20 6c65 6164 696e 673d  dent=0, leading=
-00015ae0: 2727 292c 0a20 2020 2020 2020 2020 2020  ''),.           
-00015af0: 2020 2020 2027 2729 2c0a 2020 2020 2020       ''),.      
-00015b00: 2020 2020 2020 5d0a 0a20 2020 2020 2020        ]..       
-00015b10: 2074 6573 7428 6c69 6e65 732c 2065 7870   test(lines, exp
-00015b20: 6563 7465 6429 0a0a 0a20 2020 2020 2020  ected)...       
-00015b30: 2023 230a 2020 2020 2020 2020 2323 2074   ##.        ## t
-00015b40: 6573 7420 7461 6220 746f 2073 7061 6365  est tab to space
-00015b50: 730a 2020 2020 2020 2020 2323 0a0a 2020  s.        ##..  
-00015b60: 2020 2020 2020 6c69 6e65 7320 3d20 280a        lines = (.
-00015b70: 2020 2020 2020 2020 226c 6566 7420 6d61          "left ma
-00015b80: 7267 696e 5c6e 220a 2020 2020 2020 2020  rgin\n".        
-00015b90: 225c 7465 6967 6874 5c6e 220a 2020 2020  "\teight\n".    
-00015ba0: 2020 2020 2220 205c 7420 2020 2074 7765      "  \t    twe
-00015bb0: 6c76 655c 6e22 0a20 2020 2020 2020 2022  lve\n".        "
-00015bc0: 2020 2020 2020 2020 6569 6768 7420 6973          eight is
-00015bd0: 2065 6e6f 7567 685c 6e22 0a20 2020 2020   enough\n".     
-00015be0: 2020 2029 0a0a 2020 2020 2020 2020 6578     )..        ex
-00015bf0: 7065 6374 6564 203d 205b 0a20 2020 2020  pected = [.     
-00015c00: 2020 2020 2020 2028 4c69 6e65 496e 666f         (LineInfo
-00015c10: 286c 696e 653d 276c 6566 7420 6d61 7267  (line='left marg
-00015c20: 696e 272c 206c 696e 655f 6e75 6d62 6572  in', line_number
-00015c30: 3d31 2c20 636f 6c75 6d6e 5f6e 756d 6265  =1, column_numbe
-00015c40: 723d 312c 2069 6e64 656e 743d 302c 206c  r=1, indent=0, l
-00015c50: 6561 6469 6e67 3d27 2729 2c0a 2020 2020  eading=''),.    
-00015c60: 2020 2020 2020 2020 2020 2020 276c 6566              'lef
-00015c70: 7420 6d61 7267 696e 2729 2c0a 2020 2020  t margin'),.    
-00015c80: 2020 2020 2020 2020 284c 696e 6549 6e66          (LineInf
-00015c90: 6f28 6c69 6e65 3d27 5c74 6569 6768 7427  o(line='\teight'
-00015ca0: 2c20 6c69 6e65 5f6e 756d 6265 723d 322c  , line_number=2,
-00015cb0: 2063 6f6c 756d 6e5f 6e75 6d62 6572 3d39   column_number=9
-00015cc0: 2c20 696e 6465 6e74 3d31 2c20 6c65 6164  , indent=1, lead
-00015cd0: 696e 673d 275c 7427 292c 0a20 2020 2020  ing='\t'),.     
-00015ce0: 2020 2020 2020 2020 2020 2027 6569 6768             'eigh
-00015cf0: 7427 292c 0a20 2020 2020 2020 2020 2020  t'),.           
-00015d00: 2028 4c69 6e65 496e 666f 286c 696e 653d   (LineInfo(line=
-00015d10: 2720 205c 7420 2020 2074 7765 6c76 6527  '  \t    twelve'
-00015d20: 2c20 6c69 6e65 5f6e 756d 6265 723d 332c  , line_number=3,
-00015d30: 2063 6f6c 756d 6e5f 6e75 6d62 6572 3d31   column_number=1
-00015d40: 332c 2069 6e64 656e 743d 322c 206c 6561  3, indent=2, lea
-00015d50: 6469 6e67 3d27 2020 5c74 2020 2020 2729  ding='  \t    ')
-00015d60: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00015d70: 2020 2774 7765 6c76 6527 292c 0a20 2020    'twelve'),.   
-00015d80: 2020 2020 2020 2020 2028 4c69 6e65 496e           (LineIn
-00015d90: 666f 286c 696e 653d 2720 2020 2020 2020  fo(line='       
-00015da0: 2065 6967 6874 2069 7320 656e 6f75 6768   eight is enough
-00015db0: 272c 206c 696e 655f 6e75 6d62 6572 3d34  ', line_number=4
-00015dc0: 2c20 636f 6c75 6d6e 5f6e 756d 6265 723d  , column_number=
-00015dd0: 392c 2069 6e64 656e 743d 312c 206c 6561  9, indent=1, lea
-00015de0: 6469 6e67 3d27 2020 2020 2020 2020 2729  ding='        ')
-00015df0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00015e00: 2020 2765 6967 6874 2069 7320 656e 6f75    'eight is enou
-00015e10: 6768 2729 2c0a 2020 2020 2020 2020 2020  gh'),.          
-00015e20: 2020 284c 696e 6549 6e66 6f28 6c69 6e65    (LineInfo(line
-00015e30: 3d27 272c 206c 696e 655f 6e75 6d62 6572  ='', line_number
-00015e40: 3d35 2c20 636f 6c75 6d6e 5f6e 756d 6265  =5, column_numbe
-00015e50: 723d 312c 2069 6e64 656e 743d 302c 206c  r=1, indent=0, l
-00015e60: 6561 6469 6e67 3d27 2729 2c0a 2020 2020  eading=''),.    
-00015e70: 2020 2020 2020 2020 2020 2020 2727 290a              '').
-00015e80: 2020 2020 2020 2020 2020 2020 5d0a 0a20              ].. 
-00015e90: 2020 2020 2020 2074 6573 7428 6c69 6e65         test(line
-00015ea0: 732c 2065 7870 6563 7465 6429 0a0a 2020  s, expected)..  
-00015eb0: 2020 2020 2020 6c69 6e65 7320 3d20 280a        lines = (.
-00015ec0: 2020 2020 2020 2020 2020 2020 226c 6566              "lef
-00015ed0: 7420 6d61 7267 696e 5c6e 220a 2020 2020  t margin\n".    
-00015ee0: 2020 2020 2020 2020 225c 7466 6f75 725c          "\tfour\
-00015ef0: 6e22 0a20 2020 2020 2020 2020 2020 2022  n".            "
-00015f00: 2020 5c74 2020 2020 6569 6768 745c 6e22    \t    eight\n"
-00015f10: 0a20 2020 2020 2020 2020 2020 2022 2020  .            "  
-00015f20: 5c74 5c74 6669 6775 7265 2065 6967 6874  \t\tfigure eight
-00015f30: 2069 7320 646f 7562 6c65 2066 6f75 725c   is double four\
-00015f40: 6e22 0a20 2020 2020 2020 2020 2020 2022  n".            "
-00015f50: 2020 2020 6669 6775 7265 2066 6f75 7220      figure four 
-00015f60: 6973 2068 616c 6620 6f66 2065 6967 6874  is half of eight
-00015f70: 5c6e 220a 2020 2020 2020 2020 2020 2020  \n".            
-00015f80: 290a 0a20 2020 2020 2020 2065 7870 6563  )..        expec
-00015f90: 7465 6420 3d20 5b0a 2020 2020 2020 2020  ted = [.        
-00015fa0: 2020 2020 284c 696e 6549 6e66 6f28 6c69      (LineInfo(li
-00015fb0: 6e65 3d27 6c65 6674 206d 6172 6769 6e27  ne='left margin'
-00015fc0: 2c20 6c69 6e65 5f6e 756d 6265 723d 312c  , line_number=1,
-00015fd0: 2063 6f6c 756d 6e5f 6e75 6d62 6572 3d31   column_number=1
-00015fe0: 2c20 696e 6465 6e74 3d30 2c20 6c65 6164  , indent=0, lead
-00015ff0: 696e 673d 2727 292c 0a20 2020 2020 2020  ing=''),.       
-00016000: 2020 2020 2020 2020 2027 6c65 6674 206d           'left m
-00016010: 6172 6769 6e27 292c 0a20 2020 2020 2020  argin'),.       
-00016020: 2020 2020 2028 4c69 6e65 496e 666f 286c       (LineInfo(l
-00016030: 696e 653d 275c 7466 6f75 7227 2c20 6c69  ine='\tfour', li
-00016040: 6e65 5f6e 756d 6265 723d 322c 2063 6f6c  ne_number=2, col
-00016050: 756d 6e5f 6e75 6d62 6572 3d35 2c20 696e  umn_number=5, in
-00016060: 6465 6e74 3d31 2c20 6c65 6164 696e 673d  dent=1, leading=
-00016070: 275c 7427 292c 0a20 2020 2020 2020 2020  '\t'),.         
-00016080: 2020 2020 2020 2027 666f 7572 2729 2c0a         'four'),.
-00016090: 2020 2020 2020 2020 2020 2020 284c 696e              (Lin
-000160a0: 6549 6e66 6f28 6c69 6e65 3d27 2020 5c74  eInfo(line='  \t
-000160b0: 2020 2020 6569 6768 7427 2c20 6c69 6e65      eight', line
-000160c0: 5f6e 756d 6265 723d 332c 2063 6f6c 756d  _number=3, colum
-000160d0: 6e5f 6e75 6d62 6572 3d39 2c20 696e 6465  n_number=9, inde
-000160e0: 6e74 3d32 2c20 6c65 6164 696e 673d 2720  nt=2, leading=' 
-000160f0: 205c 7420 2020 2027 292c 0a20 2020 2020   \t    '),.     
-00016100: 2020 2020 2020 2020 2020 2027 6569 6768             'eigh
-00016110: 7427 292c 0a20 2020 2020 2020 2020 2020  t'),.           
-00016120: 2028 4c69 6e65 496e 666f 286c 696e 653d   (LineInfo(line=
-00016130: 2720 205c 745c 7466 6967 7572 6520 6569  '  \t\tfigure ei
-00016140: 6768 7420 6973 2064 6f75 626c 6520 666f  ght is double fo
-00016150: 7572 272c 206c 696e 655f 6e75 6d62 6572  ur', line_number
-00016160: 3d34 2c20 636f 6c75 6d6e 5f6e 756d 6265  =4, column_numbe
-00016170: 723d 392c 2069 6e64 656e 743d 322c 206c  r=9, indent=2, l
-00016180: 6561 6469 6e67 3d27 2020 5c74 5c74 2729  eading='  \t\t')
-00016190: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-000161a0: 2020 2766 6967 7572 6520 6569 6768 7420    'figure eight 
-000161b0: 6973 2064 6f75 626c 6520 666f 7572 2729  is double four')
-000161c0: 2c0a 2020 2020 2020 2020 2020 2020 284c  ,.            (L
-000161d0: 696e 6549 6e66 6f28 6c69 6e65 3d27 2020  ineInfo(line='  
-000161e0: 2020 6669 6775 7265 2066 6f75 7220 6973    figure four is
-000161f0: 2068 616c 6620 6f66 2065 6967 6874 272c   half of eight',
-00016200: 206c 696e 655f 6e75 6d62 6572 3d35 2c20   line_number=5, 
-00016210: 636f 6c75 6d6e 5f6e 756d 6265 723d 352c  column_number=5,
-00016220: 2069 6e64 656e 743d 312c 206c 6561 6469   indent=1, leadi
-00016230: 6e67 3d27 2020 2020 2729 2c0a 2020 2020  ng='    '),.    
-00016240: 2020 2020 2020 2020 2020 2020 2766 6967              'fig
-00016250: 7572 6520 666f 7572 2069 7320 6861 6c66  ure four is half
-00016260: 206f 6620 6569 6768 7427 292c 0a20 2020   of eight'),.   
-00016270: 2020 2020 2020 2020 2028 4c69 6e65 496e           (LineIn
-00016280: 666f 286c 696e 653d 2727 2c20 6c69 6e65  fo(line='', line
-00016290: 5f6e 756d 6265 723d 362c 2063 6f6c 756d  _number=6, colum
-000162a0: 6e5f 6e75 6d62 6572 3d31 2c20 696e 6465  n_number=1, inde
-000162b0: 6e74 3d30 2c20 6c65 6164 696e 673d 2727  nt=0, leading=''
-000162c0: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
-000162d0: 2020 2027 2729 5d0a 0a20 2020 2020 2020     '')]..       
-000162e0: 2074 6573 7428 6c69 6e65 732c 2065 7870   test(lines, exp
-000162f0: 6563 7465 642c 2074 6162 5f77 6964 7468  ected, tab_width
-00016300: 3d34 290a 0a20 2020 2020 2020 2023 230a  =4)..        ##.
-00016310: 2020 2020 2020 2020 2323 2074 6573 7420          ## test 
-00016320: 7261 6973 696e 6720 666f 7220 696c 6c65  raising for ille
-00016330: 6761 6c20 6f75 7464 656e 7473 0a20 2020  gal outdents.   
-00016340: 2020 2020 2023 230a 0a20 2020 2020 2020       ##..       
-00016350: 2023 2077 6865 6e20 6974 2773 2062 6574   # when it's bet
-00016360: 7765 656e 2074 776f 2065 7869 7374 696e  ween two existin
-00016370: 6720 696e 6465 6e74 730a 2020 2020 2020  g indents.      
-00016380: 2020 6c69 6e65 7320 3d20 280a 2020 2020    lines = (.    
-00016390: 2020 2020 2020 2020 226c 6566 7420 6d61          "left ma
-000163a0: 7267 696e 5c6e 220a 2020 2020 2020 2020  rgin\n".        
-000163b0: 2020 2020 225c 7466 6f75 725c 6e22 0a20      "\tfour\n". 
-000163c0: 2020 2020 2020 2020 2020 2022 2020 5c74             "  \t
-000163d0: 2020 2020 6569 6768 745c 6e22 0a20 2020      eight\n".   
-000163e0: 2020 2020 2020 2020 2022 2020 2020 2020           "      
-000163f0: 7369 783f 215c 6e22 0a20 2020 2020 2020  six?!\n".       
-00016400: 2020 2020 2022 6c65 6674 206d 6172 6769       "left margi
-00016410: 6e20 6167 6169 6e5c 6e22 0a20 2020 2020  n again\n".     
-00016420: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
-00016430: 2020 7769 7468 2073 656c 662e 6173 7365    with self.asse
-00016440: 7274 5261 6973 6573 2849 6e64 656e 7461  rtRaises(Indenta
-00016450: 7469 6f6e 4572 726f 7229 3a0a 2020 2020  tionError):.    
-00016460: 2020 2020 2020 2020 7465 7374 286c 696e          test(lin
-00016470: 6573 2c20 5b5d 2c20 7461 625f 7769 6474  es, [], tab_widt
-00016480: 683d 3429 0a0a 0a20 2020 2020 2020 2023  h=4)...        #
-00016490: 2077 6865 6e20 6974 2773 206c 6573 7320   when it's less 
-000164a0: 7468 616e 2074 6865 2066 6972 7374 2069  than the first i
-000164b0: 6e64 656e 740a 2020 2020 2020 2020 6c69  ndent.        li
-000164c0: 6e65 7320 3d20 280a 2020 2020 2020 2020  nes = (.        
-000164d0: 2020 2020 226c 6566 7420 6d61 7267 696e      "left margin
-000164e0: 5c6e 220a 2020 2020 2020 2020 2020 2020  \n".            
-000164f0: 225c 7466 6f75 725c 6e22 0a20 2020 2020  "\tfour\n".     
-00016500: 2020 2020 2020 2022 2020 5c74 2020 2020         "  \t    
-00016510: 6569 6768 745c 6e22 0a20 2020 2020 2020  eight\n".       
-00016520: 2020 2020 2022 2020 7477 6f3f 215c 6e22       "  two?!\n"
-00016530: 0a20 2020 2020 2020 2020 2020 2022 6c65  .            "le
-00016540: 6674 206d 6172 6769 6e20 6167 6169 6e5c  ft margin again\
-00016550: 6e22 0a20 2020 2020 2020 2020 2020 2029  n".            )
-00016560: 0a0a 2020 2020 2020 2020 7769 7468 2073  ..        with s
-00016570: 656c 662e 6173 7365 7274 5261 6973 6573  elf.assertRaises
-00016580: 2849 6e64 656e 7461 7469 6f6e 4572 726f  (IndentationErro
-00016590: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
-000165a0: 7465 7374 286c 696e 6573 2c20 5b5d 2c20  test(lines, [], 
-000165b0: 7461 625f 7769 6474 683d 3429 0a0a 2020  tab_width=4)..  
-000165c0: 2020 2020 2020 7769 7468 2073 656c 662e        with self.
-000165d0: 6173 7365 7274 5261 6973 6573 2856 616c  assertRaises(Val
-000165e0: 7565 4572 726f 7229 3a0a 2020 2020 2020  ueError):.      
-000165f0: 2020 2020 2020 7465 7374 2822 6669 7273        test("firs
-00016600: 7420 6c69 6e65 5c6e 2020 5c75 3330 3030  t line\n  \u3000
-00016610: 2020 7365 636f 6e64 206c 696e 655c 6e74    second line\nt
-00016620: 6869 7264 206c 696e 655c 6e22 2c20 5b5d  hird line\n", []
-00016630: 290a 0a20 2020 2064 6566 2074 6573 745f  )..    def test_
-00016640: 6c69 6e65 735f 6d69 7363 2873 656c 6629  lines_misc(self)
-00016650: 3a0a 2020 2020 2020 2020 2323 2072 6570  :.        ## rep
-00016660: 720a 2020 2020 2020 2020 6c69 203d 2062  r.        li = b
-00016670: 6967 2e4c 696e 6549 6e66 6f28 2727 2c20  ig.LineInfo('', 
-00016680: 312c 2031 2c20 696e 6465 6e74 3d30 290a  1, 1, indent=0).
-00016690: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
-000166a0: 6572 7445 7175 616c 2872 6570 7228 6c69  ertEqual(repr(li
-000166b0: 292c 2022 4c69 6e65 496e 666f 286c 696e  ), "LineInfo(lin
-000166c0: 653d 2727 2c20 6c69 6e65 5f6e 756d 6265  e='', line_numbe
-000166d0: 723d 312c 2063 6f6c 756d 6e5f 6e75 6d62  r=1, column_numb
-000166e0: 6572 3d31 2c20 696e 6465 6e74 3d30 2922  er=1, indent=0)"
-000166f0: 290a 0a20 2020 2020 2020 2023 2320 6572  )..        ## er
-00016700: 726f 7220 6861 6e64 6c69 6e67 0a20 2020  ror handling.   
-00016710: 2020 2020 2077 6974 6820 7365 6c66 2e61       with self.a
-00016720: 7373 6572 7452 6169 7365 7328 5479 7065  ssertRaises(Type
-00016730: 4572 726f 7229 3a0a 2020 2020 2020 2020  Error):.        
-00016740: 2020 2020 6269 672e 6c69 6e65 7328 2222      big.lines(""
-00016750: 2c20 6c69 6e65 5f6e 756d 6265 723d 6d61  , line_number=ma
-00016760: 7468 2e70 6929 0a20 2020 2020 2020 2077  th.pi).        w
-00016770: 6974 6820 7365 6c66 2e61 7373 6572 7452  ith self.assertR
-00016780: 6169 7365 7328 5479 7065 4572 726f 7229  aises(TypeError)
-00016790: 3a0a 2020 2020 2020 2020 2020 2020 6269  :.            bi
-000167a0: 672e 6c69 6e65 7328 2222 2c20 636f 6c75  g.lines("", colu
-000167b0: 6d6e 5f6e 756d 6265 723d 6d61 7468 2e70  mn_number=math.p
-000167c0: 6929 0a20 2020 2020 2020 2077 6974 6820  i).        with 
-000167d0: 7365 6c66 2e61 7373 6572 7452 6169 7365  self.assertRaise
-000167e0: 7328 5479 7065 4572 726f 7229 3a0a 2020  s(TypeError):.  
-000167f0: 2020 2020 2020 2020 2020 6269 672e 6c69            big.li
-00016800: 6e65 7328 2222 2c20 7461 625f 7769 6474  nes("", tab_widt
-00016810: 683d 6d61 7468 2e70 6929 0a0a 2020 2020  h=math.pi)..    
-00016820: 2020 2020 7769 7468 2073 656c 662e 6173      with self.as
-00016830: 7365 7274 5261 6973 6573 2854 7970 6545  sertRaises(TypeE
-00016840: 7272 6f72 293a 0a20 2020 2020 2020 2020  rror):.         
-00016850: 2020 2062 6967 2e4c 696e 6549 6e66 6f28     big.LineInfo(
-00016860: 6d61 7468 2e70 692c 2031 2c20 3129 0a20  math.pi, 1, 1). 
-00016870: 2020 2020 2020 2077 6974 6820 7365 6c66         with self
-00016880: 2e61 7373 6572 7452 6169 7365 7328 5479  .assertRaises(Ty
-00016890: 7065 4572 726f 7229 3a0a 2020 2020 2020  peError):.      
-000168a0: 2020 2020 2020 6269 672e 4c69 6e65 496e        big.LineIn
-000168b0: 666f 2827 272c 206d 6174 682e 7069 2c20  fo('', math.pi, 
-000168c0: 3129 0a20 2020 2020 2020 2077 6974 6820  1).        with 
-000168d0: 7365 6c66 2e61 7373 6572 7452 6169 7365  self.assertRaise
-000168e0: 7328 5479 7065 4572 726f 7229 3a0a 2020  s(TypeError):.  
-000168f0: 2020 2020 2020 2020 2020 6269 672e 4c69            big.Li
-00016900: 6e65 496e 666f 2827 272c 2031 2c20 6d61  neInfo('', 1, ma
-00016910: 7468 2e70 6929 0a0a 2020 2020 2020 2020  th.pi)..        
-00016920: 7769 7468 2073 656c 662e 6173 7365 7274  with self.assert
-00016930: 5261 6973 6573 2856 616c 7565 4572 726f  Raises(ValueErro
-00016940: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
-00016950: 6c69 7374 2862 6967 2e6c 696e 6573 5f66  list(big.lines_f
-00016960: 696c 7465 725f 636f 6d6d 656e 745f 6c69  ilter_comment_li
-00016970: 6e65 7328 2222 2c20 5b5d 2929 0a20 2020  nes("", [])).   
-00016980: 2020 2020 2077 6974 6820 7365 6c66 2e61       with self.a
-00016990: 7373 6572 7452 6169 7365 7328 5479 7065  ssertRaises(Type
-000169a0: 4572 726f 7229 3a0a 2020 2020 2020 2020  Error):.        
-000169b0: 2020 2020 6c69 7374 2862 6967 2e6c 696e      list(big.lin
-000169c0: 6573 5f66 696c 7465 725f 636f 6d6d 656e  es_filter_commen
-000169d0: 745f 6c69 6e65 7328 2222 2c20 6d61 7468  t_lines("", math
-000169e0: 2e70 6929 290a 0a20 2020 2020 2020 2023  .pi))..        #
-000169f0: 2320 7465 7374 206b 7761 7267 730a 2020  # test kwargs.  
-00016a00: 2020 2020 2020 6920 3d20 6269 672e 6c69        i = big.li
-00016a10: 6e65 7328 2727 2c20 7175 6172 6b3d 3232  nes('', quark=22
-00016a20: 290a 2020 2020 2020 2020 7365 6c66 2e61  ).        self.a
-00016a30: 7373 6572 7454 7275 6528 6861 7361 7474  ssertTrue(hasatt
-00016a40: 7228 692c 2027 7175 6172 6b27 2929 0a20  r(i, 'quark')). 
-00016a50: 2020 2020 2020 2073 656c 662e 6173 7365         self.asse
-00016a60: 7274 4571 7561 6c28 6765 7461 7474 7228  rtEqual(getattr(
-00016a70: 692c 2027 7175 6172 6b27 292c 2032 3229  i, 'quark'), 22)
-00016a80: 0a0a 2020 2020 2020 2020 696e 666f 203d  ..        info =
-00016a90: 2062 6967 2e4c 696e 6549 6e66 6f28 2727   big.LineInfo(''
-00016aa0: 2c20 312c 2031 2c20 7175 6172 6b3d 3335  , 1, 1, quark=35
-00016ab0: 290a 2020 2020 2020 2020 7365 6c66 2e61  ).        self.a
-00016ac0: 7373 6572 7454 7275 6528 6861 7361 7474  ssertTrue(hasatt
-00016ad0: 7228 696e 666f 2c20 2771 7561 726b 2729  r(info, 'quark')
-00016ae0: 290a 2020 2020 2020 2020 7365 6c66 2e61  ).        self.a
-00016af0: 7373 6572 7445 7175 616c 2867 6574 6174  ssertEqual(getat
-00016b00: 7472 2869 6e66 6f2c 2027 7175 6172 6b27  tr(info, 'quark'
-00016b10: 292c 2033 3529 0a0a 0a69 6d70 6f72 7420  ), 35)...import 
-00016b20: 6269 6774 6573 746c 6962 0a0a 6465 6620  bigtestlib..def 
-00016b30: 7275 6e5f 7465 7374 7328 293a 0a20 2020  run_tests():.   
-00016b40: 2062 6967 7465 7374 6c69 622e 7275 6e28   bigtestlib.run(
-00016b50: 6e61 6d65 3d22 6269 672e 7465 7874 222c  name="big.text",
-00016b60: 206d 6f64 756c 653d 5f5f 6e61 6d65 5f5f   module=__name__
-00016b70: 290a 0a69 6620 5f5f 6e61 6d65 5f5f 203d  )..if __name__ =
-00016b80: 3d20 225f 5f6d 6169 6e5f 5f22 3a20 2320  = "__main__": # 
-00016b90: 7072 6167 6d61 3a20 6e6f 2063 6f76 6572  pragma: no cover
-00016ba0: 0a20 2020 2072 756e 5f74 6573 7473 2829  .    run_tests()
-00016bb0: 0a20 2020 2062 6967 7465 7374 6c69 622e  .    bigtestlib.
-00016bc0: 6669 6e69 7368 2829 0a                   finish().
+00013f30: 2028 2277 6861 745c 6e68 6f5c 6e74 6f6f   ("what\nho\ntoo
+00013f40: 2d6c 6f6e 675c 6e63 6f6c 756d 6e5c 6e68  -long\ncolumn\nh
+00013f50: 6572 655c 6e6d 795c 6e6f 685c 6e6d 795c  ere\nmy\noh\nmy\
+00013f60: 6e77 6861 745c 6e74 7765 6564 795c 6e66  nwhat\ntweedy\nf
+00013f70: 756e 5c6e 222c 2032 2c20 3429 2c0a 2020  un\n", 2, 4),.  
+00013f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013f90: 2020 2822 6161 615c 6e62 6262 5c6e 6363    ("aaa\nbbb\ncc
+00013fa0: 635c 6e64 6464 5c6e 6565 655c 6e66 6666  c\nddd\neee\nfff
+00013fb0: 5c6e 6767 675c 6e68 6868 222c 2033 2c20  \nggg\nhhh", 3, 
+00013fc0: 3329 2c0a 2020 2020 2020 2020 2020 2020  3),.            
+00013fd0: 2020 2020 2020 2020 292c 0a20 2020 2020          ),.     
+00013fe0: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+00013ff0: 6578 7428 7265 7375 6c74 735f 6974 6572  ext(results_iter
+00014000: 6174 6f72 292c 0a20 2020 2020 2020 2020  ator),.         
+00014010: 2020 2020 2020 2020 2020 2063 6f6c 756d             colum
+00014020: 6e5f 7365 7061 7261 746f 723d 2220 7c20  n_separator=" | 
+00014030: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+00014040: 2020 2020 2020 206f 7665 7266 6c6f 775f         overflow_
+00014050: 6265 666f 7265 3d6f 7665 7266 6c6f 775f  before=overflow_
+00014060: 6265 666f 7265 2c0a 2020 2020 2020 2020  before,.        
+00014070: 2020 2020 2020 2020 2020 2020 6f76 6572              over
+00014080: 666c 6f77 5f61 6674 6572 3d6f 7665 7266  flow_after=overf
+00014090: 6c6f 775f 6166 7465 722c 0a20 2020 2020  low_after,.     
+000140a0: 2020 2020 2020 2020 2020 2020 2020 206f                 o
+000140b0: 7665 7266 6c6f 775f 7374 7261 7465 6779  verflow_strategy
+000140c0: 3d62 6967 2e4f 7665 7266 6c6f 7753 7472  =big.OverflowStr
+000140d0: 6174 6567 792e 494e 5452 5544 455f 414c  ategy.INTRUDE_AL
+000140e0: 4c29 0a0a 2020 2020 2020 2020 7465 7374  L)..        test
+000140f0: 2828 0a20 2020 2020 2020 2020 2020 2028  ((.            (
+00014100: 2231 5c6e 325c 6e33 5c6e 345c 6e35 5c6e  "1\n2\n3\n4\n5\n
+00014110: 365c 6e37 5c6e 3822 2c20 312c 2031 292c  6\n7\n8", 1, 1),
+00014120: 0a20 2020 2020 2020 2020 2020 2028 2261  .            ("a
+00014130: 6161 5c6e 6262 625c 6e63 6363 5c6e 6464  aa\nbbb\nccc\ndd
+00014140: 645c 6e65 6565 5c6e 6666 665c 6e67 6767  d\neee\nfff\nggg
+00014150: 5c6e 6868 6822 2c20 332c 2033 292c 0a20  \nhhh", 3, 3),. 
+00014160: 2020 2020 2020 2020 2020 2028 2277 6861             ("wha
+00014170: 745c 6e68 6f5c 6e74 6f6f 2d6c 6f6e 675c  t\nho\ntoo-long\
+00014180: 6e63 6f6c 756d 6e5c 6e68 6572 655c 6e6d  ncolumn\nhere\nm
+00014190: 795c 6e6f 685c 6e6d 795c 6e77 6861 745c  y\noh\nmy\nwhat\
+000141a0: 6e74 7765 6564 795c 6e66 756e 5c6e 222c  ntweedy\nfun\n",
+000141b0: 2032 2c20 3429 2c0a 2020 2020 2020 2020   2, 4),.        
+000141c0: 2020 2020 2822 6161 615c 6e62 6262 5c6e      ("aaa\nbbb\n
+000141d0: 6363 635c 6e64 6464 5c6e 6565 655c 6e66  ccc\nddd\neee\nf
+000141e0: 6666 5c6e 6767 675c 6e68 6868 222c 2033  ff\nggg\nhhh", 3
+000141f0: 2c20 3329 2c0a 2020 2020 2020 2020 2020  , 3),.          
+00014200: 2020 292c 0a20 2020 2020 2020 2020 2020    ),.           
+00014210: 2027 3120 7c20 6161 6120 7c20 7768 6174   '1 | aaa | what
+00014220: 5c6e 3220 7c20 6262 6220 7c20 686f 5c6e  \n2 | bbb | ho\n
+00014230: 3320 7c20 6363 6320 7c20 746f 6f2d 6c6f  3 | ccc | too-lo
+00014240: 6e67 5c6e 3420 7c20 6464 6420 7c20 636f  ng\n4 | ddd | co
+00014250: 6c75 6d6e 5c6e 3520 7c20 6565 6520 7c20  lumn\n5 | eee | 
+00014260: 6865 7265 5c6e 3620 7c20 6666 6620 7c20  here\n6 | fff | 
+00014270: 6d79 5c6e 3720 7c20 6767 6720 7c20 6f68  my\n7 | ggg | oh
+00014280: 5c6e 3820 7c20 6868 6820 7c20 6d79 5c6e  \n8 | hhh | my\n
+00014290: 2020 7c20 2020 2020 7c20 7768 6174 5c6e    |     | what\n
+000142a0: 2020 7c20 2020 2020 7c20 7477 6565 6479    |     | tweedy
+000142b0: 5c6e 2020 7c20 2020 2020 7c20 6675 6e5c  \n  |     | fun\
+000142c0: 6e20 207c 2020 2020 207c 2020 2020 2020  n  |     |      
+000142d0: 7c20 6161 615c 6e20 207c 2020 2020 207c  | aaa\n  |     |
+000142e0: 2020 2020 2020 7c20 6262 625c 6e20 207c        | bbb\n  |
+000142f0: 2020 2020 207c 2020 2020 2020 7c20 6363       |      | cc
+00014300: 635c 6e20 207c 2020 2020 207c 2020 2020  c\n  |     |    
+00014310: 2020 7c20 6464 645c 6e20 207c 2020 2020    | ddd\n  |    
+00014320: 207c 2020 2020 2020 7c20 6565 655c 6e20   |      | eee\n 
+00014330: 207c 2020 2020 207c 2020 2020 2020 7c20   |     |      | 
+00014340: 6666 665c 6e20 207c 2020 2020 207c 2020  fff\n  |     |  
+00014350: 2020 2020 7c20 6767 675c 6e20 207c 2020      | ggg\n  |  
+00014360: 2020 207c 2020 2020 2020 7c20 6868 6827     |      | hhh'
+00014370: 2c0a 2020 2020 2020 2020 2020 2020 636f  ,.            co
+00014380: 6c75 6d6e 5f73 6570 6172 6174 6f72 3d22  lumn_separator="
+00014390: 207c 2022 2c0a 2020 2020 2020 2020 2020   | ",.          
+000143a0: 2020 6f76 6572 666c 6f77 5f73 7472 6174    overflow_strat
+000143b0: 6567 793d 6269 672e 4f76 6572 666c 6f77  egy=big.Overflow
+000143c0: 5374 7261 7465 6779 2e44 454c 4159 5f41  Strategy.DELAY_A
+000143d0: 4c4c 2c0a 2020 2020 2020 2020 2020 2020  LL,.            
+000143e0: 6f76 6572 666c 6f77 5f62 6566 6f72 653d  overflow_before=
+000143f0: 302c 0a20 2020 2020 2020 2020 2020 206f  0,.            o
+00014400: 7665 7266 6c6f 775f 6166 7465 723d 312c  verflow_after=1,
+00014410: 0a20 2020 2020 2020 2020 2020 2029 0a0a  .            )..
+00014420: 0a0a 2020 2020 6465 6620 7465 7374 5f74  ..    def test_t
+00014430: 6578 745f 7069 7065 6c69 6e65 2873 656c  ext_pipeline(sel
+00014440: 6629 3a0a 2020 2020 2020 2020 6465 6620  f):.        def 
+00014450: 7465 7374 2863 6f6c 756d 6e73 2c20 6578  test(columns, ex
+00014460: 7065 6374 6564 293a 0a20 2020 2020 2020  pected):.       
+00014470: 2020 2020 2066 6f72 2069 2069 6e20 7261       for i in ra
+00014480: 6e67 6528 3229 3a0a 2020 2020 2020 2020  nge(2):.        
+00014490: 2020 2020 2020 2020 7370 6c69 7473 203d          splits =
+000144a0: 205b 2862 6967 2e73 706c 6974 5f74 6578   [(big.split_tex
+000144b0: 745f 7769 7468 5f63 6f64 6528 636f 6c75  t_with_code(colu
+000144c0: 6d6e 292c 206d 696e 2c20 6d61 7829 2066  mn), min, max) f
+000144d0: 6f72 2063 6f6c 756d 6e2c 206d 696e 2c20  or column, min, 
+000144e0: 6d61 7820 696e 2063 6f6c 756d 6e73 5d0a  max in columns].
+000144f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014500: 7772 6170 7065 6420 3d20 5b28 6269 672e  wrapped = [(big.
+00014510: 7772 6170 5f77 6f72 6473 2873 706c 6974  wrap_words(split
+00014520: 2c20 6d61 7267 696e 3d6d 6178 292c 206d  , margin=max), m
+00014530: 696e 2c20 6d61 7829 2066 6f72 2073 706c  in, max) for spl
+00014540: 6974 2c20 6d69 6e2c 206d 6178 2069 6e20  it, min, max in 
+00014550: 7370 6c69 7473 5d0a 2020 2020 2020 2020  splits].        
+00014560: 2020 2020 2020 2020 676f 7420 3d20 6269          got = bi
+00014570: 672e 6d65 7267 655f 636f 6c75 6d6e 7328  g.merge_columns(
+00014580: 2a77 7261 7070 6564 2c20 6f76 6572 666c  *wrapped, overfl
+00014590: 6f77 5f73 7472 6174 6567 793d 6269 672e  ow_strategy=big.
+000145a0: 4f76 6572 666c 6f77 5374 7261 7465 6779  OverflowStrategy
+000145b0: 2e49 4e54 5255 4445 5f41 4c4c 290a 2020  .INTRUDE_ALL).  
+000145c0: 2020 2020 2020 2020 2020 2020 2020 6966                if
+000145d0: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
+000145e0: 2020 2020 2020 2020 7072 696e 7428 225f          print("_
+000145f0: 222a 3730 290a 2020 2020 2020 2020 2020  "*70).          
+00014600: 2020 2020 2020 2020 2020 7072 696e 7428            print(
+00014610: 2263 6f6c 756d 6e73 2229 0a20 2020 2020  "columns").     
+00014620: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+00014630: 7269 6e74 2872 6570 7228 636f 6c75 6d6e  rint(repr(column
+00014640: 7329 290a 2020 2020 2020 2020 2020 2020  s)).            
+00014650: 2020 2020 2020 2020 7072 696e 7428 2265          print("e
+00014660: 7870 6563 7465 643a 2229 0a20 2020 2020  xpected:").     
+00014670: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+00014680: 7269 6e74 2829 0a20 2020 2020 2020 2020  rint().         
+00014690: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+000146a0: 2865 7870 6563 7465 6429 0a20 2020 2020  (expected).     
+000146b0: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+000146c0: 7269 6e74 2829 0a20 2020 2020 2020 2020  rint().         
+000146d0: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+000146e0: 2822 676f 743a 2229 0a20 2020 2020 2020  ("got:").       
+000146f0: 2020 2020 2020 2020 2020 2020 2070 7269               pri
+00014700: 6e74 2829 0a20 2020 2020 2020 2020 2020  nt().           
+00014710: 2020 2020 2020 2020 2070 7269 6e74 2867           print(g
+00014720: 6f74 290a 2020 2020 2020 2020 2020 2020  ot).            
+00014730: 2020 2020 2020 2020 7072 696e 7428 290a          print().
+00014740: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014750: 2020 2020 7072 696e 7428 290a 2020 2020      print().    
+00014760: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00014770: 2e61 7373 6572 7445 7175 616c 2867 6f74  .assertEqual(got
+00014780: 2c20 6578 7065 6374 6564 290a 2020 2020  , expected).    
+00014790: 2020 2020 2020 2020 2020 2020 6966 2069              if i
+000147a0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000147b0: 2020 2020 2020 6272 6561 6b0a 2020 2020        break.    
+000147c0: 2020 2020 2020 2020 2020 2020 636f 6c75              colu
+000147d0: 6d6e 7320 3d20 5b28 746f 5f62 7974 6573  mns = [(to_bytes
+000147e0: 2874 5b30 5d29 2c20 745b 315d 2c20 745b  (t[0]), t[1], t[
+000147f0: 325d 2920 666f 7220 7420 696e 2063 6f6c  2]) for t in col
+00014800: 756d 6e73 5d0a 2020 2020 2020 2020 2020  umns].          
+00014810: 2020 2020 2020 6578 7065 6374 6564 203d        expected =
+00014820: 2074 6f5f 6279 7465 7328 6578 7065 6374   to_bytes(expect
+00014830: 6564 290a 0a0a 2020 2020 2020 2020 7465  ed)...        te
+00014840: 7374 280a 2020 2020 2020 2020 2020 2020  st(.            
+00014850: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00014860: 2020 280a 2020 2020 2020 2020 2020 2020    (.            
+00014870: 2020 2020 222d 767c 2d2d 7665 7262 6f73      "-v|--verbos
+00014880: 6522 2c0a 2020 2020 2020 2020 2020 2020  e",.            
+00014890: 2020 2020 3139 2c0a 2020 2020 2020 2020      19,.        
+000148a0: 2020 2020 2020 2020 3139 2c0a 2020 2020          19,.    
+000148b0: 2020 2020 2020 2020 2020 2020 292c 0a20              ),. 
+000148c0: 2020 2020 2020 2020 2020 2020 2020 2028                 (
+000148d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000148e0: 2022 4361 7573 6573 2074 6865 2070 726f   "Causes the pro
+000148f0: 6772 616d 2074 6f20 7072 6f64 7563 6520  gram to produce 
+00014900: 6d6f 7265 206f 7574 7075 742e 2020 5370  more output.  Sp
+00014910: 6563 6966 7969 6e67 2069 7420 6d75 6c74  ecifying it mult
+00014920: 6970 6c65 2074 696d 6573 2072 6169 7365  iple times raise
+00014930: 7320 7468 6520 766f 6c75 6d65 206f 6620  s the volume of 
+00014940: 6f75 7470 7574 2e22 2c0a 2020 2020 2020  output.",.      
+00014950: 2020 2020 2020 2020 2020 302c 0a20 2020            0,.   
+00014960: 2020 2020 2020 2020 2020 2020 2036 302c               60,
+00014970: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014980: 2029 2c0a 2020 2020 2020 2020 2020 2020   ),.            
+00014990: 292c 0a20 2020 2020 2020 2020 2020 2027  ),.            '
+000149a0: 2d76 7c2d 2d76 6572 626f 7365 2020 2020  -v|--verbose    
+000149b0: 2020 2020 4361 7573 6573 2074 6865 2070      Causes the p
+000149c0: 726f 6772 616d 2074 6f20 7072 6f64 7563  rogram to produc
+000149d0: 6520 6d6f 7265 206f 7574 7075 742e 2020  e more output.  
+000149e0: 5370 6563 6966 7969 6e67 2069 745c 6e20  Specifying it\n 
+000149f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014a00: 2020 206d 756c 7469 706c 6520 7469 6d65     multiple time
+00014a10: 7320 7261 6973 6573 2074 6865 2076 6f6c  s raises the vol
+00014a20: 756d 6520 6f66 206f 7574 7075 742e 270a  ume of output.'.
+00014a30: 2020 2020 2020 2020 290a 0a20 2020 2020          )..     
+00014a40: 2020 2074 6573 7428 0a20 2020 2020 2020     test(.       
+00014a50: 2020 2020 2028 0a20 2020 2020 2020 2020       (.         
+00014a60: 2020 2020 2020 2028 0a20 2020 2020 2020         (.       
+00014a70: 2020 2020 2020 2020 2022 2d76 7c2d 2d76           "-v|--v
+00014a80: 6572 626f 7365 222c 0a20 2020 2020 2020  erbose",.       
+00014a90: 2020 2020 2020 2020 2039 2c0a 2020 2020           9,.    
+00014aa0: 2020 2020 2020 2020 2020 2020 392c 0a20              9,. 
+00014ab0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+00014ac0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00014ad0: 2020 280a 2020 2020 2020 2020 2020 2020    (.            
+00014ae0: 2020 2020 2243 6175 7365 7320 7468 6520      "Causes the 
+00014af0: 7072 6f67 7261 6d20 746f 2070 726f 6475  program to produ
+00014b00: 6365 206d 6f72 6520 6f75 7470 7574 2e20  ce more output. 
+00014b10: 2053 7065 6369 6679 696e 6720 6974 206d   Specifying it m
+00014b20: 756c 7469 706c 6520 7469 6d65 7320 7261  ultiple times ra
+00014b30: 6973 6573 2074 6865 2076 6f6c 756d 6520  ises the volume 
+00014b40: 6f66 206f 7574 7075 742e 222c 0a20 2020  of output.",.   
+00014b50: 2020 2020 2020 2020 2020 2020 2030 2c0a               0,.
+00014b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014b70: 3630 2c0a 2020 2020 2020 2020 2020 2020  60,.            
+00014b80: 2020 2020 292c 0a20 2020 2020 2020 2020      ),.         
+00014b90: 2020 2029 2c0a 2020 2020 2020 2020 2020     ),.          
+00014ba0: 2020 272d 767c 2d2d 7665 7262 6f73 655c    '-v|--verbose\
+00014bb0: 6e20 2020 2020 2020 2020 2043 6175 7365  n          Cause
+00014bc0: 7320 7468 6520 7072 6f67 7261 6d20 746f  s the program to
+00014bd0: 2070 726f 6475 6365 206d 6f72 6520 6f75   produce more ou
+00014be0: 7470 7574 2e20 2053 7065 6369 6679 696e  tput.  Specifyin
+00014bf0: 6720 6974 5c6e 2020 2020 2020 2020 2020  g it\n          
+00014c00: 6d75 6c74 6970 6c65 2074 696d 6573 2072  multiple times r
+00014c10: 6169 7365 7320 7468 6520 766f 6c75 6d65  aises the volume
+00014c20: 206f 6620 6f75 7470 7574 2e27 0a20 2020   of output.'.   
+00014c30: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
+00014c40: 2320 616e 2065 6d70 7479 2063 6f6c 756d  # an empty colum
+00014c50: 6e20 6a75 7374 2061 6464 7320 7370 6163  n just adds spac
+00014c60: 652e 2020 736f 2c20 746f 2069 6e64 656e  e.  so, to inden
+00014c70: 7420 6576 6572 7974 6869 6e67 2c20 6164  t everything, ad
+00014c80: 6420 616e 2065 6d70 7479 2069 6e69 7469  d an empty initi
+00014c90: 616c 2063 6f6c 756d 6e2e 0a20 2020 2020  al column..     
+00014ca0: 2020 2023 206e 6f74 6520 7468 6174 2069     # note that i
+00014cb0: 7427 6c6c 2062 6520 6d69 6e5f 7769 6474  t'll be min_widt
+00014cc0: 6820 7769 6465 2061 6e64 202a 7468 656e  h wide and *then
+00014cd0: 2a20 796f 7527 6c6c 2067 6574 2074 6865  * you'll get the
+00014ce0: 2063 6f6c 756d 6e5f 7365 7061 7261 746f   column_separato
+00014cf0: 722e 0a20 2020 2020 2020 2074 6573 7428  r..        test(
+00014d00: 0a20 2020 2020 2020 2020 2020 2028 0a20  .            (. 
+00014d10: 2020 2020 2020 2020 2020 2020 2020 2028                 (
+00014d20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014d30: 2022 222c 0a20 2020 2020 2020 2020 2020   "",.           
+00014d40: 2020 2020 2033 2c0a 2020 2020 2020 2020       3,.        
+00014d50: 2020 2020 2020 2020 332c 0a20 2020 2020          3,.     
+00014d60: 2020 2020 2020 2020 2020 2029 2c0a 2020             ),.  
+00014d70: 2020 2020 2020 2020 2020 2020 2020 280a                (.
+00014d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014d90: 222d 767c 2d2d 7665 7262 6f73 6522 2c0a  "-v|--verbose",.
+00014da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014db0: 3139 2c0a 2020 2020 2020 2020 2020 2020  19,.            
+00014dc0: 2020 2020 3139 2c0a 2020 2020 2020 2020      19,.        
+00014dd0: 2020 2020 2020 2020 292c 0a20 2020 2020          ),.     
+00014de0: 2020 2020 2020 2020 2020 2028 0a20 2020             (.   
+00014df0: 2020 2020 2020 2020 2020 2020 2022 4361               "Ca
+00014e00: 7573 6573 2074 6865 2070 726f 6772 616d  uses the program
+00014e10: 2074 6f20 7072 6f64 7563 6520 6d6f 7265   to produce more
+00014e20: 206f 7574 7075 742e 2020 5370 6563 6966   output.  Specif
+00014e30: 7969 6e67 2069 7420 6d75 6c74 6970 6c65  ying it multiple
+00014e40: 2074 696d 6573 2072 6169 7365 7320 7468   times raises th
+00014e50: 6520 766f 6c75 6d65 206f 6620 6f75 7470  e volume of outp
+00014e60: 7574 2e22 2c0a 2020 2020 2020 2020 2020  ut.",.          
+00014e70: 2020 2020 2020 302c 0a20 2020 2020 2020        0,.       
+00014e80: 2020 2020 2020 2020 2036 302c 0a20 2020           60,.   
+00014e90: 2020 2020 2020 2020 2020 2020 2029 2c0a               ),.
+00014ea0: 2020 2020 2020 2020 2020 2020 292c 0a20              ),. 
+00014eb0: 2020 2020 2020 2020 2020 2027 2020 2020             '    
+00014ec0: 2d76 7c2d 2d76 6572 626f 7365 2020 2020  -v|--verbose    
+00014ed0: 2020 2020 4361 7573 6573 2074 6865 2070      Causes the p
+00014ee0: 726f 6772 616d 2074 6f20 7072 6f64 7563  rogram to produc
+00014ef0: 6520 6d6f 7265 206f 7574 7075 742e 2020  e more output.  
+00014f00: 5370 6563 6966 7969 6e67 2069 745c 6e20  Specifying it\n 
+00014f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014f20: 2020 2020 2020 206d 756c 7469 706c 6520         multiple 
+00014f30: 7469 6d65 7320 7261 6973 6573 2074 6865  times raises the
+00014f40: 2076 6f6c 756d 6520 6f66 206f 7574 7075   volume of outpu
+00014f50: 742e 270a 2020 2020 2020 2020 290a 0a20  t.'.        ).. 
+00014f60: 2020 2064 6566 2074 6573 745f 6765 6e74     def test_gent
+00014f70: 6c79 5f74 6974 6c65 2873 656c 6629 3a0a  ly_title(self):.
+00014f80: 2020 2020 2020 2020 6465 6620 7465 7374          def test
+00014f90: 2873 2c20 6578 7065 6374 6564 2c20 7465  (s, expected, te
+00014fa0: 7374 5f61 7363 6969 3d54 7275 652c 2061  st_ascii=True, a
+00014fb0: 706f 7374 726f 7068 6573 3d4e 6f6e 652c  postrophes=None,
+00014fc0: 2064 6f75 626c 655f 7175 6f74 6573 3d4e   double_quotes=N
+00014fd0: 6f6e 6529 3a0a 2020 2020 2020 2020 2020  one):.          
+00014fe0: 2020 7265 7375 6c74 203d 2062 6967 2e67    result = big.g
+00014ff0: 656e 746c 795f 7469 746c 6528 732c 2061  ently_title(s, a
+00015000: 706f 7374 726f 7068 6573 3d61 706f 7374  postrophes=apost
+00015010: 726f 7068 6573 2c20 646f 7562 6c65 5f71  rophes, double_q
+00015020: 756f 7465 733d 646f 7562 6c65 5f71 756f  uotes=double_quo
+00015030: 7465 7329 0a20 2020 2020 2020 2020 2020  tes).           
+00015040: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
+00015050: 6c28 7265 7375 6c74 2c20 6578 7065 6374  l(result, expect
+00015060: 6564 290a 2020 2020 2020 2020 2020 2020  ed).            
+00015070: 7265 7375 6c74 203d 2062 6967 2e67 656e  result = big.gen
+00015080: 746c 795f 7469 746c 6528 5374 7253 7562  tly_title(StrSub
+00015090: 636c 6173 7328 7329 2c20 6170 6f73 7472  class(s), apostr
+000150a0: 6f70 6865 733d 6170 6f73 7472 6f70 6865  ophes=apostrophe
+000150b0: 732c 2064 6f75 626c 655f 7175 6f74 6573  s, double_quotes
+000150c0: 3d64 6f75 626c 655f 7175 6f74 6573 290a  =double_quotes).
+000150d0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+000150e0: 2e61 7373 6572 7445 7175 616c 2872 6573  .assertEqual(res
+000150f0: 756c 742c 2065 7870 6563 7465 6429 0a20  ult, expected). 
+00015100: 2020 2020 2020 2020 2020 2069 6620 7465             if te
+00015110: 7374 5f61 7363 6969 3a0a 2020 2020 2020  st_ascii:.      
+00015120: 2020 2020 2020 2020 2020 6966 2061 706f            if apo
+00015130: 7374 726f 7068 6573 3a0a 2020 2020 2020  strophes:.      
+00015140: 2020 2020 2020 2020 2020 2020 2020 6170                ap
+00015150: 6f73 7472 6f70 6865 7320 3d20 6170 6f73  ostrophes = apos
+00015160: 7472 6f70 6865 732e 656e 636f 6465 2827  trophes.encode('
+00015170: 6173 6369 6927 290a 2020 2020 2020 2020  ascii').        
+00015180: 2020 2020 2020 2020 6966 2064 6f75 626c          if doubl
+00015190: 655f 7175 6f74 6573 3a0a 2020 2020 2020  e_quotes:.      
+000151a0: 2020 2020 2020 2020 2020 2020 2020 646f                do
+000151b0: 7562 6c65 5f71 756f 7465 7320 3d20 646f  uble_quotes = do
+000151c0: 7562 6c65 5f71 756f 7465 732e 656e 636f  uble_quotes.enco
+000151d0: 6465 2827 6173 6369 6927 290a 2020 2020  de('ascii').    
+000151e0: 2020 2020 2020 2020 2020 2020 7265 7375              resu
+000151f0: 6c74 203d 2062 6967 2e67 656e 746c 795f  lt = big.gently_
+00015200: 7469 746c 6528 732e 656e 636f 6465 2827  title(s.encode('
+00015210: 6173 6369 6927 292c 2061 706f 7374 726f  ascii'), apostro
+00015220: 7068 6573 3d61 706f 7374 726f 7068 6573  phes=apostrophes
+00015230: 2c20 646f 7562 6c65 5f71 756f 7465 733d  , double_quotes=
+00015240: 646f 7562 6c65 5f71 756f 7465 7329 0a20  double_quotes). 
+00015250: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00015260: 656c 662e 6173 7365 7274 4571 7561 6c28  elf.assertEqual(
+00015270: 7265 7375 6c74 2c20 6578 7065 6374 6564  result, expected
+00015280: 2e65 6e63 6f64 6528 2761 7363 6969 2729  .encode('ascii')
+00015290: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+000152a0: 2020 7265 7375 6c74 203d 2062 6967 2e67    result = big.g
+000152b0: 656e 746c 795f 7469 746c 6528 4279 7465  ently_title(Byte
+000152c0: 7353 7562 636c 6173 7328 732e 656e 636f  sSubclass(s.enco
+000152d0: 6465 2827 6173 6369 6927 2929 2c20 6170  de('ascii')), ap
+000152e0: 6f73 7472 6f70 6865 733d 6170 6f73 7472  ostrophes=apostr
+000152f0: 6f70 6865 732c 2064 6f75 626c 655f 7175  ophes, double_qu
+00015300: 6f74 6573 3d64 6f75 626c 655f 7175 6f74  otes=double_quot
+00015310: 6573 290a 2020 2020 2020 2020 2020 2020  es).            
+00015320: 2020 2020 7365 6c66 2e61 7373 6572 7445      self.assertE
+00015330: 7175 616c 2872 6573 756c 742c 2065 7870  qual(result, exp
+00015340: 6563 7465 642e 656e 636f 6465 2827 6173  ected.encode('as
+00015350: 6369 6927 2929 0a0a 2020 2020 2020 2020  cii'))..        
+00015360: 7465 7374 2822 222c 2022 2229 0a20 2020  test("", "").   
+00015370: 2020 2020 2074 6573 7428 2261 6263 6465       test("abcde
+00015380: 2066 6768 222c 2022 4162 6364 6520 4667   fgh", "Abcde Fg
+00015390: 6822 290a 2020 2020 2020 2020 7465 7374  h").        test
+000153a0: 2822 7065 7465 7220 6f27 746f 6f6c 6522  ("peter o'toole"
+000153b0: 2c20 2250 6574 6572 204f 2754 6f6f 6c65  , "Peter O'Toole
+000153c0: 2229 0a20 2020 2020 2020 2074 6573 7428  ").        test(
+000153d0: 226c 6f72 6420 6427 6172 6379 222c 2022  "lord d'arcy", "
+000153e0: 4c6f 7264 2044 2741 7263 7922 290a 2020  Lord D'Arcy").  
+000153f0: 2020 2020 2020 7465 7374 2822 6d75 6c74        test("mult
+00015400: 6970 6c65 2020 2073 7061 6365 7322 2c20  iple   spaces", 
+00015410: 224d 756c 7469 706c 6520 2020 5370 6163  "Multiple   Spac
+00015420: 6573 2229 0a20 2020 2020 2020 2074 6573  es").        tes
+00015430: 7428 2227 7477 6173 2074 6865 206e 6967  t("'twas the nig
+00015440: 6874 2062 6566 6f72 6520 6368 7269 7374  ht before christ
+00015450: 6d61 7322 2c20 2227 5477 6173 2054 6865  mas", "'Twas The
+00015460: 204e 6967 6874 2042 6566 6f72 6520 4368   Night Before Ch
+00015470: 7269 7374 6d61 7322 290a 2020 2020 2020  ristmas").      
+00015480: 2020 7465 7374 2822 646f 6e27 7420 736c    test("don't sl
+00015490: 6565 7020 6f6e 2074 6865 2073 7562 7761  eep on the subwa
+000154a0: 7922 2c20 2244 6f6e 2774 2053 6c65 6570  y", "Don't Sleep
+000154b0: 204f 6e20 5468 6520 5375 6277 6179 2229   On The Subway")
+000154c0: 0a20 2020 2020 2020 2074 6573 7428 2265  .        test("e
+000154d0: 7665 7279 626f 6479 2773 2074 6869 6e6b  verybody's think
+000154e0: 696e 6720 7468 6579 2063 6f75 6c64 6e27  ing they couldn'
+000154f0: 7427 7665 2068 6164 2061 2076 2d38 222c  t've had a v-8",
+00015500: 2022 4576 6572 7962 6f64 7927 7320 5468   "Everybody's Th
+00015510: 696e 6b69 6e67 2054 6865 7920 436f 756c  inking They Coul
+00015520: 646e 2774 2776 6520 4861 6420 4120 562d  dn't've Had A V-
+00015530: 3822 290a 2020 2020 2020 2020 7465 7374  8").        test
+00015540: 2822 646f 6e27 7420 636f 6d65 2068 6f6d  ("don't come hom
+00015550: 6520 6966 2079 6f75 2064 6f6e 2774 2067  e if you don't g
+00015560: 6574 2031 7374 222c 2022 446f 6e27 7420  et 1st", "Don't 
+00015570: 436f 6d65 2048 6f6d 6520 4966 2059 6f75  Come Home If You
+00015580: 2044 6f6e 2774 2047 6574 2031 7374 2229   Don't Get 1st")
+00015590: 0a20 2020 2020 2020 2074 6573 7428 2222  .        test(""
+000155a0: 2269 2073 6169 6420 226e 6f2c 2069 2064  "i said "no, i d
+000155b0: 6964 6e27 7422 2c20 796f 7520 6964 696f  idn't", you idio
+000155c0: 7422 2222 2c20 2222 2249 2053 6169 6420  t""", """I Said 
+000155d0: 224e 6f2c 2049 2044 6964 6e27 7422 2c20  "No, I Didn't", 
+000155e0: 596f 7520 4964 696f 7422 2222 290a 2020  You Idiot""").  
+000155f0: 2020 2020 2020 7465 7374 2827 6d75 6c74        test('mult
+00015600: 6970 6c65 20c2 ab22 e280 9c71 756f 7465  iple .."...quote
+00015610: 206d 6172 6b73 e280 9d22 c2bb 272c 2027   marks..."..', '
+00015620: 4d75 6c74 6970 6c65 20c2 ab22 e280 9c51  Multiple .."...Q
+00015630: 756f 7465 204d 6172 6b73 e280 9d22 c2bb  uote Marks..."..
+00015640: 272c 2074 6573 745f 6173 6369 693d 4661  ', test_ascii=Fa
+00015650: 6c73 6529 0a20 2020 2020 2020 2074 6573  lse).        tes
+00015660: 7428 276d 7920 6865 6164 2069 7320 6d79  t('my head is my
+00015670: 206f 6e6c 7920 686f 7573 6520 2877 6865   only house (whe
+00015680: 6e20 6974 2072 6169 6e73 2927 2c20 274d  n it rains)', 'M
+00015690: 7920 4865 6164 2049 7320 4d79 204f 6e6c  y Head Is My Onl
+000156a0: 7920 486f 7573 6520 2857 6865 6e20 4974  y House (When It
+000156b0: 2052 6169 6e73 2927 290a 0a20 2020 2020   Rains)')..     
+000156c0: 2020 2074 6573 7428 2222 2269 2073 6169     test("""i sai
+000156d0: 6420 5a64 6f6e 5874 2074 6f75 6368 2074  d ZdonXt touch t
+000156e0: 6861 742c 206f 5863 6f6e 6e65 6c6c 215a  hat, oXconnell!Z
+000156f0: 2c20 796f 7520 326e 6420 7261 7465 2069  , you 2nd rate i
+00015700: 6469 6f74 2122 2222 2c20 2222 2249 2053  diot!""", """I S
+00015710: 6169 6420 5a44 6f6e 5874 2054 6f75 6368  aid ZDonXt Touch
+00015720: 2054 6861 742c 204f 5843 6f6e 6e65 6c6c   That, OXConnell
+00015730: 215a 2c20 596f 7520 326e 6420 5261 7465  !Z, You 2nd Rate
+00015740: 2049 6469 6f74 2122 2222 2c20 6170 6f73   Idiot!""", apos
+00015750: 7472 6f70 6865 733d 2758 272c 2064 6f75  trophes='X', dou
+00015760: 626c 655f 7175 6f74 6573 3d27 5a27 290a  ble_quotes='Z').
+00015770: 0a20 2020 2020 2020 2077 6974 6820 7365  .        with se
+00015780: 6c66 2e61 7373 6572 7452 6169 7365 7328  lf.assertRaises(
+00015790: 5479 7065 4572 726f 7229 3a0a 2020 2020  TypeError):.    
+000157a0: 2020 2020 2020 2020 6269 672e 6765 6e74          big.gent
+000157b0: 6c79 5f74 6974 6c65 2822 7468 6520 5c22  ly_title("the \"
+000157c0: 7374 7269 6e67 2773 5c22 2074 6865 2074  string's\" the t
+000157d0: 6869 6e67 222c 2061 706f 7374 726f 7068  hing", apostroph
+000157e0: 6573 3d62 6967 2e61 7363 6969 5f61 706f  es=big.ascii_apo
+000157f0: 7374 726f 7068 6573 290a 2020 2020 2020  strophes).      
+00015800: 2020 7769 7468 2073 656c 662e 6173 7365    with self.asse
+00015810: 7274 5261 6973 6573 2854 7970 6545 7272  rtRaises(TypeErr
+00015820: 6f72 293a 0a20 2020 2020 2020 2020 2020  or):.           
+00015830: 2062 6967 2e67 656e 746c 795f 7469 746c   big.gently_titl
+00015840: 6528 2274 6865 205c 2273 7472 696e 6727  e("the \"string'
+00015850: 735c 2220 7468 6520 7468 696e 6722 2c20  s\" the thing", 
+00015860: 646f 7562 6c65 5f71 756f 7465 733d 6269  double_quotes=bi
+00015870: 672e 6173 6369 695f 646f 7562 6c65 5f71  g.ascii_double_q
+00015880: 756f 7465 7329 0a20 2020 2020 2020 2077  uotes).        w
+00015890: 6974 6820 7365 6c66 2e61 7373 6572 7452  ith self.assertR
+000158a0: 6169 7365 7328 5479 7065 4572 726f 7229  aises(TypeError)
+000158b0: 3a0a 2020 2020 2020 2020 2020 2020 6269  :.            bi
+000158c0: 672e 6765 6e74 6c79 5f74 6974 6c65 2822  g.gently_title("
+000158d0: 7468 6520 5c22 7374 7269 6e67 2773 5c22  the \"string's\"
+000158e0: 2074 6865 2074 6869 6e67 222c 2061 706f   the thing", apo
+000158f0: 7374 726f 7068 6573 3d62 6967 2e61 7363  strophes=big.asc
+00015900: 6969 5f61 706f 7374 726f 7068 6573 2c20  ii_apostrophes, 
+00015910: 646f 7562 6c65 5f71 756f 7465 733d 6269  double_quotes=bi
+00015920: 672e 6173 6369 695f 646f 7562 6c65 5f71  g.ascii_double_q
+00015930: 756f 7465 7329 0a0a 2020 2020 2020 2020  uotes)..        
+00015940: 7769 7468 2073 656c 662e 6173 7365 7274  with self.assert
+00015950: 5261 6973 6573 2854 7970 6545 7272 6f72  Raises(TypeError
+00015960: 293a 0a20 2020 2020 2020 2020 2020 2062  ):.            b
+00015970: 6967 2e67 656e 746c 795f 7469 746c 6528  ig.gently_title(
+00015980: 2274 6865 205c 2273 7472 696e 6727 735c  "the \"string's\
+00015990: 2220 7468 6520 7468 696e 6722 2c20 6170  " the thing", ap
+000159a0: 6f73 7472 6f70 6865 733d 2862 2227 222c  ostrophes=(b"'",
+000159b0: 2929 0a20 2020 2020 2020 2077 6974 6820  )).        with 
+000159c0: 7365 6c66 2e61 7373 6572 7452 6169 7365  self.assertRaise
+000159d0: 7328 5479 7065 4572 726f 7229 3a0a 2020  s(TypeError):.  
+000159e0: 2020 2020 2020 2020 2020 6269 672e 6765            big.ge
+000159f0: 6e74 6c79 5f74 6974 6c65 2822 7468 6520  ntly_title("the 
+00015a00: 5c22 7374 7269 6e67 2773 5c22 2074 6865  \"string's\" the
+00015a10: 2074 6869 6e67 222c 2064 6f75 626c 655f   thing", double_
+00015a20: 7175 6f74 6573 3d28 6227 2227 2c29 290a  quotes=(b'"',)).
+00015a30: 2020 2020 2020 2020 7769 7468 2073 656c          with sel
+00015a40: 662e 6173 7365 7274 5261 6973 6573 2854  f.assertRaises(T
+00015a50: 7970 6545 7272 6f72 293a 0a20 2020 2020  ypeError):.     
+00015a60: 2020 2020 2020 2062 6967 2e67 656e 746c         big.gentl
+00015a70: 795f 7469 746c 6528 2274 6865 205c 2273  y_title("the \"s
+00015a80: 7472 696e 6727 735c 2220 7468 6520 7468  tring's\" the th
+00015a90: 696e 6722 2c20 6170 6f73 7472 6f70 6865  ing", apostrophe
+00015aa0: 733d 2862 2227 222c 292c 2064 6f75 626c  s=(b"'",), doubl
+00015ab0: 655f 7175 6f74 6573 3d28 6227 2227 2c29  e_quotes=(b'"',)
+00015ac0: 290a 0a0a 2020 2020 2020 2020 7769 7468  )...        with
+00015ad0: 2073 656c 662e 6173 7365 7274 5261 6973   self.assertRais
+00015ae0: 6573 2854 7970 6545 7272 6f72 293a 0a20  es(TypeError):. 
+00015af0: 2020 2020 2020 2020 2020 2062 6967 2e67             big.g
+00015b00: 656e 746c 795f 7469 746c 6528 6222 7468  ently_title(b"th
+00015b10: 6520 5c22 7374 7269 6e67 2773 5c22 2074  e \"string's\" t
+00015b20: 6865 2074 6869 6e67 222c 2061 706f 7374  he thing", apost
+00015b30: 726f 7068 6573 3d62 6967 2e61 706f 7374  rophes=big.apost
+00015b40: 726f 7068 6573 290a 2020 2020 2020 2020  rophes).        
+00015b50: 7769 7468 2073 656c 662e 6173 7365 7274  with self.assert
+00015b60: 5261 6973 6573 2854 7970 6545 7272 6f72  Raises(TypeError
+00015b70: 293a 0a20 2020 2020 2020 2020 2020 2062  ):.            b
+00015b80: 6967 2e67 656e 746c 795f 7469 746c 6528  ig.gently_title(
+00015b90: 6222 7468 6520 5c22 7374 7269 6e67 2773  b"the \"string's
+00015ba0: 5c22 2074 6865 2074 6869 6e67 222c 2064  \" the thing", d
+00015bb0: 6f75 626c 655f 7175 6f74 6573 3d62 6967  ouble_quotes=big
+00015bc0: 2e64 6f75 626c 655f 7175 6f74 6573 290a  .double_quotes).
+00015bd0: 2020 2020 2020 2020 7769 7468 2073 656c          with sel
+00015be0: 662e 6173 7365 7274 5261 6973 6573 2854  f.assertRaises(T
+00015bf0: 7970 6545 7272 6f72 293a 0a20 2020 2020  ypeError):.     
+00015c00: 2020 2020 2020 2062 6967 2e67 656e 746c         big.gentl
+00015c10: 795f 7469 746c 6528 6222 7468 6520 5c22  y_title(b"the \"
+00015c20: 7374 7269 6e67 2773 5c22 2074 6865 2074  string's\" the t
+00015c30: 6869 6e67 222c 2061 706f 7374 726f 7068  hing", apostroph
+00015c40: 6573 3d62 6967 2e61 706f 7374 726f 7068  es=big.apostroph
+00015c50: 6573 2c20 646f 7562 6c65 5f71 756f 7465  es, double_quote
+00015c60: 733d 6269 672e 646f 7562 6c65 5f71 756f  s=big.double_quo
+00015c70: 7465 7329 0a0a 2020 2020 2020 2020 7769  tes)..        wi
+00015c80: 7468 2073 656c 662e 6173 7365 7274 5261  th self.assertRa
+00015c90: 6973 6573 2854 7970 6545 7272 6f72 293a  ises(TypeError):
+00015ca0: 0a20 2020 2020 2020 2020 2020 2062 6967  .            big
+00015cb0: 2e67 656e 746c 795f 7469 746c 6528 6222  .gently_title(b"
+00015cc0: 7468 6520 5c22 7374 7269 6e67 2773 5c22  the \"string's\"
+00015cd0: 2074 6865 2074 6869 6e67 222c 2061 706f   the thing", apo
+00015ce0: 7374 726f 7068 6573 3d28 2227 222c 2929  strophes=("'",))
+00015cf0: 0a20 2020 2020 2020 2077 6974 6820 7365  .        with se
+00015d00: 6c66 2e61 7373 6572 7452 6169 7365 7328  lf.assertRaises(
+00015d10: 5479 7065 4572 726f 7229 3a0a 2020 2020  TypeError):.    
+00015d20: 2020 2020 2020 2020 6269 672e 6765 6e74          big.gent
+00015d30: 6c79 5f74 6974 6c65 2862 2274 6865 205c  ly_title(b"the \
+00015d40: 2273 7472 696e 6727 735c 2220 7468 6520  "string's\" the 
+00015d50: 7468 696e 6722 2c20 646f 7562 6c65 5f71  thing", double_q
+00015d60: 756f 7465 733d 2827 2227 2c29 290a 2020  uotes=('"',)).  
+00015d70: 2020 2020 2020 7769 7468 2073 656c 662e        with self.
+00015d80: 6173 7365 7274 5261 6973 6573 2854 7970  assertRaises(Typ
+00015d90: 6545 7272 6f72 293a 0a20 2020 2020 2020  eError):.       
+00015da0: 2020 2020 2062 6967 2e67 656e 746c 795f       big.gently_
+00015db0: 7469 746c 6528 6222 7468 6520 5c22 7374  title(b"the \"st
+00015dc0: 7269 6e67 2773 5c22 2074 6865 2074 6869  ring's\" the thi
+00015dd0: 6e67 222c 2061 706f 7374 726f 7068 6573  ng", apostrophes
+00015de0: 3d28 2227 222c 292c 2064 6f75 626c 655f  =("'",), double_
+00015df0: 7175 6f74 6573 3d28 2722 272c 2929 0a0a  quotes=('"',))..
+00015e00: 2020 2020 2020 2020 7769 7468 2073 656c          with sel
+00015e10: 662e 6173 7365 7274 5261 6973 6573 2854  f.assertRaises(T
+00015e20: 7970 6545 7272 6f72 293a 0a20 2020 2020  ypeError):.     
+00015e30: 2020 2020 2020 2062 6967 2e67 656e 746c         big.gentl
+00015e40: 795f 7469 746c 6528 5374 7253 7562 636c  y_title(StrSubcl
+00015e50: 6173 7328 2274 6865 205c 2273 7472 696e  ass("the \"strin
+00015e60: 6727 735c 2220 7468 6520 7468 696e 6722  g's\" the thing"
+00015e70: 292c 2061 706f 7374 726f 7068 6573 3d42  ), apostrophes=B
+00015e80: 7974 6573 5375 6263 6c61 7373 2862 6967  ytesSubclass(big
+00015e90: 2e61 7363 6969 5f61 706f 7374 726f 7068  .ascii_apostroph
+00015ea0: 6573 2929 0a20 2020 2020 2020 2077 6974  es)).        wit
+00015eb0: 6820 7365 6c66 2e61 7373 6572 7452 6169  h self.assertRai
+00015ec0: 7365 7328 5479 7065 4572 726f 7229 3a0a  ses(TypeError):.
+00015ed0: 2020 2020 2020 2020 2020 2020 6269 672e              big.
+00015ee0: 6765 6e74 6c79 5f74 6974 6c65 2853 7472  gently_title(Str
+00015ef0: 5375 6263 6c61 7373 2822 7468 6520 5c22  Subclass("the \"
+00015f00: 7374 7269 6e67 2773 5c22 2074 6865 2074  string's\" the t
+00015f10: 6869 6e67 2229 2c20 646f 7562 6c65 5f71  hing"), double_q
+00015f20: 756f 7465 733d 4279 7465 7353 7562 636c  uotes=BytesSubcl
+00015f30: 6173 7328 6269 672e 6173 6369 695f 646f  ass(big.ascii_do
+00015f40: 7562 6c65 5f71 756f 7465 7329 290a 0a20  uble_quotes)).. 
+00015f50: 2020 2020 2020 2077 6974 6820 7365 6c66         with self
+00015f60: 2e61 7373 6572 7452 6169 7365 7328 5479  .assertRaises(Ty
+00015f70: 7065 4572 726f 7229 3a0a 2020 2020 2020  peError):.      
+00015f80: 2020 2020 2020 6269 672e 6765 6e74 6c79        big.gently
+00015f90: 5f74 6974 6c65 2842 7974 6573 5375 6263  _title(BytesSubc
+00015fa0: 6c61 7373 2862 2274 6865 205c 2273 7472  lass(b"the \"str
+00015fb0: 696e 6727 735c 2220 7468 6520 7468 696e  ing's\" the thin
+00015fc0: 6722 292c 2061 706f 7374 726f 7068 6573  g"), apostrophes
+00015fd0: 3d53 7472 5375 6263 6c61 7373 2862 6967  =StrSubclass(big
+00015fe0: 2e61 706f 7374 726f 7068 6573 2929 0a20  .apostrophes)). 
+00015ff0: 2020 2020 2020 2077 6974 6820 7365 6c66         with self
+00016000: 2e61 7373 6572 7452 6169 7365 7328 5479  .assertRaises(Ty
+00016010: 7065 4572 726f 7229 3a0a 2020 2020 2020  peError):.      
+00016020: 2020 2020 2020 6269 672e 6765 6e74 6c79        big.gently
+00016030: 5f74 6974 6c65 2842 7974 6573 5375 6263  _title(BytesSubc
+00016040: 6c61 7373 2862 2274 6865 205c 2273 7472  lass(b"the \"str
+00016050: 696e 6727 735c 2220 7468 6520 7468 696e  ing's\" the thin
+00016060: 6722 292c 2064 6f75 626c 655f 7175 6f74  g"), double_quot
+00016070: 6573 3d53 7472 5375 6263 6c61 7373 2862  es=StrSubclass(b
+00016080: 6967 2e64 6f75 626c 655f 7175 6f74 6573  ig.double_quotes
+00016090: 2929 0a0a 2020 2020 2020 2020 7365 6c66  ))..        self
+000160a0: 2e61 7373 6572 7445 7175 616c 280a 2020  .assertEqual(.  
+000160b0: 2020 2020 2020 2020 2020 6269 672e 6765            big.ge
+000160c0: 6e74 6c79 5f74 6974 6c65 2853 7472 5375  ntly_title(StrSu
+000160d0: 6263 6c61 7373 2822 7065 7465 7220 6f27  bclass("peter o'
+000160e0: 746f 6f6c 6522 292c 2061 706f 7374 726f  toole"), apostro
+000160f0: 7068 6573 3d44 6966 6665 7265 6e74 5374  phes=DifferentSt
+00016100: 7253 7562 636c 6173 7328 6269 672e 6170  rSubclass(big.ap
+00016110: 6f73 7472 6f70 6865 7329 292c 0a20 2020  ostrophes)),.   
+00016120: 2020 2020 2020 2020 2020 2250 6574 6572            "Peter
+00016130: 204f 2754 6f6f 6c65 220a 2020 2020 2020   O'Toole".      
+00016140: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00016150: 2073 656c 662e 6173 7365 7274 4571 7561   self.assertEqua
+00016160: 6c28 0a20 2020 2020 2020 2020 2020 2062  l(.            b
+00016170: 6967 2e67 656e 746c 795f 7469 746c 6528  ig.gently_title(
+00016180: 4279 7465 7353 7562 636c 6173 7328 6222  BytesSubclass(b"
+00016190: 7065 7465 7220 6f27 746f 6f6c 6522 292c  peter o'toole"),
+000161a0: 2061 706f 7374 726f 7068 6573 3d44 6966   apostrophes=Dif
+000161b0: 6665 7265 6e74 4279 7465 7353 7562 636c  ferentBytesSubcl
+000161c0: 6173 7328 6269 672e 6173 6369 695f 6170  ass(big.ascii_ap
+000161d0: 6f73 7472 6f70 6865 7329 292c 0a20 2020  ostrophes)),.   
+000161e0: 2020 2020 2020 2020 2020 6222 5065 7465            b"Pete
+000161f0: 7220 4f27 546f 6f6c 6522 0a20 2020 2020  r O'Toole".     
+00016200: 2020 2020 2020 2020 290a 0a20 2020 2020          )..     
+00016210: 2020 2077 6974 6820 7365 6c66 2e61 7373     with self.ass
+00016220: 6572 7452 6169 7365 7328 5661 6c75 6545  ertRaises(ValueE
+00016230: 7272 6f72 293a 0a20 2020 2020 2020 2020  rror):.         
+00016240: 2020 2062 6967 2e67 656e 746c 795f 7469     big.gently_ti
+00016250: 746c 6528 2274 6865 205c 2273 7472 696e  tle("the \"strin
+00016260: 6727 735c 2220 7468 6520 7468 696e 6722  g's\" the thing"
+00016270: 2c20 6170 6f73 7472 6f70 6865 733d 2727  , apostrophes=''
+00016280: 290a 2020 2020 2020 2020 7769 7468 2073  ).        with s
+00016290: 656c 662e 6173 7365 7274 5261 6973 6573  elf.assertRaises
+000162a0: 2856 616c 7565 4572 726f 7229 3a0a 2020  (ValueError):.  
+000162b0: 2020 2020 2020 2020 2020 6269 672e 6765            big.ge
+000162c0: 6e74 6c79 5f74 6974 6c65 2822 7468 6520  ntly_title("the 
+000162d0: 5c22 7374 7269 6e67 2773 5c22 2074 6865  \"string's\" the
+000162e0: 2074 6869 6e67 222c 2061 706f 7374 726f   thing", apostro
+000162f0: 7068 6573 3d28 2227 222c 2027 2729 290a  phes=("'", '')).
+00016300: 2020 2020 2020 2020 7769 7468 2073 656c          with sel
+00016310: 662e 6173 7365 7274 5261 6973 6573 2856  f.assertRaises(V
+00016320: 616c 7565 4572 726f 7229 3a0a 2020 2020  alueError):.    
+00016330: 2020 2020 2020 2020 6269 672e 6765 6e74          big.gent
+00016340: 6c79 5f74 6974 6c65 2822 7468 6520 5c22  ly_title("the \"
+00016350: 7374 7269 6e67 2773 5c22 2074 6865 2074  string's\" the t
+00016360: 6869 6e67 222c 2064 6f75 626c 655f 7175  hing", double_qu
+00016370: 6f74 6573 3d27 2729 0a20 2020 2020 2020  otes='').       
+00016380: 2077 6974 6820 7365 6c66 2e61 7373 6572   with self.asser
+00016390: 7452 6169 7365 7328 5661 6c75 6545 7272  tRaises(ValueErr
+000163a0: 6f72 293a 0a20 2020 2020 2020 2020 2020  or):.           
+000163b0: 2062 6967 2e67 656e 746c 795f 7469 746c   big.gently_titl
+000163c0: 6528 2274 6865 205c 2273 7472 696e 6727  e("the \"string'
+000163d0: 735c 2220 7468 6520 7468 696e 6722 2c20  s\" the thing", 
+000163e0: 646f 7562 6c65 5f71 756f 7465 733d 2827  double_quotes=('
+000163f0: 2227 2c20 2727 2929 0a0a 2020 2020 2020  "', ''))..      
+00016400: 2020 7769 7468 2073 656c 662e 6173 7365    with self.asse
+00016410: 7274 5261 6973 6573 2856 616c 7565 4572  rtRaises(ValueEr
+00016420: 726f 7229 3a0a 2020 2020 2020 2020 2020  ror):.          
+00016430: 2020 6269 672e 6765 6e74 6c79 5f74 6974    big.gently_tit
+00016440: 6c65 2862 2274 6865 205c 2273 7472 696e  le(b"the \"strin
+00016450: 6727 735c 2220 7468 6520 7468 696e 6722  g's\" the thing"
+00016460: 2c20 6170 6f73 7472 6f70 6865 733d 6227  , apostrophes=b'
+00016470: 2729 0a20 2020 2020 2020 2077 6974 6820  ').        with 
+00016480: 7365 6c66 2e61 7373 6572 7452 6169 7365  self.assertRaise
+00016490: 7328 5661 6c75 6545 7272 6f72 293a 0a20  s(ValueError):. 
+000164a0: 2020 2020 2020 2020 2020 2062 6967 2e67             big.g
+000164b0: 656e 746c 795f 7469 746c 6528 6222 7468  ently_title(b"th
+000164c0: 6520 5c22 7374 7269 6e67 2773 5c22 2074  e \"string's\" t
+000164d0: 6865 2074 6869 6e67 222c 2061 706f 7374  he thing", apost
+000164e0: 726f 7068 6573 3d28 6222 2722 2c20 6227  rophes=(b"'", b'
+000164f0: 2729 290a 2020 2020 2020 2020 7769 7468  ')).        with
+00016500: 2073 656c 662e 6173 7365 7274 5261 6973   self.assertRais
+00016510: 6573 2856 616c 7565 4572 726f 7229 3a0a  es(ValueError):.
+00016520: 2020 2020 2020 2020 2020 2020 6269 672e              big.
+00016530: 6765 6e74 6c79 5f74 6974 6c65 2862 2274  gently_title(b"t
+00016540: 6865 205c 2273 7472 696e 6727 735c 2220  he \"string's\" 
+00016550: 7468 6520 7468 696e 6722 2c20 646f 7562  the thing", doub
+00016560: 6c65 5f71 756f 7465 733d 6227 2729 0a20  le_quotes=b''). 
+00016570: 2020 2020 2020 2077 6974 6820 7365 6c66         with self
+00016580: 2e61 7373 6572 7452 6169 7365 7328 5661  .assertRaises(Va
+00016590: 6c75 6545 7272 6f72 293a 0a20 2020 2020  lueError):.     
+000165a0: 2020 2020 2020 2062 6967 2e67 656e 746c         big.gentl
+000165b0: 795f 7469 746c 6528 6222 7468 6520 5c22  y_title(b"the \"
+000165c0: 7374 7269 6e67 2773 5c22 2074 6865 2074  string's\" the t
+000165d0: 6869 6e67 222c 2064 6f75 626c 655f 7175  hing", double_qu
+000165e0: 6f74 6573 3d28 6227 2227 2c20 6227 2729  otes=(b'"', b'')
+000165f0: 290a 0a0a 2020 2020 6465 6620 7465 7374  )...    def test
+00016600: 5f6e 6f72 6d61 6c69 7a65 5f77 6869 7465  _normalize_white
+00016610: 7370 6163 6528 7365 6c66 293a 0a20 2020  space(self):.   
+00016620: 2020 2020 2064 6566 2074 6573 7428 732c       def test(s,
+00016630: 2065 7870 6563 7465 642c 202a 2c20 7365   expected, *, se
+00016640: 7061 7261 746f 7273 3d4e 6f6e 652c 2072  parators=None, r
+00016650: 6570 6c61 6365 6d65 6e74 3d22 2022 293a  eplacement=" "):
+00016660: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
+00016670: 2069 2069 6e20 7261 6e67 6528 3229 3a0a   i in range(2):.
+00016680: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016690: 7265 7375 6c74 203d 2062 6967 2e6e 6f72  result = big.nor
+000166a0: 6d61 6c69 7a65 5f77 6869 7465 7370 6163  malize_whitespac
+000166b0: 6528 732c 2073 6570 6172 6174 6f72 733d  e(s, separators=
+000166c0: 7365 7061 7261 746f 7273 2c20 7265 706c  separators, repl
+000166d0: 6163 656d 656e 743d 7265 706c 6163 656d  acement=replacem
+000166e0: 656e 7429 0a20 2020 2020 2020 2020 2020  ent).           
+000166f0: 2020 2020 2073 656c 662e 6173 7365 7274       self.assert
+00016700: 4571 7561 6c28 7265 7375 6c74 2c20 6578  Equal(result, ex
+00016710: 7065 6374 6564 290a 2020 2020 2020 2020  pected).        
+00016720: 2020 2020 2020 2020 6966 2069 3a0a 2020          if i:.  
+00016730: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016740: 2020 6272 6561 6b0a 0a20 2020 2020 2020    break..       
+00016750: 2020 2020 2020 2020 2073 203d 2074 6f5f           s = to_
+00016760: 6279 7465 7328 7329 0a20 2020 2020 2020  bytes(s).       
+00016770: 2020 2020 2020 2020 2065 7870 6563 7465           expecte
+00016780: 6420 3d20 746f 5f62 7974 6573 2865 7870  d = to_bytes(exp
+00016790: 6563 7465 6429 0a20 2020 2020 2020 2020  ected).         
+000167a0: 2020 2020 2020 2073 6570 6172 6174 6f72         separator
+000167b0: 7320 3d20 746f 5f62 7974 6573 2873 6570  s = to_bytes(sep
+000167c0: 6172 6174 6f72 7329 0a20 2020 2020 2020  arators).       
+000167d0: 2020 2020 2020 2020 2072 6570 6c61 6365           replace
+000167e0: 6d65 6e74 203d 2074 6f5f 6279 7465 7328  ment = to_bytes(
+000167f0: 7265 706c 6163 656d 656e 7429 0a0a 2020  replacement)..  
+00016800: 2020 2020 2020 7465 7374 2822 2020 2061        test("   a
+00016810: 2020 2020 6220 2020 2063 222c 2022 2061      b    c", " a
+00016820: 2062 2063 2229 0a0a 2020 2020 2020 2020   b c")..        
+00016830: 7465 7374 2822 6420 2020 2020 6520 205c  test("d     e  \
+00016840: 745c 6e20 2066 2022 2c20 2264 2065 2066  t\n  f ", "d e f
+00016850: 2022 290a 2020 2020 2020 2020 7465 7374   ").        test
+00016860: 2822 6768 6922 2c20 2267 6869 222c 2072  ("ghi", "ghi", r
+00016870: 6570 6c61 6365 6d65 6e74 3d4e 6f6e 6529  eplacement=None)
+00016880: 0a20 2020 2020 2020 2074 6573 7428 2220  .        test(" 
+00016890: 2020 6a20 2020 2020 6b6c 2020 206d 6e6f    j     kl   mno
+000168a0: 7020 2020 2022 2c20 2220 6a20 6b6c 206d  p    ", " j kl m
+000168b0: 6e6f 7020 2229 0a20 2020 2020 2020 2074  nop ").        t
+000168c0: 6573 7428 2222 2c20 2222 290a 2020 2020  est("", "").    
+000168d0: 2020 2020 7465 7374 2822 2020 205c 6e5c      test("   \n\
+000168e0: 6e5c 7420 5c74 2020 2020 2022 2c20 2220  n\t \t     ", " 
+000168f0: 2229 0a0a 2020 2020 2020 2020 7465 7374  ")..        test
+00016900: 2822 2020 206a 2020 2020 206b 6c20 2020  ("   j     kl   
+00016910: 6d6e 6f70 2020 2020 222c 2022 586a 586b  mnop    ", "XjXk
+00016920: 6c58 6d6e 6f70 5822 2c20 7265 706c 6163  lXmnopX", replac
+00016930: 656d 656e 743d 2258 2229 0a20 2020 2020  ement="X").     
+00016940: 2020 2074 6573 7428 2220 2020 6a20 2020     test("   j   
+00016950: 2020 6b6c 2020 206d 6e6f 7020 2020 2022    kl   mnop    "
+00016960: 2c20 2251 516a 5151 6b6c 5151 6d6e 6f70  , "QQjQQklQQmnop
+00016970: 5151 222c 2072 6570 6c61 6365 6d65 6e74  QQ", replacement
+00016980: 3d22 5151 2229 0a20 2020 2020 2020 2074  ="QQ").        t
+00016990: 6573 7428 2220 2020 6a20 2020 2020 6b6c  est("   j     kl
+000169a0: 2020 206d 6e6f 7020 2020 2022 2c20 226a     mnop    ", "j
+000169b0: 6b6c 6d6e 6f70 222c 2072 6570 6c61 6365  klmnop", replace
+000169c0: 6d65 6e74 3d22 2229 0a0a 2020 2020 2020  ment="")..      
+000169d0: 2020 7465 7374 2827 4445 4661 6261 6361    test('DEFabaca
+000169e0: 6247 4849 272c 2020 2020 2020 2020 2744  bGHI',        'D
+000169f0: 4546 2b47 4849 272c 2020 7365 7061 7261  EF+GHI',  separa
+00016a00: 746f 7273 3d28 2761 272c 2027 6227 2c20  tors=('a', 'b', 
+00016a10: 2763 2729 2c20 7265 706c 6163 656d 656e  'c'), replacemen
+00016a20: 743d 272b 2729 0a20 2020 2020 2020 2074  t='+').        t
+00016a30: 6573 7428 2744 4546 6162 6163 6162 4748  est('DEFabacabGH
+00016a40: 4961 6161 272c 2020 2020 2027 4445 462b  Iaaa',     'DEF+
+00016a50: 4748 492b 272c 2073 6570 6172 6174 6f72  GHI+', separator
+00016a60: 733d 2827 6127 2c20 2762 272c 2027 6327  s=('a', 'b', 'c'
+00016a70: 292c 2072 6570 6c61 6365 6d65 6e74 3d27  ), replacement='
+00016a80: 2b27 290a 2020 2020 2020 2020 7465 7374  +').        test
+00016a90: 2827 6162 6344 4546 6162 6163 6162 4748  ('abcDEFabacabGH
+00016aa0: 4927 2c20 2020 2027 2b44 4546 2b47 4849  I',    '+DEF+GHI
+00016ab0: 272c 2020 7365 7061 7261 746f 7273 3d28  ',  separators=(
+00016ac0: 2761 272c 2027 6227 2c20 2763 2729 2c20  'a', 'b', 'c'), 
+00016ad0: 7265 706c 6163 656d 656e 743d 272b 2729  replacement='+')
+00016ae0: 0a20 2020 2020 2020 2074 6573 7428 2761  .        test('a
+00016af0: 6263 4445 4661 6261 6361 6247 4849 6161  bcDEFabacabGHIaa
+00016b00: 6127 2c20 272b 4445 462b 4748 492b 272c  a', '+DEF+GHI+',
+00016b10: 2073 6570 6172 6174 6f72 733d 2827 6127   separators=('a'
+00016b20: 2c20 2762 272c 2027 6327 292c 2072 6570  , 'b', 'c'), rep
+00016b30: 6c61 6365 6d65 6e74 3d27 2b27 290a 2020  lacement='+').  
+00016b40: 2020 2020 2020 7465 7374 2827 6162 6344        test('abcD
+00016b50: 4546 6162 6163 6162 4748 4961 6161 272c  EFabacabGHIaaa',
+00016b60: 2027 2b44 4546 2b47 4849 2b27 2c20 7365   '+DEF+GHI+', se
+00016b70: 7061 7261 746f 7273 3d27 6162 6327 2c20  parators='abc', 
+00016b80: 7265 706c 6163 656d 656e 743d 272b 2729  replacement='+')
+00016b90: 0a0a 2020 2020 2020 2020 7769 7468 2073  ..        with s
+00016ba0: 656c 662e 6173 7365 7274 5261 6973 6573  elf.assertRaises
+00016bb0: 2854 7970 6545 7272 6f72 293a 0a20 2020  (TypeError):.   
+00016bc0: 2020 2020 2020 2020 2062 6967 2e6e 6f72           big.nor
+00016bd0: 6d61 6c69 7a65 5f77 6869 7465 7370 6163  malize_whitespac
+00016be0: 6528 2261 6263 222c 2022 6222 2c20 2d31  e("abc", "b", -1
+00016bf0: 290a 2020 2020 2020 2020 7769 7468 2073  ).        with s
+00016c00: 656c 662e 6173 7365 7274 5261 6973 6573  elf.assertRaises
+00016c10: 2854 7970 6545 7272 6f72 293a 0a20 2020  (TypeError):.   
+00016c20: 2020 2020 2020 2020 2062 6967 2e6e 6f72           big.nor
+00016c30: 6d61 6c69 7a65 5f77 6869 7465 7370 6163  malize_whitespac
+00016c40: 6528 2261 6263 222c 202d 312c 2022 6222  e("abc", -1, "b"
+00016c50: 290a 2020 2020 2020 2020 7769 7468 2073  ).        with s
+00016c60: 656c 662e 6173 7365 7274 5261 6973 6573  elf.assertRaises
+00016c70: 2856 616c 7565 4572 726f 7229 3a0a 2020  (ValueError):.  
+00016c80: 2020 2020 2020 2020 2020 6269 672e 6e6f            big.no
+00016c90: 726d 616c 697a 655f 7768 6974 6573 7061  rmalize_whitespa
+00016ca0: 6365 2822 6162 6322 2c20 2222 2c20 2263  ce("abc", "", "c
+00016cb0: 2229 0a20 2020 2020 2020 2077 6974 6820  ").        with 
+00016cc0: 7365 6c66 2e61 7373 6572 7452 6169 7365  self.assertRaise
+00016cd0: 7328 5661 6c75 6545 7272 6f72 293a 0a20  s(ValueError):. 
+00016ce0: 2020 2020 2020 2020 2020 2062 6967 2e6e             big.n
+00016cf0: 6f72 6d61 6c69 7a65 5f77 6869 7465 7370  ormalize_whitesp
+00016d00: 6163 6528 2261 6263 222c 2028 2761 272c  ace("abc", ('a',
+00016d10: 2022 222c 2027 6227 292c 2022 6322 290a   "", 'b'), "c").
+00016d20: 2020 2020 2020 2020 7769 7468 2073 656c          with sel
+00016d30: 662e 6173 7365 7274 5261 6973 6573 2854  f.assertRaises(T
+00016d40: 7970 6545 7272 6f72 293a 0a20 2020 2020  ypeError):.     
+00016d50: 2020 2020 2020 2062 6967 2e6e 6f72 6d61         big.norma
+00016d60: 6c69 7a65 5f77 6869 7465 7370 6163 6528  lize_whitespace(
+00016d70: 6222 6162 6322 2c20 2262 222c 2022 6322  b"abc", "b", "c"
+00016d80: 290a 2020 2020 2020 2020 7769 7468 2073  ).        with s
+00016d90: 656c 662e 6173 7365 7274 5261 6973 6573  elf.assertRaises
+00016da0: 2854 7970 6545 7272 6f72 293a 0a20 2020  (TypeError):.   
+00016db0: 2020 2020 2020 2020 2062 6967 2e6e 6f72           big.nor
+00016dc0: 6d61 6c69 7a65 5f77 6869 7465 7370 6163  malize_whitespac
+00016dd0: 6528 2261 6263 222c 2062 2262 222c 2022  e("abc", b"b", "
+00016de0: 6322 290a 2020 2020 2020 2020 7769 7468  c").        with
+00016df0: 2073 656c 662e 6173 7365 7274 5261 6973   self.assertRais
+00016e00: 6573 2854 7970 6545 7272 6f72 293a 0a20  es(TypeError):. 
+00016e10: 2020 2020 2020 2020 2020 2062 6967 2e6e             big.n
+00016e20: 6f72 6d61 6c69 7a65 5f77 6869 7465 7370  ormalize_whitesp
+00016e30: 6163 6528 2261 6263 222c 2022 6222 2c20  ace("abc", "b", 
+00016e40: 6222 6322 290a 0a20 2020 2020 2020 2023  b"c")..        #
+00016e50: 2074 6573 7420 7468 6174 2077 6520 6469   test that we di
+00016e60: 646e 2774 2061 6363 6964 656e 7461 6c6c  dn't accidentall
+00016e70: 7920 7573 6520 7468 6520 2266 6173 7420  y use the "fast 
+00016e80: 7061 7468 220a 2020 2020 2020 2020 2320  path".        # 
+00016e90: 7769 7468 2062 7974 6573 206f 626a 6563  with bytes objec
+00016ea0: 7473 0a20 2020 2020 2020 2073 7472 696e  ts.        strin
+00016eb0: 675f 7769 7468 5f65 6d5f 7370 6163 6520  g_with_em_space 
+00016ec0: 3d20 2261 625c 7532 3030 3363 6422 0a20  = "ab\u2003cd". 
+00016ed0: 2020 2020 2020 2072 6573 756c 7420 3d20         result = 
+00016ee0: 2261 6220 6364 220a 2020 2020 2020 2020  "ab cd".        
+00016ef0: 7365 6c66 2e61 7373 6572 7445 7175 616c  self.assertEqual
+00016f00: 2862 6967 2e6e 6f72 6d61 6c69 7a65 5f77  (big.normalize_w
+00016f10: 6869 7465 7370 6163 6528 2261 625c 7532  hitespace("ab\u2
+00016f20: 3030 3363 6422 292c 2072 6573 756c 7429  003cd"), result)
+00016f30: 0a20 2020 2020 2020 2073 656c 662e 6173  .        self.as
+00016f40: 7365 7274 4571 7561 6c28 6269 672e 6e6f  sertEqual(big.no
+00016f50: 726d 616c 697a 655f 7768 6974 6573 7061  rmalize_whitespa
+00016f60: 6365 2822 6162 5c75 3230 3033 6364 222e  ce("ab\u2003cd".
+00016f70: 656e 636f 6465 2827 7574 662d 3827 292c  encode('utf-8'),
+00016f80: 2062 6967 2e75 7466 385f 7768 6974 6573   big.utf8_whites
+00016f90: 7061 6365 292c 2072 6573 756c 742e 656e  pace), result.en
+00016fa0: 636f 6465 2827 7574 662d 3827 2929 0a0a  code('utf-8'))..
+00016fb0: 2020 2020 2020 2020 7769 7468 2073 656c          with sel
+00016fc0: 662e 6173 7365 7274 5261 6973 6573 2856  f.assertRaises(V
+00016fd0: 616c 7565 4572 726f 7229 3a0a 2020 2020  alueError):.    
+00016fe0: 2020 2020 2020 2020 6269 672e 6e6f 726d          big.norm
+00016ff0: 616c 697a 655f 7768 6974 6573 7061 6365  alize_whitespace
+00017000: 2822 6120 6220 6320 6420 2020 6522 2c20  ("a b c d   e", 
+00017010: 7365 7061 7261 746f 7273 3d27 2729 0a20  separators=''). 
+00017020: 2020 2020 2020 2077 6974 6820 7365 6c66         with self
+00017030: 2e61 7373 6572 7452 6169 7365 7328 5661  .assertRaises(Va
+00017040: 6c75 6545 7272 6f72 293a 0a20 2020 2020  lueError):.     
+00017050: 2020 2020 2020 2062 6967 2e6e 6f72 6d61         big.norma
+00017060: 6c69 7a65 5f77 6869 7465 7370 6163 6528  lize_whitespace(
+00017070: 2261 2062 2063 2064 2020 2065 222c 2073  "a b c d   e", s
+00017080: 6570 6172 6174 6f72 733d 5b5d 290a 2020  eparators=[]).  
+00017090: 2020 2020 2020 7769 7468 2073 656c 662e        with self.
+000170a0: 6173 7365 7274 5261 6973 6573 2856 616c  assertRaises(Val
+000170b0: 7565 4572 726f 7229 3a0a 2020 2020 2020  ueError):.      
+000170c0: 2020 2020 2020 6269 672e 6e6f 726d 616c        big.normal
+000170d0: 697a 655f 7768 6974 6573 7061 6365 2862  ize_whitespace(b
+000170e0: 2261 2062 2063 2064 2020 2065 222c 2073  "a b c d   e", s
+000170f0: 6570 6172 6174 6f72 733d 6227 2729 0a20  eparators=b''). 
+00017100: 2020 2020 2020 2077 6974 6820 7365 6c66         with self
+00017110: 2e61 7373 6572 7452 6169 7365 7328 5661  .assertRaises(Va
+00017120: 6c75 6545 7272 6f72 293a 0a20 2020 2020  lueError):.     
+00017130: 2020 2020 2020 2062 6967 2e6e 6f72 6d61         big.norma
+00017140: 6c69 7a65 5f77 6869 7465 7370 6163 6528  lize_whitespace(
+00017150: 6222 6120 6220 6320 6420 2020 6522 2c20  b"a b c d   e", 
+00017160: 7365 7061 7261 746f 7273 3d5b 5d29 0a0a  separators=[])..
+00017170: 2020 2020 6465 6620 7465 7374 5f73 706c      def test_spl
+00017180: 6974 5f71 756f 7465 645f 7374 7269 6e67  it_quoted_string
+00017190: 7328 7365 6c66 293a 0a20 2020 2020 2020  s(self):.       
+000171a0: 2064 6566 2074 6573 7428 732c 2065 7870   def test(s, exp
+000171b0: 6563 7465 642c 202a 2a6b 7761 7267 7329  ected, **kwargs)
+000171c0: 3a0a 2020 2020 2020 2020 2020 2020 676f  :.            go
+000171d0: 7420 3d20 6c69 7374 2862 6967 2e73 706c  t = list(big.spl
+000171e0: 6974 5f71 756f 7465 645f 7374 7269 6e67  it_quoted_string
+000171f0: 7328 732c 202a 2a6b 7761 7267 7329 290a  s(s, **kwargs)).
+00017200: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00017210: 2e61 7373 6572 7445 7175 616c 2867 6f74  .assertEqual(got
+00017220: 2c20 6578 7065 6374 6564 290a 0a20 2020  , expected)..   
+00017230: 2020 2020 2020 2020 2067 6f74 203d 206c           got = l
+00017240: 6973 7428 6269 672e 7370 6c69 745f 7175  ist(big.split_qu
+00017250: 6f74 6564 5f73 7472 696e 6773 2873 2e65  oted_strings(s.e
+00017260: 6e63 6f64 6528 2761 7363 6969 2729 2c20  ncode('ascii'), 
+00017270: 2a2a 6b77 6172 6773 2929 0a20 2020 2020  **kwargs)).     
+00017280: 2020 2020 2020 2073 656c 662e 6173 7365         self.asse
+00017290: 7274 4571 7561 6c28 676f 742c 205b 2862  rtEqual(got, [(b
+000172a0: 2c20 732e 656e 636f 6465 2827 6173 6369  , s.encode('asci
+000172b0: 6927 2929 2066 6f72 2062 2c20 7320 696e  i')) for b, s in
+000172c0: 2065 7870 6563 7465 645d 290a 0a20 2020   expected])..   
+000172d0: 2020 2020 2074 6573 7428 2222 2268 6579       test("""hey
+000172e0: 2074 6865 7265 2022 7468 6973 2069 7320   there "this is 
+000172f0: 7175 6f74 6564 2220 616e 2065 6d70 7479  quoted" an empty
+00017300: 2071 756f 7465 3a20 2727 2074 6869 7320   quote: '' this 
+00017310: 6973 206e 6f74 2071 756f 7465 6420 2774  is not quoted 't
+00017320: 6869 7320 6973 206d 6f72 6520 7175 6f74  his is more quot
+00017330: 6564 2720 2268 6572 6527 7320 7175 6f74  ed' "here's quot
+00017340: 696e 6720 6120 7175 6f74 6520 6d61 726b  ing a quote mark
+00017350: 3a20 5c5c 2220 776f 7721 2220 7468 6973  : \\" wow!" this
+00017360: 2069 7320 776f 726b 696e 6721 2222 222c   is working!""",
+00017370: 0a20 2020 2020 2020 2020 2020 205b 0a20  .            [. 
+00017380: 2020 2020 2020 2020 2020 2020 2020 2028                 (
+00017390: 4661 6c73 652c 2027 6865 7920 7468 6572  False, 'hey ther
+000173a0: 6520 2729 2c0a 2020 2020 2020 2020 2020  e '),.          
+000173b0: 2020 2020 2020 2854 7275 652c 2027 2274        (True, '"t
+000173c0: 6869 7320 6973 2071 756f 7465 6422 2729  his is quoted"')
+000173d0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+000173e0: 2020 2846 616c 7365 2c20 2720 616e 2065    (False, ' an e
+000173f0: 6d70 7479 2071 756f 7465 3a20 2729 2c0a  mpty quote: '),.
+00017400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017410: 2854 7275 652c 2022 2727 2229 2c0a 2020  (True, "''"),.  
+00017420: 2020 2020 2020 2020 2020 2020 2020 2846                (F
+00017430: 616c 7365 2c20 2720 7468 6973 2069 7320  alse, ' this is 
+00017440: 6e6f 7420 7175 6f74 6564 2027 292c 0a20  not quoted '),. 
+00017450: 2020 2020 2020 2020 2020 2020 2020 2028                 (
+00017460: 5472 7565 2c20 2227 7468 6973 2069 7320  True, "'this is 
+00017470: 6d6f 7265 2071 756f 7465 6427 2229 2c0a  more quoted'"),.
+00017480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017490: 2846 616c 7365 2c20 2720 2729 2c0a 2020  (False, ' '),.  
+000174a0: 2020 2020 2020 2020 2020 2020 2020 2854                (T
+000174b0: 7275 652c 2027 2268 6572 655c 2773 2071  rue, '"here\'s q
+000174c0: 756f 7469 6e67 2061 2071 756f 7465 206d  uoting a quote m
+000174d0: 6172 6b3a 205c 5c22 2077 6f77 2122 2729  ark: \\" wow!"')
+000174e0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+000174f0: 2020 2846 616c 7365 2c20 2720 7468 6973    (False, ' this
+00017500: 2069 7320 776f 726b 696e 6721 2729 2c0a   is working!'),.
+00017510: 2020 2020 2020 2020 2020 2020 5d29 0a0a              ])..
+00017520: 2020 2020 2020 2020 7465 7374 2827 2727          test('''
+00017530: 6865 7265 2069 7320 7472 6970 6c65 2071  here is triple q
+00017540: 756f 7465 643a 2022 2222 6920 616d 2074  uoted: """i am t
+00017550: 7269 706c 6520 7175 6f74 6564 2e22 2222  riple quoted."""
+00017560: 2077 6f77 2120 2061 6761 696e 3a20 2222   wow!  again: ""
+00017570: 2274 7269 706c 6520 7175 6f74 6564 2068  "triple quoted h
+00017580: 6572 652e 2022 7175 6f74 6573 2069 6e20  ere. "quotes in 
+00017590: 7175 6f74 6573 2220 656d 7074 793a 2022  quotes" empty: "
+000175a0: 2220 646f 6e65 2e22 2222 2070 6865 7721  " done.""" phew!
+000175b0: 2727 272c 0a20 2020 2020 2020 2020 2020  ''',.           
+000175c0: 205b 0a20 2020 2020 2020 2020 2020 2020   [.             
+000175d0: 2020 2028 4661 6c73 652c 2027 6865 7265     (False, 'here
+000175e0: 2069 7320 7472 6970 6c65 2071 756f 7465   is triple quote
+000175f0: 643a 2027 292c 0a20 2020 2020 2020 2020  d: '),.         
+00017600: 2020 2020 2020 2028 5472 7565 2c20 2722         (True, '"
+00017610: 2222 6920 616d 2074 7269 706c 6520 7175  ""i am triple qu
+00017620: 6f74 6564 2e22 2222 2729 2c0a 2020 2020  oted."""'),.    
+00017630: 2020 2020 2020 2020 2020 2020 2846 616c              (Fal
+00017640: 7365 2c20 2720 776f 7721 2020 6167 6169  se, ' wow!  agai
+00017650: 6e3a 2027 292c 0a20 2020 2020 2020 2020  n: '),.         
+00017660: 2020 2020 2020 2028 5472 7565 2c20 2722         (True, '"
+00017670: 2222 7472 6970 6c65 2071 756f 7465 6420  ""triple quoted 
+00017680: 6865 7265 2e20 2271 756f 7465 7320 696e  here. "quotes in
+00017690: 2071 756f 7465 7322 2065 6d70 7479 3a20   quotes" empty: 
+000176a0: 2222 2064 6f6e 652e 2222 2227 292c 0a20  "" done."""'),. 
+000176b0: 2020 2020 2020 2020 2020 2020 2020 2028                 (
+000176c0: 4661 6c73 652c 2027 2070 6865 7721 2729  False, ' phew!')
+000176d0: 2c0a 2020 2020 2020 2020 2020 2020 5d29  ,.            ])
+000176e0: 0a0a 2020 2020 2020 2020 7465 7374 2827  ..        test('
+000176f0: 2727 7465 7374 2074 7572 6e69 6e67 206f  ''test turning o
+00017700: 6666 2071 756f 7465 6420 7374 7269 6e67  ff quoted string
+00017710: 732e 2020 2222 2268 6f77 6479 2064 6f6f  s.  """howdy doo
+00017720: 646c 6573 2222 2220 6974 206b 696e 6461  dles""" it kinda
+00017730: 2077 6f72 6b73 2061 6e79 7761 7921 2727   works anyway!''
+00017740: 272c 0a20 2020 2020 2020 2020 2020 205b  ',.            [
+00017750: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00017760: 2028 4661 6c73 652c 2027 7465 7374 2074   (False, 'test t
+00017770: 7572 6e69 6e67 206f 6666 2071 756f 7465  urning off quote
+00017780: 6420 7374 7269 6e67 732e 2020 2729 2c0a  d strings.  '),.
+00017790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000177a0: 2854 7275 652c 2027 2222 2729 2c0a 2020  (True, '""'),.  
+000177b0: 2020 2020 2020 2020 2020 2020 2020 2854                (T
+000177c0: 7275 652c 2027 2268 6f77 6479 2064 6f6f  rue, '"howdy doo
+000177d0: 646c 6573 2227 292c 0a20 2020 2020 2020  dles"'),.       
+000177e0: 2020 2020 2020 2020 2028 5472 7565 2c20           (True, 
+000177f0: 2722 2227 292c 0a20 2020 2020 2020 2020  '""'),.         
+00017800: 2020 2020 2020 2028 4661 6c73 652c 2027         (False, '
+00017810: 2069 7420 6b69 6e64 6120 776f 726b 7320   it kinda works 
+00017820: 616e 7977 6179 2127 292c 0a20 2020 2020  anyway!'),.     
+00017830: 2020 2020 2020 205d 2c0a 2020 2020 2020         ],.      
+00017840: 2020 2020 2020 7472 6970 6c65 5f71 756f        triple_quo
+00017850: 7465 733d 4661 6c73 6529 0a0a 0a20 2020  tes=False)...   
+00017860: 2064 6566 2074 6573 745f 6c69 6e65 7328   def test_lines(
+00017870: 7365 6c66 293a 0a20 2020 2020 2020 2064  self):.        d
+00017880: 6566 2074 6573 7428 692c 2065 7870 6563  ef test(i, expec
+00017890: 7465 6429 3a0a 2020 2020 2020 2020 2020  ted):.          
+000178a0: 2020 676f 7420 3d20 6c69 7374 2869 290a    got = list(i).
+000178b0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+000178c0: 2e61 7373 6572 7445 7175 616c 2867 6f74  .assertEqual(got
+000178d0: 2c20 6578 7065 6374 6564 290a 0a20 2020  , expected)..   
+000178e0: 2020 2020 204c 4920 3d20 6269 672e 4c69       LI = big.Li
+000178f0: 6e65 496e 666f 0a0a 2020 2020 2020 2020  neInfo..        
+00017900: 6465 6620 4c28 6c69 6e65 2c20 6c69 6e65  def L(line, line
+00017910: 5f6e 756d 6265 722c 2063 6f6c 756d 6e5f  _number, column_
+00017920: 6e75 6d62 6572 3d31 2c20 2a2a 6b77 6172  number=1, **kwar
+00017930: 6773 293a 0a20 2020 2020 2020 2020 2020  gs):.           
+00017940: 2069 6e66 6f20 3d20 6269 672e 4c69 6e65   info = big.Line
+00017950: 496e 666f 286c 696e 652c 206c 696e 655f  Info(line, line_
+00017960: 6e75 6d62 6572 2c20 636f 6c75 6d6e 5f6e  number, column_n
+00017970: 756d 6265 722c 202a 2a6b 7761 7267 7329  umber, **kwargs)
+00017980: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00017990: 7572 6e20 2869 6e66 6f2c 206c 696e 6529  urn (info, line)
+000179a0: 0a0a 2020 2020 2020 2020 7465 7374 2862  ..        test(b
+000179b0: 6967 2e6c 696e 6573 2822 615c 6e62 5c6e  ig.lines("a\nb\n
+000179c0: 635c 6e64 5c6e 655c 6e22 292c 0a20 2020  c\nd\ne\n"),.   
+000179d0: 2020 2020 2020 2020 205b 0a20 2020 2020           [.     
+000179e0: 2020 2020 2020 2028 4c49 2827 6127 2c20         (LI('a', 
+000179f0: 312c 2031 292c 2027 6127 292c 0a20 2020  1, 1), 'a'),.   
+00017a00: 2020 2020 2020 2020 2028 4c49 2827 6227           (LI('b'
+00017a10: 2c20 322c 2031 292c 2027 6227 292c 0a20  , 2, 1), 'b'),. 
+00017a20: 2020 2020 2020 2020 2020 2028 4c49 2827             (LI('
+00017a30: 6327 2c20 332c 2031 292c 2027 6327 292c  c', 3, 1), 'c'),
+00017a40: 0a20 2020 2020 2020 2020 2020 2028 4c49  .            (LI
+00017a50: 2827 6427 2c20 342c 2031 292c 2027 6427  ('d', 4, 1), 'd'
+00017a60: 292c 0a20 2020 2020 2020 2020 2020 2028  ),.            (
+00017a70: 4c49 2827 6527 2c20 352c 2031 292c 2027  LI('e', 5, 1), '
+00017a80: 6527 292c 0a20 2020 2020 2020 2020 2020  e'),.           
+00017a90: 2028 4c49 2827 272c 2020 362c 2031 292c   (LI('',  6, 1),
+00017aa0: 2027 2729 2c0a 2020 2020 2020 2020 2020   ''),.          
+00017ab0: 2020 5d29 0a0a 2020 2020 2020 2020 6c69    ])..        li
+00017ac0: 6e65 7320 3d20 5b27 6669 7273 7420 6c69  nes = ['first li
+00017ad0: 6e65 272c 2027 5c74 7365 636f 6e64 206c  ne', '\tsecond l
+00017ae0: 696e 6527 2c20 2774 6869 7264 206c 696e  ine', 'third lin
+00017af0: 6527 5d0a 2020 2020 2020 2020 7465 7374  e'].        test
+00017b00: 2862 6967 2e6c 696e 6573 5f73 7472 6970  (big.lines_strip
+00017b10: 2862 6967 2e6c 696e 6573 286c 696e 6573  (big.lines(lines
+00017b20: 2929 2c0a 2020 2020 2020 2020 2020 2020  )),.            
+00017b30: 5b0a 2020 2020 2020 2020 2020 2020 284c  [.            (L
+00017b40: 4928 2766 6972 7374 206c 696e 6527 2c20  I('first line', 
+00017b50: 312c 2031 292c 2027 6669 7273 7420 6c69  1, 1), 'first li
+00017b60: 6e65 2729 2c0a 2020 2020 2020 2020 2020  ne'),.          
+00017b70: 2020 284c 4928 275c 7473 6563 6f6e 6420    (LI('\tsecond 
+00017b80: 6c69 6e65 272c 2032 2c20 392c 206c 6561  line', 2, 9, lea
+00017b90: 6469 6e67 3d27 5c74 2729 2c20 2773 6563  ding='\t'), 'sec
+00017ba0: 6f6e 6420 6c69 6e65 2729 2c0a 2020 2020  ond line'),.    
+00017bb0: 2020 2020 2020 2020 284c 4928 2774 6869          (LI('thi
+00017bc0: 7264 206c 696e 6527 2c20 332c 2031 292c  rd line', 3, 1),
+00017bd0: 2027 7468 6972 6420 6c69 6e65 2729 2c0a   'third line'),.
+00017be0: 2020 2020 2020 2020 2020 2020 5d29 0a0a              ])..
+00017bf0: 2020 2020 2020 2020 7465 7374 2862 6967          test(big
+00017c00: 2e6c 696e 6573 5f66 696c 7465 725f 636f  .lines_filter_co
+00017c10: 6d6d 656e 745f 6c69 6e65 7328 6269 672e  mment_lines(big.
+00017c20: 6c69 6e65 7328 2222 220a 2020 2020 2320  lines(""".    # 
+00017c30: 636f 6d6d 656e 740a 2020 2020 6120 3d20  comment.    a = 
+00017c40: 620a 2020 2020 2f2f 2061 6e6f 7468 6572  b.    // another
+00017c50: 2063 6f6d 6d65 6e74 0a20 2020 2063 203d   comment.    c =
+00017c60: 2064 0a20 2020 202f 206e 6f74 2061 2063   d.    / not a c
+00017c70: 6f6d 6d65 6e74 0a20 2020 202f 2f2f 2069  omment.    /// i
+00017c80: 7320 6120 636f 6d6d 656e 7421 0a20 2020  s a comment!.   
+00017c90: 2023 2320 616e 6f74 6865 7220 636f 6d6d   ## another comm
+00017ca0: 656e 7421 0a20 2020 2023 2120 6120 7468  ent!.    #! a th
+00017cb0: 6972 6420 636f 6d6d 656e 7421 0a22 2222  ird comment!."""
+00017cc0: 2e6c 7374 7269 7028 275c 6e27 2929 2c20  .lstrip('\n')), 
+00017cd0: 2827 2327 2c20 272f 2f27 2929 2c0a 2020  ('#', '//')),.  
+00017ce0: 2020 2020 2020 2020 2020 5b0a 2020 2020            [.    
+00017cf0: 2020 2020 2020 2020 284c 4928 2720 2020          (LI('   
+00017d00: 2061 203d 2062 272c 2020 2020 2020 2020   a = b',        
+00017d10: 2020 2032 2c20 3129 2c20 2720 2020 2061     2, 1), '    a
+00017d20: 203d 2062 2729 2c0a 2020 2020 2020 2020   = b'),.        
+00017d30: 2020 2020 284c 4928 2720 2020 2063 203d      (LI('    c =
+00017d40: 2064 272c 2020 2020 2020 2020 2020 2034   d',           4
+00017d50: 2c20 3129 2c20 2720 2020 2063 203d 2064  , 1), '    c = d
+00017d60: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
+00017d70: 284c 4928 2720 2020 202f 206e 6f74 2061  (LI('    / not a
+00017d80: 2063 6f6d 6d65 6e74 272c 2035 2c20 3129   comment', 5, 1)
+00017d90: 2c20 2720 2020 202f 206e 6f74 2061 2063  , '    / not a c
+00017da0: 6f6d 6d65 6e74 2729 2c0a 2020 2020 2020  omment'),.      
+00017db0: 2020 2020 2020 284c 4928 2727 2c20 2020        (LI('',   
+00017dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017dd0: 2039 2c20 3129 2c20 2727 292c 0a20 2020   9, 1), ''),.   
+00017de0: 2020 2020 2020 2020 205d 290a 0a20 2020           ])..   
+00017df0: 2020 2020 2074 6573 7428 6269 672e 6c69       test(big.li
+00017e00: 6e65 735f 6669 6c74 6572 5f63 6f6d 6d65  nes_filter_comme
+00017e10: 6e74 5f6c 696e 6573 2862 6967 2e6c 696e  nt_lines(big.lin
+00017e20: 6573 2862 2261 5c6e 2320 6967 6e6f 7265  es(b"a\n# ignore
+00017e30: 645c 6e20 6322 292c 2062 2723 2729 2c0a  d\n c"), b'#'),.
+00017e40: 2020 2020 2020 2020 2020 2020 5b0a 2020              [.  
+00017e50: 2020 2020 2020 2020 2020 4c28 6227 6127            L(b'a'
+00017e60: 2c20 3129 2c0a 2020 2020 2020 2020 2020  , 1),.          
+00017e70: 2020 4c28 6227 2063 272c 2033 292c 0a20    L(b' c', 3),. 
+00017e80: 2020 2020 2020 2020 2020 205d 0a20 2020             ].   
+00017e90: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
+00017ea0: 2020 2020 7465 7374 2862 6967 2e6c 696e      test(big.lin
+00017eb0: 6573 5f63 6f6e 7461 696e 696e 6728 6269  es_containing(bi
+00017ec0: 672e 6c69 6e65 7328 2222 220a 6865 6c6c  g.lines(""".hell
+00017ed0: 6f20 796f 6c6b 730a 7768 6174 2064 6f20  o yolks.what do 
+00017ee0: 796f 7520 6861 7665 2074 6f20 7361 792c  you have to say,
+00017ef0: 2063 6861 6d70 3f0a 6920 6c69 6b65 2065   champ?.i like e
+00017f00: 6767 732e 0a74 6865 7920 646f 6e27 7420  ggs..they don't 
+00017f10: 6861 7665 2074 6f20 6265 2066 616e 6379  have to be fancy
+00017f20: 2e0a 7369 6d70 6c65 2073 6372 616d 626c  ..simple scrambl
+00017f30: 6564 2065 6767 7320 6172 6520 6a75 7374  ed eggs are just
+00017f40: 2066 696e 652e 0a6e 6567 6761 746f 7279   fine..neggatory
+00017f50: 210a 7768 6f6f 7073 2c20 4920 6d65 616e  !.whoops, I mean
+00017f60: 742c 206e 6567 6174 6f72 792e 0a22 2222  t, negatory.."""
+00017f70: 5b31 3a5d 292c 2022 6567 6722 292c 0a20  [1:]), "egg"),. 
+00017f80: 2020 2020 2020 2020 2020 205b 0a20 2020             [.   
+00017f90: 2020 2020 2020 2020 2020 2020 2028 4c49               (LI
+00017fa0: 2827 6920 6c69 6b65 2065 6767 732e 272c  ('i like eggs.',
+00017fb0: 2033 2c20 3129 2c20 2769 206c 696b 6520   3, 1), 'i like 
+00017fc0: 6567 6773 2e27 292c 0a20 2020 2020 2020  eggs.'),.       
+00017fd0: 2020 2020 2020 2020 2028 4c49 2827 7369           (LI('si
+00017fe0: 6d70 6c65 2073 6372 616d 626c 6564 2065  mple scrambled e
+00017ff0: 6767 7320 6172 6520 6a75 7374 2066 696e  ggs are just fin
+00018000: 652e 272c 2035 2c20 3129 2c20 2773 696d  e.', 5, 1), 'sim
+00018010: 706c 6520 7363 7261 6d62 6c65 6420 6567  ple scrambled eg
+00018020: 6773 2061 7265 206a 7573 7420 6669 6e65  gs are just fine
+00018030: 2e27 292c 0a20 2020 2020 2020 2020 2020  .'),.           
+00018040: 2020 2020 2028 4c49 2827 6e65 6767 6174       (LI('neggat
+00018050: 6f72 7921 272c 2036 2c20 3129 2c20 276e  ory!', 6, 1), 'n
+00018060: 6567 6761 746f 7279 2127 292c 0a20 2020  eggatory!'),.   
+00018070: 2020 2020 2020 2020 205d 0a20 2020 2020           ].     
+00018080: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
+00018090: 2020 7465 7374 2862 6967 2e6c 696e 6573    test(big.lines
+000180a0: 5f63 6f6e 7461 696e 696e 6728 6269 672e  _containing(big.
+000180b0: 6c69 6e65 7328 2222 220a 6865 6c6c 6f20  lines(""".hello 
+000180c0: 796f 6c6b 730a 7768 6174 2064 6f20 796f  yolks.what do yo
+000180d0: 7520 6861 7665 2074 6f20 7361 792c 2063  u have to say, c
+000180e0: 6861 6d70 3f0a 6920 6c69 6b65 2065 6767  hamp?.i like egg
+000180f0: 732e 0a74 6865 7920 646f 6e27 7420 6861  s..they don't ha
+00018100: 7665 2074 6f20 6265 2066 616e 6379 2e0a  ve to be fancy..
+00018110: 7369 6d70 6c65 2073 6372 616d 626c 6564  simple scrambled
+00018120: 2065 6767 7320 6172 6520 6a75 7374 2066   eggs are just f
+00018130: 696e 652e 0a6e 6567 6761 746f 7279 210a  ine..neggatory!.
+00018140: 7768 6f6f 7073 2c20 4920 6d65 616e 742c  whoops, I meant,
+00018150: 206e 6567 6174 6f72 792e 0a22 2222 5b31   negatory.."""[1
+00018160: 3a5d 292c 2022 6567 6722 2c20 696e 7665  :]), "egg", inve
+00018170: 7274 3d54 7275 6529 2c0a 2020 2020 2020  rt=True),.      
+00018180: 2020 2020 2020 5b0a 2020 2020 2020 2020        [.        
+00018190: 2020 2020 2020 2020 284c 4928 2768 656c          (LI('hel
+000181a0: 6c6f 2079 6f6c 6b73 272c 2031 2c20 3129  lo yolks', 1, 1)
+000181b0: 2c20 2768 656c 6c6f 2079 6f6c 6b73 2729  , 'hello yolks')
+000181c0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+000181d0: 2020 284c 4928 2777 6861 7420 646f 2079    (LI('what do y
+000181e0: 6f75 2068 6176 6520 746f 2073 6179 2c20  ou have to say, 
+000181f0: 6368 616d 703f 272c 2032 2c20 3129 2c20  champ?', 2, 1), 
+00018200: 2777 6861 7420 646f 2079 6f75 2068 6176  'what do you hav
+00018210: 6520 746f 2073 6179 2c20 6368 616d 703f  e to say, champ?
+00018220: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
+00018230: 2020 2020 284c 4928 2274 6865 7920 646f      (LI("they do
+00018240: 6e27 7420 6861 7665 2074 6f20 6265 2066  n't have to be f
+00018250: 616e 6379 2e22 2c20 342c 2031 292c 2022  ancy.", 4, 1), "
+00018260: 7468 6579 2064 6f6e 2774 2068 6176 6520  they don't have 
+00018270: 746f 2062 6520 6661 6e63 792e 2229 2c0a  to be fancy."),.
+00018280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018290: 284c 4928 2777 686f 6f70 732c 2049 206d  (LI('whoops, I m
+000182a0: 6561 6e74 2c20 6e65 6761 746f 7279 2e27  eant, negatory.'
+000182b0: 2c20 372c 2031 292c 2027 7768 6f6f 7073  , 7, 1), 'whoops
+000182c0: 2c20 4920 6d65 616e 742c 206e 6567 6174  , I meant, negat
+000182d0: 6f72 792e 2729 2c0a 2020 2020 2020 2020  ory.'),.        
+000182e0: 2020 2020 2020 2020 284c 4928 2727 2c20          (LI('', 
+000182f0: 382c 2031 292c 2027 2729 2c0a 2020 2020  8, 1), ''),.    
+00018300: 2020 2020 2020 2020 5d0a 2020 2020 2020          ].      
+00018310: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
+00018320: 2074 6573 7428 6269 672e 6c69 6e65 735f   test(big.lines_
+00018330: 6772 6570 2862 6967 2e6c 696e 6573 2822  grep(big.lines("
+00018340: 2222 0a68 656c 6c6f 2079 6f6c 6b73 0a77  "".hello yolks.w
+00018350: 6861 7420 646f 2079 6f75 2068 6176 6520  hat do you have 
+00018360: 746f 2073 6179 2c20 6368 616d 703f 0a69  to say, champ?.i
+00018370: 206c 696b 6520 6567 6773 2e0a 7468 6579   like eggs..they
+00018380: 2064 6f6e 2774 2068 6176 6520 746f 2062   don't have to b
+00018390: 6520 6661 6e63 792e 0a73 696d 706c 6520  e fancy..simple 
+000183a0: 7363 7261 6d62 6c65 6420 6567 6773 2061  scrambled eggs a
+000183b0: 7265 206a 7573 7420 6669 6e65 2e0a 6e65  re just fine..ne
+000183c0: 6767 6174 6f72 7921 0a77 686f 6f70 732c  ggatory!.whoops,
+000183d0: 2049 206d 6561 6e74 2c20 6e65 6761 746f   I meant, negato
+000183e0: 7279 2e0a 2222 225b 313a 5d29 2c20 2265  ry.."""[1:]), "e
+000183f0: 672b 2229 2c0a 2020 2020 2020 2020 2020  g+"),.          
+00018400: 2020 5b0a 2020 2020 2020 2020 2020 2020    [.            
+00018410: 2020 2020 284c 4928 2769 206c 696b 6520      (LI('i like 
+00018420: 6567 6773 2e27 2c20 332c 2031 292c 2027  eggs.', 3, 1), '
+00018430: 6920 6c69 6b65 2065 6767 732e 2729 2c0a  i like eggs.'),.
+00018440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018450: 284c 4928 2773 696d 706c 6520 7363 7261  (LI('simple scra
+00018460: 6d62 6c65 6420 6567 6773 2061 7265 206a  mbled eggs are j
+00018470: 7573 7420 6669 6e65 2e27 2c20 352c 2031  ust fine.', 5, 1
+00018480: 292c 2027 7369 6d70 6c65 2073 6372 616d  ), 'simple scram
+00018490: 626c 6564 2065 6767 7320 6172 6520 6a75  bled eggs are ju
+000184a0: 7374 2066 696e 652e 2729 2c0a 2020 2020  st fine.'),.    
+000184b0: 2020 2020 2020 2020 2020 2020 284c 4928              (LI(
+000184c0: 276e 6567 6761 746f 7279 2127 2c20 362c  'neggatory!', 6,
+000184d0: 2031 292c 2027 6e65 6767 6174 6f72 7921   1), 'neggatory!
+000184e0: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
+000184f0: 2020 2020 284c 4928 2777 686f 6f70 732c      (LI('whoops,
+00018500: 2049 206d 6561 6e74 2c20 6e65 6761 746f   I meant, negato
+00018510: 7279 2e27 2c20 372c 2031 292c 2027 7768  ry.', 7, 1), 'wh
+00018520: 6f6f 7073 2c20 4920 6d65 616e 742c 206e  oops, I meant, n
+00018530: 6567 6174 6f72 792e 2729 2c0a 2020 2020  egatory.'),.    
+00018540: 2020 2020 2020 2020 5d0a 2020 2020 2020          ].      
+00018550: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
+00018560: 2074 6573 7428 6269 672e 6c69 6e65 735f   test(big.lines_
+00018570: 6772 6570 2862 6967 2e6c 696e 6573 2822  grep(big.lines("
+00018580: 2222 0a68 656c 6c6f 2079 6f6c 6b73 0a77  "".hello yolks.w
+00018590: 6861 7420 646f 2079 6f75 2068 6176 6520  hat do you have 
+000185a0: 746f 2073 6179 2c20 6368 616d 703f 0a69  to say, champ?.i
+000185b0: 206c 696b 6520 6567 6773 2e0a 7468 6579   like eggs..they
+000185c0: 2064 6f6e 2774 2068 6176 6520 746f 2062   don't have to b
+000185d0: 6520 6661 6e63 792e 0a73 696d 706c 6520  e fancy..simple 
+000185e0: 7363 7261 6d62 6c65 6420 6567 6773 2061  scrambled eggs a
+000185f0: 7265 206a 7573 7420 6669 6e65 2e0a 6e65  re just fine..ne
+00018600: 6767 6174 6f72 7921 0a77 686f 6f70 732c  ggatory!.whoops,
+00018610: 2049 206d 6561 6e74 2c20 6e65 6761 746f   I meant, negato
+00018620: 7279 2e0a 2222 225b 313a 5d29 2c20 2265  ry.."""[1:]), "e
+00018630: 672b 222c 2069 6e76 6572 743d 5472 7565  g+", invert=True
+00018640: 292c 0a20 2020 2020 2020 2020 2020 205b  ),.            [
+00018650: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00018660: 2028 4c49 2827 6865 6c6c 6f20 796f 6c6b   (LI('hello yolk
+00018670: 7327 2c20 312c 2031 292c 2027 6865 6c6c  s', 1, 1), 'hell
+00018680: 6f20 796f 6c6b 7327 292c 0a20 2020 2020  o yolks'),.     
+00018690: 2020 2020 2020 2020 2020 2028 4c49 2827             (LI('
+000186a0: 7768 6174 2064 6f20 796f 7520 6861 7665  what do you have
+000186b0: 2074 6f20 7361 792c 2063 6861 6d70 3f27   to say, champ?'
+000186c0: 2c20 322c 2031 292c 2027 7768 6174 2064  , 2, 1), 'what d
+000186d0: 6f20 796f 7520 6861 7665 2074 6f20 7361  o you have to sa
+000186e0: 792c 2063 6861 6d70 3f27 292c 0a20 2020  y, champ?'),.   
+000186f0: 2020 2020 2020 2020 2020 2020 2028 4c49               (LI
+00018700: 2822 7468 6579 2064 6f6e 2774 2068 6176  ("they don't hav
+00018710: 6520 746f 2062 6520 6661 6e63 792e 222c  e to be fancy.",
+00018720: 2034 2c20 3129 2c20 2274 6865 7920 646f   4, 1), "they do
+00018730: 6e27 7420 6861 7665 2074 6f20 6265 2066  n't have to be f
+00018740: 616e 6379 2e22 292c 0a20 2020 2020 2020  ancy."),.       
+00018750: 2020 2020 2020 2020 2028 4c49 2827 272c           (LI('',
+00018760: 2038 2c20 3129 2c20 2727 292c 0a20 2020   8, 1), ''),.   
+00018770: 2020 2020 2020 2020 205d 0a20 2020 2020           ].     
+00018780: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
+00018790: 2020 7465 7374 2862 6967 2e6c 696e 6573    test(big.lines
+000187a0: 5f73 6f72 7428 6269 672e 6c69 6e65 7328  _sort(big.lines(
+000187b0: 2222 220a 636f 726d 6f72 616e 740a 6669  """.cormorant.fi
+000187c0: 7265 666f 780a 616c 6c69 6761 746f 720a  refox.alligator.
+000187d0: 6469 706c 6f64 6f63 7573 0a65 6c65 7068  diplodocus.eleph
+000187e0: 616e 740a 6769 7261 6666 650a 6261 7272  ant.giraffe.barr
+000187f0: 6163 7564 610a 6875 6d6d 696e 6762 6972  acuda.hummingbir
+00018800: 640a 2222 225b 313a 2d31 5d29 292c 0a20  d."""[1:-1])),. 
+00018810: 2020 2020 2020 2020 2020 205b 0a20 2020             [.   
+00018820: 2020 2020 2020 2020 2020 2020 204c 2827               L('
+00018830: 616c 6c69 6761 746f 7227 2c20 3329 2c0a  alligator', 3),.
+00018840: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018850: 4c28 2762 6172 7261 6375 6461 272c 2037  L('barracuda', 7
+00018860: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+00018870: 2020 204c 2827 636f 726d 6f72 616e 7427     L('cormorant'
+00018880: 2c20 3129 2c0a 2020 2020 2020 2020 2020  , 1),.          
+00018890: 2020 2020 2020 4c28 2764 6970 6c6f 646f        L('diplodo
+000188a0: 6375 7327 2c20 3429 2c0a 2020 2020 2020  cus', 4),.      
+000188b0: 2020 2020 2020 2020 2020 4c28 2765 6c65            L('ele
+000188c0: 7068 616e 7427 2c20 3529 2c0a 2020 2020  phant', 5),.    
+000188d0: 2020 2020 2020 2020 2020 2020 4c28 2766              L('f
+000188e0: 6972 6566 6f78 272c 2032 292c 0a20 2020  irefox', 2),.   
+000188f0: 2020 2020 2020 2020 2020 2020 204c 2827               L('
+00018900: 6769 7261 6666 6527 2c20 3629 2c0a 2020  giraffe', 6),.  
+00018910: 2020 2020 2020 2020 2020 2020 2020 4c28                L(
+00018920: 2768 756d 6d69 6e67 6269 7264 272c 2038  'hummingbird', 8
+00018930: 292c 0a20 2020 2020 2020 2020 2020 205d  ),.            ]
+00018940: 0a20 2020 2020 2020 2020 2020 2029 0a0a  .            )..
+00018950: 2020 2020 2020 2020 7465 7374 2862 6967          test(big
+00018960: 2e6c 696e 6573 5f73 6f72 7428 6269 672e  .lines_sort(big.
+00018970: 6c69 6e65 7328 2222 220a 636f 726d 6f72  lines(""".cormor
+00018980: 616e 740a 6669 7265 666f 780a 616c 6c69  ant.firefox.alli
+00018990: 6761 746f 720a 6469 706c 6f64 6f63 7573  gator.diplodocus
+000189a0: 0a65 6c65 7068 616e 740a 6769 7261 6666  .elephant.giraff
+000189b0: 650a 6261 7272 6163 7564 610a 6875 6d6d  e.barracuda.humm
+000189c0: 696e 6762 6972 640a 2222 225b 313a 2d31  ingbird."""[1:-1
+000189d0: 5d29 2c20 7265 7665 7273 653d 5472 7565  ]), reverse=True
+000189e0: 292c 0a20 2020 2020 2020 2020 2020 205b  ),.            [
+000189f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00018a00: 204c 2827 6875 6d6d 696e 6762 6972 6427   L('hummingbird'
+00018a10: 2c20 3829 2c0a 2020 2020 2020 2020 2020  , 8),.          
+00018a20: 2020 2020 2020 4c28 2767 6972 6166 6665        L('giraffe
+00018a30: 272c 2036 292c 0a20 2020 2020 2020 2020  ', 6),.         
+00018a40: 2020 2020 2020 204c 2827 6669 7265 666f         L('firefo
+00018a50: 7827 2c20 3229 2c0a 2020 2020 2020 2020  x', 2),.        
+00018a60: 2020 2020 2020 2020 4c28 2765 6c65 7068          L('eleph
+00018a70: 616e 7427 2c20 3529 2c0a 2020 2020 2020  ant', 5),.      
+00018a80: 2020 2020 2020 2020 2020 4c28 2764 6970            L('dip
+00018a90: 6c6f 646f 6375 7327 2c20 3429 2c0a 2020  lodocus', 4),.  
+00018aa0: 2020 2020 2020 2020 2020 2020 2020 4c28                L(
+00018ab0: 2763 6f72 6d6f 7261 6e74 272c 2031 292c  'cormorant', 1),
+00018ac0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00018ad0: 204c 2827 6261 7272 6163 7564 6127 2c20   L('barracuda', 
+00018ae0: 3729 2c0a 2020 2020 2020 2020 2020 2020  7),.            
+00018af0: 2020 2020 4c28 2761 6c6c 6967 6174 6f72      L('alligator
+00018b00: 272c 2033 292c 0a20 2020 2020 2020 2020  ', 3),.         
+00018b10: 2020 205d 0a20 2020 2020 2020 2020 2020     ].           
+00018b20: 2029 0a0a 2020 2020 2020 2020 7465 7374   )..        test
+00018b30: 2862 6967 2e6c 696e 6573 5f72 7374 7269  (big.lines_rstri
+00018b40: 7028 6269 672e 6c69 6e65 7328 0a22 2020  p(big.lines(."  
+00018b50: 2020 6120 3d20 6220 205c 6e22 0a22 2020    a = b  \n"."  
+00018b60: 2020 6320 3d20 6420 2020 2020 5c6e 220a    c = d     \n".
+00018b70: 2929 2c0a 2020 2020 2020 2020 2020 2020  )),.            
+00018b80: 5b0a 2020 2020 2020 2020 2020 2020 284c  [.            (L
+00018b90: 4928 2720 2020 2061 203d 2062 2020 272c  I('    a = b  ',
+00018ba0: 2020 2020 312c 2031 292c 2027 2020 2020      1, 1), '    
+00018bb0: 6120 3d20 6227 292c 0a20 2020 2020 2020  a = b'),.       
+00018bc0: 2020 2020 2028 4c49 2827 2020 2020 6320       (LI('    c 
+00018bd0: 3d20 6420 2020 2020 272c 2032 2c20 3129  = d     ', 2, 1)
+00018be0: 2c20 2720 2020 2063 203d 2064 2729 2c0a  , '    c = d'),.
+00018bf0: 2020 2020 2020 2020 2020 2020 284c 4928              (LI(
+00018c00: 2727 2c20 2020 2020 2020 2020 2020 2020  '',             
+00018c10: 2020 332c 2031 292c 2027 2729 2c0a 2020    3, 1), ''),.  
+00018c20: 2020 2020 2020 2020 2020 5d29 0a0a 2020            ])..  
+00018c30: 2020 2020 2020 7465 7374 2862 6967 2e6c        test(big.l
+00018c40: 696e 6573 5f73 7472 6970 2862 6967 2e6c  ines_strip(big.l
+00018c50: 696e 6573 280a 2220 2020 2061 203d 2062  ines(."    a = b
+00018c60: 2020 5c6e 220a 2220 2020 2063 203d 2064    \n"."    c = d
+00018c70: 2020 2020 205c 6e22 0a29 292c 0a20 2020       \n".)),.   
+00018c80: 2020 2020 2020 2020 205b 0a20 2020 2020           [.     
+00018c90: 2020 2020 2020 2028 4c49 2827 2020 2020         (LI('    
+00018ca0: 6120 3d20 6220 2027 2c20 2020 2031 2c20  a = b  ',    1, 
+00018cb0: 352c 206c 6561 6469 6e67 3d27 2020 2020  5, leading='    
+00018cc0: 2729 2c20 2761 203d 2062 2729 2c0a 2020  '), 'a = b'),.  
+00018cd0: 2020 2020 2020 2020 2020 284c 4928 2720            (LI(' 
+00018ce0: 2020 2063 203d 2064 2020 2020 2027 2c20     c = d     ', 
+00018cf0: 322c 2035 2c20 6c65 6164 696e 673d 2720  2, 5, leading=' 
+00018d00: 2020 2027 292c 2027 6320 3d20 6427 292c     '), 'c = d'),
+00018d10: 0a20 2020 2020 2020 2020 2020 2028 4c49  .            (LI
+00018d20: 2827 272c 2020 2020 2020 2020 2020 2020  ('',            
+00018d30: 2020 2033 2c20 3129 2c20 2727 292c 0a20     3, 1), ''),. 
+00018d40: 2020 2020 2020 2020 2020 205d 290a 0a20             ]).. 
+00018d50: 2020 2020 2020 2074 6573 7428 6269 672e         test(big.
+00018d60: 6c69 6e65 735f 6669 6c74 6572 5f65 6d70  lines_filter_emp
+00018d70: 7479 5f6c 696e 6573 2862 6967 2e6c 696e  ty_lines(big.lin
+00018d80: 6573 2822 2222 0a0a 2020 2020 6120 3d20  es("""..    a = 
+00018d90: 620a 0a0a 2020 2020 6320 3d20 640a 0a22  b...    c = d.."
+00018da0: 2222 5b31 3a5d 2929 2c0a 2020 2020 2020  ""[1:])),.      
+00018db0: 2020 2020 2020 5b0a 2020 2020 2020 2020        [.        
+00018dc0: 2020 2020 284c 4928 2720 2020 2061 203d      (LI('    a =
+00018dd0: 2062 272c 2032 2c20 3129 2c20 2720 2020   b', 2, 1), '   
+00018de0: 2061 203d 2062 2729 2c0a 2020 2020 2020   a = b'),.      
+00018df0: 2020 2020 2020 284c 4928 2720 2020 2063        (LI('    c
+00018e00: 203d 2064 272c 2035 2c20 3129 2c20 2720   = d', 5, 1), ' 
+00018e10: 2020 2063 203d 2064 2729 2c0a 2020 2020     c = d'),.    
+00018e20: 2020 2020 2020 2020 5d29 0a0a 2020 2020          ])..    
+00018e30: 2020 2020 7465 7374 2862 6967 2e6c 696e      test(big.lin
+00018e40: 6573 5f63 6f6e 7665 7274 5f74 6162 735f  es_convert_tabs_
+00018e50: 746f 5f73 7061 6365 7328 6269 672e 6c69  to_spaces(big.li
+00018e60: 6e65 7328 0a20 2020 2020 2020 2020 2020  nes(.           
+00018e70: 2022 5c74 6669 7273 7420 6c69 6e65 5c6e   "\tfirst line\n
+00018e80: 220a 2020 2020 2020 2020 2020 2020 225c  ".            "\
+00018e90: 745c 7473 6563 6f6e 6420 6c69 6e65 5c6e  t\tsecond line\n
+00018ea0: 220a 2020 2020 2020 2020 2020 2020 2220  ".            " 
+00018eb0: 205c 7474 6869 7264 206c 696e 655c 6e22   \tthird line\n"
+00018ec0: 2c0a 2020 2020 2020 2020 2020 2020 7461  ,.            ta
+00018ed0: 625f 7769 6474 683d 3829 292c 0a20 2020  b_width=8)),.   
+00018ee0: 2020 2020 2020 2020 205b 0a20 2020 2020           [.     
+00018ef0: 2020 2020 2020 2020 2020 2028 4c49 2822             (LI("
+00018f00: 5c74 6669 7273 7420 6c69 6e65 222c 2031  \tfirst line", 1
+00018f10: 2c20 3129 2c20 2220 2020 2020 2020 2066  , 1), "        f
+00018f20: 6972 7374 206c 696e 6522 292c 0a20 2020  irst line"),.   
+00018f30: 2020 2020 2020 2020 2020 2020 2028 4c49               (LI
+00018f40: 2822 5c74 5c74 7365 636f 6e64 206c 696e  ("\t\tsecond lin
+00018f50: 6522 2c20 322c 2031 292c 2022 2020 2020  e", 2, 1), "    
+00018f60: 2020 2020 2020 2020 2020 2020 7365 636f              seco
+00018f70: 6e64 206c 696e 6522 292c 0a20 2020 2020  nd line"),.     
+00018f80: 2020 2020 2020 2020 2020 2028 4c49 2822             (LI("
+00018f90: 2020 5c74 7468 6972 6420 6c69 6e65 222c    \tthird line",
+00018fa0: 2033 2c20 3129 2c20 2220 2020 2020 2020   3, 1), "       
+00018fb0: 2074 6869 7264 206c 696e 6522 292c 0a20   third line"),. 
+00018fc0: 2020 2020 2020 2020 2020 2020 2020 2028                 (
+00018fd0: 4c49 2822 222c 2034 2c20 3129 2c20 2222  LI("", 4, 1), ""
+00018fe0: 292c 0a20 2020 2020 2020 2020 2020 205d  ),.            ]
+00018ff0: 290a 0a20 2020 2020 2020 2074 6573 7428  )..        test(
+00019000: 6269 672e 6c69 6e65 735f 7374 7269 705f  big.lines_strip_
+00019010: 636f 6d6d 656e 7473 2862 6967 2e6c 696e  comments(big.lin
+00019020: 6573 2822 2222 0a66 6f72 2078 2069 6e20  es(""".for x in 
+00019030: 7261 6e67 6528 3529 3a20 2320 7468 6973  range(5): # this
+00019040: 2069 7320 6120 636f 6d6d 656e 740a 2020   is a comment.  
+00019050: 2020 7072 696e 7428 2223 2074 6869 7320    print("# this 
+00019060: 6973 2071 756f 7465 6422 2c20 7829 0a20  is quoted", x). 
+00019070: 2020 2070 7269 6e74 2822 2229 2023 2074     print("") # t
+00019080: 6869 7320 2263 6f6d 6d65 6e74 2220 6973  his "comment" is
+00019090: 2075 7365 6c65 7373 0a20 2020 2070 7269   useless.    pri
+000190a0: 6e74 286e 6f5f 636f 6d6d 656e 7473 5f6f  nt(no_comments_o
+000190b0: 725f 7175 6f74 6573 5f6f 6e5f 7468 6973  r_quotes_on_this
+000190c0: 5f6c 696e 6529 0a22 2222 5b31 3a5d 292c  _line)."""[1:]),
+000190d0: 2028 2223 222c 2022 2f2f 2229 292c 0a20   ("#", "//")),. 
+000190e0: 2020 2020 2020 2020 2020 205b 0a20 2020             [.   
+000190f0: 2020 2020 2020 2020 2020 2020 2028 4c49               (LI
+00019100: 286c 696e 653d 2766 6f72 2078 2069 6e20  (line='for x in 
+00019110: 7261 6e67 6528 3529 3a20 2320 7468 6973  range(5): # this
+00019120: 2069 7320 6120 636f 6d6d 656e 7427 2c20   is a comment', 
+00019130: 6c69 6e65 5f6e 756d 6265 723d 312c 2063  line_number=1, c
+00019140: 6f6c 756d 6e5f 6e75 6d62 6572 3d31 2c20  olumn_number=1, 
+00019150: 636f 6d6d 656e 743d 2723 2074 6869 7320  comment='# this 
+00019160: 6973 2061 2063 6f6d 6d65 6e74 2729 2c0a  is a comment'),.
+00019170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019180: 2020 2020 2766 6f72 2078 2069 6e20 7261      'for x in ra
+00019190: 6e67 6528 3529 3a27 292c 0a20 2020 2020  nge(5):'),.     
+000191a0: 2020 2020 2020 2020 2020 2028 4c49 286c             (LI(l
+000191b0: 696e 653d 2720 2020 2070 7269 6e74 2822  ine='    print("
+000191c0: 2320 7468 6973 2069 7320 7175 6f74 6564  # this is quoted
+000191d0: 222c 2078 2927 2c20 6c69 6e65 5f6e 756d  ", x)', line_num
+000191e0: 6265 723d 322c 2063 6f6c 756d 6e5f 6e75  ber=2, column_nu
+000191f0: 6d62 6572 3d31 2c20 636f 6d6d 656e 743d  mber=1, comment=
+00019200: 2727 292c 0a20 2020 2020 2020 2020 2020  ''),.           
+00019210: 2020 2020 2020 2020 2027 2020 2020 7072           '    pr
+00019220: 696e 7428 2223 2074 6869 7320 6973 2071  int("# this is q
+00019230: 756f 7465 6422 2c20 7829 2729 2c0a 2020  uoted", x)'),.  
+00019240: 2020 2020 2020 2020 2020 2020 2020 284c                (L
+00019250: 4928 6c69 6e65 3d27 2020 2020 7072 696e  I(line='    prin
+00019260: 7428 2222 2920 2320 7468 6973 2022 636f  t("") # this "co
+00019270: 6d6d 656e 7422 2069 7320 7573 656c 6573  mment" is useles
+00019280: 7327 2c20 6c69 6e65 5f6e 756d 6265 723d  s', line_number=
+00019290: 332c 2063 6f6c 756d 6e5f 6e75 6d62 6572  3, column_number
+000192a0: 3d31 2c20 636f 6d6d 656e 743d 2723 2074  =1, comment='# t
+000192b0: 6869 7320 2263 6f6d 6d65 6e74 2220 6973  his "comment" is
+000192c0: 2075 7365 6c65 7373 2729 2c0a 2020 2020   useless'),.    
+000192d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000192e0: 2720 2020 2070 7269 6e74 2822 2229 2729  '    print("")')
+000192f0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00019300: 2020 284c 4928 6c69 6e65 3d27 2020 2020    (LI(line='    
+00019310: 7072 696e 7428 6e6f 5f63 6f6d 6d65 6e74  print(no_comment
+00019320: 735f 6f72 5f71 756f 7465 735f 6f6e 5f74  s_or_quotes_on_t
+00019330: 6869 735f 6c69 6e65 2927 2c20 6c69 6e65  his_line)', line
+00019340: 5f6e 756d 6265 723d 342c 2063 6f6c 756d  _number=4, colum
+00019350: 6e5f 6e75 6d62 6572 3d31 2c20 636f 6d6d  n_number=1, comm
+00019360: 656e 743d 2727 292c 0a20 2020 2020 2020  ent=''),.       
+00019370: 2020 2020 2020 2020 2020 2020 2027 2020               '  
+00019380: 2020 7072 696e 7428 6e6f 5f63 6f6d 6d65    print(no_comme
+00019390: 6e74 735f 6f72 5f71 756f 7465 735f 6f6e  nts_or_quotes_on
+000193a0: 5f74 6869 735f 6c69 6e65 2927 292c 0a20  _this_line)'),. 
+000193b0: 2020 2020 2020 2020 2020 2020 2020 2028                 (
+000193c0: 4c49 286c 696e 653d 2727 2c20 6c69 6e65  LI(line='', line
+000193d0: 5f6e 756d 6265 723d 352c 2063 6f6c 756d  _number=5, colum
+000193e0: 6e5f 6e75 6d62 6572 3d31 2c20 636f 6d6d  n_number=1, comm
+000193f0: 656e 743d 2727 292c 0a20 2020 2020 2020  ent=''),.       
+00019400: 2020 2020 2020 2020 2020 2020 2027 2729               '')
+00019410: 0a20 2020 2020 2020 2020 2020 205d 290a  .            ]).
+00019420: 0a20 2020 2020 2020 2074 6573 7428 6269  .        test(bi
+00019430: 672e 6c69 6e65 735f 7374 7269 705f 636f  g.lines_strip_co
+00019440: 6d6d 656e 7473 2862 6967 2e6c 696e 6573  mments(big.lines
+00019450: 2822 2222 0a66 6f72 2078 2069 6e20 7261  (""".for x in ra
+00019460: 6e67 6528 3529 3a20 2320 7468 6973 2069  nge(5): # this i
+00019470: 7320 6120 636f 6d6d 656e 740a 2020 2020  s a comment.    
+00019480: 7072 696e 7428 2223 2074 6869 7320 6973  print("# this is
+00019490: 2071 756f 7465 6422 2c20 7829 0a20 2020   quoted", x).   
+000194a0: 2070 7269 6e74 2822 2229 2023 2074 6869   print("") # thi
+000194b0: 7320 2263 6f6d 6d65 6e74 2220 6973 2075  s "comment" is u
+000194c0: 7365 6c65 7373 0a20 2020 2070 7269 6e74  seless.    print
+000194d0: 286e 6f5f 636f 6d6d 656e 7473 5f6f 725f  (no_comments_or_
+000194e0: 7175 6f74 6573 5f6f 6e5f 7468 6973 5f6c  quotes_on_this_l
+000194f0: 696e 6529 0a22 2222 5b31 3a5d 292c 2028  ine)."""[1:]), (
+00019500: 2223 222c 2022 2f2f 2229 2c20 7175 6f74  "#", "//"), quot
+00019510: 6573 3d4e 6f6e 6529 2c0a 2020 2020 2020  es=None),.      
+00019520: 2020 2020 2020 5b0a 2020 2020 2020 2020        [.        
+00019530: 2020 2020 2020 2020 284c 4928 6c69 6e65          (LI(line
+00019540: 3d27 666f 7220 7820 696e 2072 616e 6765  ='for x in range
+00019550: 2835 293a 2023 2074 6869 7320 6973 2061  (5): # this is a
+00019560: 2063 6f6d 6d65 6e74 272c 206c 696e 655f   comment', line_
+00019570: 6e75 6d62 6572 3d31 2c20 636f 6c75 6d6e  number=1, column
+00019580: 5f6e 756d 6265 723d 312c 2063 6f6d 6d65  _number=1, comme
+00019590: 6e74 3d27 2320 7468 6973 2069 7320 6120  nt='# this is a 
+000195a0: 636f 6d6d 656e 7427 292c 0a20 2020 2020  comment'),.     
+000195b0: 2020 2020 2020 2020 2020 2020 2027 666f               'fo
+000195c0: 7220 7820 696e 2072 616e 6765 2835 293a  r x in range(5):
+000195d0: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
+000195e0: 2020 2020 284c 4928 6c69 6e65 3d27 2020      (LI(line='  
+000195f0: 2020 7072 696e 7428 2223 2074 6869 7320    print("# this 
+00019600: 6973 2071 756f 7465 6422 2c20 7829 272c  is quoted", x)',
+00019610: 206c 696e 655f 6e75 6d62 6572 3d32 2c20   line_number=2, 
+00019620: 636f 6c75 6d6e 5f6e 756d 6265 723d 312c  column_number=1,
+00019630: 2063 6f6d 6d65 6e74 3d27 2320 7468 6973   comment='# this
+00019640: 2069 7320 7175 6f74 6564 222c 2078 2927   is quoted", x)'
+00019650: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+00019660: 2020 2020 2020 2027 2020 2020 7072 696e         '    prin
+00019670: 7428 2227 292c 0a20 2020 2020 2020 2020  t("'),.         
+00019680: 2020 2020 2020 2028 4c49 286c 696e 653d         (LI(line=
+00019690: 2720 2020 2070 7269 6e74 2822 2229 2023  '    print("") #
+000196a0: 2074 6869 7320 2263 6f6d 6d65 6e74 2220   this "comment" 
+000196b0: 6973 2075 7365 6c65 7373 272c 206c 696e  is useless', lin
+000196c0: 655f 6e75 6d62 6572 3d33 2c20 636f 6c75  e_number=3, colu
+000196d0: 6d6e 5f6e 756d 6265 723d 312c 2063 6f6d  mn_number=1, com
+000196e0: 6d65 6e74 3d27 2320 7468 6973 2022 636f  ment='# this "co
+000196f0: 6d6d 656e 7422 2069 7320 7573 656c 6573  mment" is useles
+00019700: 7327 292c 0a20 2020 2020 2020 2020 2020  s'),.           
+00019710: 2020 2020 2020 2020 2027 2020 2020 7072           '    pr
+00019720: 696e 7428 2222 2927 292c 0a20 2020 2020  int("")'),.     
+00019730: 2020 2020 2020 2020 2020 2028 4c49 286c             (LI(l
+00019740: 696e 653d 2720 2020 2070 7269 6e74 286e  ine='    print(n
+00019750: 6f5f 636f 6d6d 656e 7473 5f6f 725f 7175  o_comments_or_qu
+00019760: 6f74 6573 5f6f 6e5f 7468 6973 5f6c 696e  otes_on_this_lin
+00019770: 6529 272c 206c 696e 655f 6e75 6d62 6572  e)', line_number
+00019780: 3d34 2c20 636f 6c75 6d6e 5f6e 756d 6265  =4, column_numbe
+00019790: 723d 312c 2063 6f6d 6d65 6e74 3d27 2729  r=1, comment='')
+000197a0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+000197b0: 2020 2020 2020 2720 2020 2070 7269 6e74        '    print
+000197c0: 286e 6f5f 636f 6d6d 656e 7473 5f6f 725f  (no_comments_or_
+000197d0: 7175 6f74 6573 5f6f 6e5f 7468 6973 5f6c  quotes_on_this_l
+000197e0: 696e 6529 2729 2c0a 2020 2020 2020 2020  ine)'),.        
+000197f0: 2020 2020 2020 2020 284c 4928 6c69 6e65          (LI(line
+00019800: 3d27 272c 206c 696e 655f 6e75 6d62 6572  ='', line_number
+00019810: 3d35 2c20 636f 6c75 6d6e 5f6e 756d 6265  =5, column_numbe
+00019820: 723d 312c 2063 6f6d 6d65 6e74 3d27 2729  r=1, comment='')
+00019830: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00019840: 2020 2020 2020 2727 292c 0a20 2020 2020        ''),.     
+00019850: 2020 2020 2020 205d 290a 0a20 2020 2020         ])..     
+00019860: 2020 2077 6974 6820 7365 6c66 2e61 7373     with self.ass
+00019870: 6572 7452 6169 7365 7328 5661 6c75 6545  ertRaises(ValueE
+00019880: 7272 6f72 293a 0a20 2020 2020 2020 2020  rror):.         
+00019890: 2020 2074 6573 7428 6269 672e 6c69 6e65     test(big.line
+000198a0: 735f 7374 7269 705f 636f 6d6d 656e 7473  s_strip_comments
+000198b0: 2862 6967 2e6c 696e 6573 2822 615c 6e62  (big.lines("a\nb
+000198c0: 5c6e 2229 2c20 4e6f 6e65 292c 205b 5d29  \n"), None), [])
+000198d0: 0a0a 2020 2020 2020 2020 7465 7374 2862  ..        test(b
+000198e0: 6967 2e6c 696e 6573 5f73 7472 6970 5f63  ig.lines_strip_c
+000198f0: 6f6d 6d65 6e74 7328 6269 672e 6c69 6e65  omments(big.line
+00019900: 7328 6222 615c 6e62 2320 6967 6e6f 7265  s(b"a\nb# ignore
+00019910: 645c 6e20 6322 292c 2062 2723 2729 2c0a  d\n c"), b'#'),.
+00019920: 2020 2020 2020 2020 2020 2020 5b0a 2020              [.  
+00019930: 2020 2020 2020 2020 2020 4c28 6227 6127            L(b'a'
+00019940: 2c20 312c 2063 6f6d 6d65 6e74 3d62 2727  , 1, comment=b''
+00019950: 292c 0a20 2020 2020 2020 2020 2020 2028  ),.            (
+00019960: 4c49 2862 2762 2320 6967 6e6f 7265 6427  LI(b'b# ignored'
+00019970: 2c20 322c 2031 2c20 636f 6d6d 656e 743d  , 2, 1, comment=
+00019980: 6227 2320 6967 6e6f 7265 6427 292c 2062  b'# ignored'), b
+00019990: 2762 2729 2c0a 2020 2020 2020 2020 2020  'b'),.          
+000199a0: 2020 4c28 6227 2063 272c 2033 2c20 636f    L(b' c', 3, co
+000199b0: 6d6d 656e 743d 6227 2729 2c0a 2020 2020  mment=b''),.    
+000199c0: 2020 2020 2020 2020 5d0a 2020 2020 2020          ].      
+000199d0: 2020 2020 2020 290a 0a0a 2020 2020 2020        )...      
+000199e0: 2020 7465 7374 2862 6967 2e6c 696e 6573    test(big.lines
+000199f0: 5f66 696c 7465 725f 656d 7074 795f 6c69  _filter_empty_li
+00019a00: 6e65 7328 6269 672e 6c69 6e65 735f 6669  nes(big.lines_fi
+00019a10: 6c74 6572 5f63 6f6d 6d65 6e74 5f6c 696e  lter_comment_lin
+00019a20: 6573 2862 6967 2e6c 696e 6573 5f73 7472  es(big.lines_str
+00019a30: 6970 2862 6967 2e6c 696e 6573 280a 2220  ip(big.lines(." 
+00019a40: 2020 5c6e 2220 2b0a 2220 2020 2061 203d    \n" +."    a =
+00019a50: 2062 205c 6e22 202b 0a22 2020 205c 6e22   b \n" +."   \n"
+00019a60: 202b 0a22 2020 2020 2320 636f 6d6d 656e   +."    # commen
+00019a70: 7420 6c69 6e65 205c 6e22 202b 0a22 2020  t line \n" +."  
+00019a80: 2020 5c6e 2220 2b0a 2220 2020 205c 6e22    \n" +."    \n"
+00019a90: 202b 0a22 2020 2020 6320 3d20 6420 205c   +."    c = d  \
+00019aa0: 6e22 202b 0a22 2020 2020 205c 6e22 2929  n" +."     \n"))
+00019ab0: 2c20 2723 2729 292c 0a20 2020 2020 2020  , '#')),.       
+00019ac0: 2020 2020 205b 0a20 2020 2020 2020 2020       [.         
+00019ad0: 2020 2028 4c49 2827 2020 2020 6120 3d20     (LI('    a = 
+00019ae0: 6220 272c 2020 322c 2035 2c20 6c65 6164  b ',  2, 5, lead
+00019af0: 696e 673d 2720 2020 2027 292c 2027 6120  ing='    '), 'a 
+00019b00: 3d20 6227 292c 0a20 2020 2020 2020 2020  = b'),.         
+00019b10: 2020 2028 4c49 2827 2020 2020 6320 3d20     (LI('    c = 
+00019b20: 6420 2027 2c20 372c 2035 2c20 6c65 6164  d  ', 7, 5, lead
+00019b30: 696e 673d 2720 2020 2027 292c 2027 6320  ing='    '), 'c 
+00019b40: 3d20 6427 292c 0a20 2020 2020 2020 2020  = d'),.         
+00019b50: 2020 205d 290a 0a0a 2020 2020 6465 6620     ])...    def 
+00019b60: 7465 7374 5f6c 696e 6573 5f73 7472 6970  test_lines_strip
+00019b70: 5f69 6e64 656e 7428 7365 6c66 293a 0a20  _indent(self):. 
+00019b80: 2020 2020 2020 2064 6566 2074 6573 7428         def test(
+00019b90: 6c69 6e65 732c 2065 7870 6563 7465 642c  lines, expected,
+00019ba0: 202a 2c20 7461 625f 7769 6474 683d 3829   *, tab_width=8)
+00019bb0: 3a0a 2020 2020 2020 2020 2020 2020 676f  :.            go
+00019bc0: 7420 3d20 6c69 7374 2862 6967 2e6c 696e  t = list(big.lin
+00019bd0: 6573 5f73 7472 6970 5f69 6e64 656e 7428  es_strip_indent(
+00019be0: 6269 672e 6c69 6e65 7328 6c69 6e65 732c  big.lines(lines,
+00019bf0: 2074 6162 5f77 6964 7468 3d74 6162 5f77   tab_width=tab_w
+00019c00: 6964 7468 2929 290a 2020 2020 2020 2020  idth))).        
+00019c10: 2020 2020 7365 6c66 2e61 7373 6572 7445      self.assertE
+00019c20: 7175 616c 2867 6f74 2c20 6578 7065 6374  qual(got, expect
+00019c30: 6564 290a 0a0a 2020 2020 2020 2020 4c69  ed)...        Li
+00019c40: 6e65 496e 666f 203d 2062 6967 2e74 6578  neInfo = big.tex
+00019c50: 742e 4c69 6e65 496e 666f 0a0a 2020 2020  t.LineInfo..    
+00019c60: 2020 2020 6c69 6e65 7320 3d20 2222 220a      lines = """.
+00019c70: 6c65 6674 206d 6172 6769 6e0a 6966 2033  left margin.if 3
+00019c80: 3a0a 2020 2020 7465 7874 0a65 6c73 653a  :.    text.else:
+00019c90: 0a20 2020 2069 6620 313a 0a20 2020 2020  .    if 1:.     
+00019ca0: 2020 2020 206f 7468 6572 2074 6578 740a       other text.
+00019cb0: 2020 2020 2020 2020 2020 6f74 6865 7220            other 
+00019cc0: 7465 7874 0a20 2020 206d 6f72 6520 7465  text.    more te
+00019cd0: 7874 0a20 2020 2020 2064 6966 6665 7265  xt.      differe
+00019ce0: 6e74 2069 6e64 656e 740a 2020 2020 6f75  nt indent.    ou
+00019cf0: 7464 656e 740a 6f75 7464 656e 740a 2020  tdent.outdent.  
+00019d00: 6e65 7720 696e 6465 6e74 0a6f 7574 6465  new indent.outde
+00019d10: 6e74 0a22 2222 0a0a 2020 2020 2020 2020  nt."""..        
+00019d20: 6578 7065 6374 6564 203d 205b 0a20 2020  expected = [.   
+00019d30: 2020 2020 2020 2020 2028 4c69 6e65 496e           (LineIn
+00019d40: 666f 286c 696e 653d 2727 2c20 6c69 6e65  fo(line='', line
+00019d50: 5f6e 756d 6265 723d 312c 2063 6f6c 756d  _number=1, colum
+00019d60: 6e5f 6e75 6d62 6572 3d31 2c20 696e 6465  n_number=1, inde
+00019d70: 6e74 3d30 2c20 6c65 6164 696e 673d 2727  nt=0, leading=''
+00019d80: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+00019d90: 2020 2027 2729 2c0a 2020 2020 2020 2020     ''),.        
+00019da0: 2020 2020 284c 696e 6549 6e66 6f28 6c69      (LineInfo(li
+00019db0: 6e65 3d27 6c65 6674 206d 6172 6769 6e27  ne='left margin'
+00019dc0: 2c20 6c69 6e65 5f6e 756d 6265 723d 322c  , line_number=2,
+00019dd0: 2063 6f6c 756d 6e5f 6e75 6d62 6572 3d31   column_number=1
+00019de0: 2c20 696e 6465 6e74 3d30 2c20 6c65 6164  , indent=0, lead
+00019df0: 696e 673d 2727 292c 0a20 2020 2020 2020  ing=''),.       
+00019e00: 2020 2020 2020 2020 2027 6c65 6674 206d           'left m
+00019e10: 6172 6769 6e27 292c 0a20 2020 2020 2020  argin'),.       
+00019e20: 2020 2020 2028 4c69 6e65 496e 666f 286c       (LineInfo(l
+00019e30: 696e 653d 2769 6620 333a 272c 206c 696e  ine='if 3:', lin
+00019e40: 655f 6e75 6d62 6572 3d33 2c20 636f 6c75  e_number=3, colu
+00019e50: 6d6e 5f6e 756d 6265 723d 312c 2069 6e64  mn_number=1, ind
+00019e60: 656e 743d 302c 206c 6561 6469 6e67 3d27  ent=0, leading='
+00019e70: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
+00019e80: 2020 2020 2769 6620 333a 2729 2c0a 2020      'if 3:'),.  
+00019e90: 2020 2020 2020 2020 2020 284c 696e 6549            (LineI
+00019ea0: 6e66 6f28 6c69 6e65 3d27 2020 2020 7465  nfo(line='    te
+00019eb0: 7874 272c 206c 696e 655f 6e75 6d62 6572  xt', line_number
+00019ec0: 3d34 2c20 636f 6c75 6d6e 5f6e 756d 6265  =4, column_numbe
+00019ed0: 723d 352c 2069 6e64 656e 743d 312c 206c  r=5, indent=1, l
+00019ee0: 6561 6469 6e67 3d27 2020 2020 2729 2c0a  eading='    '),.
+00019ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019f00: 2774 6578 7427 292c 0a20 2020 2020 2020  'text'),.       
+00019f10: 2020 2020 2028 4c69 6e65 496e 666f 286c       (LineInfo(l
+00019f20: 696e 653d 2765 6c73 653a 272c 206c 696e  ine='else:', lin
+00019f30: 655f 6e75 6d62 6572 3d35 2c20 636f 6c75  e_number=5, colu
+00019f40: 6d6e 5f6e 756d 6265 723d 312c 2069 6e64  mn_number=1, ind
+00019f50: 656e 743d 302c 206c 6561 6469 6e67 3d27  ent=0, leading='
+00019f60: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
+00019f70: 2020 2020 2765 6c73 653a 2729 2c0a 2020      'else:'),.  
+00019f80: 2020 2020 2020 2020 2020 284c 696e 6549            (LineI
+00019f90: 6e66 6f28 6c69 6e65 3d27 2020 2020 6966  nfo(line='    if
+00019fa0: 2031 3a27 2c20 6c69 6e65 5f6e 756d 6265   1:', line_numbe
+00019fb0: 723d 362c 2063 6f6c 756d 6e5f 6e75 6d62  r=6, column_numb
+00019fc0: 6572 3d35 2c20 696e 6465 6e74 3d31 2c20  er=5, indent=1, 
+00019fd0: 6c65 6164 696e 673d 2720 2020 2027 292c  leading='    '),
+00019fe0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00019ff0: 2027 6966 2031 3a27 292c 0a20 2020 2020   'if 1:'),.     
+0001a000: 2020 2020 2020 2028 4c69 6e65 496e 666f         (LineInfo
+0001a010: 286c 696e 653d 2720 2020 2020 2020 2020  (line='         
+0001a020: 206f 7468 6572 2074 6578 7427 2c20 6c69   other text', li
+0001a030: 6e65 5f6e 756d 6265 723d 372c 2063 6f6c  ne_number=7, col
+0001a040: 756d 6e5f 6e75 6d62 6572 3d31 312c 2069  umn_number=11, i
+0001a050: 6e64 656e 743d 322c 206c 6561 6469 6e67  ndent=2, leading
+0001a060: 3d27 2020 2020 2020 2020 2020 2729 2c0a  ='          '),.
+0001a070: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a080: 276f 7468 6572 2074 6578 7427 292c 0a20  'other text'),. 
+0001a090: 2020 2020 2020 2020 2020 2028 4c69 6e65             (Line
+0001a0a0: 496e 666f 286c 696e 653d 2720 2020 2020  Info(line='     
+0001a0b0: 2020 2020 206f 7468 6572 2074 6578 7427       other text'
+0001a0c0: 2c20 6c69 6e65 5f6e 756d 6265 723d 382c  , line_number=8,
+0001a0d0: 2063 6f6c 756d 6e5f 6e75 6d62 6572 3d31   column_number=1
+0001a0e0: 312c 2069 6e64 656e 743d 322c 206c 6561  1, indent=2, lea
+0001a0f0: 6469 6e67 3d27 2020 2020 2020 2020 2020  ding='          
+0001a100: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
+0001a110: 2020 2020 276f 7468 6572 2074 6578 7427      'other text'
+0001a120: 292c 0a20 2020 2020 2020 2020 2020 2028  ),.            (
+0001a130: 4c69 6e65 496e 666f 286c 696e 653d 2720  LineInfo(line=' 
+0001a140: 2020 206d 6f72 6520 7465 7874 272c 206c     more text', l
+0001a150: 696e 655f 6e75 6d62 6572 3d39 2c20 636f  ine_number=9, co
+0001a160: 6c75 6d6e 5f6e 756d 6265 723d 352c 2069  lumn_number=5, i
+0001a170: 6e64 656e 743d 312c 206c 6561 6469 6e67  ndent=1, leading
+0001a180: 3d27 2020 2020 2729 2c0a 2020 2020 2020  ='    '),.      
+0001a190: 2020 2020 2020 2020 2020 276d 6f72 6520            'more 
+0001a1a0: 7465 7874 2729 2c0a 2020 2020 2020 2020  text'),.        
+0001a1b0: 2020 2020 284c 696e 6549 6e66 6f28 6c69      (LineInfo(li
+0001a1c0: 6e65 3d27 2020 2020 2020 6469 6666 6572  ne='      differ
+0001a1d0: 656e 7420 696e 6465 6e74 272c 206c 696e  ent indent', lin
+0001a1e0: 655f 6e75 6d62 6572 3d31 302c 2063 6f6c  e_number=10, col
+0001a1f0: 756d 6e5f 6e75 6d62 6572 3d37 2c20 696e  umn_number=7, in
+0001a200: 6465 6e74 3d32 2c20 6c65 6164 696e 673d  dent=2, leading=
+0001a210: 2720 2020 2020 2027 292c 0a20 2020 2020  '      '),.     
+0001a220: 2020 2020 2020 2020 2020 2027 6469 6666             'diff
+0001a230: 6572 656e 7420 696e 6465 6e74 2729 2c0a  erent indent'),.
+0001a240: 2020 2020 2020 2020 2020 2020 284c 696e              (Lin
+0001a250: 6549 6e66 6f28 6c69 6e65 3d27 2020 2020  eInfo(line='    
+0001a260: 6f75 7464 656e 7427 2c20 6c69 6e65 5f6e  outdent', line_n
+0001a270: 756d 6265 723d 3131 2c20 636f 6c75 6d6e  umber=11, column
+0001a280: 5f6e 756d 6265 723d 352c 2069 6e64 656e  _number=5, inden
+0001a290: 743d 312c 206c 6561 6469 6e67 3d27 2020  t=1, leading='  
+0001a2a0: 2020 2729 2c0a 2020 2020 2020 2020 2020    '),.          
+0001a2b0: 2020 2020 2020 276f 7574 6465 6e74 2729        'outdent')
+0001a2c0: 2c0a 2020 2020 2020 2020 2020 2020 284c  ,.            (L
+0001a2d0: 696e 6549 6e66 6f28 6c69 6e65 3d27 6f75  ineInfo(line='ou
+0001a2e0: 7464 656e 7427 2c20 6c69 6e65 5f6e 756d  tdent', line_num
+0001a2f0: 6265 723d 3132 2c20 636f 6c75 6d6e 5f6e  ber=12, column_n
+0001a300: 756d 6265 723d 312c 2069 6e64 656e 743d  umber=1, indent=
+0001a310: 302c 206c 6561 6469 6e67 3d27 2729 2c0a  0, leading=''),.
+0001a320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a330: 276f 7574 6465 6e74 2729 2c0a 2020 2020  'outdent'),.    
+0001a340: 2020 2020 2020 2020 284c 696e 6549 6e66          (LineInf
+0001a350: 6f28 6c69 6e65 3d27 2020 6e65 7720 696e  o(line='  new in
+0001a360: 6465 6e74 272c 206c 696e 655f 6e75 6d62  dent', line_numb
+0001a370: 6572 3d31 332c 2063 6f6c 756d 6e5f 6e75  er=13, column_nu
+0001a380: 6d62 6572 3d33 2c20 696e 6465 6e74 3d31  mber=3, indent=1
+0001a390: 2c20 6c65 6164 696e 673d 2720 2027 292c  , leading='  '),
+0001a3a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001a3b0: 2027 6e65 7720 696e 6465 6e74 2729 2c0a   'new indent'),.
+0001a3c0: 2020 2020 2020 2020 2020 2020 284c 696e              (Lin
+0001a3d0: 6549 6e66 6f28 6c69 6e65 3d27 6f75 7464  eInfo(line='outd
+0001a3e0: 656e 7427 2c20 6c69 6e65 5f6e 756d 6265  ent', line_numbe
+0001a3f0: 723d 3134 2c20 636f 6c75 6d6e 5f6e 756d  r=14, column_num
+0001a400: 6265 723d 312c 2069 6e64 656e 743d 302c  ber=1, indent=0,
+0001a410: 206c 6561 6469 6e67 3d27 2729 2c0a 2020   leading=''),.  
+0001a420: 2020 2020 2020 2020 2020 2020 2020 276f                'o
+0001a430: 7574 6465 6e74 2729 2c0a 2020 2020 2020  utdent'),.      
+0001a440: 2020 2020 2020 284c 696e 6549 6e66 6f28        (LineInfo(
+0001a450: 6c69 6e65 3d27 272c 206c 696e 655f 6e75  line='', line_nu
+0001a460: 6d62 6572 3d31 352c 2063 6f6c 756d 6e5f  mber=15, column_
+0001a470: 6e75 6d62 6572 3d31 2c20 696e 6465 6e74  number=1, indent
+0001a480: 3d30 2c20 6c65 6164 696e 673d 2727 292c  =0, leading=''),
+0001a490: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001a4a0: 2027 2729 2c0a 2020 2020 2020 2020 2020   ''),.          
+0001a4b0: 2020 5d0a 0a20 2020 2020 2020 2074 6573    ]..        tes
+0001a4c0: 7428 6c69 6e65 732c 2065 7870 6563 7465  t(lines, expecte
+0001a4d0: 6429 0a0a 0a20 2020 2020 2020 2023 230a  d)...        ##.
+0001a4e0: 2020 2020 2020 2020 2323 2074 6573 7420          ## test 
+0001a4f0: 7461 6220 746f 2073 7061 6365 730a 2020  tab to spaces.  
+0001a500: 2020 2020 2020 2323 0a0a 2020 2020 2020        ##..      
+0001a510: 2020 6c69 6e65 7320 3d20 280a 2020 2020    lines = (.    
+0001a520: 2020 2020 226c 6566 7420 6d61 7267 696e      "left margin
+0001a530: 5c6e 220a 2020 2020 2020 2020 225c 7465  \n".        "\te
+0001a540: 6967 6874 5c6e 220a 2020 2020 2020 2020  ight\n".        
+0001a550: 2220 205c 7420 2020 2074 7765 6c76 655c  "  \t    twelve\
+0001a560: 6e22 0a20 2020 2020 2020 2022 2020 2020  n".        "    
+0001a570: 2020 2020 6569 6768 7420 6973 2065 6e6f      eight is eno
+0001a580: 7567 685c 6e22 0a20 2020 2020 2020 2029  ugh\n".        )
+0001a590: 0a0a 2020 2020 2020 2020 6578 7065 6374  ..        expect
+0001a5a0: 6564 203d 205b 0a20 2020 2020 2020 2020  ed = [.         
+0001a5b0: 2020 2028 4c69 6e65 496e 666f 286c 696e     (LineInfo(lin
+0001a5c0: 653d 276c 6566 7420 6d61 7267 696e 272c  e='left margin',
+0001a5d0: 206c 696e 655f 6e75 6d62 6572 3d31 2c20   line_number=1, 
+0001a5e0: 636f 6c75 6d6e 5f6e 756d 6265 723d 312c  column_number=1,
+0001a5f0: 2069 6e64 656e 743d 302c 206c 6561 6469   indent=0, leadi
+0001a600: 6e67 3d27 2729 2c0a 2020 2020 2020 2020  ng=''),.        
+0001a610: 2020 2020 2020 2020 276c 6566 7420 6d61          'left ma
+0001a620: 7267 696e 2729 2c0a 2020 2020 2020 2020  rgin'),.        
+0001a630: 2020 2020 284c 696e 6549 6e66 6f28 6c69      (LineInfo(li
+0001a640: 6e65 3d27 5c74 6569 6768 7427 2c20 6c69  ne='\teight', li
+0001a650: 6e65 5f6e 756d 6265 723d 322c 2063 6f6c  ne_number=2, col
+0001a660: 756d 6e5f 6e75 6d62 6572 3d39 2c20 696e  umn_number=9, in
+0001a670: 6465 6e74 3d31 2c20 6c65 6164 696e 673d  dent=1, leading=
+0001a680: 275c 7427 292c 0a20 2020 2020 2020 2020  '\t'),.         
+0001a690: 2020 2020 2020 2027 6569 6768 7427 292c         'eight'),
+0001a6a0: 0a20 2020 2020 2020 2020 2020 2028 4c69  .            (Li
+0001a6b0: 6e65 496e 666f 286c 696e 653d 2720 205c  neInfo(line='  \
+0001a6c0: 7420 2020 2074 7765 6c76 6527 2c20 6c69  t    twelve', li
+0001a6d0: 6e65 5f6e 756d 6265 723d 332c 2063 6f6c  ne_number=3, col
+0001a6e0: 756d 6e5f 6e75 6d62 6572 3d31 332c 2069  umn_number=13, i
+0001a6f0: 6e64 656e 743d 322c 206c 6561 6469 6e67  ndent=2, leading
+0001a700: 3d27 2020 5c74 2020 2020 2729 2c0a 2020  ='  \t    '),.  
+0001a710: 2020 2020 2020 2020 2020 2020 2020 2774                't
+0001a720: 7765 6c76 6527 292c 0a20 2020 2020 2020  welve'),.       
+0001a730: 2020 2020 2028 4c69 6e65 496e 666f 286c       (LineInfo(l
+0001a740: 696e 653d 2720 2020 2020 2020 2065 6967  ine='        eig
+0001a750: 6874 2069 7320 656e 6f75 6768 272c 206c  ht is enough', l
+0001a760: 696e 655f 6e75 6d62 6572 3d34 2c20 636f  ine_number=4, co
+0001a770: 6c75 6d6e 5f6e 756d 6265 723d 392c 2069  lumn_number=9, i
+0001a780: 6e64 656e 743d 312c 206c 6561 6469 6e67  ndent=1, leading
+0001a790: 3d27 2020 2020 2020 2020 2729 2c0a 2020  ='        '),.  
+0001a7a0: 2020 2020 2020 2020 2020 2020 2020 2765                'e
+0001a7b0: 6967 6874 2069 7320 656e 6f75 6768 2729  ight is enough')
+0001a7c0: 2c0a 2020 2020 2020 2020 2020 2020 284c  ,.            (L
+0001a7d0: 696e 6549 6e66 6f28 6c69 6e65 3d27 272c  ineInfo(line='',
+0001a7e0: 206c 696e 655f 6e75 6d62 6572 3d35 2c20   line_number=5, 
+0001a7f0: 636f 6c75 6d6e 5f6e 756d 6265 723d 312c  column_number=1,
+0001a800: 2069 6e64 656e 743d 302c 206c 6561 6469   indent=0, leadi
+0001a810: 6e67 3d27 2729 2c0a 2020 2020 2020 2020  ng=''),.        
+0001a820: 2020 2020 2020 2020 2727 290a 2020 2020          '').    
+0001a830: 2020 2020 2020 2020 5d0a 0a20 2020 2020          ]..     
+0001a840: 2020 2074 6573 7428 6c69 6e65 732c 2065     test(lines, e
+0001a850: 7870 6563 7465 6429 0a0a 2020 2020 2020  xpected)..      
+0001a860: 2020 6c69 6e65 7320 3d20 280a 2020 2020    lines = (.    
+0001a870: 2020 2020 2020 2020 226c 6566 7420 6d61          "left ma
+0001a880: 7267 696e 5c6e 220a 2020 2020 2020 2020  rgin\n".        
+0001a890: 2020 2020 225c 7466 6f75 725c 6e22 0a20      "\tfour\n". 
+0001a8a0: 2020 2020 2020 2020 2020 2022 2020 5c74             "  \t
+0001a8b0: 2020 2020 6569 6768 745c 6e22 0a20 2020      eight\n".   
+0001a8c0: 2020 2020 2020 2020 2022 2020 5c74 5c74           "  \t\t
+0001a8d0: 6669 6775 7265 2065 6967 6874 2069 7320  figure eight is 
+0001a8e0: 646f 7562 6c65 2066 6f75 725c 6e22 0a20  double four\n". 
+0001a8f0: 2020 2020 2020 2020 2020 2022 2020 2020             "    
+0001a900: 6669 6775 7265 2066 6f75 7220 6973 2068  figure four is h
+0001a910: 616c 6620 6f66 2065 6967 6874 5c6e 220a  alf of eight\n".
+0001a920: 2020 2020 2020 2020 2020 2020 290a 0a20              ).. 
+0001a930: 2020 2020 2020 2065 7870 6563 7465 6420         expected 
+0001a940: 3d20 5b0a 2020 2020 2020 2020 2020 2020  = [.            
+0001a950: 284c 696e 6549 6e66 6f28 6c69 6e65 3d27  (LineInfo(line='
+0001a960: 6c65 6674 206d 6172 6769 6e27 2c20 6c69  left margin', li
+0001a970: 6e65 5f6e 756d 6265 723d 312c 2063 6f6c  ne_number=1, col
+0001a980: 756d 6e5f 6e75 6d62 6572 3d31 2c20 696e  umn_number=1, in
+0001a990: 6465 6e74 3d30 2c20 6c65 6164 696e 673d  dent=0, leading=
+0001a9a0: 2727 292c 0a20 2020 2020 2020 2020 2020  ''),.           
+0001a9b0: 2020 2020 2027 6c65 6674 206d 6172 6769       'left margi
+0001a9c0: 6e27 292c 0a20 2020 2020 2020 2020 2020  n'),.           
+0001a9d0: 2028 4c69 6e65 496e 666f 286c 696e 653d   (LineInfo(line=
+0001a9e0: 275c 7466 6f75 7227 2c20 6c69 6e65 5f6e  '\tfour', line_n
+0001a9f0: 756d 6265 723d 322c 2063 6f6c 756d 6e5f  umber=2, column_
+0001aa00: 6e75 6d62 6572 3d35 2c20 696e 6465 6e74  number=5, indent
+0001aa10: 3d31 2c20 6c65 6164 696e 673d 275c 7427  =1, leading='\t'
+0001aa20: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+0001aa30: 2020 2027 666f 7572 2729 2c0a 2020 2020     'four'),.    
+0001aa40: 2020 2020 2020 2020 284c 696e 6549 6e66          (LineInf
+0001aa50: 6f28 6c69 6e65 3d27 2020 5c74 2020 2020  o(line='  \t    
+0001aa60: 6569 6768 7427 2c20 6c69 6e65 5f6e 756d  eight', line_num
+0001aa70: 6265 723d 332c 2063 6f6c 756d 6e5f 6e75  ber=3, column_nu
+0001aa80: 6d62 6572 3d39 2c20 696e 6465 6e74 3d32  mber=9, indent=2
+0001aa90: 2c20 6c65 6164 696e 673d 2720 205c 7420  , leading='  \t 
+0001aaa0: 2020 2027 292c 0a20 2020 2020 2020 2020     '),.         
+0001aab0: 2020 2020 2020 2027 6569 6768 7427 292c         'eight'),
+0001aac0: 0a20 2020 2020 2020 2020 2020 2028 4c69  .            (Li
+0001aad0: 6e65 496e 666f 286c 696e 653d 2720 205c  neInfo(line='  \
+0001aae0: 745c 7466 6967 7572 6520 6569 6768 7420  t\tfigure eight 
+0001aaf0: 6973 2064 6f75 626c 6520 666f 7572 272c  is double four',
+0001ab00: 206c 696e 655f 6e75 6d62 6572 3d34 2c20   line_number=4, 
+0001ab10: 636f 6c75 6d6e 5f6e 756d 6265 723d 392c  column_number=9,
+0001ab20: 2069 6e64 656e 743d 322c 206c 6561 6469   indent=2, leadi
+0001ab30: 6e67 3d27 2020 5c74 5c74 2729 2c0a 2020  ng='  \t\t'),.  
+0001ab40: 2020 2020 2020 2020 2020 2020 2020 2766                'f
+0001ab50: 6967 7572 6520 6569 6768 7420 6973 2064  igure eight is d
+0001ab60: 6f75 626c 6520 666f 7572 2729 2c0a 2020  ouble four'),.  
+0001ab70: 2020 2020 2020 2020 2020 284c 696e 6549            (LineI
+0001ab80: 6e66 6f28 6c69 6e65 3d27 2020 2020 6669  nfo(line='    fi
+0001ab90: 6775 7265 2066 6f75 7220 6973 2068 616c  gure four is hal
+0001aba0: 6620 6f66 2065 6967 6874 272c 206c 696e  f of eight', lin
+0001abb0: 655f 6e75 6d62 6572 3d35 2c20 636f 6c75  e_number=5, colu
+0001abc0: 6d6e 5f6e 756d 6265 723d 352c 2069 6e64  mn_number=5, ind
+0001abd0: 656e 743d 312c 206c 6561 6469 6e67 3d27  ent=1, leading='
+0001abe0: 2020 2020 2729 2c0a 2020 2020 2020 2020      '),.        
+0001abf0: 2020 2020 2020 2020 2766 6967 7572 6520          'figure 
+0001ac00: 666f 7572 2069 7320 6861 6c66 206f 6620  four is half of 
+0001ac10: 6569 6768 7427 292c 0a20 2020 2020 2020  eight'),.       
+0001ac20: 2020 2020 2028 4c69 6e65 496e 666f 286c       (LineInfo(l
+0001ac30: 696e 653d 2727 2c20 6c69 6e65 5f6e 756d  ine='', line_num
+0001ac40: 6265 723d 362c 2063 6f6c 756d 6e5f 6e75  ber=6, column_nu
+0001ac50: 6d62 6572 3d31 2c20 696e 6465 6e74 3d30  mber=1, indent=0
+0001ac60: 2c20 6c65 6164 696e 673d 2727 292c 0a20  , leading=''),. 
+0001ac70: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+0001ac80: 2729 5d0a 0a20 2020 2020 2020 2074 6573  ')]..        tes
+0001ac90: 7428 6c69 6e65 732c 2065 7870 6563 7465  t(lines, expecte
+0001aca0: 642c 2074 6162 5f77 6964 7468 3d34 290a  d, tab_width=4).
+0001acb0: 0a20 2020 2020 2020 2023 230a 2020 2020  .        ##.    
+0001acc0: 2020 2020 2323 2074 6573 7420 7261 6973      ## test rais
+0001acd0: 696e 6720 666f 7220 696c 6c65 6761 6c20  ing for illegal 
+0001ace0: 6f75 7464 656e 7473 0a20 2020 2020 2020  outdents.       
+0001acf0: 2023 230a 0a20 2020 2020 2020 2023 2077   ##..        # w
+0001ad00: 6865 6e20 6974 2773 2062 6574 7765 656e  hen it's between
+0001ad10: 2074 776f 2065 7869 7374 696e 6720 696e   two existing in
+0001ad20: 6465 6e74 730a 2020 2020 2020 2020 6c69  dents.        li
+0001ad30: 6e65 7320 3d20 280a 2020 2020 2020 2020  nes = (.        
+0001ad40: 2020 2020 226c 6566 7420 6d61 7267 696e      "left margin
+0001ad50: 5c6e 220a 2020 2020 2020 2020 2020 2020  \n".            
+0001ad60: 225c 7466 6f75 725c 6e22 0a20 2020 2020  "\tfour\n".     
+0001ad70: 2020 2020 2020 2022 2020 5c74 2020 2020         "  \t    
+0001ad80: 6569 6768 745c 6e22 0a20 2020 2020 2020  eight\n".       
+0001ad90: 2020 2020 2022 2020 2020 2020 7369 783f       "      six?
+0001ada0: 215c 6e22 0a20 2020 2020 2020 2020 2020  !\n".           
+0001adb0: 2022 6c65 6674 206d 6172 6769 6e20 6167   "left margin ag
+0001adc0: 6169 6e5c 6e22 0a20 2020 2020 2020 2020  ain\n".         
+0001add0: 2020 2029 0a0a 2020 2020 2020 2020 7769     )..        wi
+0001ade0: 7468 2073 656c 662e 6173 7365 7274 5261  th self.assertRa
+0001adf0: 6973 6573 2849 6e64 656e 7461 7469 6f6e  ises(Indentation
+0001ae00: 4572 726f 7229 3a0a 2020 2020 2020 2020  Error):.        
+0001ae10: 2020 2020 7465 7374 286c 696e 6573 2c20      test(lines, 
+0001ae20: 5b5d 2c20 7461 625f 7769 6474 683d 3429  [], tab_width=4)
+0001ae30: 0a0a 0a20 2020 2020 2020 2023 2077 6865  ...        # whe
+0001ae40: 6e20 6974 2773 206c 6573 7320 7468 616e  n it's less than
+0001ae50: 2074 6865 2066 6972 7374 2069 6e64 656e   the first inden
+0001ae60: 740a 2020 2020 2020 2020 6c69 6e65 7320  t.        lines 
+0001ae70: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
+0001ae80: 226c 6566 7420 6d61 7267 696e 5c6e 220a  "left margin\n".
+0001ae90: 2020 2020 2020 2020 2020 2020 225c 7466              "\tf
+0001aea0: 6f75 725c 6e22 0a20 2020 2020 2020 2020  our\n".         
+0001aeb0: 2020 2022 2020 5c74 2020 2020 6569 6768     "  \t    eigh
+0001aec0: 745c 6e22 0a20 2020 2020 2020 2020 2020  t\n".           
+0001aed0: 2022 2020 7477 6f3f 215c 6e22 0a20 2020   "  two?!\n".   
+0001aee0: 2020 2020 2020 2020 2022 6c65 6674 206d           "left m
+0001aef0: 6172 6769 6e20 6167 6169 6e5c 6e22 0a20  argin again\n". 
+0001af00: 2020 2020 2020 2020 2020 2029 0a0a 2020             )..  
+0001af10: 2020 2020 2020 7769 7468 2073 656c 662e        with self.
+0001af20: 6173 7365 7274 5261 6973 6573 2849 6e64  assertRaises(Ind
+0001af30: 656e 7461 7469 6f6e 4572 726f 7229 3a0a  entationError):.
+0001af40: 2020 2020 2020 2020 2020 2020 7465 7374              test
+0001af50: 286c 696e 6573 2c20 5b5d 2c20 7461 625f  (lines, [], tab_
+0001af60: 7769 6474 683d 3429 0a0a 2020 2020 2020  width=4)..      
+0001af70: 2020 7769 7468 2073 656c 662e 6173 7365    with self.asse
+0001af80: 7274 5261 6973 6573 2856 616c 7565 4572  rtRaises(ValueEr
+0001af90: 726f 7229 3a0a 2020 2020 2020 2020 2020  ror):.          
+0001afa0: 2020 7465 7374 2822 6669 7273 7420 6c69    test("first li
+0001afb0: 6e65 5c6e 2020 5c75 3330 3030 2020 7365  ne\n  \u3000  se
+0001afc0: 636f 6e64 206c 696e 655c 6e74 6869 7264  cond line\nthird
+0001afd0: 206c 696e 655c 6e22 2c20 5b5d 290a 0a20   line\n", []).. 
+0001afe0: 2020 2064 6566 2074 6573 745f 6c69 6e65     def test_line
+0001aff0: 735f 6d69 7363 2873 656c 6629 3a0a 2020  s_misc(self):.  
+0001b000: 2020 2020 2020 2323 2072 6570 720a 2020        ## repr.  
+0001b010: 2020 2020 2020 6c69 203d 2062 6967 2e4c        li = big.L
+0001b020: 696e 6549 6e66 6f28 2727 2c20 312c 2031  ineInfo('', 1, 1
+0001b030: 2c20 696e 6465 6e74 3d30 290a 2020 2020  , indent=0).    
+0001b040: 2020 2020 7365 6c66 2e61 7373 6572 7445      self.assertE
+0001b050: 7175 616c 2872 6570 7228 6c69 292c 2022  qual(repr(li), "
+0001b060: 4c69 6e65 496e 666f 286c 696e 653d 2727  LineInfo(line=''
+0001b070: 2c20 6c69 6e65 5f6e 756d 6265 723d 312c  , line_number=1,
+0001b080: 2063 6f6c 756d 6e5f 6e75 6d62 6572 3d31   column_number=1
+0001b090: 2c20 696e 6465 6e74 3d30 2922 290a 0a20  , indent=0)").. 
+0001b0a0: 2020 2020 2020 2023 2320 6572 726f 7220         ## error 
+0001b0b0: 6861 6e64 6c69 6e67 0a20 2020 2020 2020  handling.       
+0001b0c0: 2077 6974 6820 7365 6c66 2e61 7373 6572   with self.asser
+0001b0d0: 7452 6169 7365 7328 5479 7065 4572 726f  tRaises(TypeErro
+0001b0e0: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
+0001b0f0: 6269 672e 6c69 6e65 7328 2222 2c20 6c69  big.lines("", li
+0001b100: 6e65 5f6e 756d 6265 723d 6d61 7468 2e70  ne_number=math.p
+0001b110: 6929 0a20 2020 2020 2020 2077 6974 6820  i).        with 
+0001b120: 7365 6c66 2e61 7373 6572 7452 6169 7365  self.assertRaise
+0001b130: 7328 5479 7065 4572 726f 7229 3a0a 2020  s(TypeError):.  
+0001b140: 2020 2020 2020 2020 2020 6269 672e 6c69            big.li
+0001b150: 6e65 7328 2222 2c20 636f 6c75 6d6e 5f6e  nes("", column_n
+0001b160: 756d 6265 723d 6d61 7468 2e70 6929 0a20  umber=math.pi). 
+0001b170: 2020 2020 2020 2077 6974 6820 7365 6c66         with self
+0001b180: 2e61 7373 6572 7452 6169 7365 7328 5479  .assertRaises(Ty
+0001b190: 7065 4572 726f 7229 3a0a 2020 2020 2020  peError):.      
+0001b1a0: 2020 2020 2020 6269 672e 6c69 6e65 7328        big.lines(
+0001b1b0: 2222 2c20 7461 625f 7769 6474 683d 6d61  "", tab_width=ma
+0001b1c0: 7468 2e70 6929 0a0a 2020 2020 2020 2020  th.pi)..        
+0001b1d0: 7769 7468 2073 656c 662e 6173 7365 7274  with self.assert
+0001b1e0: 5261 6973 6573 2854 7970 6545 7272 6f72  Raises(TypeError
+0001b1f0: 293a 0a20 2020 2020 2020 2020 2020 2062  ):.            b
+0001b200: 6967 2e4c 696e 6549 6e66 6f28 6d61 7468  ig.LineInfo(math
+0001b210: 2e70 692c 2031 2c20 3129 0a20 2020 2020  .pi, 1, 1).     
+0001b220: 2020 2077 6974 6820 7365 6c66 2e61 7373     with self.ass
+0001b230: 6572 7452 6169 7365 7328 5479 7065 4572  ertRaises(TypeEr
+0001b240: 726f 7229 3a0a 2020 2020 2020 2020 2020  ror):.          
+0001b250: 2020 6269 672e 4c69 6e65 496e 666f 2827    big.LineInfo('
+0001b260: 272c 206d 6174 682e 7069 2c20 3129 0a20  ', math.pi, 1). 
+0001b270: 2020 2020 2020 2077 6974 6820 7365 6c66         with self
+0001b280: 2e61 7373 6572 7452 6169 7365 7328 5479  .assertRaises(Ty
+0001b290: 7065 4572 726f 7229 3a0a 2020 2020 2020  peError):.      
+0001b2a0: 2020 2020 2020 6269 672e 4c69 6e65 496e        big.LineIn
+0001b2b0: 666f 2827 272c 2031 2c20 6d61 7468 2e70  fo('', 1, math.p
+0001b2c0: 6929 0a0a 2020 2020 2020 2020 7769 7468  i)..        with
+0001b2d0: 2073 656c 662e 6173 7365 7274 5261 6973   self.assertRais
+0001b2e0: 6573 2856 616c 7565 4572 726f 7229 3a0a  es(ValueError):.
+0001b2f0: 2020 2020 2020 2020 2020 2020 6c69 7374              list
+0001b300: 2862 6967 2e6c 696e 6573 5f66 696c 7465  (big.lines_filte
+0001b310: 725f 636f 6d6d 656e 745f 6c69 6e65 7328  r_comment_lines(
+0001b320: 2222 2c20 5b5d 2929 0a20 2020 2020 2020  "", [])).       
+0001b330: 2077 6974 6820 7365 6c66 2e61 7373 6572   with self.asser
+0001b340: 7452 6169 7365 7328 5479 7065 4572 726f  tRaises(TypeErro
+0001b350: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
+0001b360: 6c69 7374 2862 6967 2e6c 696e 6573 5f66  list(big.lines_f
+0001b370: 696c 7465 725f 636f 6d6d 656e 745f 6c69  ilter_comment_li
+0001b380: 6e65 7328 2222 2c20 6d61 7468 2e70 6929  nes("", math.pi)
+0001b390: 290a 0a20 2020 2020 2020 2023 2320 7465  )..        ## te
+0001b3a0: 7374 206b 7761 7267 730a 2020 2020 2020  st kwargs.      
+0001b3b0: 2020 6920 3d20 6269 672e 6c69 6e65 7328    i = big.lines(
+0001b3c0: 2727 2c20 7175 6172 6b3d 3232 290a 2020  '', quark=22).  
+0001b3d0: 2020 2020 2020 7365 6c66 2e61 7373 6572        self.asser
+0001b3e0: 7454 7275 6528 6861 7361 7474 7228 692c  tTrue(hasattr(i,
+0001b3f0: 2027 7175 6172 6b27 2929 0a20 2020 2020   'quark')).     
+0001b400: 2020 2073 656c 662e 6173 7365 7274 4571     self.assertEq
+0001b410: 7561 6c28 6765 7461 7474 7228 692c 2027  ual(getattr(i, '
+0001b420: 7175 6172 6b27 292c 2032 3229 0a0a 2020  quark'), 22)..  
+0001b430: 2020 2020 2020 696e 666f 203d 2062 6967        info = big
+0001b440: 2e4c 696e 6549 6e66 6f28 2727 2c20 312c  .LineInfo('', 1,
+0001b450: 2031 2c20 7175 6172 6b3d 3335 290a 2020   1, quark=35).  
+0001b460: 2020 2020 2020 7365 6c66 2e61 7373 6572        self.asser
+0001b470: 7454 7275 6528 6861 7361 7474 7228 696e  tTrue(hasattr(in
+0001b480: 666f 2c20 2771 7561 726b 2729 290a 2020  fo, 'quark')).  
+0001b490: 2020 2020 2020 7365 6c66 2e61 7373 6572        self.asser
+0001b4a0: 7445 7175 616c 2867 6574 6174 7472 2869  tEqual(getattr(i
+0001b4b0: 6e66 6f2c 2027 7175 6172 6b27 292c 2033  nfo, 'quark'), 3
+0001b4c0: 3529 0a0a 0a69 6d70 6f72 7420 6269 6774  5)...import bigt
+0001b4d0: 6573 746c 6962 0a0a 6465 6620 7275 6e5f  estlib..def run_
+0001b4e0: 7465 7374 7328 293a 0a20 2020 2062 6967  tests():.    big
+0001b4f0: 7465 7374 6c69 622e 7275 6e28 6e61 6d65  testlib.run(name
+0001b500: 3d22 6269 672e 7465 7874 222c 206d 6f64  ="big.text", mod
+0001b510: 756c 653d 5f5f 6e61 6d65 5f5f 290a 0a69  ule=__name__)..i
+0001b520: 6620 5f5f 6e61 6d65 5f5f 203d 3d20 225f  f __name__ == "_
+0001b530: 5f6d 6169 6e5f 5f22 3a20 2320 7072 6167  _main__": # prag
+0001b540: 6d61 3a20 6e6f 2063 6f76 6572 0a20 2020  ma: no cover.   
+0001b550: 2072 756e 5f74 6573 7473 2829 0a20 2020   run_tests().   
+0001b560: 2062 6967 7465 7374 6c69 622e 6669 6e69   bigtestlib.fini
+0001b570: 7368 2829 0a                             sh().
```

### Comparing `big-0.7.1/test/test_time.py` & `big-0.8/test/test_time.py`

 * *Files identical despite different names*

### Comparing `big-0.7.1/PKG-INFO` & `big-0.8/README.md`

 * *Files 2% similar despite different names*

```diff
@@ -1,22 +1,8 @@
-Metadata-Version: 2.1
-Name: big
-Version: 0.7.1
-Summary: The big package is a grab-bag of cool code for use in your programs.
-Author-email: Larry Hastings <larry@hastings.org>
-Requires-Python: >=3.6
-Description-Content-Type: text/markdown
-Classifier: Intended Audience :: Developers
-Classifier: License :: CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
-Classifier: Programming Language :: Python :: 3 :: Only
-Requires-Dist: python-dateutil ; extra == "time"
-Project-URL: Source, https://github.com/larryhastings/big/
-Provides-Extra: time
-
-![# big](/resources/images/big.header.png)
+![# big](https://raw.githubusercontent.com/larryhastings/big/master/resources/images/big.header.png)
 
 ##### Copyright 2022-2023 by Larry Hastings
 
 **big** is a Python package, a grab-bag of useful technology
 I always want to have handy.
 
 Finally!  For years, I've copied-and-pasted all my little
@@ -209,14 +195,16 @@
 
 [`Regulator.now()`](#regulatornow)
 
 [`Regulator.sleep(t)`](#regulatorsleept)
 
 [`Regulator.wake()`](#regulatorwake)
 
+[`reversed_re_finditer(pattern, string, flags=0)`](#reversed_re_finditerpattern-string-flags0)
+
 [`safe_mkdir(path)`](#safe_mkdirpath)
 
 [`safe_unlink(path)`](#safe_unlinkpath)
 
 [`Scheduler(regulator=default_regulator)`](#schedulerregulatordefault_regulator)
 
 [`Scheduler.schedule(o, time, *, absolute=False, priority=DEFAULT_PRIORITY)`](#schedulerscheduleo-time--absolutefalse-prioritydefault_priority)
@@ -388,20 +376,20 @@
 > tries `int(o)`.  If that conversion succeeds, returns the result.
 > Otherwise, tries `float(o)`.  If that conversion succeeds, returns
 > the result.  Otherwise returns the default value.  If you don't
 > pass in an explicit default value, the default value is `o`.
 
 #### `try_float(o)`
 
-> Returns `True` if `o` can be converted into a float,
+> Returns `True` if `o` can be converted into a `float`,
 > and `False` if it can't.
 
 #### `try_int(o)`
 
-> Returns `True` if `o` can be converted into an int,
+> Returns `True` if `o` can be converted into an `int`,
 > and `False` if it can't.
 
 
 ## `big.file`
 
 Functions for working with files, directories, and I/O.
 
@@ -416,30 +404,31 @@
 > * a bytes object, or
 > * a `pathlib.Path` object.
 >
 > `text` should be either string or bytes.
 >
 > `encoding` is used as the file encoding when opening the file.
 >
-> if `text` is a str, the file is opened in text mode.
-> if `text` is a bytes object, the file is opened in binary mode.
-> `encoding` must be `None` when the file is opened in binary mode.
+> * If `text` is a str, the file is opened in text mode.
+> * If `text` is a bytes object, the file is opened in binary mode.
+>   `encoding` must be `None` when the file is opened in binary mode.
 >
 > If `case_insensitive` is true, perform the search in a case-insensitive
 > manner.
 >
 > Returns a list of lines in the file containing `text`.  The lines are either
 > strings or bytes objects, depending on the type of `pattern`.  The lines
 > have their newlines stripped but preserve all other whitespace.
 >
 > If `enumerate` is true, returns a list of tuples of (line_number, line).
 > The first line of the file is line number 1.
 >
 > For simplicity of implementation, the entire file is read in to memory
-> at one time.  If `case_insensitive` is True, a lowercased copy is also used.
+> at one time.  If `case_insensitive` is true, `fgrep` also makes a lowercased
+> copy.
 
 #### `file_mtime(path)`
 
 > Returns the modification time of `path`, in seconds since the epoch.
 > Note that seconds is a float, indicating the sub-second with some
 > precision.
 
@@ -451,15 +440,15 @@
 
 > Returns the size of the file at `path`, as an integer representing the
 > number of bytes.
 
 #### `grep(path, pattern, *, encoding=None, enumerate=False, flags=0)`
 
 > Look for matches to a regular expression pattern in the lines of a file,
-> like the UNIX `grep` utility program.
+> similarly to the UNIX `grep` utility program.
 >
 > `path` should be an object representing a path to an existing file, one of:
 >
 > * a string,
 > * a bytes object, or
 > * a `pathlib.Path` object.
 >
@@ -508,36 +497,39 @@
 > This would change into the `'x'` subdirectory before
 > executing the nested block, then change back to
 > the original directory after the nested block.
 >
 > You can change directories in the nested block;
 > this won't affect pushd restoring the original current
 > working directory upon exiting the nested block.
+>
+> You can safely nest `with pushd` blocks.
 
 #### `safe_mkdir(path)`
 
 > Ensures that a directory exists at `path`.
 > If this function returns and doesn't raise,
 > it guarantees that a directory exists at `path`.
 >
 > If a directory already exists at `path`,
-> does nothing.
+> `safe_mkdir` does nothing.
 >
-> If a file exists at `path`, unlinks it
-> then creates the directory.
+> If a file exists at `path`, `safe_mkdir`
+> unlinks `path` then creates the directory.
 >
 > If the parent directory doesn't exist,
-> creates it, then creates `path`.
+> `safe_mkdir` creates that directory,
+> then creates `path`.
 >
 > This function can still fail:
 >
-> * 'path' could be on a read-only filesystem.
+> * `path` could be on a read-only filesystem.
 > * You might lack the permissions to create `path`.
-> * You could ask to create the directory 'x/y'
->   and 'x' is a file (not a directory).
+> * You could ask to create the directory `x/y`
+>   and `x` is a file (not a directory).
 
 #### `safe_unlink(path)`
 
 > Unlinks `path`, if `path` exists and is a file.
 
 #### `touch(path)`
 
@@ -1000,29 +992,60 @@
 >
 > This `Regulator` isn't guaranteed to be safe
 > for use while in a signal-handler callback.
 
 
 ## `big.text`
 
-> Functions for working with text strings.  There are
-> several families of functions inside the `text` module;
-> for a higher-level view of those families, read the
-> following deep-dives:
->
-> * [**The `multi-` family of functions**](#The-multi--family-of-functions)
-> * [**`lines` and lines modifier functions**](#lines-and-lines-modifier-functions)
-> * [**Word wrapping and formatting**](#word-wrapping-and-formatting)
->
-> All the functions in `big.text` will work with either
-> `str` or `bytes` objects, except the three
-> [**Word wrapping and formatting**](#word-wrapping-and-formatting)
-> functions.  When working with `bytes`,
-> by default the functions will only work with ASCII
-> characters.
+Functions for working with text strings.  There are
+several families of functions inside the `text` module;
+for a higher-level view of those families, read the
+following deep-dives:
+
+* [**The `multi-` family of functions**](#The-multi--family-of-functions)
+* [**`lines` and lines modifier functions**](#lines-and-lines-modifier-functions)
+* [**Word wrapping and formatting**](#word-wrapping-and-formatting)
+
+All the functions in `big.text` will work with either
+`str` or `bytes` objects, except the three
+[**Word wrapping and formatting**](#word-wrapping-and-formatting)
+functions.  When working with `bytes`,
+by default the functions will only work with ASCII
+characters.
+
+## Support for bytes and str
+
+The **big** text functions all support both `str` and `bytes`.
+The functions all automatically detect whether you passed in
+`str` or `bytes`  using an
+intentionally simple and predictable process, as follows:
+
+At the start of each function, it'll test its first "string"
+argument to see if it's a `bytes` object.
+
+```Python
+is_bytes = isinstance(<argument>, bytes)
+```
+
+If `isinstance` returns `True`, the function assumes all arguments are
+`bytes` objects.  Otherwise the function assumes all arguments
+are `str` objects.
+
+As a rule, no further further testing, casting, or catching exceptions
+is done.
+
+Functions that take multiple string-like parameters require all
+such arguments to be the same type.
+These functions will check that all such arguments
+are of the same type.
+
+Subclasses of `str` and `bytes` will also work; anywhere you
+should pass in a `str`, you can also pass in a subclass of
+`str`, and likewise for `bytes`.
+
 
 #### `gently_title(s, *, apostrophes=None, double_quotes=None)`
 
 > Uppercase the first character of every word in `s`.
 > Leave the other letters alone.  s should be `str` or `bytes`.
 >
 > (For the purposes of this algorithm, words are
@@ -1078,26 +1101,25 @@
 > is set to a string containing these Unicode double quote code points:
 >     "“”„‟«»‹›
 
 #### `lines(s, separators=None, *, line_number=1, column_number=1, tab_width=8, **kwargs)`
 
 > A "lines iterator" object.  Splits s into lines, and iterates yielding those lines.
 >
-> `s` can be `str`, `bytes`, or any iterable.
+> `s` can be `str`, `bytes`, or any iterable of `str` or `bytes`.
 >
-> By default, if `s` is `str`, splits `s` by all Unicode line break characters.
-> If `s` is `bytes`, splits `s` by all ASCII line break characters.
->
-> If `s` is neither str nor bytes, `s` must be an iterable;
-> lines yields successive elements of `s` as lines.
->
-> `separators`, if not `None`, must be an iterable of strings of the
-> same type as `s`.  `lines` will split `s` using those strings as
-> separator strings (using
-> [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)).
+> If `s` is neither `str` nor `bytes`, `s` must be an iterable;
+> `lines` yields successive elements of `s` as lines.  All objects
+> yielded by this iterable should be homogeneous, either `str` or `bytes`.
+>
+> If `s` is `str` or `bytes`, and `separators` is `None`, `lines`
+> will split `s` at line boundaries and yield those lines, including
+> empty lines.  If `separators` is not `None`, it must be an iterable
+> of strings of the same type as `s`; `lines` will split `s` using
+> [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse).
 >
 > When iterated over, yields 2-tuples:
 >     (info, line)
 >
 > `info` is a `LineInfo` object, which contains three fields by
 > default:
 >
@@ -1307,18 +1329,18 @@
 > Returns a string.
 >
 > `columns` should be an iterable of column tuples.
 > Each column tuple should contain three items:
 > ```Python
 >     (text, min_width, max_width)
 > ```
-> `text` should be a single text string, with newline
-> characters separating lines. `min_width` and `max_width`
-> are the minimum and maximum permissible widths for that
-> column, not including the column separator (if any).
+> `text` should be a single string, either `str` or `bytes`,
+> with newline characters separating lines. `min_width`
+> and `max_width` are the minimum and maximum permissible widths
+> for that column, not including the column separator (if any).
 >
 > Note that this function does not text-wrap the lines.
 >
 > `column_separator` is printed between every column.
 >
 > `overflow_strategy` tells merge_columns how to handle a column
 > with one or more lines that are wider than that column's `max_width`.
@@ -1340,15 +1362,15 @@
 > [**Word wrapping and formatting.**](#word-wrapping-and-formatting)
 
 #### `multipartition(s, separators, count=1, *, reverse=False, separate=True)`
 
 > Like `str.partition`, but supports partitioning based on multiple
 > separator strings, and can partition more than once.
 >
-> `s` can be str or bytes.
+> `s` can be either `str` or `bytes`.
 >
 > `separators` should be an iterable of objects of the same type as `s`.
 >
 > By default, if any of the strings in `separators` are found in `s`,
 > returns a tuple of three strings: the portion of `s` leading up to
 > the earliest separator, the separator, and the portion of `s` after
 > that separator.  Example:
@@ -1384,18 +1406,15 @@
 
 #### `multisplit(s, separators, *, keep=False, maxsplit=-1, reverse=False, separate=False, strip=False)`
 
 > Splits strings like `str.split`, but with multiple separators and options.
 >
 > `s` can be `str` or `bytes`.
 >
-> `separators` should be an iterable.  Each element of `separators`
-> should be the same type as `text`.  If `separators` is a string or bytes
-> object, `multisplit` behaves as separators is a tuple containing each
-> individual character.
+> `separators` should be an iterable of `str` or `bytes`, matching `s`.
 >
 > Returns an iterator yielding the strings split from `s`.  If `keep`
 > is true (or `ALTERNATING`), and `strip` is false, joining these strings
 > together will recreate `s`.
 >
 > `multisplit` is *greedy:* if two or more separators start at the same
 > location in `s`, `multisplit` splits using the longest matching separator.
@@ -1482,41 +1501,35 @@
 >            parse moving left (towards the beginning).
 >
 >    Splitting starting from the end of the string and parsing to
 >    the left has two effects.  First, if `maxsplit` is a number
 >    greater than 0, the splits will start at the end of the string
 >    rather than the beginning.  Second, if there are overlapping
 >    instances of separators in the string, `multisplit` will prefer
->    the rightmost separator rather than the left.  For example:
->
->        multisplit(" x x ", (" x ",), keep=big.ALTERNATING)
->
->    will split on the leftmost instance of `" x "`, yielding
->
->        "", " x ", "x "
+>    the rightmost separator rather than the left.  Consider this
+>    example, where `reverse` is false:
 >
->    whereas
+>        multisplit("A x x Z", (" x ",), keep=big.ALTERNATING) => "A", " x ", "x Z"
 >
->        multisplit(" x x ", (" x ",), keep=big.ALTERNATING, reverse=True)
+>    If you pass in a true value for `reverse`, `multisplit` will prefer
+>    the rightmost overlapping separator:
 >
->    will split on the rightmost instance of `" x "`, yielding
->
->        " x", " x ", ""
+>        multisplit("A x x Z", (" x ",), keep=big.ALTERNATING, reverse=True) => "A x", " x ", "Z"
 >
 > For more information, see the deep-dive on
 > [**The `multi-` family of functions.**](#The-multi--family-of-functions)
 
 #### `multistrip(s, separators, left=True, right=True)`
 
 > Like `str.strip`, but supports stripping multiple substrings from `s`.
 >
 > Strips from the string `s` all leading and trailing instances of strings
 > found in `separators`.
 >
-> `s` should be str or bytes.
+> `s` should be `str` or `bytes`.
 >
 > `separators` should be an iterable of either `str` or `bytes`
 > objects matching the type of `s`.
 >
 > If `left` is a true value, strips all leading separators
 > from `s`.
 >
@@ -1534,31 +1547,34 @@
 > [**The `multi-` family of functions.**](#The-multi--family-of-functions)
 
 #### `newlines`
 
 > A list of all newline characters recognized by Python.
 > Includes many Unicode newline characters, like `'\u2029'`
 > (a paragraph separator).  Useful as a list of separator
-> strings for `[`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)` et al; `newlines` is specifically
-> used by the [`lines`](#liness-separatorsnone--line_number1-column_number1-tab_width8-kwargs) iterator constructor.
+> strings for
+> [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
+> et al; `newlines` is specifically used by the
+> [`lines`](#liness-separatorsnone--line_number1-column_number1-tab_width8-kwargs)
+> iterator constructor.
 >
 > **big** also defines `utf8_newlines`, which is `newlines`
 > with all strings encoded to UTF-8 (as bytes),
 > and `ascii_newlines`, with all strings converted into
 > bytes and all characters with code points greater than
 > 128 discarded.
 >
 > Note that `newlines` contains `'\r\n'`, the DOS sequence
 > of characters representing a newline.  This lets **big**
 > text-processing functions recognize this sequence as a
 > *single* newline marker, rather than as two *separate*
 > newline characters.  If you don't want this behavior,
-> you can use `newlines_without_dos` instead;
-> **big** also provides `utf8_newlines_without_dos` and
-> `ascii_newlines_without_dos`.
+> you can use `newlines_without_dos` instead.
+> (**big** also provides `utf8_newlines_without_dos` and
+> `ascii_newlines_without_dos`.)
 
 
 #### `normalize_whitespace(s, separators=None, replacement=None)`
 
 > Returns `s`, but with every run of consecutive
 > separator characters turned into a replacement string.
 > By default turns all runs of consecutive whitespace
@@ -1566,29 +1582,28 @@
 >
 > `s` may be `str` or `bytes`.
 > `separators` should be an iterable of either `str` or `bytes`
 > objects, matching `s`.
 > `replacement` should be either a `str` or `bytes` object,
 > also matching `s`, or `None` (the default).
 > If `replacement` is `None`, `normalize_whitespace` will use
-> a replacement string consisting of a single space character,
-> either `str` or `bytes` as appropriate.)
+> a replacement string consisting of a single space character.
 >
 > Leading or trailing runs of separator characters will
 > be replaced with the replacement string, e.g.:
 >
 >     normalize_whitespace("   a    b   c") == " a b c"
 
 #### `re_partition(text, pattern, count=1, *, flags=0, reverse=False)`
 
 > Like `str.partition`, but `pattern` is matched as a regular expression.
 >
 > `text` can be a string or a bytes object.
 >
-> `pattern` can be a string, bytes, or an `re.Pattern` object.
+> `pattern` can be a string, bytes, or `re.Pattern` object.
 >
 > `text` and `pattern` (or `pattern.pattern`) must be the same type.
 >
 > If `pattern` is found in text, returns a tuple
 > ```Python
 >     (before, match, after)
 > ```
@@ -1621,17 +1636,17 @@
 > (In older versions of Python, `re.Pattern` was a private type called
 > `re._pattern_type`.)
 
 #### `re_rpartition(text, pattern, count=1, *, flags=0)`
 
 > Like `str.rpartition`, but `pattern` is matched as a regular expression.
 >
-> `text` can be a string or a bytes object.
+> `text` can be a `str` or `bytes` object.
 >
-> `pattern` can be a string, bytes, or an `re.Pattern` object.
+> `pattern` can be a `str`, `bytes`, or `re.Pattern` object.
 >
 > `text` and `pattern` (or `pattern.pattern`) must be the same type.
 >
 > If `pattern` is found in `text`, returns a tuple
 > ```Python
 >     (before, match, after)
 > ```
@@ -1657,36 +1672,56 @@
 >
 > If `pattern` is a string, `flags` is passed in
 > as the `flags` argument to `re.compile`.
 >
 > (In older versions of Python, `re.Pattern` was a private type called
 > `re._pattern_type`.)
 
+#### `reversed_re_finditer(pattern, string, flags=0)`
+
+> An iterator.  Behaves almost identically to the Python
+> standard library function `re.finditer`, yielding
+> non-overlapping matches of `pattern` in `string`.  The difference
+> is, `reversed_re_finditer` searches `string` from right to left.
+>
+> `pattern` can be str, bytes, or a precompiled `re.Pattern` object.
+> If it's str or bytes, it'll be compiled
+> with `re.compile` using the `flags` you passed in.
+>
+> `string` should be the same type as `pattern` (or `pattern.pattern`).
+
 #### `split_quoted_strings(s, quotes=('"', "'"), *, triple_quotes=True, backslash='\\')`
 
-> Splits s into quoted and unquoted segments.  Returns an iterator yielding 2-tuples:
->     (is_quoted, segment)
-> where `segment` is a substring of `s`, and `is_quoted` is true if the segment is
-> quoted.  Joining all the segments together recreates `s`.
+> Splits `s` into quoted and unquoted segments.
 >
-> `quotes` is an iterable of quote separators.  Note that `split_quoted_strings`
+> `s` can be either `str` or `bytes`.
+>
+> `quotes` is an iterable of quote separators, either `str` or `bytes`
+> matching `s`.  Note that `split_quoted_strings`
 > only supports quote *characters,* as in, each quote separator must be exactly
 > one character long.
 >
+> Returns an iterator yielding 2-tuples:
+>     (is_quoted, segment)
+> where `segment` is a substring of `s`, and `is_quoted` is true if the segment is
+> quoted.  Joining all the segments together recreates `s`.
+>
 > If `triple_quotes` is true, supports "triple-quoted" strings like Python.
 >
 > If `backslash` is a character, this character will quoting characters inside
 > a quoted string, like the backslash character inside strings in Python.
 
 #### `split_text_with_code(s, *, tab_width=8, allow_code=True, code_indent=4, convert_tabs_to_spaces=True)`
 
-> Splits the string `s` into individual words,
+> Splits `s` into individual words,
 > suitable for feeding into
 > [`wrap_words`](#wrap_wordswords-margin79--two_spacestrue).
 >
+> `s` may be either `str` or `bytes`.
+>
 > Paragraphs indented by less than `code_indent` will be
 > broken up into individual words.
 >
 > If `allow_code` is true, paragraphs indented by at least
 > `code_indent` spaces will preserve their whitespace:
 > internal whitespace is preserved, and the newline is
 > preserved.  (This will preserve the formatting of code
@@ -1697,15 +1732,17 @@
 > [**Word wrapping and formatting.**](#word-wrapping-and-formatting)
 
 #### `whitespace`
 
 > A list of all whitespace characters recognized by Python.
 > Includes many Unicode whitespace strings, like `'\xa0'`
 > (a non-breaking space).  Useful as a list of separator
-> strings for `[`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)` et al.
+> strings for
+> [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
+>5 et al.
 >
 > **big** also defines `utf8_whitespace`, which is `whitespace`
 > with all strings encoded to UTF-8 (as bytes),
 > and `ascii_whitespace`, with all strings converted into
 > bytes and all characters with code points greater than
 > 128 discarded.
 >
@@ -1719,16 +1756,17 @@
 > `ascii_whitespace_without_dos`.
 
 #### `wrap_words(words, margin=79, *, two_spaces=True)`
 
 > Combines `words` into lines and returns the result as a string.
 > Similar to `textwrap.wrap`.
 >
-> `words` should be an iterator containing text split at word
-> boundaries.  Example:
+> `words` should be an iterator yielding str or bytes strings,
+> and these strings should already be split at word boundaries.
+> Here's an example of a valid argument for `words`:
 > ```Python
 >      "this is an example of text split at word boundaries".split()
 > ```
 >
 > A single `'\n'` indicates a line break.
 > If you want a paragraph break, embed two `'\n'` characters in a row.
 >
@@ -1931,24 +1969,24 @@
 (For example, `comment_separators` for `lines_filter_comment_lines`.)
 
 The downside of [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
 is that, since it *is* so
 sophisticated and tunable, it can be hard to use.  It takes
 *five keyword-only parameters* after all.  However, they're
 designed to be reasonably memorable, and their default values
-are designedo to be easy to remember.  But the best
+are designed to be easy to remember.  But the best
 way to combat the complexity of calling
 [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
 is to use it as a building block for your own
 text splitting functions.  For example, inside **big**,
 [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
 is used to implement
 [`multipartition`,](#multipartitions-separators-count1--reverseFalse-separateTrue)
 [`normalize_whitespace`,](#normalize_whitespaces-separatorsNone-replacementnone)
-[`lines`,](#liness-separatorsnone--line_number1-column_number1-tab_width8-kwargs),
+[`lines`,](#liness-separatorsnone--line_number1-column_number1-tab_width8-kwargs)
 and several others.
 
 ### Demonstrations of each `multisplit` keyword-only parameter
 
 To give you a sense of how the five keyword-only parameters changes the behavior of
 [`multisplit`,](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
 here's a breakdown of each of these parameters with examples.
@@ -2039,26 +2077,33 @@
 ```Python
     >>> list(big.multisplit('appleXbananaYcookie', ('X', 'Y'), keep=big.AS_PAIRS))
     [('apple', 'X'), ('banana', 'Y'), ('cookie', '')]
     >>> list(big.multisplit('appleXbananaYcookieXXX', ('X', 'Y'), keep=big.AS_PAIRS, strip=True))
     [('apple', 'X'), ('banana', 'Y'), ('cookie', '')]
 ```
 
+(This rule means that `AS_PAIRS` always emits an *even* number of strings.
+Contrast that with `ALTERNATING`, which always emits an *odd* number of strings,
+and the last string it emits is always a non-separator string.  Put another
+way: if you ignore the tuples, the list of strings emitted by `AS_PAIRS` is the
+same as those emitted by `ALTERNATING`, except `AS_PAIRS` appends an empty
+string.)
+
 Because of this rule, if the original string ends with a separator,
-and `multisplit` doesn't `strip` the right side, `AS_PAIRS`
-will emit a 2-tuple containing two empty strings:
+and `multisplit` doesn't `strip` the right side, the final tuple
+emitted by `AS_PAIRS` will be a 2-tuple containing two empty strings:
 
 ```Python
     >>> list(big.multisplit('appleXbananaYcookieX', ('X', 'Y'), keep=big.AS_PAIRS))
     [('apple', 'X'), ('banana', 'Y'), ('cookie', 'X'), ('', '')]
 ```
 
-This looks strange--but it *is* correct.  This behavior is discussed in the
+This looks strange and unnecessary.  But it *is* what you want.
+This odd-looking behavior is discussed at length in the section below, titled
 [Why do you sometimes get empty strings when you split?](#why-do-you-sometimes-get-empty-strings-when-you-split)
-section below.
 
 The behavior of `keep` can be affected by the value of `separate`.
 For more information, see the next section, on `separate`.
 
 
 #### `separate`
 
@@ -2187,18 +2232,19 @@
     ['apple', 'Ybanana', 'Ycookie']
     >>> list(big.multisplit('appleXAYbananaXAYcookie', ('XA', 'AY'), reverse=True))
     ['appleX', 'bananaX', 'cookie']
 ```
 
 ### Reimplementing library functions using `multisplit`
 
-Finally, here are some concrete examples of how you could use
+Here are some examples of how you could use
 [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
 to replace some common Python string splitting methods.  These exactly duplicate the
-behavior of the originals:
+behavior of the originals.
+
 ```Python
 def _multisplit_to_split(s, sep, maxsplit, reverse):
     separate = sep != None
     if separate:
         strip = False
     else:
         sep = big.ascii_whitespace if isinstance(s, bytes) else big.whitespace
@@ -2243,14 +2289,17 @@
 def str_partition(s, sep):
     return _partition_to_multisplit(s, sep, False)
 
 def str_rpartition(s, sep):
     return _partition_to_multisplit(s, sep, True)
 ```
 
+You wouldn't want to use these, of course--Python's built-in
+functions are so much faster!
+
 ### Why do you sometimes get empty strings when you split?
 
 Sometimes when you split using
 [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse),
 you'll get empty strings in the return value.  This might be unexpected,
 violating the [Principle Of Least Astonishment.](https://en.wikipedia.org/wiki/Principle_of_least_astonishment)
 But there are excellent reasons for this behavior.
@@ -2463,14 +2512,84 @@
 ['', '1', 'a', '1', 'z', '1', '']
 ```
 
 If the `AS_PAIRS` output *didn't* end with that tuple of empty strings,
 you'd need to add an `if` statement to restore the trailing empty
 strings as needed.
 
+### Other differences between multisplit and str.split
+
+`str.split` returns an *empty list* when you split an
+empty string by whitespace:
+
+```Python
+>>> ''.split()
+[]
+```
+
+But not when you split by an explicit separator:
+
+```Python
+>>> ''.split('x')
+['']
+```
+
+[`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
+is consistent here.  If you split an empty string, it always returns an empty string,
+as long as the separators are valid:
+
+```Python
+>>> list(big.multisplit(''))
+['']
+>>> list(big.multisplit('', ('a', 'b', 'c')))
+['']
+```
+
+Similarly, when splitting a string that only contains whitespace, `str.split` also
+returns an empty list:
+
+```Python
+>>> '     '.split()
+[]
+```
+
+This is really the same as "splitting an empty string", because when `str.split`
+splits on whitespace, the first thing it does is strip leading whitespace.
+
+If you [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
+a string that only contains whitespace, and you split on whitespace characters,
+it returns two empty strings:
+
+```Python
+>>> list(big.multisplit('     '))
+['', '']
+```
+
+This is because the string conceptually starts with a zero-length string,
+then has a run of whitespace characters, then ends with another zero-length
+string.  So those two empty strings are the leading and trailing zero-length
+strings, separated by whitespace.  If you tell
+[`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
+to also strip the string, you'll get back a single empty string:
+
+```Python
+>>> list(big.multisplit('     ', strip=True))
+['']
+```
+
+And
+[`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
+behaves consistently even when you use different separators:
+
+```Python
+>>> list(big.multisplit('ababa', 'ab'))
+['', '']
+>>> list(big.multisplit('ababa', 'ab', strip=True))
+['']
+```
 
 ## `lines` and lines modifier functions
 
 [`lines`](#liness-separatorsnone--line_number1-column_number1-tab_width8-kwargs) creates an iterator that yields individual lines
 split from a string.  It's designed to make it easy to write
 well-behaved simple text parsers.
 
@@ -2787,31 +2906,32 @@
 [`merge_columns`](#merge_columnscolumns-column_separator--overflow_responseoverflowresponseraise-overflow_before0-overflow_after0)
 needs to consider both "overflow lines",
 lines that are longer than `max_width`, and "overflow columns",
 columns that contain one or more overflow lines.
 
 What does
 [`merge_columns`](#merge_columnscolumns-column_separator--overflow_responseoverflowresponseraise-overflow_before0-overflow_after0)
-do when it encounters overflow?  It depends on what you want.
+do when it encounters overflow?
 [`merge_columns`](#merge_columnscolumns-column_separator--overflow_responseoverflowresponseraise-overflow_before0-overflow_after0)
-provides three "strategies" to deal with this condition, and you can specify
-which one you want with its `overflow_strategy` parameter.  The three are:
+supports three "strategies" to deal with this condition, and you can specify
+which one you want using its `overflow_strategy` parameter.  The three
+strategies are:
 
 - `OverflowStrategy.RAISE`: Raise an `OverflowError` exception.  The default.
 
 - `OverflowStrategy.INTRUDE_ALL`: Intrude into all subsequent columns on
-all lines where the overflowed column is wider than its max_width.
+all lines where the overflowed column is wider than its `max_width`.
 The subsequent columns "make space" for the overflow text by not adding
 text on those overflowed lines; this is called "pausing" their output.
 
 - `OverflowStrategy.DELAY_ALL`:  Delay all columns after the overflowed
 column, not beginning any until after the last overflowed line
-in the overflowed column.  This is like `INTRUDE_ALL`, except that
-they "make space" by pausing their output until the last overflowed
-line.
+in the overflowed column.  This is like the `INTRUDE_ALL` strategy,
+except that the columns "make space" by pausing their output until
+the last overflowed line.
 
 When `overflow_strategy` is `INTRUDE_ALL` or `DELAY_ALL`, and
 either `overflow_before` or `overflow_after` is nonzero, these
 specify the number of extra lines before or after
 the overflowed lines in a column where the subsequent columns
 "pause".
 
@@ -2904,17 +3024,17 @@
 others.  Views are completely independent from each other.
 
 
 ## Bound inner classes
 
 #### Overview
 
-One minor complaint I have about Python is about inner classes.
+One minor complaint I have about Python regards inner classes.
 An "inner class" is a class defined inside another class.  And,
-well, inner classes seem kind of half-baked.   Unlike methods,
+well, inner classes seem kind of half-baked.  Unlike functions,
 inner classes don't get bound to the object.
 
 Consider this Python code:
 
 ```Python
 class Outer(object):
     def method(self):
@@ -2928,17 +3048,18 @@
 i = o.Inner()
 ```
 
 When `o.method` is called, Python automatically passes in the `o` object as the first parameter
 (generally called `self`).  In object-oriented lingo, `o` is *bound* to `method`, and indeed
 Python calls this object a *bound method*:
 
-
+```
     >>> o.method
     <bound method Outer.method of <__main__.Outer object at 0x########>>
+```
 
 But that doesn't happen when `o.Inner` is called.  (It *does* pass in
 a `self`, but in this case it's the newly-created `Inner` object.)
 There's just no built-in way for the `o.Inner` object being constructed
 to *automatically* get a reference to `o`.  If you need one, you must
 explicitly pass one in, like so:
 
@@ -2955,15 +3076,16 @@
 i = o.Inner(o)
 ```
 
 This seems redundant.  You don't have to pass in `o` explicitly to method calls,
 why should you have to pass it in explicitly to inner classes?
 
 Well--now you don't have to!
-You just need to decorate the inner class with `@big.BoundInnerClass`.
+You just decorate the inner class with `@big.BoundInnerClass`,
+and `BoundInnerClass` takes care of the rest!
 
 #### Using bound inner classes
 
 Let's modify the above example to use our [`BoundInnerClass`](#boundinnerclasscls)
 decorator:
 
 ```Python
@@ -2979,23 +3101,23 @@
             self.outer = outer
 
 o = Outer()
 o.method()
 i = o.Inner()
 ```
 
-Notice that `Inner.__init__` now accepts an `outer` parameter,
+Notice that `Inner.__init__` now requires an `outer` parameter,
 even though you didn't pass in any arguments to `o.Inner`.
-And when it's called, `o` is magically passed in to `outer`!
-Thanks, [`BoundInnerClass`](#boundinnerclasscls)!  You've saved the day.
+When it's called, `o` is magically passed in to `outer`!
+Thanks, [`BoundInnerClass`](#boundinnerclasscls)!  You've saved the day!
 
 Decorating an inner class like this always adds a second positional
-parameter, after `self`.  And, like `self`, in theory you don't have
-to use the name `outer`.  (Although for consistency's sakes, it's probably
-a good idea.)
+parameter, after `self`.  And, like `self`, you don't have
+to use the name `outer`, you can use any name you like.
+(Although it's probably a good idea, for consistency's sakes.)
 
 #### Inheritance
 
 Bound inner classes get slightly complicated when mixed with inheritance.
 It's not all that difficult, you merely need to obey the following rules:
 
 1. *A bound inner class can inherit normally from any unbound class.*
@@ -3004,31 +3126,34 @@
 class scope, or when referencing the inner class from the outer class
 (as opposed to an instance of the outer class), you must actually
 subclass or reference `classname.cls`.*  This is because inside the
 outer class, the "class" you see is actually an instance of a
 [`BoundInnerClass`](#boundinnerclasscls) object.
 
 3. *All classes that inherit from a bound inner class must always call the
-superclass's `__init__`. You don't need to pass in the outer parameter;
+superclass's `__init__`. You don't need to pass in the `outer` parameter;
 it'll be automatically passed in to the superclass's `__init__` as before.*
 
-4. *An inner class that inherits from a bound inner class, and which also wants
-to be bound to the outer object, should be decorated with
+4. *An inner class that inherits from a bound inner class, and which also
+wants to be bound to the outer object, should be decorated with
 [`BoundInnerClass`](#boundinnerclasscls).*
 
-5. *An inner class that inherits from a bound inner class, but doesn't want
-to be bound to the outer object, should be decorated with
+5. *An inner class that inherits from a bound inner class, but doesn't
+want to be bound to the outer object, should be decorated with
 [`UnboundInnerClass`](#unboundinnerclasscls).*
 
 Restating the last two rules: every class that descends from any
 [`BoundInnerClass`](#boundinnerclasscls)
 should be decorated with either
 [`BoundInnerClass`](#boundinnerclasscls)
 or
 [`UnboundInnerClass`](#unboundinnerclasscls).
+Which one you use depends on what behavior you want--whether or
+not you want your inner subclass to automatically get the `outer`
+instance passed in to its `__init__`.
 
 Here's a simple example using inheritance with bound inner classes:
 
 ```Python
 from big import BoundInnerClass, UnboundInnerClass
 
 class Outer(object):
@@ -3100,21 +3225,23 @@
 You can see more complex examples of using inheritance with
 [`BoundInnerClass`](#boundinnerclasscls)
 (and [`UnboundInnerClass`](#unboundinnerclasscls))
 in the **big** test suite.
 
 #### Miscellaneous notes
 
-* If you refer to a bound inner class directly from the outer class,
-  rather than using the outer instance, you get the original class.
-  This means that references to `Outer.Inner` are consistent, and it's
-  a base class of all the bound inner classes. This also means that if
-  you attempt to construct one without using an outer instance, you must
-  pass in the outer parameter by hand, just as you would have to pass
-  in the self parameter by hand when calling an unbound method.
+* If you refer to a bound inner class directly from the outer *class,*
+  rather than using the outer *instance,* you get the original class.
+  This ensures that references to `Outer.Inner` are consistent; this
+  class is also a base class of all the bound inner classes. Additionally,
+  if you attempt to construct an instance of an unbound `Outer.Inner`
+  class without referencing it via an instance, you must pass in the
+  outer parameter by hand--just like you'd have to pass in the `self`
+  parameter by hand when calling a method on the *class itself* rather
+  than on an *instance* of the class.
 
 * If you refer to a bound inner class from an outer instance,
   you get a subclass of the original class.
 
 * Bound classes are cached in the outer object, which both provides
   a small speedup and ensures that `isinstance` relationships are
   consistent.
@@ -3157,24 +3284,98 @@
   class from the `__init__` of the outer class, which should allow
   the code to cache the bound inner class instance before a second
   thread could ever get a reference to the outer object.
 
 
 ## Release history
 
+**0.8**
+
+* Major retooling of `str` and `bytes` support in `big.text`.
+  * Functions in `big.text` now uniformly accept `str` or `bytes`
+    or a subclass of either.  See the
+    [Support for bytes and str](#Support-for-bytes-and-str) section
+    for how it works.
+  * Functions in `big.text` are now more consistent about raising
+    `TypeError` vs `ValueError`.  If you mix `bytes` and `str`
+    objects together in one call, you'll get a `TypeError`, but
+    if you pass in an empty iterable (of a correct type) where
+    a non-empty iterable is required you'll get a `ValueError`.
+    `big.text` generally tries to give the `TypeError` higher
+    priority; if you pass in a value that fails both the type
+    check and the value check, the `big.text` function will raise
+    `TypeError` first.
+* Major rewrite of
+  [`re_rpartition`.](#re_rpartitiontext-pattern-count1--flags0)
+  I realized it had the same "reverse mode" problem that
+  I fixed in
+  [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
+  back in version **0.6.10**: the regular expression should really
+  search the string in "reverse mode", from right to left.
+  The difference is whether the regular
+  expression potentially matches against overlapping strings.
+  When in forwards mode, the regular expression should prefer
+  the *leftmost* overlapping match, but in reverse mode it
+  should prefer the *rightmost* overlapping match.  Most of the
+  time this produces the same list of matches as you'd
+  find searching the string forwards--but sometimes the matches come
+  out *very* different.
+  This was way harder to fix with `re_rpartition` than with `multisplit`,
+  because Python's `re` module only supports searching forwards.
+  I have to emulate reverse-mode searching by manually checking for
+  overlapping matches and figuring out which one(s) to keep--a *lot* of
+  work!  Fortunately it's only a minor speed hit if you don't have
+  overlapping matches.  (And if you *do* have overlapping matches,
+  you're probably just happy `re_rpartition` now produces correct
+  results--though I did my best to make it performant anyway.)
+  In the future, **big** will probably add support for the
+  PyPI package `regex`, which reimplements Python's `re` module
+  but adds many features... including reverse mode!
+* New function:
+  [`reversed_re_finditer`.](#reversed_re_finditerpattern-string-flags0)
+  Behaves almost identically to the Python
+  standard library function `re.finditer`, yielding
+  non-overlapping matches of `pattern` in `string`.  The difference
+  is, `reversed_re_finditer` searches `string` from right to left.
+  (Written as part of the
+  [`re_rpartition`](#re_rpartitiontext-pattern-count1--flags0)
+  rewrite mentioned above.)
+* Added `apostrophes`, `double_quotes`,
+  `ascii_apostrophes`, `ascii_double_quotes`,
+  `utf8_apostrophes`, and `utf8_double_quotes`
+  to the `big.text` module.  Previously the first
+  four of these were hard-coded strings inside
+  [`gently_title`.](#gently_titles-apostrophesnone-double_quotesnone)
+  (And the last two didn't exist!)
+* Code cleanup in `split_text_with_code`, removed redundant code.
+  I think it has about the same number of `if` statements; if anything
+  it might be slightly faster.
+* Retooled
+  [`re_partition`](#re_partitiontext-pattern-count1--flags0)
+  and
+  [`re_rpartition`](#re_rpartitiontext-pattern-count1--flags0)
+  slightly, should now be very-slightly faster.  (Well, `re_rpartition`
+  will be slower if your pattern finds overlapping matches.  But at
+  least now it's correct!)
+* Lots and lots of doc improvements, as usual.
+
 **0.7.1**
 
-* Tweaked the implementation of `multisplit`.  Internally, it does the
+* Tweaked the implementation of
+  [`multisplit`.](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
+  Internally, it does the
   string splitting using `re.split`, which returns a `list`.  It used
   to iterate over the list and yield each element.  But that meant keeping
-  tne entire list around in memory until `multisplit` exited.  Now,
-  `multisplit` reverses the list, pops off the final element, and yields
-  that.  This means `multisplit` drops all references to the split strings
+  the entire list around in memory until `multisplit` exited.  Now,
+  [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
+  reverses the list, pops off the final element, and yields
+  that.  This means
+  [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
+  drops all references to the split strings
   as it iterates over the string, which may help in low-memory situations.
-
 * Minor doc fixes.
 
 **0.7**
 
 * Breaking changes to the
   [`Scheduler`](#schedulerregulatordefault_regulator):
   * It's no longer thread-safe by default, which means it's much faster
@@ -3199,15 +3400,14 @@
     [`Event`](#eventscheduler-event-time-priority-sequence)
     constructor were rearranged.  (You shouldn't care, as you
     shouldn't be manually constructing
     [`Event`](#eventscheduler-event-time-priority-sequence)
     objects anyway.)
   * The `Scheduler` now guarantees that it will only call `now` and `wake`
     on a `Regulator` object while holding that `Regulator`'s lock.
-
 * Minor doc fixes.
 
 **0.6.18**
 
 * Retooled
   [`multisplit`](#multisplits-separators--keepFalse-maxsplit-1-reverseFalse-separateFalse-stripFalse)
   and
@@ -3265,16 +3465,16 @@
 
 * Changed [`translate_filename_to_exfat(s)`](#translate_filename_to_exfats)
   behavior: when modifying a string with a colon (`':'`) *not* followed by
   a space, it used to convert it to a dash (`'-'`).  Now it converts the
   colon to a period (`'.'`), which looks a little more natural.  A colon
   followed by a space is still converted to a dash followed by a space.
 
-*p.s.* There's a revision with a comment claiming it represents 0.6.13.  But
-I forgot to actually tag it and release it, and I forgot to actually.  Oops!
+*p.s.* I forgot to release packages for 0.6.11 and 0.6.12.  But they're
+tagged, in case you want to examine them for some reason.
 
 **0.6.12**
 
 * Bugfix: When calling
   [`TopologicalSorter.print()`](#topologicalsorterprintprintprint),
   it sorts the list of nodes, for consistency's sakes.
   But if the node objects don't support `<` or `>` comparison,
@@ -3470,8 +3670,7 @@
   If the colon is not followed by a space, turns the colon into `'-'`.
   This is good for tiresome modern gobbledygook like `'Re:code'`, which
   will now be translated to `'Re-code'`.
 
 **0.5**
 
 * Initial release.
-
```

