# Comparing `tmp/quivr-0.3.0.tar.gz` & `tmp/quivr-0.3.1.tar.gz`

## Comparing `quivr-0.3.0.tar` & `quivr-0.3.1.tar`

### file list

```diff
@@ -1,16 +1,17 @@
--rw-r--r--   0        0        0     1504 2020-02-02 00:00:00.000000 quivr-0.3.0/quivr/__init__.py
--rw-r--r--   0        0        0       22 2020-02-02 00:00:00.000000 quivr-0.3.0/quivr/__version__.py
--rw-r--r--   0        0        0     1013 2020-02-02 00:00:00.000000 quivr-0.3.0/quivr/concat.py
--rw-r--r--   0        0        0      431 2020-02-02 00:00:00.000000 quivr-0.3.0/quivr/defragment.py
--rw-r--r--   0        0        0      114 2020-02-02 00:00:00.000000 quivr-0.3.0/quivr/errors.py
--rw-r--r--   0        0        0    22772 2020-02-02 00:00:00.000000 quivr-0.3.0/quivr/fields.py
--rw-r--r--   0        0        0     2325 2020-02-02 00:00:00.000000 quivr-0.3.0/quivr/indexing.py
--rw-r--r--   0        0        0     1059 2020-02-02 00:00:00.000000 quivr-0.3.0/quivr/matrix.py
--rw-r--r--   0        0        0        0 2020-02-02 00:00:00.000000 quivr-0.3.0/quivr/py.typed
--rw-r--r--   0        0        0      647 2020-02-02 00:00:00.000000 quivr-0.3.0/quivr/schemagraph.py
--rw-r--r--   0        0        0    19299 2020-02-02 00:00:00.000000 quivr-0.3.0/quivr/tables.py
--rw-r--r--   0        0        0       35 2020-02-02 00:00:00.000000 quivr-0.3.0/.gitignore
--rw-r--r--   0        0        0     1514 2020-02-02 00:00:00.000000 quivr-0.3.0/LICENSE
--rw-r--r--   0        0        0     9343 2020-02-02 00:00:00.000000 quivr-0.3.0/README.md
--rw-r--r--   0        0        0     1242 2020-02-02 00:00:00.000000 quivr-0.3.0/pyproject.toml
--rw-r--r--   0        0        0     9741 2020-02-02 00:00:00.000000 quivr-0.3.0/PKG-INFO
+-rw-r--r--   0        0        0     1504 2020-02-02 00:00:00.000000 quivr-0.3.1/quivr/__init__.py
+-rw-r--r--   0        0        0       22 2020-02-02 00:00:00.000000 quivr-0.3.1/quivr/__version__.py
+-rw-r--r--   0        0        0     1013 2020-02-02 00:00:00.000000 quivr-0.3.1/quivr/concat.py
+-rw-r--r--   0        0        0      431 2020-02-02 00:00:00.000000 quivr-0.3.1/quivr/defragment.py
+-rw-r--r--   0        0        0      114 2020-02-02 00:00:00.000000 quivr-0.3.1/quivr/errors.py
+-rw-r--r--   0        0        0    22772 2020-02-02 00:00:00.000000 quivr-0.3.1/quivr/fields.py
+-rw-r--r--   0        0        0     2325 2020-02-02 00:00:00.000000 quivr-0.3.1/quivr/indexing.py
+-rw-r--r--   0        0        0     1059 2020-02-02 00:00:00.000000 quivr-0.3.1/quivr/matrix.py
+-rw-r--r--   0        0        0        0 2020-02-02 00:00:00.000000 quivr-0.3.1/quivr/py.typed
+-rw-r--r--   0        0        0      647 2020-02-02 00:00:00.000000 quivr-0.3.1/quivr/schemagraph.py
+-rw-r--r--   0        0        0      363 2020-02-02 00:00:00.000000 quivr-0.3.1/quivr/streaming.py
+-rw-r--r--   0        0        0    20435 2020-02-02 00:00:00.000000 quivr-0.3.1/quivr/tables.py
+-rw-r--r--   0        0        0       35 2020-02-02 00:00:00.000000 quivr-0.3.1/.gitignore
+-rw-r--r--   0        0        0     1514 2020-02-02 00:00:00.000000 quivr-0.3.1/LICENSE
+-rw-r--r--   0        0        0     9323 2020-02-02 00:00:00.000000 quivr-0.3.1/README.md
+-rw-r--r--   0        0        0     1242 2020-02-02 00:00:00.000000 quivr-0.3.1/pyproject.toml
+-rw-r--r--   0        0        0     9721 2020-02-02 00:00:00.000000 quivr-0.3.1/PKG-INFO
```

### Comparing `quivr-0.3.0/quivr/__init__.py` & `quivr-0.3.1/quivr/__init__.py`

 * *Files identical despite different names*

### Comparing `quivr-0.3.0/quivr/concat.py` & `quivr-0.3.1/quivr/concat.py`

 * *Files identical despite different names*

### Comparing `quivr-0.3.0/quivr/fields.py` & `quivr-0.3.1/quivr/fields.py`

 * *Files identical despite different names*

### Comparing `quivr-0.3.0/quivr/indexing.py` & `quivr-0.3.1/quivr/indexing.py`

 * *Files identical despite different names*

### Comparing `quivr-0.3.0/quivr/matrix.py` & `quivr-0.3.1/quivr/matrix.py`

 * *Files identical despite different names*

### Comparing `quivr-0.3.0/quivr/schemagraph.py` & `quivr-0.3.1/quivr/schemagraph.py`

 * *Files identical despite different names*

### Comparing `quivr-0.3.0/quivr/tables.py` & `quivr-0.3.1/quivr/tables.py`

 * *Files 4% similar despite different names*

```diff
@@ -140,17 +140,17 @@
                 )
 
             if isinstance(value, Table):
                 arrays.append(value.to_structarray())
             elif isinstance(value, pa.Array):
                 arrays.append(value)
             elif isinstance(value, np.ndarray):
-                arrays.append(pa.array(value))
+                arrays.append(pa.array(value, type=field.type))
             elif isinstance(value, list):
-                arrays.append(pa.array(value))
+                arrays.append(pa.array(value, type=field.type))
             else:
                 raise TypeError(f"Unsupported type for {column_name}: {type(value)}")
 
         if size is None:
             raise ValueError("No data provided")
 
         for idx in empty_columns:
@@ -486,17 +486,47 @@
         return self.__class__(self.table.take(row_indices))
 
     def to_parquet(self, path: str, **kwargs):
         """Write the table to a Parquet file."""
         pyarrow.parquet.write_table(self.table, path, **kwargs)
 
     @classmethod
-    def from_parquet(cls, path: str, **kwargs):
-        """Read a table from a Parquet file."""
-        return cls(table=pyarrow.parquet.read_table(path), **kwargs)
+    def from_parquet(
+        cls,
+        path: str,
+        memory_map: bool = False,
+        pq_buffer_size: int = 0,
+        filters: Optional[pc.Expression] = None,
+        **kwargs,
+    ):
+        """Read a table from a Parquet file.
+
+        Arguments:
+            path: The path to the Parquet file.
+            memory_map: If True, memory-map the file, otherwise read it into memory.
+            pq_buffer_size: If positive, perform read buffering when
+                deserializing individual column chunks. Otherwise, IO
+                calls are unbuffered.
+            filters: An optional filter predicate to apply to the
+                data. Rows which do not match the predicate will be
+                removed from scanned data. For more information, see
+                the PyArrow documentation on
+                pyarrow.parquet.read_table and its filter parameter.
+            **kwargs: Additional keyword arguments to pass to the __init__ method.
+
+
+        """
+        table = pyarrow.parquet.read_table(
+            source=path,
+            columns=[field.name for field in cls.schema],
+            memory_map=memory_map,
+            buffer_size=pq_buffer_size,
+            filters=filters,
+        )
+        return cls(table=table, **kwargs)
 
     def to_feather(self, path: str, **kwargs):
         """Write the table to a Feather file."""
         pyarrow.feather.write_feather(self.table, path, **kwargs)
 
     @classmethod
     def from_feather(cls, path: str, **kwargs):
```

### Comparing `quivr-0.3.0/LICENSE` & `quivr-0.3.1/LICENSE`

 * *Files identical despite different names*

### Comparing `quivr-0.3.0/README.md` & `quivr-0.3.1/README.md`

 * *Files 1% similar despite different names*

```diff
@@ -49,15 +49,15 @@
 will handle the rest.
 
 ```python
 from quivr import Table, Float64Field
 import pyarrow as pa
 
 
-class Coordinates(TableBase):
+class Coordinates(Table):
 	x = Float64Field()
 	y = Float64Field()
 	z = Float64Field()
 	vx = Float64Field()
 	vy = Float64Field()
 	vz = Float64Field()
 ```
@@ -90,15 +90,15 @@
 
 ### Embedded definitions and nullable fields
 
 You can embed one table's definition within another, and you can make fields nullable:
 
 ```python
 
-class AsteroidOrbit(TableBase):
+class AsteroidOrbit(Table):
 	designation = StringField()
 	mass = Float64Field(nullable=True)
 	radius = Float64Field(nullable=True)
 	coords = Coordinates.as_field()
 
 # You can construct embedded fields from Arrow StructArrays, which you can get from
 # other Quivr tables using the to_structarray() method with zero copy.
@@ -146,38 +146,38 @@
 Because Quivr tables are just Python classes, you can customize the
 behavior of your tables by adding or overriding methods. For example, if you want to add a
 method to compute the total mass of the asteroids in the table, you
 can do so like this:
 
 ```python
 
-class AsteroidOrbit(TableBase):
+class AsteroidOrbit(Table):
 	designation = StringField()
 	mass = Float64Field(nullable=True)
 	radius = Float64Field(nullable=True)
 	coords = Coordinates.as_field()
 
     def total_mass(self):
         return pc.sum(self.mass)
 
 ```
 
 You can also use this to add "meta-fields" which are combinations of other fields. For example:
 
 ```python
-class CoordinateCovariance(TableBase):
+class CoordinateCovariance(Table):
 	matrix_values = ListField(pa.float64(), 36)
 
     @property
     def matrix(self):
         # This is a numpy array of shape (n, 6, 6)
         return self.matrix_values.to_numpy().reshape(-1, 6, 6)
 
 
-class AsteroidOrbit(TableBase):
+class AsteroidOrbit(Table):
 	designation = StringField()
 	mass = Float64Field(nullable=True)
 	radius = Float64Field(nullable=True)
 	coords = Coordinates.as_field()
 	covariance = CoordinateCovariance.as_field()
 
 orbits = load_orbits() # Analogous to the example above
```

### Comparing `quivr-0.3.0/pyproject.toml` & `quivr-0.3.1/pyproject.toml`

 * *Files identical despite different names*

### Comparing `quivr-0.3.0/PKG-INFO` & `quivr-0.3.1/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: quivr
-Version: 0.3.0
+Version: 0.3.1
 Summary: Container library for working with tabular Arrow data
 Project-URL: Source, https://github.com/spenczar/quivr
 Author-email: Spencer Nelson <spencer@spencerwnelson.com>
 License-File: LICENSE
 Requires-Python: >=3.11
 Requires-Dist: mmh3
 Requires-Dist: numpy
@@ -63,15 +63,15 @@
 will handle the rest.
 
 ```python
 from quivr import Table, Float64Field
 import pyarrow as pa
 
 
-class Coordinates(TableBase):
+class Coordinates(Table):
 	x = Float64Field()
 	y = Float64Field()
 	z = Float64Field()
 	vx = Float64Field()
 	vy = Float64Field()
 	vz = Float64Field()
 ```
@@ -104,15 +104,15 @@
 
 ### Embedded definitions and nullable fields
 
 You can embed one table's definition within another, and you can make fields nullable:
 
 ```python
 
-class AsteroidOrbit(TableBase):
+class AsteroidOrbit(Table):
 	designation = StringField()
 	mass = Float64Field(nullable=True)
 	radius = Float64Field(nullable=True)
 	coords = Coordinates.as_field()
 
 # You can construct embedded fields from Arrow StructArrays, which you can get from
 # other Quivr tables using the to_structarray() method with zero copy.
@@ -160,38 +160,38 @@
 Because Quivr tables are just Python classes, you can customize the
 behavior of your tables by adding or overriding methods. For example, if you want to add a
 method to compute the total mass of the asteroids in the table, you
 can do so like this:
 
 ```python
 
-class AsteroidOrbit(TableBase):
+class AsteroidOrbit(Table):
 	designation = StringField()
 	mass = Float64Field(nullable=True)
 	radius = Float64Field(nullable=True)
 	coords = Coordinates.as_field()
 
     def total_mass(self):
         return pc.sum(self.mass)
 
 ```
 
 You can also use this to add "meta-fields" which are combinations of other fields. For example:
 
 ```python
-class CoordinateCovariance(TableBase):
+class CoordinateCovariance(Table):
 	matrix_values = ListField(pa.float64(), 36)
 
     @property
     def matrix(self):
         # This is a numpy array of shape (n, 6, 6)
         return self.matrix_values.to_numpy().reshape(-1, 6, 6)
 
 
-class AsteroidOrbit(TableBase):
+class AsteroidOrbit(Table):
 	designation = StringField()
 	mass = Float64Field(nullable=True)
 	radius = Float64Field(nullable=True)
 	coords = Coordinates.as_field()
 	covariance = CoordinateCovariance.as_field()
 
 orbits = load_orbits() # Analogous to the example above
```

